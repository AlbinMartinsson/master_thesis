
wolfSSLTest.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001bc  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001a1e8  080001c0  080001c0  000101c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00001274  0801a3a8  0801a3a8  0002a3a8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0801b61c  0801b61c  000301dc  2**0
                  CONTENTS
  4 .ARM          00000008  0801b61c  0801b61c  0002b61c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0801b624  0801b624  000301dc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0801b624  0801b624  0002b624  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0801b628  0801b628  0002b628  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         000001dc  20000000  0801b62c  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000004f4  200001dc  0801b808  000301dc  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  200006d0  0801b808  000306d0  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  000301dc  2**0
                  CONTENTS, READONLY
 12 .debug_info   00058f18  00000000  00000000  0003020c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000059fc  00000000  00000000  00089124  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 000038a8  00000000  00000000  0008eb20  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 000039b0  00000000  00000000  000923c8  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  0003408e  00000000  00000000  00095d78  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   00028401  00000000  00000000  000c9e06  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    001325a8  00000000  00000000  000f2207  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      0000007b  00000000  00000000  002247af  2**0
                  CONTENTS, READONLY
 20 .debug_frame  000108f4  00000000  00000000  0022482c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001c0 <__do_global_dtors_aux>:
 80001c0:	b510      	push	{r4, lr}
 80001c2:	4c05      	ldr	r4, [pc, #20]	; (80001d8 <__do_global_dtors_aux+0x18>)
 80001c4:	7823      	ldrb	r3, [r4, #0]
 80001c6:	b933      	cbnz	r3, 80001d6 <__do_global_dtors_aux+0x16>
 80001c8:	4b04      	ldr	r3, [pc, #16]	; (80001dc <__do_global_dtors_aux+0x1c>)
 80001ca:	b113      	cbz	r3, 80001d2 <__do_global_dtors_aux+0x12>
 80001cc:	4804      	ldr	r0, [pc, #16]	; (80001e0 <__do_global_dtors_aux+0x20>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	2301      	movs	r3, #1
 80001d4:	7023      	strb	r3, [r4, #0]
 80001d6:	bd10      	pop	{r4, pc}
 80001d8:	200001dc 	.word	0x200001dc
 80001dc:	00000000 	.word	0x00000000
 80001e0:	0801a390 	.word	0x0801a390

080001e4 <frame_dummy>:
 80001e4:	b508      	push	{r3, lr}
 80001e6:	4b03      	ldr	r3, [pc, #12]	; (80001f4 <frame_dummy+0x10>)
 80001e8:	b11b      	cbz	r3, 80001f2 <frame_dummy+0xe>
 80001ea:	4903      	ldr	r1, [pc, #12]	; (80001f8 <frame_dummy+0x14>)
 80001ec:	4803      	ldr	r0, [pc, #12]	; (80001fc <frame_dummy+0x18>)
 80001ee:	f3af 8000 	nop.w
 80001f2:	bd08      	pop	{r3, pc}
 80001f4:	00000000 	.word	0x00000000
 80001f8:	200001e0 	.word	0x200001e0
 80001fc:	0801a390 	.word	0x0801a390

08000200 <strlen>:
 8000200:	4603      	mov	r3, r0
 8000202:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000206:	2a00      	cmp	r2, #0
 8000208:	d1fb      	bne.n	8000202 <strlen+0x2>
 800020a:	1a18      	subs	r0, r3, r0
 800020c:	3801      	subs	r0, #1
 800020e:	4770      	bx	lr

08000210 <memchr>:
 8000210:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000214:	2a10      	cmp	r2, #16
 8000216:	db2b      	blt.n	8000270 <memchr+0x60>
 8000218:	f010 0f07 	tst.w	r0, #7
 800021c:	d008      	beq.n	8000230 <memchr+0x20>
 800021e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000222:	3a01      	subs	r2, #1
 8000224:	428b      	cmp	r3, r1
 8000226:	d02d      	beq.n	8000284 <memchr+0x74>
 8000228:	f010 0f07 	tst.w	r0, #7
 800022c:	b342      	cbz	r2, 8000280 <memchr+0x70>
 800022e:	d1f6      	bne.n	800021e <memchr+0xe>
 8000230:	b4f0      	push	{r4, r5, r6, r7}
 8000232:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000236:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800023a:	f022 0407 	bic.w	r4, r2, #7
 800023e:	f07f 0700 	mvns.w	r7, #0
 8000242:	2300      	movs	r3, #0
 8000244:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000248:	3c08      	subs	r4, #8
 800024a:	ea85 0501 	eor.w	r5, r5, r1
 800024e:	ea86 0601 	eor.w	r6, r6, r1
 8000252:	fa85 f547 	uadd8	r5, r5, r7
 8000256:	faa3 f587 	sel	r5, r3, r7
 800025a:	fa86 f647 	uadd8	r6, r6, r7
 800025e:	faa5 f687 	sel	r6, r5, r7
 8000262:	b98e      	cbnz	r6, 8000288 <memchr+0x78>
 8000264:	d1ee      	bne.n	8000244 <memchr+0x34>
 8000266:	bcf0      	pop	{r4, r5, r6, r7}
 8000268:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800026c:	f002 0207 	and.w	r2, r2, #7
 8000270:	b132      	cbz	r2, 8000280 <memchr+0x70>
 8000272:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000276:	3a01      	subs	r2, #1
 8000278:	ea83 0301 	eor.w	r3, r3, r1
 800027c:	b113      	cbz	r3, 8000284 <memchr+0x74>
 800027e:	d1f8      	bne.n	8000272 <memchr+0x62>
 8000280:	2000      	movs	r0, #0
 8000282:	4770      	bx	lr
 8000284:	3801      	subs	r0, #1
 8000286:	4770      	bx	lr
 8000288:	2d00      	cmp	r5, #0
 800028a:	bf06      	itte	eq
 800028c:	4635      	moveq	r5, r6
 800028e:	3803      	subeq	r0, #3
 8000290:	3807      	subne	r0, #7
 8000292:	f015 0f01 	tst.w	r5, #1
 8000296:	d107      	bne.n	80002a8 <memchr+0x98>
 8000298:	3001      	adds	r0, #1
 800029a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800029e:	bf02      	ittt	eq
 80002a0:	3001      	addeq	r0, #1
 80002a2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80002a6:	3001      	addeq	r0, #1
 80002a8:	bcf0      	pop	{r4, r5, r6, r7}
 80002aa:	3801      	subs	r0, #1
 80002ac:	4770      	bx	lr
 80002ae:	bf00      	nop

080002b0 <__aeabi_uldivmod>:
 80002b0:	b953      	cbnz	r3, 80002c8 <__aeabi_uldivmod+0x18>
 80002b2:	b94a      	cbnz	r2, 80002c8 <__aeabi_uldivmod+0x18>
 80002b4:	2900      	cmp	r1, #0
 80002b6:	bf08      	it	eq
 80002b8:	2800      	cmpeq	r0, #0
 80002ba:	bf1c      	itt	ne
 80002bc:	f04f 31ff 	movne.w	r1, #4294967295
 80002c0:	f04f 30ff 	movne.w	r0, #4294967295
 80002c4:	f000 b972 	b.w	80005ac <__aeabi_idiv0>
 80002c8:	f1ad 0c08 	sub.w	ip, sp, #8
 80002cc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80002d0:	f000 f806 	bl	80002e0 <__udivmoddi4>
 80002d4:	f8dd e004 	ldr.w	lr, [sp, #4]
 80002d8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80002dc:	b004      	add	sp, #16
 80002de:	4770      	bx	lr

080002e0 <__udivmoddi4>:
 80002e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80002e4:	9e08      	ldr	r6, [sp, #32]
 80002e6:	4604      	mov	r4, r0
 80002e8:	4688      	mov	r8, r1
 80002ea:	2b00      	cmp	r3, #0
 80002ec:	d14b      	bne.n	8000386 <__udivmoddi4+0xa6>
 80002ee:	428a      	cmp	r2, r1
 80002f0:	4615      	mov	r5, r2
 80002f2:	d967      	bls.n	80003c4 <__udivmoddi4+0xe4>
 80002f4:	fab2 f282 	clz	r2, r2
 80002f8:	b14a      	cbz	r2, 800030e <__udivmoddi4+0x2e>
 80002fa:	f1c2 0720 	rsb	r7, r2, #32
 80002fe:	fa01 f302 	lsl.w	r3, r1, r2
 8000302:	fa20 f707 	lsr.w	r7, r0, r7
 8000306:	4095      	lsls	r5, r2
 8000308:	ea47 0803 	orr.w	r8, r7, r3
 800030c:	4094      	lsls	r4, r2
 800030e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000312:	0c23      	lsrs	r3, r4, #16
 8000314:	fbb8 f7fe 	udiv	r7, r8, lr
 8000318:	fa1f fc85 	uxth.w	ip, r5
 800031c:	fb0e 8817 	mls	r8, lr, r7, r8
 8000320:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000324:	fb07 f10c 	mul.w	r1, r7, ip
 8000328:	4299      	cmp	r1, r3
 800032a:	d909      	bls.n	8000340 <__udivmoddi4+0x60>
 800032c:	18eb      	adds	r3, r5, r3
 800032e:	f107 30ff 	add.w	r0, r7, #4294967295
 8000332:	f080 811b 	bcs.w	800056c <__udivmoddi4+0x28c>
 8000336:	4299      	cmp	r1, r3
 8000338:	f240 8118 	bls.w	800056c <__udivmoddi4+0x28c>
 800033c:	3f02      	subs	r7, #2
 800033e:	442b      	add	r3, r5
 8000340:	1a5b      	subs	r3, r3, r1
 8000342:	b2a4      	uxth	r4, r4
 8000344:	fbb3 f0fe 	udiv	r0, r3, lr
 8000348:	fb0e 3310 	mls	r3, lr, r0, r3
 800034c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000350:	fb00 fc0c 	mul.w	ip, r0, ip
 8000354:	45a4      	cmp	ip, r4
 8000356:	d909      	bls.n	800036c <__udivmoddi4+0x8c>
 8000358:	192c      	adds	r4, r5, r4
 800035a:	f100 33ff 	add.w	r3, r0, #4294967295
 800035e:	f080 8107 	bcs.w	8000570 <__udivmoddi4+0x290>
 8000362:	45a4      	cmp	ip, r4
 8000364:	f240 8104 	bls.w	8000570 <__udivmoddi4+0x290>
 8000368:	3802      	subs	r0, #2
 800036a:	442c      	add	r4, r5
 800036c:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8000370:	eba4 040c 	sub.w	r4, r4, ip
 8000374:	2700      	movs	r7, #0
 8000376:	b11e      	cbz	r6, 8000380 <__udivmoddi4+0xa0>
 8000378:	40d4      	lsrs	r4, r2
 800037a:	2300      	movs	r3, #0
 800037c:	e9c6 4300 	strd	r4, r3, [r6]
 8000380:	4639      	mov	r1, r7
 8000382:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000386:	428b      	cmp	r3, r1
 8000388:	d909      	bls.n	800039e <__udivmoddi4+0xbe>
 800038a:	2e00      	cmp	r6, #0
 800038c:	f000 80eb 	beq.w	8000566 <__udivmoddi4+0x286>
 8000390:	2700      	movs	r7, #0
 8000392:	e9c6 0100 	strd	r0, r1, [r6]
 8000396:	4638      	mov	r0, r7
 8000398:	4639      	mov	r1, r7
 800039a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800039e:	fab3 f783 	clz	r7, r3
 80003a2:	2f00      	cmp	r7, #0
 80003a4:	d147      	bne.n	8000436 <__udivmoddi4+0x156>
 80003a6:	428b      	cmp	r3, r1
 80003a8:	d302      	bcc.n	80003b0 <__udivmoddi4+0xd0>
 80003aa:	4282      	cmp	r2, r0
 80003ac:	f200 80fa 	bhi.w	80005a4 <__udivmoddi4+0x2c4>
 80003b0:	1a84      	subs	r4, r0, r2
 80003b2:	eb61 0303 	sbc.w	r3, r1, r3
 80003b6:	2001      	movs	r0, #1
 80003b8:	4698      	mov	r8, r3
 80003ba:	2e00      	cmp	r6, #0
 80003bc:	d0e0      	beq.n	8000380 <__udivmoddi4+0xa0>
 80003be:	e9c6 4800 	strd	r4, r8, [r6]
 80003c2:	e7dd      	b.n	8000380 <__udivmoddi4+0xa0>
 80003c4:	b902      	cbnz	r2, 80003c8 <__udivmoddi4+0xe8>
 80003c6:	deff      	udf	#255	; 0xff
 80003c8:	fab2 f282 	clz	r2, r2
 80003cc:	2a00      	cmp	r2, #0
 80003ce:	f040 808f 	bne.w	80004f0 <__udivmoddi4+0x210>
 80003d2:	1b49      	subs	r1, r1, r5
 80003d4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80003d8:	fa1f f885 	uxth.w	r8, r5
 80003dc:	2701      	movs	r7, #1
 80003de:	fbb1 fcfe 	udiv	ip, r1, lr
 80003e2:	0c23      	lsrs	r3, r4, #16
 80003e4:	fb0e 111c 	mls	r1, lr, ip, r1
 80003e8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80003ec:	fb08 f10c 	mul.w	r1, r8, ip
 80003f0:	4299      	cmp	r1, r3
 80003f2:	d907      	bls.n	8000404 <__udivmoddi4+0x124>
 80003f4:	18eb      	adds	r3, r5, r3
 80003f6:	f10c 30ff 	add.w	r0, ip, #4294967295
 80003fa:	d202      	bcs.n	8000402 <__udivmoddi4+0x122>
 80003fc:	4299      	cmp	r1, r3
 80003fe:	f200 80cd 	bhi.w	800059c <__udivmoddi4+0x2bc>
 8000402:	4684      	mov	ip, r0
 8000404:	1a59      	subs	r1, r3, r1
 8000406:	b2a3      	uxth	r3, r4
 8000408:	fbb1 f0fe 	udiv	r0, r1, lr
 800040c:	fb0e 1410 	mls	r4, lr, r0, r1
 8000410:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 8000414:	fb08 f800 	mul.w	r8, r8, r0
 8000418:	45a0      	cmp	r8, r4
 800041a:	d907      	bls.n	800042c <__udivmoddi4+0x14c>
 800041c:	192c      	adds	r4, r5, r4
 800041e:	f100 33ff 	add.w	r3, r0, #4294967295
 8000422:	d202      	bcs.n	800042a <__udivmoddi4+0x14a>
 8000424:	45a0      	cmp	r8, r4
 8000426:	f200 80b6 	bhi.w	8000596 <__udivmoddi4+0x2b6>
 800042a:	4618      	mov	r0, r3
 800042c:	eba4 0408 	sub.w	r4, r4, r8
 8000430:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8000434:	e79f      	b.n	8000376 <__udivmoddi4+0x96>
 8000436:	f1c7 0c20 	rsb	ip, r7, #32
 800043a:	40bb      	lsls	r3, r7
 800043c:	fa22 fe0c 	lsr.w	lr, r2, ip
 8000440:	ea4e 0e03 	orr.w	lr, lr, r3
 8000444:	fa01 f407 	lsl.w	r4, r1, r7
 8000448:	fa20 f50c 	lsr.w	r5, r0, ip
 800044c:	fa21 f30c 	lsr.w	r3, r1, ip
 8000450:	ea4f 481e 	mov.w	r8, lr, lsr #16
 8000454:	4325      	orrs	r5, r4
 8000456:	fbb3 f9f8 	udiv	r9, r3, r8
 800045a:	0c2c      	lsrs	r4, r5, #16
 800045c:	fb08 3319 	mls	r3, r8, r9, r3
 8000460:	fa1f fa8e 	uxth.w	sl, lr
 8000464:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 8000468:	fb09 f40a 	mul.w	r4, r9, sl
 800046c:	429c      	cmp	r4, r3
 800046e:	fa02 f207 	lsl.w	r2, r2, r7
 8000472:	fa00 f107 	lsl.w	r1, r0, r7
 8000476:	d90b      	bls.n	8000490 <__udivmoddi4+0x1b0>
 8000478:	eb1e 0303 	adds.w	r3, lr, r3
 800047c:	f109 30ff 	add.w	r0, r9, #4294967295
 8000480:	f080 8087 	bcs.w	8000592 <__udivmoddi4+0x2b2>
 8000484:	429c      	cmp	r4, r3
 8000486:	f240 8084 	bls.w	8000592 <__udivmoddi4+0x2b2>
 800048a:	f1a9 0902 	sub.w	r9, r9, #2
 800048e:	4473      	add	r3, lr
 8000490:	1b1b      	subs	r3, r3, r4
 8000492:	b2ad      	uxth	r5, r5
 8000494:	fbb3 f0f8 	udiv	r0, r3, r8
 8000498:	fb08 3310 	mls	r3, r8, r0, r3
 800049c:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 80004a0:	fb00 fa0a 	mul.w	sl, r0, sl
 80004a4:	45a2      	cmp	sl, r4
 80004a6:	d908      	bls.n	80004ba <__udivmoddi4+0x1da>
 80004a8:	eb1e 0404 	adds.w	r4, lr, r4
 80004ac:	f100 33ff 	add.w	r3, r0, #4294967295
 80004b0:	d26b      	bcs.n	800058a <__udivmoddi4+0x2aa>
 80004b2:	45a2      	cmp	sl, r4
 80004b4:	d969      	bls.n	800058a <__udivmoddi4+0x2aa>
 80004b6:	3802      	subs	r0, #2
 80004b8:	4474      	add	r4, lr
 80004ba:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 80004be:	fba0 8902 	umull	r8, r9, r0, r2
 80004c2:	eba4 040a 	sub.w	r4, r4, sl
 80004c6:	454c      	cmp	r4, r9
 80004c8:	46c2      	mov	sl, r8
 80004ca:	464b      	mov	r3, r9
 80004cc:	d354      	bcc.n	8000578 <__udivmoddi4+0x298>
 80004ce:	d051      	beq.n	8000574 <__udivmoddi4+0x294>
 80004d0:	2e00      	cmp	r6, #0
 80004d2:	d069      	beq.n	80005a8 <__udivmoddi4+0x2c8>
 80004d4:	ebb1 050a 	subs.w	r5, r1, sl
 80004d8:	eb64 0403 	sbc.w	r4, r4, r3
 80004dc:	fa04 fc0c 	lsl.w	ip, r4, ip
 80004e0:	40fd      	lsrs	r5, r7
 80004e2:	40fc      	lsrs	r4, r7
 80004e4:	ea4c 0505 	orr.w	r5, ip, r5
 80004e8:	e9c6 5400 	strd	r5, r4, [r6]
 80004ec:	2700      	movs	r7, #0
 80004ee:	e747      	b.n	8000380 <__udivmoddi4+0xa0>
 80004f0:	f1c2 0320 	rsb	r3, r2, #32
 80004f4:	fa20 f703 	lsr.w	r7, r0, r3
 80004f8:	4095      	lsls	r5, r2
 80004fa:	fa01 f002 	lsl.w	r0, r1, r2
 80004fe:	fa21 f303 	lsr.w	r3, r1, r3
 8000502:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000506:	4338      	orrs	r0, r7
 8000508:	0c01      	lsrs	r1, r0, #16
 800050a:	fbb3 f7fe 	udiv	r7, r3, lr
 800050e:	fa1f f885 	uxth.w	r8, r5
 8000512:	fb0e 3317 	mls	r3, lr, r7, r3
 8000516:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800051a:	fb07 f308 	mul.w	r3, r7, r8
 800051e:	428b      	cmp	r3, r1
 8000520:	fa04 f402 	lsl.w	r4, r4, r2
 8000524:	d907      	bls.n	8000536 <__udivmoddi4+0x256>
 8000526:	1869      	adds	r1, r5, r1
 8000528:	f107 3cff 	add.w	ip, r7, #4294967295
 800052c:	d22f      	bcs.n	800058e <__udivmoddi4+0x2ae>
 800052e:	428b      	cmp	r3, r1
 8000530:	d92d      	bls.n	800058e <__udivmoddi4+0x2ae>
 8000532:	3f02      	subs	r7, #2
 8000534:	4429      	add	r1, r5
 8000536:	1acb      	subs	r3, r1, r3
 8000538:	b281      	uxth	r1, r0
 800053a:	fbb3 f0fe 	udiv	r0, r3, lr
 800053e:	fb0e 3310 	mls	r3, lr, r0, r3
 8000542:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000546:	fb00 f308 	mul.w	r3, r0, r8
 800054a:	428b      	cmp	r3, r1
 800054c:	d907      	bls.n	800055e <__udivmoddi4+0x27e>
 800054e:	1869      	adds	r1, r5, r1
 8000550:	f100 3cff 	add.w	ip, r0, #4294967295
 8000554:	d217      	bcs.n	8000586 <__udivmoddi4+0x2a6>
 8000556:	428b      	cmp	r3, r1
 8000558:	d915      	bls.n	8000586 <__udivmoddi4+0x2a6>
 800055a:	3802      	subs	r0, #2
 800055c:	4429      	add	r1, r5
 800055e:	1ac9      	subs	r1, r1, r3
 8000560:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 8000564:	e73b      	b.n	80003de <__udivmoddi4+0xfe>
 8000566:	4637      	mov	r7, r6
 8000568:	4630      	mov	r0, r6
 800056a:	e709      	b.n	8000380 <__udivmoddi4+0xa0>
 800056c:	4607      	mov	r7, r0
 800056e:	e6e7      	b.n	8000340 <__udivmoddi4+0x60>
 8000570:	4618      	mov	r0, r3
 8000572:	e6fb      	b.n	800036c <__udivmoddi4+0x8c>
 8000574:	4541      	cmp	r1, r8
 8000576:	d2ab      	bcs.n	80004d0 <__udivmoddi4+0x1f0>
 8000578:	ebb8 0a02 	subs.w	sl, r8, r2
 800057c:	eb69 020e 	sbc.w	r2, r9, lr
 8000580:	3801      	subs	r0, #1
 8000582:	4613      	mov	r3, r2
 8000584:	e7a4      	b.n	80004d0 <__udivmoddi4+0x1f0>
 8000586:	4660      	mov	r0, ip
 8000588:	e7e9      	b.n	800055e <__udivmoddi4+0x27e>
 800058a:	4618      	mov	r0, r3
 800058c:	e795      	b.n	80004ba <__udivmoddi4+0x1da>
 800058e:	4667      	mov	r7, ip
 8000590:	e7d1      	b.n	8000536 <__udivmoddi4+0x256>
 8000592:	4681      	mov	r9, r0
 8000594:	e77c      	b.n	8000490 <__udivmoddi4+0x1b0>
 8000596:	3802      	subs	r0, #2
 8000598:	442c      	add	r4, r5
 800059a:	e747      	b.n	800042c <__udivmoddi4+0x14c>
 800059c:	f1ac 0c02 	sub.w	ip, ip, #2
 80005a0:	442b      	add	r3, r5
 80005a2:	e72f      	b.n	8000404 <__udivmoddi4+0x124>
 80005a4:	4638      	mov	r0, r7
 80005a6:	e708      	b.n	80003ba <__udivmoddi4+0xda>
 80005a8:	4637      	mov	r7, r6
 80005aa:	e6e9      	b.n	8000380 <__udivmoddi4+0xa0>

080005ac <__aeabi_idiv0>:
 80005ac:	4770      	bx	lr
 80005ae:	bf00      	nop

080005b0 <__io_putchar>:
#ifdef __GNUC__
int __io_putchar(int ch)
#else
int fputc(int ch, FILE *f)
#endif
{
 80005b0:	b580      	push	{r7, lr}
 80005b2:	b082      	sub	sp, #8
 80005b4:	af00      	add	r7, sp, #0
 80005b6:	6078      	str	r0, [r7, #4]
    HAL_UART_Transmit(&HAL_CONSOLE_UART, (uint8_t *)&ch, 1, 0xFFFF);
 80005b8:	1d39      	adds	r1, r7, #4
 80005ba:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80005be:	2201      	movs	r2, #1
 80005c0:	4803      	ldr	r0, [pc, #12]	; (80005d0 <__io_putchar+0x20>)
 80005c2:	f005 f8be 	bl	8005742 <HAL_UART_Transmit>

    return ch;
 80005c6:	687b      	ldr	r3, [r7, #4]
}
 80005c8:	4618      	mov	r0, r3
 80005ca:	3708      	adds	r7, #8
 80005cc:	46bd      	mov	sp, r7
 80005ce:	bd80      	pop	{r7, pc}
 80005d0:	20000488 	.word	0x20000488

080005d4 <_write>:
#ifdef __GNUC__
int _write(int file,char *ptr, int len)
{
 80005d4:	b580      	push	{r7, lr}
 80005d6:	b086      	sub	sp, #24
 80005d8:	af00      	add	r7, sp, #0
 80005da:	60f8      	str	r0, [r7, #12]
 80005dc:	60b9      	str	r1, [r7, #8]
 80005de:	607a      	str	r2, [r7, #4]
    int DataIdx;
    for (DataIdx= 0; DataIdx< len; DataIdx++) {
 80005e0:	2300      	movs	r3, #0
 80005e2:	617b      	str	r3, [r7, #20]
 80005e4:	e009      	b.n	80005fa <_write+0x26>
        __io_putchar(*ptr++);
 80005e6:	68bb      	ldr	r3, [r7, #8]
 80005e8:	1c5a      	adds	r2, r3, #1
 80005ea:	60ba      	str	r2, [r7, #8]
 80005ec:	781b      	ldrb	r3, [r3, #0]
 80005ee:	4618      	mov	r0, r3
 80005f0:	f7ff ffde 	bl	80005b0 <__io_putchar>
    for (DataIdx= 0; DataIdx< len; DataIdx++) {
 80005f4:	697b      	ldr	r3, [r7, #20]
 80005f6:	3301      	adds	r3, #1
 80005f8:	617b      	str	r3, [r7, #20]
 80005fa:	697a      	ldr	r2, [r7, #20]
 80005fc:	687b      	ldr	r3, [r7, #4]
 80005fe:	429a      	cmp	r2, r3
 8000600:	dbf1      	blt.n	80005e6 <_write+0x12>
    }
    return len;
 8000602:	687b      	ldr	r3, [r7, #4]
}
 8000604:	4618      	mov	r0, r3
 8000606:	3718      	adds	r7, #24
 8000608:	46bd      	mov	sp, r7
 800060a:	bd80      	pop	{r7, pc}

0800060c <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 800060c:	b580      	push	{r7, lr}
 800060e:	b082      	sub	sp, #8
 8000610:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8000612:	f001 f980 	bl	8001916 <HAL_Init>

  /* USER CODE BEGIN Init */

  setvbuf(stdin, NULL, _IONBF, 0);
 8000616:	4b2d      	ldr	r3, [pc, #180]	; (80006cc <main+0xc0>)
 8000618:	681b      	ldr	r3, [r3, #0]
 800061a:	6858      	ldr	r0, [r3, #4]
 800061c:	2300      	movs	r3, #0
 800061e:	2202      	movs	r2, #2
 8000620:	2100      	movs	r1, #0
 8000622:	f018 ffe5 	bl	80195f0 <setvbuf>
  setvbuf(stdout, NULL, _IONBF, 0);
 8000626:	4b29      	ldr	r3, [pc, #164]	; (80006cc <main+0xc0>)
 8000628:	681b      	ldr	r3, [r3, #0]
 800062a:	6898      	ldr	r0, [r3, #8]
 800062c:	2300      	movs	r3, #0
 800062e:	2202      	movs	r2, #2
 8000630:	2100      	movs	r1, #0
 8000632:	f018 ffdd 	bl	80195f0 <setvbuf>
  setvbuf(stderr, NULL, _IONBF, 0);
 8000636:	4b25      	ldr	r3, [pc, #148]	; (80006cc <main+0xc0>)
 8000638:	681b      	ldr	r3, [r3, #0]
 800063a:	68d8      	ldr	r0, [r3, #12]
 800063c:	2300      	movs	r3, #0
 800063e:	2202      	movs	r2, #2
 8000640:	2100      	movs	r1, #0
 8000642:	f018 ffd5 	bl	80195f0 <setvbuf>

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8000646:	f000 f84d 	bl	80006e4 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 800064a:	f000 fc23 	bl	8000e94 <MX_GPIO_Init>
  MX_ADC1_Init();
 800064e:	f000 f8f9 	bl	8000844 <MX_ADC1_Init>
  MX_DFSDM1_Init();
 8000652:	f000 f95b 	bl	800090c <MX_DFSDM1_Init>
  MX_I2C1_Init();
 8000656:	f000 f991 	bl	800097c <MX_I2C1_Init>
  MX_I2C2_Init();
 800065a:	f000 f9cf 	bl	80009fc <MX_I2C2_Init>
  MX_OCTOSPI1_Init();
 800065e:	f000 fa0d 	bl	8000a7c <MX_OCTOSPI1_Init>
  MX_SPI1_Init();
 8000662:	f000 fa61 	bl	8000b28 <MX_SPI1_Init>
  MX_SPI3_Init();
 8000666:	f000 fa9d 	bl	8000ba4 <MX_SPI3_Init>
  MX_UART4_Init();
 800066a:	f000 fad9 	bl	8000c20 <MX_UART4_Init>
  MX_USART1_UART_Init();
 800066e:	f000 fb23 	bl	8000cb8 <MX_USART1_UART_Init>
  MX_USART2_UART_Init();
 8000672:	f000 fb6d 	bl	8000d50 <MX_USART2_UART_Init>
  MX_USART3_UART_Init();
 8000676:	f000 fbb9 	bl	8000dec <MX_USART3_UART_Init>
  MX_USB_OTG_FS_USB_Init();
 800067a:	f000 fc03 	bl	8000e84 <MX_USB_OTG_FS_USB_Init>
  




   int ret = 0;
 800067e:	2300      	movs	r3, #0
 8000680:	607b      	str	r3, [r7, #4]

   WOLFSSL_CTX* ctx;

   wolfSSL_Init();/* Initialize wolfSSL */
 8000682:	f006 fef7 	bl	8007474 <wolfSSL_Init>

   ctx = wolfSSL_CTX_new(wolfTLSv1_2_client_method());
 8000686:	f008 f817 	bl	80086b8 <wolfTLSv1_2_client_method>
 800068a:	4603      	mov	r3, r0
 800068c:	4618      	mov	r0, r3
 800068e:	f006 fb95 	bl	8006dbc <wolfSSL_CTX_new>
 8000692:	6038      	str	r0, [r7, #0]

   ret = wolfSSL_CTX_load_verify_buffer(ctx,  server_cert_der_2048, sizeof_server_cert_der_2048, SSL_FILETYPE_ASN1);
 8000694:	f240 3257 	movw	r2, #855	; 0x357
 8000698:	2302      	movs	r3, #2
 800069a:	490d      	ldr	r1, [pc, #52]	; (80006d0 <main+0xc4>)
 800069c:	6838      	ldr	r0, [r7, #0]
 800069e:	f007 fef0 	bl	8008482 <wolfSSL_CTX_load_verify_buffer>
 80006a2:	6078      	str	r0, [r7, #4]

   printf("return value = %d\n", ret);
 80006a4:	6879      	ldr	r1, [r7, #4]
 80006a6:	480b      	ldr	r0, [pc, #44]	; (80006d4 <main+0xc8>)
 80006a8:	f018 ff7a 	bl	80195a0 <iprintf>

   printf("SSL_SUCCESS = %d\n", SSL_SUCCESS);
 80006ac:	2101      	movs	r1, #1
 80006ae:	480a      	ldr	r0, [pc, #40]	; (80006d8 <main+0xcc>)
 80006b0:	f018 ff76 	bl	80195a0 <iprintf>

   printf("SSL_BAD_FILETYPE = %d\n", SSL_BAD_FILETYPE);
 80006b4:	f06f 0104 	mvn.w	r1, #4
 80006b8:	4808      	ldr	r0, [pc, #32]	; (80006dc <main+0xd0>)
 80006ba:	f018 ff71 	bl	80195a0 <iprintf>

   printf("SSL_BAD_FILE = %d\n", SSL_BAD_FILE);
 80006be:	f06f 0103 	mvn.w	r1, #3
 80006c2:	4807      	ldr	r0, [pc, #28]	; (80006e0 <main+0xd4>)
 80006c4:	f018 ff6c 	bl	80195a0 <iprintf>

  while (1)
 80006c8:	e7fe      	b.n	80006c8 <main+0xbc>
 80006ca:	bf00      	nop
 80006cc:	2000000c 	.word	0x2000000c
 80006d0:	0801a830 	.word	0x0801a830
 80006d4:	0801a3a8 	.word	0x0801a3a8
 80006d8:	0801a3bc 	.word	0x0801a3bc
 80006dc:	0801a3d0 	.word	0x0801a3d0
 80006e0:	0801a3e8 	.word	0x0801a3e8

080006e4 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80006e4:	b580      	push	{r7, lr}
 80006e6:	b0bc      	sub	sp, #240	; 0xf0
 80006e8:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80006ea:	f107 03ac 	add.w	r3, r7, #172	; 0xac
 80006ee:	2244      	movs	r2, #68	; 0x44
 80006f0:	2100      	movs	r1, #0
 80006f2:	4618      	mov	r0, r3
 80006f4:	f018 fea3 	bl	801943e <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80006f8:	f107 0398 	add.w	r3, r7, #152	; 0x98
 80006fc:	2200      	movs	r2, #0
 80006fe:	601a      	str	r2, [r3, #0]
 8000700:	605a      	str	r2, [r3, #4]
 8000702:	609a      	str	r2, [r3, #8]
 8000704:	60da      	str	r2, [r3, #12]
 8000706:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8000708:	1d3b      	adds	r3, r7, #4
 800070a:	2294      	movs	r2, #148	; 0x94
 800070c:	2100      	movs	r1, #0
 800070e:	4618      	mov	r0, r3
 8000710:	f018 fe95 	bl	801943e <memset>

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST) != HAL_OK)
 8000714:	2000      	movs	r0, #0
 8000716:	f003 fa8f 	bl	8003c38 <HAL_PWREx_ControlVoltageScaling>
 800071a:	4603      	mov	r3, r0
 800071c:	2b00      	cmp	r3, #0
 800071e:	d001      	beq.n	8000724 <SystemClock_Config+0x40>
  {
    Error_Handler();
 8000720:	f000 fcf8 	bl	8001114 <Error_Handler>
  }
  /** Configure LSE Drive Capability
  */
  HAL_PWR_EnableBkUpAccess();
 8000724:	f003 fa58 	bl	8003bd8 <HAL_PWR_EnableBkUpAccess>
  __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
 8000728:	4b44      	ldr	r3, [pc, #272]	; (800083c <SystemClock_Config+0x158>)
 800072a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800072e:	4a43      	ldr	r2, [pc, #268]	; (800083c <SystemClock_Config+0x158>)
 8000730:	f023 0318 	bic.w	r3, r3, #24
 8000734:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
 8000738:	2314      	movs	r3, #20
 800073a:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 800073e:	2301      	movs	r3, #1
 8000740:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 8000744:	2301      	movs	r3, #1
 8000746:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
  RCC_OscInitStruct.MSICalibrationValue = 0;
 800074a:	2300      	movs	r3, #0
 800074c:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
 8000750:	2360      	movs	r3, #96	; 0x60
 8000752:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000756:	2302      	movs	r3, #2
 8000758:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
 800075c:	2301      	movs	r3, #1
 800075e:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
  RCC_OscInitStruct.PLL.PLLM = 1;
 8000762:	2301      	movs	r3, #1
 8000764:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
  RCC_OscInitStruct.PLL.PLLN = 60;
 8000768:	233c      	movs	r3, #60	; 0x3c
 800076a:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800076e:	2302      	movs	r3, #2
 8000770:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 8000774:	2302      	movs	r3, #2
 8000776:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 800077a:	2302      	movs	r3, #2
 800077c:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000780:	f107 03ac 	add.w	r3, r7, #172	; 0xac
 8000784:	4618      	mov	r0, r3
 8000786:	f003 fafb 	bl	8003d80 <HAL_RCC_OscConfig>
 800078a:	4603      	mov	r3, r0
 800078c:	2b00      	cmp	r3, #0
 800078e:	d001      	beq.n	8000794 <SystemClock_Config+0xb0>
  {
    Error_Handler();
 8000790:	f000 fcc0 	bl	8001114 <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000794:	230f      	movs	r3, #15
 8000796:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800079a:	2303      	movs	r3, #3
 800079c:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80007a0:	2300      	movs	r3, #0
 80007a2:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80007a6:	2300      	movs	r3, #0
 80007a8:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80007ac:	2300      	movs	r3, #0
 80007ae:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 80007b2:	f107 0398 	add.w	r3, r7, #152	; 0x98
 80007b6:	2105      	movs	r1, #5
 80007b8:	4618      	mov	r0, r3
 80007ba:	f003 ff07 	bl	80045cc <HAL_RCC_ClockConfig>
 80007be:	4603      	mov	r3, r0
 80007c0:	2b00      	cmp	r3, #0
 80007c2:	d001      	beq.n	80007c8 <SystemClock_Config+0xe4>
  {
    Error_Handler();
 80007c4:	f000 fca6 	bl	8001114 <Error_Handler>
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_USART2
 80007c8:	4b1d      	ldr	r3, [pc, #116]	; (8000840 <SystemClock_Config+0x15c>)
 80007ca:	607b      	str	r3, [r7, #4]
                              |RCC_PERIPHCLK_USART3|RCC_PERIPHCLK_UART4
                              |RCC_PERIPHCLK_I2C1|RCC_PERIPHCLK_I2C2
                              |RCC_PERIPHCLK_DFSDM1|RCC_PERIPHCLK_USB
                              |RCC_PERIPHCLK_ADC|RCC_PERIPHCLK_OSPI;
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
 80007cc:	2300      	movs	r3, #0
 80007ce:	643b      	str	r3, [r7, #64]	; 0x40
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 80007d0:	2300      	movs	r3, #0
 80007d2:	647b      	str	r3, [r7, #68]	; 0x44
  PeriphClkInit.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1;
 80007d4:	2300      	movs	r3, #0
 80007d6:	64bb      	str	r3, [r7, #72]	; 0x48
  PeriphClkInit.Uart4ClockSelection = RCC_UART4CLKSOURCE_PCLK1;
 80007d8:	2300      	movs	r3, #0
 80007da:	64fb      	str	r3, [r7, #76]	; 0x4c
  PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
 80007dc:	2300      	movs	r3, #0
 80007de:	65bb      	str	r3, [r7, #88]	; 0x58
  PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
 80007e0:	2300      	movs	r3, #0
 80007e2:	65fb      	str	r3, [r7, #92]	; 0x5c
  PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
 80007e4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80007e8:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  PeriphClkInit.Dfsdm1ClockSelection = RCC_DFSDM1CLKSOURCE_PCLK;
 80007ec:	2300      	movs	r3, #0
 80007ee:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  PeriphClkInit.OspiClockSelection = RCC_OSPICLKSOURCE_SYSCLK;
 80007f2:	2300      	movs	r3, #0
 80007f4:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
 80007f8:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 80007fc:	67bb      	str	r3, [r7, #120]	; 0x78
  PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_MSI;
 80007fe:	2301      	movs	r3, #1
 8000800:	60bb      	str	r3, [r7, #8]
  PeriphClkInit.PLLSAI1.PLLSAI1M = 1;
 8000802:	2301      	movs	r3, #1
 8000804:	60fb      	str	r3, [r7, #12]
  PeriphClkInit.PLLSAI1.PLLSAI1N = 24;
 8000806:	2318      	movs	r3, #24
 8000808:	613b      	str	r3, [r7, #16]
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV2;
 800080a:	2302      	movs	r3, #2
 800080c:	617b      	str	r3, [r7, #20]
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
 800080e:	2302      	movs	r3, #2
 8000810:	61bb      	str	r3, [r7, #24]
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
 8000812:	2302      	movs	r3, #2
 8000814:	61fb      	str	r3, [r7, #28]
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK|RCC_PLLSAI1_ADC1CLK;
 8000816:	f04f 7388 	mov.w	r3, #17825792	; 0x1100000
 800081a:	623b      	str	r3, [r7, #32]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 800081c:	1d3b      	adds	r3, r7, #4
 800081e:	4618      	mov	r0, r3
 8000820:	f004 f984 	bl	8004b2c <HAL_RCCEx_PeriphCLKConfig>
 8000824:	4603      	mov	r3, r0
 8000826:	2b00      	cmp	r3, #0
 8000828:	d001      	beq.n	800082e <SystemClock_Config+0x14a>
  {
    Error_Handler();
 800082a:	f000 fc73 	bl	8001114 <Error_Handler>
  }
  /** Enable MSI Auto calibration
  */
  HAL_RCCEx_EnableMSIPLLMode();
 800082e:	f004 fca5 	bl	800517c <HAL_RCCEx_EnableMSIPLLMode>
}
 8000832:	bf00      	nop
 8000834:	37f0      	adds	r7, #240	; 0xf0
 8000836:	46bd      	mov	sp, r7
 8000838:	bd80      	pop	{r7, pc}
 800083a:	bf00      	nop
 800083c:	40021000 	.word	0x40021000
 8000840:	010160cf 	.word	0x010160cf

08000844 <MX_ADC1_Init>:
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{
 8000844:	b580      	push	{r7, lr}
 8000846:	b086      	sub	sp, #24
 8000848:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};
 800084a:	463b      	mov	r3, r7
 800084c:	2200      	movs	r2, #0
 800084e:	601a      	str	r2, [r3, #0]
 8000850:	605a      	str	r2, [r3, #4]
 8000852:	609a      	str	r2, [r3, #8]
 8000854:	60da      	str	r2, [r3, #12]
 8000856:	611a      	str	r2, [r3, #16]
 8000858:	615a      	str	r2, [r3, #20]
  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */
  /** Common config
  */
  hadc1.Instance = ADC1;
 800085a:	4b29      	ldr	r3, [pc, #164]	; (8000900 <MX_ADC1_Init+0xbc>)
 800085c:	4a29      	ldr	r2, [pc, #164]	; (8000904 <MX_ADC1_Init+0xc0>)
 800085e:	601a      	str	r2, [r3, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 8000860:	4b27      	ldr	r3, [pc, #156]	; (8000900 <MX_ADC1_Init+0xbc>)
 8000862:	2200      	movs	r2, #0
 8000864:	605a      	str	r2, [r3, #4]
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 8000866:	4b26      	ldr	r3, [pc, #152]	; (8000900 <MX_ADC1_Init+0xbc>)
 8000868:	2200      	movs	r2, #0
 800086a:	609a      	str	r2, [r3, #8]
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 800086c:	4b24      	ldr	r3, [pc, #144]	; (8000900 <MX_ADC1_Init+0xbc>)
 800086e:	2200      	movs	r2, #0
 8000870:	60da      	str	r2, [r3, #12]
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
 8000872:	4b23      	ldr	r3, [pc, #140]	; (8000900 <MX_ADC1_Init+0xbc>)
 8000874:	2200      	movs	r2, #0
 8000876:	611a      	str	r2, [r3, #16]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000878:	4b21      	ldr	r3, [pc, #132]	; (8000900 <MX_ADC1_Init+0xbc>)
 800087a:	2204      	movs	r2, #4
 800087c:	615a      	str	r2, [r3, #20]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 800087e:	4b20      	ldr	r3, [pc, #128]	; (8000900 <MX_ADC1_Init+0xbc>)
 8000880:	2200      	movs	r2, #0
 8000882:	761a      	strb	r2, [r3, #24]
  hadc1.Init.ContinuousConvMode = DISABLE;
 8000884:	4b1e      	ldr	r3, [pc, #120]	; (8000900 <MX_ADC1_Init+0xbc>)
 8000886:	2200      	movs	r2, #0
 8000888:	765a      	strb	r2, [r3, #25]
  hadc1.Init.NbrOfConversion = 1;
 800088a:	4b1d      	ldr	r3, [pc, #116]	; (8000900 <MX_ADC1_Init+0xbc>)
 800088c:	2201      	movs	r2, #1
 800088e:	61da      	str	r2, [r3, #28]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8000890:	4b1b      	ldr	r3, [pc, #108]	; (8000900 <MX_ADC1_Init+0xbc>)
 8000892:	2200      	movs	r2, #0
 8000894:	f883 2020 	strb.w	r2, [r3, #32]
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8000898:	4b19      	ldr	r3, [pc, #100]	; (8000900 <MX_ADC1_Init+0xbc>)
 800089a:	2200      	movs	r2, #0
 800089c:	629a      	str	r2, [r3, #40]	; 0x28
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 800089e:	4b18      	ldr	r3, [pc, #96]	; (8000900 <MX_ADC1_Init+0xbc>)
 80008a0:	2200      	movs	r2, #0
 80008a2:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc1.Init.DMAContinuousRequests = DISABLE;
 80008a4:	4b16      	ldr	r3, [pc, #88]	; (8000900 <MX_ADC1_Init+0xbc>)
 80008a6:	2200      	movs	r2, #0
 80008a8:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 80008ac:	4b14      	ldr	r3, [pc, #80]	; (8000900 <MX_ADC1_Init+0xbc>)
 80008ae:	2200      	movs	r2, #0
 80008b0:	635a      	str	r2, [r3, #52]	; 0x34
  hadc1.Init.OversamplingMode = DISABLE;
 80008b2:	4b13      	ldr	r3, [pc, #76]	; (8000900 <MX_ADC1_Init+0xbc>)
 80008b4:	2200      	movs	r2, #0
 80008b6:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 80008ba:	4811      	ldr	r0, [pc, #68]	; (8000900 <MX_ADC1_Init+0xbc>)
 80008bc:	f001 fa40 	bl	8001d40 <HAL_ADC_Init>
 80008c0:	4603      	mov	r3, r0
 80008c2:	2b00      	cmp	r3, #0
 80008c4:	d001      	beq.n	80008ca <MX_ADC1_Init+0x86>
  {
    Error_Handler();
 80008c6:	f000 fc25 	bl	8001114 <Error_Handler>
  }
  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_1;
 80008ca:	4b0f      	ldr	r3, [pc, #60]	; (8000908 <MX_ADC1_Init+0xc4>)
 80008cc:	603b      	str	r3, [r7, #0]
  sConfig.Rank = ADC_REGULAR_RANK_1;
 80008ce:	2306      	movs	r3, #6
 80008d0:	607b      	str	r3, [r7, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
 80008d2:	2300      	movs	r3, #0
 80008d4:	60bb      	str	r3, [r7, #8]
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 80008d6:	237f      	movs	r3, #127	; 0x7f
 80008d8:	60fb      	str	r3, [r7, #12]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 80008da:	2304      	movs	r3, #4
 80008dc:	613b      	str	r3, [r7, #16]
  sConfig.Offset = 0;
 80008de:	2300      	movs	r3, #0
 80008e0:	617b      	str	r3, [r7, #20]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 80008e2:	463b      	mov	r3, r7
 80008e4:	4619      	mov	r1, r3
 80008e6:	4806      	ldr	r0, [pc, #24]	; (8000900 <MX_ADC1_Init+0xbc>)
 80008e8:	f001 fb74 	bl	8001fd4 <HAL_ADC_ConfigChannel>
 80008ec:	4603      	mov	r3, r0
 80008ee:	2b00      	cmp	r3, #0
 80008f0:	d001      	beq.n	80008f6 <MX_ADC1_Init+0xb2>
  {
    Error_Handler();
 80008f2:	f000 fc0f 	bl	8001114 <Error_Handler>
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}
 80008f6:	bf00      	nop
 80008f8:	3718      	adds	r7, #24
 80008fa:	46bd      	mov	sp, r7
 80008fc:	bd80      	pop	{r7, pc}
 80008fe:	bf00      	nop
 8000900:	20000420 	.word	0x20000420
 8000904:	50040000 	.word	0x50040000
 8000908:	04300002 	.word	0x04300002

0800090c <MX_DFSDM1_Init>:
  * @brief DFSDM1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_DFSDM1_Init(void)
{
 800090c:	b580      	push	{r7, lr}
 800090e:	af00      	add	r7, sp, #0
  /* USER CODE END DFSDM1_Init 0 */

  /* USER CODE BEGIN DFSDM1_Init 1 */

  /* USER CODE END DFSDM1_Init 1 */
  hdfsdm1_channel2.Instance = DFSDM1_Channel2;
 8000910:	4b18      	ldr	r3, [pc, #96]	; (8000974 <MX_DFSDM1_Init+0x68>)
 8000912:	4a19      	ldr	r2, [pc, #100]	; (8000978 <MX_DFSDM1_Init+0x6c>)
 8000914:	601a      	str	r2, [r3, #0]
  hdfsdm1_channel2.Init.OutputClock.Activation = ENABLE;
 8000916:	4b17      	ldr	r3, [pc, #92]	; (8000974 <MX_DFSDM1_Init+0x68>)
 8000918:	2201      	movs	r2, #1
 800091a:	711a      	strb	r2, [r3, #4]
  hdfsdm1_channel2.Init.OutputClock.Selection = DFSDM_CHANNEL_OUTPUT_CLOCK_SYSTEM;
 800091c:	4b15      	ldr	r3, [pc, #84]	; (8000974 <MX_DFSDM1_Init+0x68>)
 800091e:	2200      	movs	r2, #0
 8000920:	609a      	str	r2, [r3, #8]
  hdfsdm1_channel2.Init.OutputClock.Divider = 2;
 8000922:	4b14      	ldr	r3, [pc, #80]	; (8000974 <MX_DFSDM1_Init+0x68>)
 8000924:	2202      	movs	r2, #2
 8000926:	60da      	str	r2, [r3, #12]
  hdfsdm1_channel2.Init.Input.Multiplexer = DFSDM_CHANNEL_EXTERNAL_INPUTS;
 8000928:	4b12      	ldr	r3, [pc, #72]	; (8000974 <MX_DFSDM1_Init+0x68>)
 800092a:	2200      	movs	r2, #0
 800092c:	611a      	str	r2, [r3, #16]
  hdfsdm1_channel2.Init.Input.DataPacking = DFSDM_CHANNEL_STANDARD_MODE;
 800092e:	4b11      	ldr	r3, [pc, #68]	; (8000974 <MX_DFSDM1_Init+0x68>)
 8000930:	2200      	movs	r2, #0
 8000932:	615a      	str	r2, [r3, #20]
  hdfsdm1_channel2.Init.Input.Pins = DFSDM_CHANNEL_SAME_CHANNEL_PINS;
 8000934:	4b0f      	ldr	r3, [pc, #60]	; (8000974 <MX_DFSDM1_Init+0x68>)
 8000936:	2200      	movs	r2, #0
 8000938:	619a      	str	r2, [r3, #24]
  hdfsdm1_channel2.Init.SerialInterface.Type = DFSDM_CHANNEL_SPI_RISING;
 800093a:	4b0e      	ldr	r3, [pc, #56]	; (8000974 <MX_DFSDM1_Init+0x68>)
 800093c:	2200      	movs	r2, #0
 800093e:	61da      	str	r2, [r3, #28]
  hdfsdm1_channel2.Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 8000940:	4b0c      	ldr	r3, [pc, #48]	; (8000974 <MX_DFSDM1_Init+0x68>)
 8000942:	2204      	movs	r2, #4
 8000944:	621a      	str	r2, [r3, #32]
  hdfsdm1_channel2.Init.Awd.FilterOrder = DFSDM_CHANNEL_FASTSINC_ORDER;
 8000946:	4b0b      	ldr	r3, [pc, #44]	; (8000974 <MX_DFSDM1_Init+0x68>)
 8000948:	2200      	movs	r2, #0
 800094a:	625a      	str	r2, [r3, #36]	; 0x24
  hdfsdm1_channel2.Init.Awd.Oversampling = 1;
 800094c:	4b09      	ldr	r3, [pc, #36]	; (8000974 <MX_DFSDM1_Init+0x68>)
 800094e:	2201      	movs	r2, #1
 8000950:	629a      	str	r2, [r3, #40]	; 0x28
  hdfsdm1_channel2.Init.Offset = 0;
 8000952:	4b08      	ldr	r3, [pc, #32]	; (8000974 <MX_DFSDM1_Init+0x68>)
 8000954:	2200      	movs	r2, #0
 8000956:	62da      	str	r2, [r3, #44]	; 0x2c
  hdfsdm1_channel2.Init.RightBitShift = 0x00;
 8000958:	4b06      	ldr	r3, [pc, #24]	; (8000974 <MX_DFSDM1_Init+0x68>)
 800095a:	2200      	movs	r2, #0
 800095c:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_DFSDM_ChannelInit(&hdfsdm1_channel2) != HAL_OK)
 800095e:	4805      	ldr	r0, [pc, #20]	; (8000974 <MX_DFSDM1_Init+0x68>)
 8000960:	f002 f844 	bl	80029ec <HAL_DFSDM_ChannelInit>
 8000964:	4603      	mov	r3, r0
 8000966:	2b00      	cmp	r3, #0
 8000968:	d001      	beq.n	800096e <MX_DFSDM1_Init+0x62>
  {
    Error_Handler();
 800096a:	f000 fbd3 	bl	8001114 <Error_Handler>
  }
  /* USER CODE BEGIN DFSDM1_Init 2 */

  /* USER CODE END DFSDM1_Init 2 */

}
 800096e:	bf00      	nop
 8000970:	bd80      	pop	{r7, pc}
 8000972:	bf00      	nop
 8000974:	20000690 	.word	0x20000690
 8000978:	40016040 	.word	0x40016040

0800097c <MX_I2C1_Init>:
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{
 800097c:	b580      	push	{r7, lr}
 800097e:	af00      	add	r7, sp, #0
  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
 8000980:	4b1b      	ldr	r3, [pc, #108]	; (80009f0 <MX_I2C1_Init+0x74>)
 8000982:	4a1c      	ldr	r2, [pc, #112]	; (80009f4 <MX_I2C1_Init+0x78>)
 8000984:	601a      	str	r2, [r3, #0]
  hi2c1.Init.Timing = 0x307075B1;
 8000986:	4b1a      	ldr	r3, [pc, #104]	; (80009f0 <MX_I2C1_Init+0x74>)
 8000988:	4a1b      	ldr	r2, [pc, #108]	; (80009f8 <MX_I2C1_Init+0x7c>)
 800098a:	605a      	str	r2, [r3, #4]
  hi2c1.Init.OwnAddress1 = 0;
 800098c:	4b18      	ldr	r3, [pc, #96]	; (80009f0 <MX_I2C1_Init+0x74>)
 800098e:	2200      	movs	r2, #0
 8000990:	609a      	str	r2, [r3, #8]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8000992:	4b17      	ldr	r3, [pc, #92]	; (80009f0 <MX_I2C1_Init+0x74>)
 8000994:	2201      	movs	r2, #1
 8000996:	60da      	str	r2, [r3, #12]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8000998:	4b15      	ldr	r3, [pc, #84]	; (80009f0 <MX_I2C1_Init+0x74>)
 800099a:	2200      	movs	r2, #0
 800099c:	611a      	str	r2, [r3, #16]
  hi2c1.Init.OwnAddress2 = 0;
 800099e:	4b14      	ldr	r3, [pc, #80]	; (80009f0 <MX_I2C1_Init+0x74>)
 80009a0:	2200      	movs	r2, #0
 80009a2:	615a      	str	r2, [r3, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 80009a4:	4b12      	ldr	r3, [pc, #72]	; (80009f0 <MX_I2C1_Init+0x74>)
 80009a6:	2200      	movs	r2, #0
 80009a8:	619a      	str	r2, [r3, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 80009aa:	4b11      	ldr	r3, [pc, #68]	; (80009f0 <MX_I2C1_Init+0x74>)
 80009ac:	2200      	movs	r2, #0
 80009ae:	61da      	str	r2, [r3, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 80009b0:	4b0f      	ldr	r3, [pc, #60]	; (80009f0 <MX_I2C1_Init+0x74>)
 80009b2:	2200      	movs	r2, #0
 80009b4:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 80009b6:	480e      	ldr	r0, [pc, #56]	; (80009f0 <MX_I2C1_Init+0x74>)
 80009b8:	f002 faf1 	bl	8002f9e <HAL_I2C_Init>
 80009bc:	4603      	mov	r3, r0
 80009be:	2b00      	cmp	r3, #0
 80009c0:	d001      	beq.n	80009c6 <MX_I2C1_Init+0x4a>
  {
    Error_Handler();
 80009c2:	f000 fba7 	bl	8001114 <Error_Handler>
  }
  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 80009c6:	2100      	movs	r1, #0
 80009c8:	4809      	ldr	r0, [pc, #36]	; (80009f0 <MX_I2C1_Init+0x74>)
 80009ca:	f002 fb77 	bl	80030bc <HAL_I2CEx_ConfigAnalogFilter>
 80009ce:	4603      	mov	r3, r0
 80009d0:	2b00      	cmp	r3, #0
 80009d2:	d001      	beq.n	80009d8 <MX_I2C1_Init+0x5c>
  {
    Error_Handler();
 80009d4:	f000 fb9e 	bl	8001114 <Error_Handler>
  }
  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 80009d8:	2100      	movs	r1, #0
 80009da:	4805      	ldr	r0, [pc, #20]	; (80009f0 <MX_I2C1_Init+0x74>)
 80009dc:	f002 fbb9 	bl	8003152 <HAL_I2CEx_ConfigDigitalFilter>
 80009e0:	4603      	mov	r3, r0
 80009e2:	2b00      	cmp	r3, #0
 80009e4:	d001      	beq.n	80009ea <MX_I2C1_Init+0x6e>
  {
    Error_Handler();
 80009e6:	f000 fb95 	bl	8001114 <Error_Handler>
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}
 80009ea:	bf00      	nop
 80009ec:	bd80      	pop	{r7, pc}
 80009ee:	bf00      	nop
 80009f0:	200002d4 	.word	0x200002d4
 80009f4:	40005400 	.word	0x40005400
 80009f8:	307075b1 	.word	0x307075b1

080009fc <MX_I2C2_Init>:
  * @brief I2C2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C2_Init(void)
{
 80009fc:	b580      	push	{r7, lr}
 80009fe:	af00      	add	r7, sp, #0
  /* USER CODE END I2C2_Init 0 */

  /* USER CODE BEGIN I2C2_Init 1 */

  /* USER CODE END I2C2_Init 1 */
  hi2c2.Instance = I2C2;
 8000a00:	4b1b      	ldr	r3, [pc, #108]	; (8000a70 <MX_I2C2_Init+0x74>)
 8000a02:	4a1c      	ldr	r2, [pc, #112]	; (8000a74 <MX_I2C2_Init+0x78>)
 8000a04:	601a      	str	r2, [r3, #0]
  hi2c2.Init.Timing = 0x307075B1;
 8000a06:	4b1a      	ldr	r3, [pc, #104]	; (8000a70 <MX_I2C2_Init+0x74>)
 8000a08:	4a1b      	ldr	r2, [pc, #108]	; (8000a78 <MX_I2C2_Init+0x7c>)
 8000a0a:	605a      	str	r2, [r3, #4]
  hi2c2.Init.OwnAddress1 = 0;
 8000a0c:	4b18      	ldr	r3, [pc, #96]	; (8000a70 <MX_I2C2_Init+0x74>)
 8000a0e:	2200      	movs	r2, #0
 8000a10:	609a      	str	r2, [r3, #8]
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8000a12:	4b17      	ldr	r3, [pc, #92]	; (8000a70 <MX_I2C2_Init+0x74>)
 8000a14:	2201      	movs	r2, #1
 8000a16:	60da      	str	r2, [r3, #12]
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8000a18:	4b15      	ldr	r3, [pc, #84]	; (8000a70 <MX_I2C2_Init+0x74>)
 8000a1a:	2200      	movs	r2, #0
 8000a1c:	611a      	str	r2, [r3, #16]
  hi2c2.Init.OwnAddress2 = 0;
 8000a1e:	4b14      	ldr	r3, [pc, #80]	; (8000a70 <MX_I2C2_Init+0x74>)
 8000a20:	2200      	movs	r2, #0
 8000a22:	615a      	str	r2, [r3, #20]
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 8000a24:	4b12      	ldr	r3, [pc, #72]	; (8000a70 <MX_I2C2_Init+0x74>)
 8000a26:	2200      	movs	r2, #0
 8000a28:	619a      	str	r2, [r3, #24]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8000a2a:	4b11      	ldr	r3, [pc, #68]	; (8000a70 <MX_I2C2_Init+0x74>)
 8000a2c:	2200      	movs	r2, #0
 8000a2e:	61da      	str	r2, [r3, #28]
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8000a30:	4b0f      	ldr	r3, [pc, #60]	; (8000a70 <MX_I2C2_Init+0x74>)
 8000a32:	2200      	movs	r2, #0
 8000a34:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
 8000a36:	480e      	ldr	r0, [pc, #56]	; (8000a70 <MX_I2C2_Init+0x74>)
 8000a38:	f002 fab1 	bl	8002f9e <HAL_I2C_Init>
 8000a3c:	4603      	mov	r3, r0
 8000a3e:	2b00      	cmp	r3, #0
 8000a40:	d001      	beq.n	8000a46 <MX_I2C2_Init+0x4a>
  {
    Error_Handler();
 8000a42:	f000 fb67 	bl	8001114 <Error_Handler>
  }
  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 8000a46:	2100      	movs	r1, #0
 8000a48:	4809      	ldr	r0, [pc, #36]	; (8000a70 <MX_I2C2_Init+0x74>)
 8000a4a:	f002 fb37 	bl	80030bc <HAL_I2CEx_ConfigAnalogFilter>
 8000a4e:	4603      	mov	r3, r0
 8000a50:	2b00      	cmp	r3, #0
 8000a52:	d001      	beq.n	8000a58 <MX_I2C2_Init+0x5c>
  {
    Error_Handler();
 8000a54:	f000 fb5e 	bl	8001114 <Error_Handler>
  }
  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
 8000a58:	2100      	movs	r1, #0
 8000a5a:	4805      	ldr	r0, [pc, #20]	; (8000a70 <MX_I2C2_Init+0x74>)
 8000a5c:	f002 fb79 	bl	8003152 <HAL_I2CEx_ConfigDigitalFilter>
 8000a60:	4603      	mov	r3, r0
 8000a62:	2b00      	cmp	r3, #0
 8000a64:	d001      	beq.n	8000a6a <MX_I2C2_Init+0x6e>
  {
    Error_Handler();
 8000a66:	f000 fb55 	bl	8001114 <Error_Handler>
  }
  /* USER CODE BEGIN I2C2_Init 2 */

  /* USER CODE END I2C2_Init 2 */

}
 8000a6a:	bf00      	nop
 8000a6c:	bd80      	pop	{r7, pc}
 8000a6e:	bf00      	nop
 8000a70:	20000370 	.word	0x20000370
 8000a74:	40005800 	.word	0x40005800
 8000a78:	307075b1 	.word	0x307075b1

08000a7c <MX_OCTOSPI1_Init>:
  * @brief OCTOSPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_OCTOSPI1_Init(void)
{
 8000a7c:	b580      	push	{r7, lr}
 8000a7e:	b086      	sub	sp, #24
 8000a80:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN OCTOSPI1_Init 0 */

  /* USER CODE END OCTOSPI1_Init 0 */

  OSPIM_CfgTypeDef OSPIM_Cfg_Struct = {0};
 8000a82:	1d3b      	adds	r3, r7, #4
 8000a84:	2200      	movs	r2, #0
 8000a86:	601a      	str	r2, [r3, #0]
 8000a88:	605a      	str	r2, [r3, #4]
 8000a8a:	609a      	str	r2, [r3, #8]
 8000a8c:	60da      	str	r2, [r3, #12]
 8000a8e:	611a      	str	r2, [r3, #16]

  /* USER CODE BEGIN OCTOSPI1_Init 1 */

  /* USER CODE END OCTOSPI1_Init 1 */
  /* OCTOSPI1 parameter configuration*/
  hospi1.Instance = OCTOSPI1;
 8000a90:	4b23      	ldr	r3, [pc, #140]	; (8000b20 <MX_OCTOSPI1_Init+0xa4>)
 8000a92:	4a24      	ldr	r2, [pc, #144]	; (8000b24 <MX_OCTOSPI1_Init+0xa8>)
 8000a94:	601a      	str	r2, [r3, #0]
  hospi1.Init.FifoThreshold = 1;
 8000a96:	4b22      	ldr	r3, [pc, #136]	; (8000b20 <MX_OCTOSPI1_Init+0xa4>)
 8000a98:	2201      	movs	r2, #1
 8000a9a:	605a      	str	r2, [r3, #4]
  hospi1.Init.DualQuad = HAL_OSPI_DUALQUAD_DISABLE;
 8000a9c:	4b20      	ldr	r3, [pc, #128]	; (8000b20 <MX_OCTOSPI1_Init+0xa4>)
 8000a9e:	2200      	movs	r2, #0
 8000aa0:	609a      	str	r2, [r3, #8]
  hospi1.Init.MemoryType = HAL_OSPI_MEMTYPE_MACRONIX;
 8000aa2:	4b1f      	ldr	r3, [pc, #124]	; (8000b20 <MX_OCTOSPI1_Init+0xa4>)
 8000aa4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8000aa8:	60da      	str	r2, [r3, #12]
  hospi1.Init.DeviceSize = 32;
 8000aaa:	4b1d      	ldr	r3, [pc, #116]	; (8000b20 <MX_OCTOSPI1_Init+0xa4>)
 8000aac:	2220      	movs	r2, #32
 8000aae:	611a      	str	r2, [r3, #16]
  hospi1.Init.ChipSelectHighTime = 1;
 8000ab0:	4b1b      	ldr	r3, [pc, #108]	; (8000b20 <MX_OCTOSPI1_Init+0xa4>)
 8000ab2:	2201      	movs	r2, #1
 8000ab4:	615a      	str	r2, [r3, #20]
  hospi1.Init.FreeRunningClock = HAL_OSPI_FREERUNCLK_DISABLE;
 8000ab6:	4b1a      	ldr	r3, [pc, #104]	; (8000b20 <MX_OCTOSPI1_Init+0xa4>)
 8000ab8:	2200      	movs	r2, #0
 8000aba:	619a      	str	r2, [r3, #24]
  hospi1.Init.ClockMode = HAL_OSPI_CLOCK_MODE_0;
 8000abc:	4b18      	ldr	r3, [pc, #96]	; (8000b20 <MX_OCTOSPI1_Init+0xa4>)
 8000abe:	2200      	movs	r2, #0
 8000ac0:	61da      	str	r2, [r3, #28]
  hospi1.Init.ClockPrescaler = 1;
 8000ac2:	4b17      	ldr	r3, [pc, #92]	; (8000b20 <MX_OCTOSPI1_Init+0xa4>)
 8000ac4:	2201      	movs	r2, #1
 8000ac6:	621a      	str	r2, [r3, #32]
  hospi1.Init.SampleShifting = HAL_OSPI_SAMPLE_SHIFTING_NONE;
 8000ac8:	4b15      	ldr	r3, [pc, #84]	; (8000b20 <MX_OCTOSPI1_Init+0xa4>)
 8000aca:	2200      	movs	r2, #0
 8000acc:	625a      	str	r2, [r3, #36]	; 0x24
  hospi1.Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_DISABLE;
 8000ace:	4b14      	ldr	r3, [pc, #80]	; (8000b20 <MX_OCTOSPI1_Init+0xa4>)
 8000ad0:	2200      	movs	r2, #0
 8000ad2:	629a      	str	r2, [r3, #40]	; 0x28
  hospi1.Init.ChipSelectBoundary = 0;
 8000ad4:	4b12      	ldr	r3, [pc, #72]	; (8000b20 <MX_OCTOSPI1_Init+0xa4>)
 8000ad6:	2200      	movs	r2, #0
 8000ad8:	62da      	str	r2, [r3, #44]	; 0x2c
  hospi1.Init.DelayBlockBypass = HAL_OSPI_DELAY_BLOCK_BYPASSED;
 8000ada:	4b11      	ldr	r3, [pc, #68]	; (8000b20 <MX_OCTOSPI1_Init+0xa4>)
 8000adc:	2208      	movs	r2, #8
 8000ade:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_OSPI_Init(&hospi1) != HAL_OK)
 8000ae0:	480f      	ldr	r0, [pc, #60]	; (8000b20 <MX_OCTOSPI1_Init+0xa4>)
 8000ae2:	f002 fb83 	bl	80031ec <HAL_OSPI_Init>
 8000ae6:	4603      	mov	r3, r0
 8000ae8:	2b00      	cmp	r3, #0
 8000aea:	d001      	beq.n	8000af0 <MX_OCTOSPI1_Init+0x74>
  {
    Error_Handler();
 8000aec:	f000 fb12 	bl	8001114 <Error_Handler>
  }
  OSPIM_Cfg_Struct.ClkPort = 1;
 8000af0:	2301      	movs	r3, #1
 8000af2:	607b      	str	r3, [r7, #4]
  OSPIM_Cfg_Struct.NCSPort = 1;
 8000af4:	2301      	movs	r3, #1
 8000af6:	60fb      	str	r3, [r7, #12]
  OSPIM_Cfg_Struct.IOLowPort = HAL_OSPIM_IOPORT_1_LOW;
 8000af8:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8000afc:	613b      	str	r3, [r7, #16]
  if (HAL_OSPIM_Config(&hospi1, &OSPIM_Cfg_Struct, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8000afe:	1d3b      	adds	r3, r7, #4
 8000b00:	f241 3288 	movw	r2, #5000	; 0x1388
 8000b04:	4619      	mov	r1, r3
 8000b06:	4806      	ldr	r0, [pc, #24]	; (8000b20 <MX_OCTOSPI1_Init+0xa4>)
 8000b08:	f002 fc2a 	bl	8003360 <HAL_OSPIM_Config>
 8000b0c:	4603      	mov	r3, r0
 8000b0e:	2b00      	cmp	r3, #0
 8000b10:	d001      	beq.n	8000b16 <MX_OCTOSPI1_Init+0x9a>
  {
    Error_Handler();
 8000b12:	f000 faff 	bl	8001114 <Error_Handler>
  }
  /* USER CODE BEGIN OCTOSPI1_Init 2 */

  /* USER CODE END OCTOSPI1_Init 2 */

}
 8000b16:	bf00      	nop
 8000b18:	3718      	adds	r7, #24
 8000b1a:	46bd      	mov	sp, r7
 8000b1c:	bd80      	pop	{r7, pc}
 8000b1e:	bf00      	nop
 8000b20:	20000320 	.word	0x20000320
 8000b24:	a0001000 	.word	0xa0001000

08000b28 <MX_SPI1_Init>:
  * @brief SPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI1_Init(void)
{
 8000b28:	b580      	push	{r7, lr}
 8000b2a:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
 8000b2c:	4b1b      	ldr	r3, [pc, #108]	; (8000b9c <MX_SPI1_Init+0x74>)
 8000b2e:	4a1c      	ldr	r2, [pc, #112]	; (8000ba0 <MX_SPI1_Init+0x78>)
 8000b30:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 8000b32:	4b1a      	ldr	r3, [pc, #104]	; (8000b9c <MX_SPI1_Init+0x74>)
 8000b34:	f44f 7282 	mov.w	r2, #260	; 0x104
 8000b38:	605a      	str	r2, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 8000b3a:	4b18      	ldr	r3, [pc, #96]	; (8000b9c <MX_SPI1_Init+0x74>)
 8000b3c:	2200      	movs	r2, #0
 8000b3e:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_4BIT;
 8000b40:	4b16      	ldr	r3, [pc, #88]	; (8000b9c <MX_SPI1_Init+0x74>)
 8000b42:	f44f 7240 	mov.w	r2, #768	; 0x300
 8000b46:	60da      	str	r2, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 8000b48:	4b14      	ldr	r3, [pc, #80]	; (8000b9c <MX_SPI1_Init+0x74>)
 8000b4a:	2200      	movs	r2, #0
 8000b4c:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 8000b4e:	4b13      	ldr	r3, [pc, #76]	; (8000b9c <MX_SPI1_Init+0x74>)
 8000b50:	2200      	movs	r2, #0
 8000b52:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 8000b54:	4b11      	ldr	r3, [pc, #68]	; (8000b9c <MX_SPI1_Init+0x74>)
 8000b56:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000b5a:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 8000b5c:	4b0f      	ldr	r3, [pc, #60]	; (8000b9c <MX_SPI1_Init+0x74>)
 8000b5e:	2208      	movs	r2, #8
 8000b60:	61da      	str	r2, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8000b62:	4b0e      	ldr	r3, [pc, #56]	; (8000b9c <MX_SPI1_Init+0x74>)
 8000b64:	2200      	movs	r2, #0
 8000b66:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 8000b68:	4b0c      	ldr	r3, [pc, #48]	; (8000b9c <MX_SPI1_Init+0x74>)
 8000b6a:	2200      	movs	r2, #0
 8000b6c:	625a      	str	r2, [r3, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8000b6e:	4b0b      	ldr	r3, [pc, #44]	; (8000b9c <MX_SPI1_Init+0x74>)
 8000b70:	2200      	movs	r2, #0
 8000b72:	629a      	str	r2, [r3, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 7;
 8000b74:	4b09      	ldr	r3, [pc, #36]	; (8000b9c <MX_SPI1_Init+0x74>)
 8000b76:	2207      	movs	r2, #7
 8000b78:	62da      	str	r2, [r3, #44]	; 0x2c
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 8000b7a:	4b08      	ldr	r3, [pc, #32]	; (8000b9c <MX_SPI1_Init+0x74>)
 8000b7c:	2200      	movs	r2, #0
 8000b7e:	631a      	str	r2, [r3, #48]	; 0x30
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 8000b80:	4b06      	ldr	r3, [pc, #24]	; (8000b9c <MX_SPI1_Init+0x74>)
 8000b82:	2208      	movs	r2, #8
 8000b84:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8000b86:	4805      	ldr	r0, [pc, #20]	; (8000b9c <MX_SPI1_Init+0x74>)
 8000b88:	f004 fce8 	bl	800555c <HAL_SPI_Init>
 8000b8c:	4603      	mov	r3, r0
 8000b8e:	2b00      	cmp	r3, #0
 8000b90:	d001      	beq.n	8000b96 <MX_SPI1_Init+0x6e>
  {
    Error_Handler();
 8000b92:	f000 fabf 	bl	8001114 <Error_Handler>
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}
 8000b96:	bf00      	nop
 8000b98:	bd80      	pop	{r7, pc}
 8000b9a:	bf00      	nop
 8000b9c:	200005a0 	.word	0x200005a0
 8000ba0:	40013000 	.word	0x40013000

08000ba4 <MX_SPI3_Init>:
  * @brief SPI3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI3_Init(void)
{
 8000ba4:	b580      	push	{r7, lr}
 8000ba6:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN SPI3_Init 1 */

  /* USER CODE END SPI3_Init 1 */
  /* SPI3 parameter configuration*/
  hspi3.Instance = SPI3;
 8000ba8:	4b1b      	ldr	r3, [pc, #108]	; (8000c18 <MX_SPI3_Init+0x74>)
 8000baa:	4a1c      	ldr	r2, [pc, #112]	; (8000c1c <MX_SPI3_Init+0x78>)
 8000bac:	601a      	str	r2, [r3, #0]
  hspi3.Init.Mode = SPI_MODE_MASTER;
 8000bae:	4b1a      	ldr	r3, [pc, #104]	; (8000c18 <MX_SPI3_Init+0x74>)
 8000bb0:	f44f 7282 	mov.w	r2, #260	; 0x104
 8000bb4:	605a      	str	r2, [r3, #4]
  hspi3.Init.Direction = SPI_DIRECTION_2LINES;
 8000bb6:	4b18      	ldr	r3, [pc, #96]	; (8000c18 <MX_SPI3_Init+0x74>)
 8000bb8:	2200      	movs	r2, #0
 8000bba:	609a      	str	r2, [r3, #8]
  hspi3.Init.DataSize = SPI_DATASIZE_4BIT;
 8000bbc:	4b16      	ldr	r3, [pc, #88]	; (8000c18 <MX_SPI3_Init+0x74>)
 8000bbe:	f44f 7240 	mov.w	r2, #768	; 0x300
 8000bc2:	60da      	str	r2, [r3, #12]
  hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
 8000bc4:	4b14      	ldr	r3, [pc, #80]	; (8000c18 <MX_SPI3_Init+0x74>)
 8000bc6:	2200      	movs	r2, #0
 8000bc8:	611a      	str	r2, [r3, #16]
  hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
 8000bca:	4b13      	ldr	r3, [pc, #76]	; (8000c18 <MX_SPI3_Init+0x74>)
 8000bcc:	2200      	movs	r2, #0
 8000bce:	615a      	str	r2, [r3, #20]
  hspi3.Init.NSS = SPI_NSS_SOFT;
 8000bd0:	4b11      	ldr	r3, [pc, #68]	; (8000c18 <MX_SPI3_Init+0x74>)
 8000bd2:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000bd6:	619a      	str	r2, [r3, #24]
  hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 8000bd8:	4b0f      	ldr	r3, [pc, #60]	; (8000c18 <MX_SPI3_Init+0x74>)
 8000bda:	2208      	movs	r2, #8
 8000bdc:	61da      	str	r2, [r3, #28]
  hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8000bde:	4b0e      	ldr	r3, [pc, #56]	; (8000c18 <MX_SPI3_Init+0x74>)
 8000be0:	2200      	movs	r2, #0
 8000be2:	621a      	str	r2, [r3, #32]
  hspi3.Init.TIMode = SPI_TIMODE_DISABLE;
 8000be4:	4b0c      	ldr	r3, [pc, #48]	; (8000c18 <MX_SPI3_Init+0x74>)
 8000be6:	2200      	movs	r2, #0
 8000be8:	625a      	str	r2, [r3, #36]	; 0x24
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8000bea:	4b0b      	ldr	r3, [pc, #44]	; (8000c18 <MX_SPI3_Init+0x74>)
 8000bec:	2200      	movs	r2, #0
 8000bee:	629a      	str	r2, [r3, #40]	; 0x28
  hspi3.Init.CRCPolynomial = 7;
 8000bf0:	4b09      	ldr	r3, [pc, #36]	; (8000c18 <MX_SPI3_Init+0x74>)
 8000bf2:	2207      	movs	r2, #7
 8000bf4:	62da      	str	r2, [r3, #44]	; 0x2c
  hspi3.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 8000bf6:	4b08      	ldr	r3, [pc, #32]	; (8000c18 <MX_SPI3_Init+0x74>)
 8000bf8:	2200      	movs	r2, #0
 8000bfa:	631a      	str	r2, [r3, #48]	; 0x30
  hspi3.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 8000bfc:	4b06      	ldr	r3, [pc, #24]	; (8000c18 <MX_SPI3_Init+0x74>)
 8000bfe:	2208      	movs	r2, #8
 8000c00:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_SPI_Init(&hspi3) != HAL_OK)
 8000c02:	4805      	ldr	r0, [pc, #20]	; (8000c18 <MX_SPI3_Init+0x74>)
 8000c04:	f004 fcaa 	bl	800555c <HAL_SPI_Init>
 8000c08:	4603      	mov	r3, r0
 8000c0a:	2b00      	cmp	r3, #0
 8000c0c:	d001      	beq.n	8000c12 <MX_SPI3_Init+0x6e>
  {
    Error_Handler();
 8000c0e:	f000 fa81 	bl	8001114 <Error_Handler>
  }
  /* USER CODE BEGIN SPI3_Init 2 */

  /* USER CODE END SPI3_Init 2 */

}
 8000c12:	bf00      	nop
 8000c14:	bd80      	pop	{r7, pc}
 8000c16:	bf00      	nop
 8000c18:	200003bc 	.word	0x200003bc
 8000c1c:	40003c00 	.word	0x40003c00

08000c20 <MX_UART4_Init>:
  * @brief UART4 Initialization Function
  * @param None
  * @retval None
  */
static void MX_UART4_Init(void)
{
 8000c20:	b580      	push	{r7, lr}
 8000c22:	af00      	add	r7, sp, #0
  /* USER CODE END UART4_Init 0 */

  /* USER CODE BEGIN UART4_Init 1 */

  /* USER CODE END UART4_Init 1 */
  huart4.Instance = UART4;
 8000c24:	4b22      	ldr	r3, [pc, #136]	; (8000cb0 <MX_UART4_Init+0x90>)
 8000c26:	4a23      	ldr	r2, [pc, #140]	; (8000cb4 <MX_UART4_Init+0x94>)
 8000c28:	601a      	str	r2, [r3, #0]
  huart4.Init.BaudRate = 115200;
 8000c2a:	4b21      	ldr	r3, [pc, #132]	; (8000cb0 <MX_UART4_Init+0x90>)
 8000c2c:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 8000c30:	605a      	str	r2, [r3, #4]
  huart4.Init.WordLength = UART_WORDLENGTH_8B;
 8000c32:	4b1f      	ldr	r3, [pc, #124]	; (8000cb0 <MX_UART4_Init+0x90>)
 8000c34:	2200      	movs	r2, #0
 8000c36:	609a      	str	r2, [r3, #8]
  huart4.Init.StopBits = UART_STOPBITS_1;
 8000c38:	4b1d      	ldr	r3, [pc, #116]	; (8000cb0 <MX_UART4_Init+0x90>)
 8000c3a:	2200      	movs	r2, #0
 8000c3c:	60da      	str	r2, [r3, #12]
  huart4.Init.Parity = UART_PARITY_NONE;
 8000c3e:	4b1c      	ldr	r3, [pc, #112]	; (8000cb0 <MX_UART4_Init+0x90>)
 8000c40:	2200      	movs	r2, #0
 8000c42:	611a      	str	r2, [r3, #16]
  huart4.Init.Mode = UART_MODE_TX_RX;
 8000c44:	4b1a      	ldr	r3, [pc, #104]	; (8000cb0 <MX_UART4_Init+0x90>)
 8000c46:	220c      	movs	r2, #12
 8000c48:	615a      	str	r2, [r3, #20]
  huart4.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8000c4a:	4b19      	ldr	r3, [pc, #100]	; (8000cb0 <MX_UART4_Init+0x90>)
 8000c4c:	2200      	movs	r2, #0
 8000c4e:	619a      	str	r2, [r3, #24]
  huart4.Init.OverSampling = UART_OVERSAMPLING_16;
 8000c50:	4b17      	ldr	r3, [pc, #92]	; (8000cb0 <MX_UART4_Init+0x90>)
 8000c52:	2200      	movs	r2, #0
 8000c54:	61da      	str	r2, [r3, #28]
  huart4.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8000c56:	4b16      	ldr	r3, [pc, #88]	; (8000cb0 <MX_UART4_Init+0x90>)
 8000c58:	2200      	movs	r2, #0
 8000c5a:	621a      	str	r2, [r3, #32]
  huart4.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 8000c5c:	4b14      	ldr	r3, [pc, #80]	; (8000cb0 <MX_UART4_Init+0x90>)
 8000c5e:	2200      	movs	r2, #0
 8000c60:	625a      	str	r2, [r3, #36]	; 0x24
  huart4.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8000c62:	4b13      	ldr	r3, [pc, #76]	; (8000cb0 <MX_UART4_Init+0x90>)
 8000c64:	2200      	movs	r2, #0
 8000c66:	629a      	str	r2, [r3, #40]	; 0x28
  if (HAL_UART_Init(&huart4) != HAL_OK)
 8000c68:	4811      	ldr	r0, [pc, #68]	; (8000cb0 <MX_UART4_Init+0x90>)
 8000c6a:	f004 fd1a 	bl	80056a2 <HAL_UART_Init>
 8000c6e:	4603      	mov	r3, r0
 8000c70:	2b00      	cmp	r3, #0
 8000c72:	d001      	beq.n	8000c78 <MX_UART4_Init+0x58>
  {
    Error_Handler();
 8000c74:	f000 fa4e 	bl	8001114 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart4, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8000c78:	2100      	movs	r1, #0
 8000c7a:	480d      	ldr	r0, [pc, #52]	; (8000cb0 <MX_UART4_Init+0x90>)
 8000c7c:	f005 fa6d 	bl	800615a <HAL_UARTEx_SetTxFifoThreshold>
 8000c80:	4603      	mov	r3, r0
 8000c82:	2b00      	cmp	r3, #0
 8000c84:	d001      	beq.n	8000c8a <MX_UART4_Init+0x6a>
  {
    Error_Handler();
 8000c86:	f000 fa45 	bl	8001114 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart4, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8000c8a:	2100      	movs	r1, #0
 8000c8c:	4808      	ldr	r0, [pc, #32]	; (8000cb0 <MX_UART4_Init+0x90>)
 8000c8e:	f005 faa2 	bl	80061d6 <HAL_UARTEx_SetRxFifoThreshold>
 8000c92:	4603      	mov	r3, r0
 8000c94:	2b00      	cmp	r3, #0
 8000c96:	d001      	beq.n	8000c9c <MX_UART4_Init+0x7c>
  {
    Error_Handler();
 8000c98:	f000 fa3c 	bl	8001114 <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart4) != HAL_OK)
 8000c9c:	4804      	ldr	r0, [pc, #16]	; (8000cb0 <MX_UART4_Init+0x90>)
 8000c9e:	f005 fa23 	bl	80060e8 <HAL_UARTEx_DisableFifoMode>
 8000ca2:	4603      	mov	r3, r0
 8000ca4:	2b00      	cmp	r3, #0
 8000ca6:	d001      	beq.n	8000cac <MX_UART4_Init+0x8c>
  {
    Error_Handler();
 8000ca8:	f000 fa34 	bl	8001114 <Error_Handler>
  }
  /* USER CODE BEGIN UART4_Init 2 */

  /* USER CODE END UART4_Init 2 */

}
 8000cac:	bf00      	nop
 8000cae:	bd80      	pop	{r7, pc}
 8000cb0:	20000514 	.word	0x20000514
 8000cb4:	40004c00 	.word	0x40004c00

08000cb8 <MX_USART1_UART_Init>:
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{
 8000cb8:	b580      	push	{r7, lr}
 8000cba:	af00      	add	r7, sp, #0
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
 8000cbc:	4b22      	ldr	r3, [pc, #136]	; (8000d48 <MX_USART1_UART_Init+0x90>)
 8000cbe:	4a23      	ldr	r2, [pc, #140]	; (8000d4c <MX_USART1_UART_Init+0x94>)
 8000cc0:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 8000cc2:	4b21      	ldr	r3, [pc, #132]	; (8000d48 <MX_USART1_UART_Init+0x90>)
 8000cc4:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 8000cc8:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 8000cca:	4b1f      	ldr	r3, [pc, #124]	; (8000d48 <MX_USART1_UART_Init+0x90>)
 8000ccc:	2200      	movs	r2, #0
 8000cce:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 8000cd0:	4b1d      	ldr	r3, [pc, #116]	; (8000d48 <MX_USART1_UART_Init+0x90>)
 8000cd2:	2200      	movs	r2, #0
 8000cd4:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 8000cd6:	4b1c      	ldr	r3, [pc, #112]	; (8000d48 <MX_USART1_UART_Init+0x90>)
 8000cd8:	2200      	movs	r2, #0
 8000cda:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 8000cdc:	4b1a      	ldr	r3, [pc, #104]	; (8000d48 <MX_USART1_UART_Init+0x90>)
 8000cde:	220c      	movs	r2, #12
 8000ce0:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8000ce2:	4b19      	ldr	r3, [pc, #100]	; (8000d48 <MX_USART1_UART_Init+0x90>)
 8000ce4:	2200      	movs	r2, #0
 8000ce6:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 8000ce8:	4b17      	ldr	r3, [pc, #92]	; (8000d48 <MX_USART1_UART_Init+0x90>)
 8000cea:	2200      	movs	r2, #0
 8000cec:	61da      	str	r2, [r3, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8000cee:	4b16      	ldr	r3, [pc, #88]	; (8000d48 <MX_USART1_UART_Init+0x90>)
 8000cf0:	2200      	movs	r2, #0
 8000cf2:	621a      	str	r2, [r3, #32]
  huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 8000cf4:	4b14      	ldr	r3, [pc, #80]	; (8000d48 <MX_USART1_UART_Init+0x90>)
 8000cf6:	2200      	movs	r2, #0
 8000cf8:	625a      	str	r2, [r3, #36]	; 0x24
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8000cfa:	4b13      	ldr	r3, [pc, #76]	; (8000d48 <MX_USART1_UART_Init+0x90>)
 8000cfc:	2200      	movs	r2, #0
 8000cfe:	629a      	str	r2, [r3, #40]	; 0x28
  if (HAL_UART_Init(&huart1) != HAL_OK)
 8000d00:	4811      	ldr	r0, [pc, #68]	; (8000d48 <MX_USART1_UART_Init+0x90>)
 8000d02:	f004 fcce 	bl	80056a2 <HAL_UART_Init>
 8000d06:	4603      	mov	r3, r0
 8000d08:	2b00      	cmp	r3, #0
 8000d0a:	d001      	beq.n	8000d10 <MX_USART1_UART_Init+0x58>
  {
    Error_Handler();
 8000d0c:	f000 fa02 	bl	8001114 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8000d10:	2100      	movs	r1, #0
 8000d12:	480d      	ldr	r0, [pc, #52]	; (8000d48 <MX_USART1_UART_Init+0x90>)
 8000d14:	f005 fa21 	bl	800615a <HAL_UARTEx_SetTxFifoThreshold>
 8000d18:	4603      	mov	r3, r0
 8000d1a:	2b00      	cmp	r3, #0
 8000d1c:	d001      	beq.n	8000d22 <MX_USART1_UART_Init+0x6a>
  {
    Error_Handler();
 8000d1e:	f000 f9f9 	bl	8001114 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8000d22:	2100      	movs	r1, #0
 8000d24:	4808      	ldr	r0, [pc, #32]	; (8000d48 <MX_USART1_UART_Init+0x90>)
 8000d26:	f005 fa56 	bl	80061d6 <HAL_UARTEx_SetRxFifoThreshold>
 8000d2a:	4603      	mov	r3, r0
 8000d2c:	2b00      	cmp	r3, #0
 8000d2e:	d001      	beq.n	8000d34 <MX_USART1_UART_Init+0x7c>
  {
    Error_Handler();
 8000d30:	f000 f9f0 	bl	8001114 <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
 8000d34:	4804      	ldr	r0, [pc, #16]	; (8000d48 <MX_USART1_UART_Init+0x90>)
 8000d36:	f005 f9d7 	bl	80060e8 <HAL_UARTEx_DisableFifoMode>
 8000d3a:	4603      	mov	r3, r0
 8000d3c:	2b00      	cmp	r3, #0
 8000d3e:	d001      	beq.n	8000d44 <MX_USART1_UART_Init+0x8c>
  {
    Error_Handler();
 8000d40:	f000 f9e8 	bl	8001114 <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
 8000d44:	bf00      	nop
 8000d46:	bd80      	pop	{r7, pc}
 8000d48:	20000488 	.word	0x20000488
 8000d4c:	40013800 	.word	0x40013800

08000d50 <MX_USART2_UART_Init>:
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{
 8000d50:	b580      	push	{r7, lr}
 8000d52:	af00      	add	r7, sp, #0
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 8000d54:	4b23      	ldr	r3, [pc, #140]	; (8000de4 <MX_USART2_UART_Init+0x94>)
 8000d56:	4a24      	ldr	r2, [pc, #144]	; (8000de8 <MX_USART2_UART_Init+0x98>)
 8000d58:	601a      	str	r2, [r3, #0]
  huart2.Init.BaudRate = 115200;
 8000d5a:	4b22      	ldr	r3, [pc, #136]	; (8000de4 <MX_USART2_UART_Init+0x94>)
 8000d5c:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 8000d60:	605a      	str	r2, [r3, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8000d62:	4b20      	ldr	r3, [pc, #128]	; (8000de4 <MX_USART2_UART_Init+0x94>)
 8000d64:	2200      	movs	r2, #0
 8000d66:	609a      	str	r2, [r3, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 8000d68:	4b1e      	ldr	r3, [pc, #120]	; (8000de4 <MX_USART2_UART_Init+0x94>)
 8000d6a:	2200      	movs	r2, #0
 8000d6c:	60da      	str	r2, [r3, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 8000d6e:	4b1d      	ldr	r3, [pc, #116]	; (8000de4 <MX_USART2_UART_Init+0x94>)
 8000d70:	2200      	movs	r2, #0
 8000d72:	611a      	str	r2, [r3, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8000d74:	4b1b      	ldr	r3, [pc, #108]	; (8000de4 <MX_USART2_UART_Init+0x94>)
 8000d76:	220c      	movs	r2, #12
 8000d78:	615a      	str	r2, [r3, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_RTS_CTS;
 8000d7a:	4b1a      	ldr	r3, [pc, #104]	; (8000de4 <MX_USART2_UART_Init+0x94>)
 8000d7c:	f44f 7240 	mov.w	r2, #768	; 0x300
 8000d80:	619a      	str	r2, [r3, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8000d82:	4b18      	ldr	r3, [pc, #96]	; (8000de4 <MX_USART2_UART_Init+0x94>)
 8000d84:	2200      	movs	r2, #0
 8000d86:	61da      	str	r2, [r3, #28]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8000d88:	4b16      	ldr	r3, [pc, #88]	; (8000de4 <MX_USART2_UART_Init+0x94>)
 8000d8a:	2200      	movs	r2, #0
 8000d8c:	621a      	str	r2, [r3, #32]
  huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 8000d8e:	4b15      	ldr	r3, [pc, #84]	; (8000de4 <MX_USART2_UART_Init+0x94>)
 8000d90:	2200      	movs	r2, #0
 8000d92:	625a      	str	r2, [r3, #36]	; 0x24
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8000d94:	4b13      	ldr	r3, [pc, #76]	; (8000de4 <MX_USART2_UART_Init+0x94>)
 8000d96:	2200      	movs	r2, #0
 8000d98:	629a      	str	r2, [r3, #40]	; 0x28
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8000d9a:	4812      	ldr	r0, [pc, #72]	; (8000de4 <MX_USART2_UART_Init+0x94>)
 8000d9c:	f004 fc81 	bl	80056a2 <HAL_UART_Init>
 8000da0:	4603      	mov	r3, r0
 8000da2:	2b00      	cmp	r3, #0
 8000da4:	d001      	beq.n	8000daa <MX_USART2_UART_Init+0x5a>
  {
    Error_Handler();
 8000da6:	f000 f9b5 	bl	8001114 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8000daa:	2100      	movs	r1, #0
 8000dac:	480d      	ldr	r0, [pc, #52]	; (8000de4 <MX_USART2_UART_Init+0x94>)
 8000dae:	f005 f9d4 	bl	800615a <HAL_UARTEx_SetTxFifoThreshold>
 8000db2:	4603      	mov	r3, r0
 8000db4:	2b00      	cmp	r3, #0
 8000db6:	d001      	beq.n	8000dbc <MX_USART2_UART_Init+0x6c>
  {
    Error_Handler();
 8000db8:	f000 f9ac 	bl	8001114 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8000dbc:	2100      	movs	r1, #0
 8000dbe:	4809      	ldr	r0, [pc, #36]	; (8000de4 <MX_USART2_UART_Init+0x94>)
 8000dc0:	f005 fa09 	bl	80061d6 <HAL_UARTEx_SetRxFifoThreshold>
 8000dc4:	4603      	mov	r3, r0
 8000dc6:	2b00      	cmp	r3, #0
 8000dc8:	d001      	beq.n	8000dce <MX_USART2_UART_Init+0x7e>
  {
    Error_Handler();
 8000dca:	f000 f9a3 	bl	8001114 <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart2) != HAL_OK)
 8000dce:	4805      	ldr	r0, [pc, #20]	; (8000de4 <MX_USART2_UART_Init+0x94>)
 8000dd0:	f005 f98a 	bl	80060e8 <HAL_UARTEx_DisableFifoMode>
 8000dd4:	4603      	mov	r3, r0
 8000dd6:	2b00      	cmp	r3, #0
 8000dd8:	d001      	beq.n	8000dde <MX_USART2_UART_Init+0x8e>
  {
    Error_Handler();
 8000dda:	f000 f99b 	bl	8001114 <Error_Handler>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 8000dde:	bf00      	nop
 8000de0:	bd80      	pop	{r7, pc}
 8000de2:	bf00      	nop
 8000de4:	20000604 	.word	0x20000604
 8000de8:	40004400 	.word	0x40004400

08000dec <MX_USART3_UART_Init>:
  * @brief USART3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART3_UART_Init(void)
{
 8000dec:	b580      	push	{r7, lr}
 8000dee:	af00      	add	r7, sp, #0
  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
 8000df0:	4b22      	ldr	r3, [pc, #136]	; (8000e7c <MX_USART3_UART_Init+0x90>)
 8000df2:	4a23      	ldr	r2, [pc, #140]	; (8000e80 <MX_USART3_UART_Init+0x94>)
 8000df4:	601a      	str	r2, [r3, #0]
  huart3.Init.BaudRate = 115200;
 8000df6:	4b21      	ldr	r3, [pc, #132]	; (8000e7c <MX_USART3_UART_Init+0x90>)
 8000df8:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 8000dfc:	605a      	str	r2, [r3, #4]
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
 8000dfe:	4b1f      	ldr	r3, [pc, #124]	; (8000e7c <MX_USART3_UART_Init+0x90>)
 8000e00:	2200      	movs	r2, #0
 8000e02:	609a      	str	r2, [r3, #8]
  huart3.Init.StopBits = UART_STOPBITS_1;
 8000e04:	4b1d      	ldr	r3, [pc, #116]	; (8000e7c <MX_USART3_UART_Init+0x90>)
 8000e06:	2200      	movs	r2, #0
 8000e08:	60da      	str	r2, [r3, #12]
  huart3.Init.Parity = UART_PARITY_NONE;
 8000e0a:	4b1c      	ldr	r3, [pc, #112]	; (8000e7c <MX_USART3_UART_Init+0x90>)
 8000e0c:	2200      	movs	r2, #0
 8000e0e:	611a      	str	r2, [r3, #16]
  huart3.Init.Mode = UART_MODE_TX_RX;
 8000e10:	4b1a      	ldr	r3, [pc, #104]	; (8000e7c <MX_USART3_UART_Init+0x90>)
 8000e12:	220c      	movs	r2, #12
 8000e14:	615a      	str	r2, [r3, #20]
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8000e16:	4b19      	ldr	r3, [pc, #100]	; (8000e7c <MX_USART3_UART_Init+0x90>)
 8000e18:	2200      	movs	r2, #0
 8000e1a:	619a      	str	r2, [r3, #24]
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
 8000e1c:	4b17      	ldr	r3, [pc, #92]	; (8000e7c <MX_USART3_UART_Init+0x90>)
 8000e1e:	2200      	movs	r2, #0
 8000e20:	61da      	str	r2, [r3, #28]
  huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8000e22:	4b16      	ldr	r3, [pc, #88]	; (8000e7c <MX_USART3_UART_Init+0x90>)
 8000e24:	2200      	movs	r2, #0
 8000e26:	621a      	str	r2, [r3, #32]
  huart3.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 8000e28:	4b14      	ldr	r3, [pc, #80]	; (8000e7c <MX_USART3_UART_Init+0x90>)
 8000e2a:	2200      	movs	r2, #0
 8000e2c:	625a      	str	r2, [r3, #36]	; 0x24
  huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8000e2e:	4b13      	ldr	r3, [pc, #76]	; (8000e7c <MX_USART3_UART_Init+0x90>)
 8000e30:	2200      	movs	r2, #0
 8000e32:	629a      	str	r2, [r3, #40]	; 0x28
  if (HAL_UART_Init(&huart3) != HAL_OK)
 8000e34:	4811      	ldr	r0, [pc, #68]	; (8000e7c <MX_USART3_UART_Init+0x90>)
 8000e36:	f004 fc34 	bl	80056a2 <HAL_UART_Init>
 8000e3a:	4603      	mov	r3, r0
 8000e3c:	2b00      	cmp	r3, #0
 8000e3e:	d001      	beq.n	8000e44 <MX_USART3_UART_Init+0x58>
  {
    Error_Handler();
 8000e40:	f000 f968 	bl	8001114 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart3, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8000e44:	2100      	movs	r1, #0
 8000e46:	480d      	ldr	r0, [pc, #52]	; (8000e7c <MX_USART3_UART_Init+0x90>)
 8000e48:	f005 f987 	bl	800615a <HAL_UARTEx_SetTxFifoThreshold>
 8000e4c:	4603      	mov	r3, r0
 8000e4e:	2b00      	cmp	r3, #0
 8000e50:	d001      	beq.n	8000e56 <MX_USART3_UART_Init+0x6a>
  {
    Error_Handler();
 8000e52:	f000 f95f 	bl	8001114 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart3, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8000e56:	2100      	movs	r1, #0
 8000e58:	4808      	ldr	r0, [pc, #32]	; (8000e7c <MX_USART3_UART_Init+0x90>)
 8000e5a:	f005 f9bc 	bl	80061d6 <HAL_UARTEx_SetRxFifoThreshold>
 8000e5e:	4603      	mov	r3, r0
 8000e60:	2b00      	cmp	r3, #0
 8000e62:	d001      	beq.n	8000e68 <MX_USART3_UART_Init+0x7c>
  {
    Error_Handler();
 8000e64:	f000 f956 	bl	8001114 <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart3) != HAL_OK)
 8000e68:	4804      	ldr	r0, [pc, #16]	; (8000e7c <MX_USART3_UART_Init+0x90>)
 8000e6a:	f005 f93d 	bl	80060e8 <HAL_UARTEx_DisableFifoMode>
 8000e6e:	4603      	mov	r3, r0
 8000e70:	2b00      	cmp	r3, #0
 8000e72:	d001      	beq.n	8000e78 <MX_USART3_UART_Init+0x8c>
  {
    Error_Handler();
 8000e74:	f000 f94e 	bl	8001114 <Error_Handler>
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}
 8000e78:	bf00      	nop
 8000e7a:	bd80      	pop	{r7, pc}
 8000e7c:	20000248 	.word	0x20000248
 8000e80:	40004800 	.word	0x40004800

08000e84 <MX_USB_OTG_FS_USB_Init>:
  * @brief USB_OTG_FS Initialization Function
  * @param None
  * @retval None
  */
static void MX_USB_OTG_FS_USB_Init(void)
{
 8000e84:	b480      	push	{r7}
 8000e86:	af00      	add	r7, sp, #0
  /* USER CODE END USB_OTG_FS_Init 1 */
  /* USER CODE BEGIN USB_OTG_FS_Init 2 */

  /* USER CODE END USB_OTG_FS_Init 2 */

}
 8000e88:	bf00      	nop
 8000e8a:	46bd      	mov	sp, r7
 8000e8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000e90:	4770      	bx	lr
	...

08000e94 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 8000e94:	b580      	push	{r7, lr}
 8000e96:	b08c      	sub	sp, #48	; 0x30
 8000e98:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000e9a:	f107 031c 	add.w	r3, r7, #28
 8000e9e:	2200      	movs	r2, #0
 8000ea0:	601a      	str	r2, [r3, #0]
 8000ea2:	605a      	str	r2, [r3, #4]
 8000ea4:	609a      	str	r2, [r3, #8]
 8000ea6:	60da      	str	r2, [r3, #12]
 8000ea8:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8000eaa:	4b94      	ldr	r3, [pc, #592]	; (80010fc <MX_GPIO_Init+0x268>)
 8000eac:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000eae:	4a93      	ldr	r2, [pc, #588]	; (80010fc <MX_GPIO_Init+0x268>)
 8000eb0:	f043 0310 	orr.w	r3, r3, #16
 8000eb4:	64d3      	str	r3, [r2, #76]	; 0x4c
 8000eb6:	4b91      	ldr	r3, [pc, #580]	; (80010fc <MX_GPIO_Init+0x268>)
 8000eb8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000eba:	f003 0310 	and.w	r3, r3, #16
 8000ebe:	61bb      	str	r3, [r7, #24]
 8000ec0:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000ec2:	4b8e      	ldr	r3, [pc, #568]	; (80010fc <MX_GPIO_Init+0x268>)
 8000ec4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000ec6:	4a8d      	ldr	r2, [pc, #564]	; (80010fc <MX_GPIO_Init+0x268>)
 8000ec8:	f043 0304 	orr.w	r3, r3, #4
 8000ecc:	64d3      	str	r3, [r2, #76]	; 0x4c
 8000ece:	4b8b      	ldr	r3, [pc, #556]	; (80010fc <MX_GPIO_Init+0x268>)
 8000ed0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000ed2:	f003 0304 	and.w	r3, r3, #4
 8000ed6:	617b      	str	r3, [r7, #20]
 8000ed8:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8000eda:	4b88      	ldr	r3, [pc, #544]	; (80010fc <MX_GPIO_Init+0x268>)
 8000edc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000ede:	4a87      	ldr	r2, [pc, #540]	; (80010fc <MX_GPIO_Init+0x268>)
 8000ee0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000ee4:	64d3      	str	r3, [r2, #76]	; 0x4c
 8000ee6:	4b85      	ldr	r3, [pc, #532]	; (80010fc <MX_GPIO_Init+0x268>)
 8000ee8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000eea:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000eee:	613b      	str	r3, [r7, #16]
 8000ef0:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000ef2:	4b82      	ldr	r3, [pc, #520]	; (80010fc <MX_GPIO_Init+0x268>)
 8000ef4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000ef6:	4a81      	ldr	r2, [pc, #516]	; (80010fc <MX_GPIO_Init+0x268>)
 8000ef8:	f043 0301 	orr.w	r3, r3, #1
 8000efc:	64d3      	str	r3, [r2, #76]	; 0x4c
 8000efe:	4b7f      	ldr	r3, [pc, #508]	; (80010fc <MX_GPIO_Init+0x268>)
 8000f00:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000f02:	f003 0301 	and.w	r3, r3, #1
 8000f06:	60fb      	str	r3, [r7, #12]
 8000f08:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000f0a:	4b7c      	ldr	r3, [pc, #496]	; (80010fc <MX_GPIO_Init+0x268>)
 8000f0c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000f0e:	4a7b      	ldr	r2, [pc, #492]	; (80010fc <MX_GPIO_Init+0x268>)
 8000f10:	f043 0302 	orr.w	r3, r3, #2
 8000f14:	64d3      	str	r3, [r2, #76]	; 0x4c
 8000f16:	4b79      	ldr	r3, [pc, #484]	; (80010fc <MX_GPIO_Init+0x268>)
 8000f18:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000f1a:	f003 0302 	and.w	r3, r3, #2
 8000f1e:	60bb      	str	r3, [r7, #8]
 8000f20:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000f22:	4b76      	ldr	r3, [pc, #472]	; (80010fc <MX_GPIO_Init+0x268>)
 8000f24:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000f26:	4a75      	ldr	r2, [pc, #468]	; (80010fc <MX_GPIO_Init+0x268>)
 8000f28:	f043 0308 	orr.w	r3, r3, #8
 8000f2c:	64d3      	str	r3, [r2, #76]	; 0x4c
 8000f2e:	4b73      	ldr	r3, [pc, #460]	; (80010fc <MX_GPIO_Init+0x268>)
 8000f30:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000f32:	f003 0308 	and.w	r3, r3, #8
 8000f36:	607b      	str	r3, [r7, #4]
 8000f38:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, ST25DV04K_RF_DISABLE_Pin|ISM43362_RST_Pin|ISM43362_SPI3_CSN_Pin, GPIO_PIN_RESET);
 8000f3a:	2200      	movs	r2, #0
 8000f3c:	f240 1105 	movw	r1, #261	; 0x105
 8000f40:	486f      	ldr	r0, [pc, #444]	; (8001100 <MX_GPIO_Init+0x26c>)
 8000f42:	f001 fff1 	bl	8002f28 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, ARD_D10_Pin|ARD_D4_Pin|ARD_D7_Pin|SPBTLE_RF_RST_Pin
 8000f46:	2200      	movs	r2, #0
 8000f48:	f248 111c 	movw	r1, #33052	; 0x811c
 8000f4c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000f50:	f001 ffea 	bl	8002f28 <HAL_GPIO_WritePin>
                          |ARD_D9_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, ARD_D8_Pin|ISM43362_BOOT0_Pin|ISM43362_WAKEUP_Pin|LED2_Pin
 8000f54:	2200      	movs	r2, #0
 8000f56:	f24f 0134 	movw	r1, #61492	; 0xf034
 8000f5a:	486a      	ldr	r0, [pc, #424]	; (8001104 <MX_GPIO_Init+0x270>)
 8000f5c:	f001 ffe4 	bl	8002f28 <HAL_GPIO_WritePin>
                          |SPSGRF_915_SDN_Pin|ARD_D5_Pin|SPSGRF_915_SPI3_CSN_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, SPBTLE_RF_SPI3_CSN_Pin|PMOD_RESET_Pin|PMOD_SPI2_SCK_Pin|STSAFE_A110_RESET_Pin, GPIO_PIN_RESET);
 8000f60:	2200      	movs	r2, #0
 8000f62:	f242 0183 	movw	r1, #8323	; 0x2083
 8000f66:	4868      	ldr	r0, [pc, #416]	; (8001108 <MX_GPIO_Init+0x274>)
 8000f68:	f001 ffde 	bl	8002f28 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, VL53L0X_XSHUT_Pin|LED3_WIFI__LED4_BLE_Pin, GPIO_PIN_RESET);
 8000f6c:	2200      	movs	r2, #0
 8000f6e:	f44f 7110 	mov.w	r1, #576	; 0x240
 8000f72:	4866      	ldr	r0, [pc, #408]	; (800110c <MX_GPIO_Init+0x278>)
 8000f74:	f001 ffd8 	bl	8002f28 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : ST25DV04K_RF_DISABLE_Pin ISM43362_RST_Pin ISM43362_SPI3_CSN_Pin */
  GPIO_InitStruct.Pin = ST25DV04K_RF_DISABLE_Pin|ISM43362_RST_Pin|ISM43362_SPI3_CSN_Pin;
 8000f78:	f240 1305 	movw	r3, #261	; 0x105
 8000f7c:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000f7e:	2301      	movs	r3, #1
 8000f80:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000f82:	2300      	movs	r3, #0
 8000f84:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000f86:	2300      	movs	r3, #0
 8000f88:	62bb      	str	r3, [r7, #40]	; 0x28
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8000f8a:	f107 031c 	add.w	r3, r7, #28
 8000f8e:	4619      	mov	r1, r3
 8000f90:	485b      	ldr	r0, [pc, #364]	; (8001100 <MX_GPIO_Init+0x26c>)
 8000f92:	f001 fe37 	bl	8002c04 <HAL_GPIO_Init>

  /*Configure GPIO pins : USB_OTG_FS_OVRCR_EXTI3_Pin ST25DV04K_GPO_Pin SPSGRF_915_GPIO3_EXTI5_Pin SPBTLE_RF_IRQ_EXTI6_Pin
                           ISM43362_DRDY_EXTI1_Pin */
  GPIO_InitStruct.Pin = USB_OTG_FS_OVRCR_EXTI3_Pin|ST25DV04K_GPO_Pin|SPSGRF_915_GPIO3_EXTI5_Pin|SPBTLE_RF_IRQ_EXTI6_Pin
 8000f96:	237a      	movs	r3, #122	; 0x7a
 8000f98:	61fb      	str	r3, [r7, #28]
                          |ISM43362_DRDY_EXTI1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8000f9a:	4b5d      	ldr	r3, [pc, #372]	; (8001110 <MX_GPIO_Init+0x27c>)
 8000f9c:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000f9e:	2300      	movs	r3, #0
 8000fa0:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8000fa2:	f107 031c 	add.w	r3, r7, #28
 8000fa6:	4619      	mov	r1, r3
 8000fa8:	4855      	ldr	r0, [pc, #340]	; (8001100 <MX_GPIO_Init+0x26c>)
 8000faa:	f001 fe2b 	bl	8002c04 <HAL_GPIO_Init>

  /*Configure GPIO pins : BUTTON_EXTI13_Pin VL53L0X_GPIO1_EXTI7_Pin LSM3MDL_DRDY_EXTI8_Pin */
  GPIO_InitStruct.Pin = BUTTON_EXTI13_Pin|VL53L0X_GPIO1_EXTI7_Pin|LSM3MDL_DRDY_EXTI8_Pin;
 8000fae:	f44f 5306 	mov.w	r3, #8576	; 0x2180
 8000fb2:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8000fb4:	4b56      	ldr	r3, [pc, #344]	; (8001110 <MX_GPIO_Init+0x27c>)
 8000fb6:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000fb8:	2300      	movs	r3, #0
 8000fba:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000fbc:	f107 031c 	add.w	r3, r7, #28
 8000fc0:	4619      	mov	r1, r3
 8000fc2:	4852      	ldr	r0, [pc, #328]	; (800110c <MX_GPIO_Init+0x278>)
 8000fc4:	f001 fe1e 	bl	8002c04 <HAL_GPIO_Init>

  /*Configure GPIO pins : ARD_D10_Pin ARD_D4_Pin ARD_D7_Pin SPBTLE_RF_RST_Pin
                           ARD_D9_Pin */
  GPIO_InitStruct.Pin = ARD_D10_Pin|ARD_D4_Pin|ARD_D7_Pin|SPBTLE_RF_RST_Pin
 8000fc8:	f248 131c 	movw	r3, #33052	; 0x811c
 8000fcc:	61fb      	str	r3, [r7, #28]
                          |ARD_D9_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000fce:	2301      	movs	r3, #1
 8000fd0:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000fd2:	2300      	movs	r3, #0
 8000fd4:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000fd6:	2300      	movs	r3, #0
 8000fd8:	62bb      	str	r3, [r7, #40]	; 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000fda:	f107 031c 	add.w	r3, r7, #28
 8000fde:	4619      	mov	r1, r3
 8000fe0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000fe4:	f001 fe0e 	bl	8002c04 <HAL_GPIO_Init>

  /*Configure GPIO pin : ARD_D3_Pin */
  GPIO_InitStruct.Pin = ARD_D3_Pin;
 8000fe8:	2301      	movs	r3, #1
 8000fea:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8000fec:	4b48      	ldr	r3, [pc, #288]	; (8001110 <MX_GPIO_Init+0x27c>)
 8000fee:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000ff0:	2300      	movs	r3, #0
 8000ff2:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(ARD_D3_GPIO_Port, &GPIO_InitStruct);
 8000ff4:	f107 031c 	add.w	r3, r7, #28
 8000ff8:	4619      	mov	r1, r3
 8000ffa:	4842      	ldr	r0, [pc, #264]	; (8001104 <MX_GPIO_Init+0x270>)
 8000ffc:	f001 fe02 	bl	8002c04 <HAL_GPIO_Init>

  /*Configure GPIO pin : ARD_D6_Pin */
  GPIO_InitStruct.Pin = ARD_D6_Pin;
 8001000:	2302      	movs	r3, #2
 8001002:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001004:	2302      	movs	r3, #2
 8001006:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001008:	2300      	movs	r3, #0
 800100a:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800100c:	2300      	movs	r3, #0
 800100e:	62bb      	str	r3, [r7, #40]	; 0x28
  GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 8001010:	2302      	movs	r3, #2
 8001012:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(ARD_D6_GPIO_Port, &GPIO_InitStruct);
 8001014:	f107 031c 	add.w	r3, r7, #28
 8001018:	4619      	mov	r1, r3
 800101a:	483a      	ldr	r0, [pc, #232]	; (8001104 <MX_GPIO_Init+0x270>)
 800101c:	f001 fdf2 	bl	8002c04 <HAL_GPIO_Init>

  /*Configure GPIO pins : ARD_D8_Pin ISM43362_BOOT0_Pin ISM43362_WAKEUP_Pin LED2_Pin
                           SPSGRF_915_SDN_Pin ARD_D5_Pin SPSGRF_915_SPI3_CSN_Pin */
  GPIO_InitStruct.Pin = ARD_D8_Pin|ISM43362_BOOT0_Pin|ISM43362_WAKEUP_Pin|LED2_Pin
 8001020:	f24f 0334 	movw	r3, #61492	; 0xf034
 8001024:	61fb      	str	r3, [r7, #28]
                          |SPSGRF_915_SDN_Pin|ARD_D5_Pin|SPSGRF_915_SPI3_CSN_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001026:	2301      	movs	r3, #1
 8001028:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800102a:	2300      	movs	r3, #0
 800102c:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800102e:	2300      	movs	r3, #0
 8001030:	62bb      	str	r3, [r7, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001032:	f107 031c 	add.w	r3, r7, #28
 8001036:	4619      	mov	r1, r3
 8001038:	4832      	ldr	r0, [pc, #200]	; (8001104 <MX_GPIO_Init+0x270>)
 800103a:	f001 fde3 	bl	8002c04 <HAL_GPIO_Init>

  /*Configure GPIO pins : LPS22HB_INT_DRDY_EXTI10_Pin LSM6DSL_INT1_EXTI11_Pin USB_OTG_FS_PWR_EN_Pin ARD_D2_Pin
                           HTS221_DRDY_EXTI15_Pin PMOD_IRQ_EXTI12_Pin */
  GPIO_InitStruct.Pin = LPS22HB_INT_DRDY_EXTI10_Pin|LSM6DSL_INT1_EXTI11_Pin|USB_OTG_FS_PWR_EN_Pin|ARD_D2_Pin
 800103e:	f64d 4304 	movw	r3, #56324	; 0xdc04
 8001042:	61fb      	str	r3, [r7, #28]
                          |HTS221_DRDY_EXTI15_Pin|PMOD_IRQ_EXTI12_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8001044:	4b32      	ldr	r3, [pc, #200]	; (8001110 <MX_GPIO_Init+0x27c>)
 8001046:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001048:	2300      	movs	r3, #0
 800104a:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800104c:	f107 031c 	add.w	r3, r7, #28
 8001050:	4619      	mov	r1, r3
 8001052:	482d      	ldr	r0, [pc, #180]	; (8001108 <MX_GPIO_Init+0x274>)
 8001054:	f001 fdd6 	bl	8002c04 <HAL_GPIO_Init>

  /*Configure GPIO pins : SPBTLE_RF_SPI3_CSN_Pin PMOD_RESET_Pin PMOD_SPI2_SCK_Pin STSAFE_A110_RESET_Pin */
  GPIO_InitStruct.Pin = SPBTLE_RF_SPI3_CSN_Pin|PMOD_RESET_Pin|PMOD_SPI2_SCK_Pin|STSAFE_A110_RESET_Pin;
 8001058:	f242 0383 	movw	r3, #8323	; 0x2083
 800105c:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800105e:	2301      	movs	r3, #1
 8001060:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001062:	2300      	movs	r3, #0
 8001064:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001066:	2300      	movs	r3, #0
 8001068:	62bb      	str	r3, [r7, #40]	; 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800106a:	f107 031c 	add.w	r3, r7, #28
 800106e:	4619      	mov	r1, r3
 8001070:	4825      	ldr	r0, [pc, #148]	; (8001108 <MX_GPIO_Init+0x274>)
 8001072:	f001 fdc7 	bl	8002c04 <HAL_GPIO_Init>

  /*Configure GPIO pins : VL53L0X_XSHUT_Pin LED3_WIFI__LED4_BLE_Pin */
  GPIO_InitStruct.Pin = VL53L0X_XSHUT_Pin|LED3_WIFI__LED4_BLE_Pin;
 8001076:	f44f 7310 	mov.w	r3, #576	; 0x240
 800107a:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800107c:	2301      	movs	r3, #1
 800107e:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001080:	2300      	movs	r3, #0
 8001082:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001084:	2300      	movs	r3, #0
 8001086:	62bb      	str	r3, [r7, #40]	; 0x28
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001088:	f107 031c 	add.w	r3, r7, #28
 800108c:	4619      	mov	r1, r3
 800108e:	481f      	ldr	r0, [pc, #124]	; (800110c <MX_GPIO_Init+0x278>)
 8001090:	f001 fdb8 	bl	8002c04 <HAL_GPIO_Init>

  /*Configure GPIO pin : USB_OTG_FS_VBUS_Pin */
  GPIO_InitStruct.Pin = USB_OTG_FS_VBUS_Pin;
 8001094:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001098:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800109a:	2300      	movs	r3, #0
 800109c:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800109e:	2300      	movs	r3, #0
 80010a0:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(USB_OTG_FS_VBUS_GPIO_Port, &GPIO_InitStruct);
 80010a2:	f107 031c 	add.w	r3, r7, #28
 80010a6:	4619      	mov	r1, r3
 80010a8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80010ac:	f001 fdaa 	bl	8002c04 <HAL_GPIO_Init>

  /*Configure GPIO pins : USB_OTG_FS_ID_Pin USB_OTG_FS_DM_Pin USB_OTG_FS_DP_Pin */
  GPIO_InitStruct.Pin = USB_OTG_FS_ID_Pin|USB_OTG_FS_DM_Pin|USB_OTG_FS_DP_Pin;
 80010b0:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 80010b4:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80010b6:	2302      	movs	r3, #2
 80010b8:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80010ba:	2300      	movs	r3, #0
 80010bc:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80010be:	2303      	movs	r3, #3
 80010c0:	62bb      	str	r3, [r7, #40]	; 0x28
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 80010c2:	230a      	movs	r3, #10
 80010c4:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80010c6:	f107 031c 	add.w	r3, r7, #28
 80010ca:	4619      	mov	r1, r3
 80010cc:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80010d0:	f001 fd98 	bl	8002c04 <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI9_5_IRQn, 0, 0);
 80010d4:	2200      	movs	r2, #0
 80010d6:	2100      	movs	r1, #0
 80010d8:	2017      	movs	r0, #23
 80010da:	f001 fc50 	bl	800297e <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 80010de:	2017      	movs	r0, #23
 80010e0:	f001 fc69 	bl	80029b6 <HAL_NVIC_EnableIRQ>

  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
 80010e4:	2200      	movs	r2, #0
 80010e6:	2100      	movs	r1, #0
 80010e8:	2028      	movs	r0, #40	; 0x28
 80010ea:	f001 fc48 	bl	800297e <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 80010ee:	2028      	movs	r0, #40	; 0x28
 80010f0:	f001 fc61 	bl	80029b6 <HAL_NVIC_EnableIRQ>

}
 80010f4:	bf00      	nop
 80010f6:	3730      	adds	r7, #48	; 0x30
 80010f8:	46bd      	mov	sp, r7
 80010fa:	bd80      	pop	{r7, pc}
 80010fc:	40021000 	.word	0x40021000
 8001100:	48001000 	.word	0x48001000
 8001104:	48000400 	.word	0x48000400
 8001108:	48000c00 	.word	0x48000c00
 800110c:	48000800 	.word	0x48000800
 8001110:	10110000 	.word	0x10110000

08001114 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8001114:	b480      	push	{r7}
 8001116:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001118:	b672      	cpsid	i
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 800111a:	e7fe      	b.n	800111a <Error_Handler+0x6>

0800111c <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800111c:	b480      	push	{r7}
 800111e:	b083      	sub	sp, #12
 8001120:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001122:	4b0f      	ldr	r3, [pc, #60]	; (8001160 <HAL_MspInit+0x44>)
 8001124:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001126:	4a0e      	ldr	r2, [pc, #56]	; (8001160 <HAL_MspInit+0x44>)
 8001128:	f043 0301 	orr.w	r3, r3, #1
 800112c:	6613      	str	r3, [r2, #96]	; 0x60
 800112e:	4b0c      	ldr	r3, [pc, #48]	; (8001160 <HAL_MspInit+0x44>)
 8001130:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001132:	f003 0301 	and.w	r3, r3, #1
 8001136:	607b      	str	r3, [r7, #4]
 8001138:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 800113a:	4b09      	ldr	r3, [pc, #36]	; (8001160 <HAL_MspInit+0x44>)
 800113c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800113e:	4a08      	ldr	r2, [pc, #32]	; (8001160 <HAL_MspInit+0x44>)
 8001140:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001144:	6593      	str	r3, [r2, #88]	; 0x58
 8001146:	4b06      	ldr	r3, [pc, #24]	; (8001160 <HAL_MspInit+0x44>)
 8001148:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800114a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800114e:	603b      	str	r3, [r7, #0]
 8001150:	683b      	ldr	r3, [r7, #0]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8001152:	bf00      	nop
 8001154:	370c      	adds	r7, #12
 8001156:	46bd      	mov	sp, r7
 8001158:	f85d 7b04 	ldr.w	r7, [sp], #4
 800115c:	4770      	bx	lr
 800115e:	bf00      	nop
 8001160:	40021000 	.word	0x40021000

08001164 <HAL_ADC_MspInit>:
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8001164:	b580      	push	{r7, lr}
 8001166:	b08a      	sub	sp, #40	; 0x28
 8001168:	af00      	add	r7, sp, #0
 800116a:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800116c:	f107 0314 	add.w	r3, r7, #20
 8001170:	2200      	movs	r2, #0
 8001172:	601a      	str	r2, [r3, #0]
 8001174:	605a      	str	r2, [r3, #4]
 8001176:	609a      	str	r2, [r3, #8]
 8001178:	60da      	str	r2, [r3, #12]
 800117a:	611a      	str	r2, [r3, #16]
  if(hadc->Instance==ADC1)
 800117c:	687b      	ldr	r3, [r7, #4]
 800117e:	681b      	ldr	r3, [r3, #0]
 8001180:	4a15      	ldr	r2, [pc, #84]	; (80011d8 <HAL_ADC_MspInit+0x74>)
 8001182:	4293      	cmp	r3, r2
 8001184:	d123      	bne.n	80011ce <HAL_ADC_MspInit+0x6a>
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_ADC_CLK_ENABLE();
 8001186:	4b15      	ldr	r3, [pc, #84]	; (80011dc <HAL_ADC_MspInit+0x78>)
 8001188:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800118a:	4a14      	ldr	r2, [pc, #80]	; (80011dc <HAL_ADC_MspInit+0x78>)
 800118c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001190:	64d3      	str	r3, [r2, #76]	; 0x4c
 8001192:	4b12      	ldr	r3, [pc, #72]	; (80011dc <HAL_ADC_MspInit+0x78>)
 8001194:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001196:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 800119a:	613b      	str	r3, [r7, #16]
 800119c:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOC_CLK_ENABLE();
 800119e:	4b0f      	ldr	r3, [pc, #60]	; (80011dc <HAL_ADC_MspInit+0x78>)
 80011a0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80011a2:	4a0e      	ldr	r2, [pc, #56]	; (80011dc <HAL_ADC_MspInit+0x78>)
 80011a4:	f043 0304 	orr.w	r3, r3, #4
 80011a8:	64d3      	str	r3, [r2, #76]	; 0x4c
 80011aa:	4b0c      	ldr	r3, [pc, #48]	; (80011dc <HAL_ADC_MspInit+0x78>)
 80011ac:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80011ae:	f003 0304 	and.w	r3, r3, #4
 80011b2:	60fb      	str	r3, [r7, #12]
 80011b4:	68fb      	ldr	r3, [r7, #12]
    PC2     ------> ADC1_IN3
    PC3     ------> ADC1_IN4
    PC4     ------> ADC1_IN13
    PC5     ------> ADC1_IN14
    */
    GPIO_InitStruct.Pin = ARD_A5_Pin|ARD_A4_Pin|ARD_A3_Pin|ARD_A2_Pin
 80011b6:	233f      	movs	r3, #63	; 0x3f
 80011b8:	617b      	str	r3, [r7, #20]
                          |ARD_A1_Pin|ARD_A0_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG_ADC_CONTROL;
 80011ba:	230b      	movs	r3, #11
 80011bc:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80011be:	2300      	movs	r3, #0
 80011c0:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80011c2:	f107 0314 	add.w	r3, r7, #20
 80011c6:	4619      	mov	r1, r3
 80011c8:	4805      	ldr	r0, [pc, #20]	; (80011e0 <HAL_ADC_MspInit+0x7c>)
 80011ca:	f001 fd1b 	bl	8002c04 <HAL_GPIO_Init>
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }

}
 80011ce:	bf00      	nop
 80011d0:	3728      	adds	r7, #40	; 0x28
 80011d2:	46bd      	mov	sp, r7
 80011d4:	bd80      	pop	{r7, pc}
 80011d6:	bf00      	nop
 80011d8:	50040000 	.word	0x50040000
 80011dc:	40021000 	.word	0x40021000
 80011e0:	48000800 	.word	0x48000800

080011e4 <HAL_DFSDM_ChannelMspInit>:
* This function configures the hardware resources used in this example
* @param hdfsdm_channel: DFSDM_Channel handle pointer
* @retval None
*/
void HAL_DFSDM_ChannelMspInit(DFSDM_Channel_HandleTypeDef* hdfsdm_channel)
{
 80011e4:	b580      	push	{r7, lr}
 80011e6:	b08a      	sub	sp, #40	; 0x28
 80011e8:	af00      	add	r7, sp, #0
 80011ea:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80011ec:	f107 0314 	add.w	r3, r7, #20
 80011f0:	2200      	movs	r2, #0
 80011f2:	601a      	str	r2, [r3, #0]
 80011f4:	605a      	str	r2, [r3, #4]
 80011f6:	609a      	str	r2, [r3, #8]
 80011f8:	60da      	str	r2, [r3, #12]
 80011fa:	611a      	str	r2, [r3, #16]
  if(DFSDM1_Init == 0)
 80011fc:	4b1a      	ldr	r3, [pc, #104]	; (8001268 <HAL_DFSDM_ChannelMspInit+0x84>)
 80011fe:	681b      	ldr	r3, [r3, #0]
 8001200:	2b00      	cmp	r3, #0
 8001202:	d12d      	bne.n	8001260 <HAL_DFSDM_ChannelMspInit+0x7c>
  {
  /* USER CODE BEGIN DFSDM1_MspInit 0 */

  /* USER CODE END DFSDM1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_DFSDM1_CLK_ENABLE();
 8001204:	4b19      	ldr	r3, [pc, #100]	; (800126c <HAL_DFSDM_ChannelMspInit+0x88>)
 8001206:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001208:	4a18      	ldr	r2, [pc, #96]	; (800126c <HAL_DFSDM_ChannelMspInit+0x88>)
 800120a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800120e:	6613      	str	r3, [r2, #96]	; 0x60
 8001210:	4b16      	ldr	r3, [pc, #88]	; (800126c <HAL_DFSDM_ChannelMspInit+0x88>)
 8001212:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001214:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8001218:	613b      	str	r3, [r7, #16]
 800121a:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOE_CLK_ENABLE();
 800121c:	4b13      	ldr	r3, [pc, #76]	; (800126c <HAL_DFSDM_ChannelMspInit+0x88>)
 800121e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001220:	4a12      	ldr	r2, [pc, #72]	; (800126c <HAL_DFSDM_ChannelMspInit+0x88>)
 8001222:	f043 0310 	orr.w	r3, r3, #16
 8001226:	64d3      	str	r3, [r2, #76]	; 0x4c
 8001228:	4b10      	ldr	r3, [pc, #64]	; (800126c <HAL_DFSDM_ChannelMspInit+0x88>)
 800122a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800122c:	f003 0310 	and.w	r3, r3, #16
 8001230:	60fb      	str	r3, [r7, #12]
 8001232:	68fb      	ldr	r3, [r7, #12]
    /**DFSDM1 GPIO Configuration
    PE7     ------> DFSDM1_DATIN2
    PE9     ------> DFSDM1_CKOUT
    */
    GPIO_InitStruct.Pin = DFSDM1_DATIN2_Pin|DFSDM1_CKOUT_Pin;
 8001234:	f44f 7320 	mov.w	r3, #640	; 0x280
 8001238:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800123a:	2302      	movs	r3, #2
 800123c:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800123e:	2300      	movs	r3, #0
 8001240:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001242:	2300      	movs	r3, #0
 8001244:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF6_DFSDM1;
 8001246:	2306      	movs	r3, #6
 8001248:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800124a:	f107 0314 	add.w	r3, r7, #20
 800124e:	4619      	mov	r1, r3
 8001250:	4807      	ldr	r0, [pc, #28]	; (8001270 <HAL_DFSDM_ChannelMspInit+0x8c>)
 8001252:	f001 fcd7 	bl	8002c04 <HAL_GPIO_Init>

  /* USER CODE BEGIN DFSDM1_MspInit 1 */

  /* USER CODE END DFSDM1_MspInit 1 */
  DFSDM1_Init++;
 8001256:	4b04      	ldr	r3, [pc, #16]	; (8001268 <HAL_DFSDM_ChannelMspInit+0x84>)
 8001258:	681b      	ldr	r3, [r3, #0]
 800125a:	3301      	adds	r3, #1
 800125c:	4a02      	ldr	r2, [pc, #8]	; (8001268 <HAL_DFSDM_ChannelMspInit+0x84>)
 800125e:	6013      	str	r3, [r2, #0]
  }

}
 8001260:	bf00      	nop
 8001262:	3728      	adds	r7, #40	; 0x28
 8001264:	46bd      	mov	sp, r7
 8001266:	bd80      	pop	{r7, pc}
 8001268:	200001f8 	.word	0x200001f8
 800126c:	40021000 	.word	0x40021000
 8001270:	48001000 	.word	0x48001000

08001274 <HAL_I2C_MspInit>:
* This function configures the hardware resources used in this example
* @param hi2c: I2C handle pointer
* @retval None
*/
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 8001274:	b580      	push	{r7, lr}
 8001276:	b08c      	sub	sp, #48	; 0x30
 8001278:	af00      	add	r7, sp, #0
 800127a:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800127c:	f107 031c 	add.w	r3, r7, #28
 8001280:	2200      	movs	r2, #0
 8001282:	601a      	str	r2, [r3, #0]
 8001284:	605a      	str	r2, [r3, #4]
 8001286:	609a      	str	r2, [r3, #8]
 8001288:	60da      	str	r2, [r3, #12]
 800128a:	611a      	str	r2, [r3, #16]
  if(hi2c->Instance==I2C1)
 800128c:	687b      	ldr	r3, [r7, #4]
 800128e:	681b      	ldr	r3, [r3, #0]
 8001290:	4a2f      	ldr	r2, [pc, #188]	; (8001350 <HAL_I2C_MspInit+0xdc>)
 8001292:	4293      	cmp	r3, r2
 8001294:	d129      	bne.n	80012ea <HAL_I2C_MspInit+0x76>
  {
  /* USER CODE BEGIN I2C1_MspInit 0 */

  /* USER CODE END I2C1_MspInit 0 */

    __HAL_RCC_GPIOB_CLK_ENABLE();
 8001296:	4b2f      	ldr	r3, [pc, #188]	; (8001354 <HAL_I2C_MspInit+0xe0>)
 8001298:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800129a:	4a2e      	ldr	r2, [pc, #184]	; (8001354 <HAL_I2C_MspInit+0xe0>)
 800129c:	f043 0302 	orr.w	r3, r3, #2
 80012a0:	64d3      	str	r3, [r2, #76]	; 0x4c
 80012a2:	4b2c      	ldr	r3, [pc, #176]	; (8001354 <HAL_I2C_MspInit+0xe0>)
 80012a4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80012a6:	f003 0302 	and.w	r3, r3, #2
 80012aa:	61bb      	str	r3, [r7, #24]
 80012ac:	69bb      	ldr	r3, [r7, #24]
    /**I2C1 GPIO Configuration
    PB8     ------> I2C1_SCL
    PB9     ------> I2C1_SDA
    */
    GPIO_InitStruct.Pin = ARD_D15_Pin|ARD_D14_Pin;
 80012ae:	f44f 7340 	mov.w	r3, #768	; 0x300
 80012b2:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80012b4:	2312      	movs	r3, #18
 80012b6:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80012b8:	2301      	movs	r3, #1
 80012ba:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80012bc:	2303      	movs	r3, #3
 80012be:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 80012c0:	2304      	movs	r3, #4
 80012c2:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80012c4:	f107 031c 	add.w	r3, r7, #28
 80012c8:	4619      	mov	r1, r3
 80012ca:	4823      	ldr	r0, [pc, #140]	; (8001358 <HAL_I2C_MspInit+0xe4>)
 80012cc:	f001 fc9a 	bl	8002c04 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 80012d0:	4b20      	ldr	r3, [pc, #128]	; (8001354 <HAL_I2C_MspInit+0xe0>)
 80012d2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80012d4:	4a1f      	ldr	r2, [pc, #124]	; (8001354 <HAL_I2C_MspInit+0xe0>)
 80012d6:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80012da:	6593      	str	r3, [r2, #88]	; 0x58
 80012dc:	4b1d      	ldr	r3, [pc, #116]	; (8001354 <HAL_I2C_MspInit+0xe0>)
 80012de:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80012e0:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80012e4:	617b      	str	r3, [r7, #20]
 80012e6:	697b      	ldr	r3, [r7, #20]
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }

}
 80012e8:	e02d      	b.n	8001346 <HAL_I2C_MspInit+0xd2>
  else if(hi2c->Instance==I2C2)
 80012ea:	687b      	ldr	r3, [r7, #4]
 80012ec:	681b      	ldr	r3, [r3, #0]
 80012ee:	4a1b      	ldr	r2, [pc, #108]	; (800135c <HAL_I2C_MspInit+0xe8>)
 80012f0:	4293      	cmp	r3, r2
 80012f2:	d128      	bne.n	8001346 <HAL_I2C_MspInit+0xd2>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80012f4:	4b17      	ldr	r3, [pc, #92]	; (8001354 <HAL_I2C_MspInit+0xe0>)
 80012f6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80012f8:	4a16      	ldr	r2, [pc, #88]	; (8001354 <HAL_I2C_MspInit+0xe0>)
 80012fa:	f043 0302 	orr.w	r3, r3, #2
 80012fe:	64d3      	str	r3, [r2, #76]	; 0x4c
 8001300:	4b14      	ldr	r3, [pc, #80]	; (8001354 <HAL_I2C_MspInit+0xe0>)
 8001302:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001304:	f003 0302 	and.w	r3, r3, #2
 8001308:	613b      	str	r3, [r7, #16]
 800130a:	693b      	ldr	r3, [r7, #16]
    GPIO_InitStruct.Pin = INTERNAL_I2C2_SCL_Pin|INTERNAL_I2C2_SDA_Pin;
 800130c:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8001310:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8001312:	2312      	movs	r3, #18
 8001314:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8001316:	2301      	movs	r3, #1
 8001318:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800131a:	2303      	movs	r3, #3
 800131c:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
 800131e:	2304      	movs	r3, #4
 8001320:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001322:	f107 031c 	add.w	r3, r7, #28
 8001326:	4619      	mov	r1, r3
 8001328:	480b      	ldr	r0, [pc, #44]	; (8001358 <HAL_I2C_MspInit+0xe4>)
 800132a:	f001 fc6b 	bl	8002c04 <HAL_GPIO_Init>
    __HAL_RCC_I2C2_CLK_ENABLE();
 800132e:	4b09      	ldr	r3, [pc, #36]	; (8001354 <HAL_I2C_MspInit+0xe0>)
 8001330:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001332:	4a08      	ldr	r2, [pc, #32]	; (8001354 <HAL_I2C_MspInit+0xe0>)
 8001334:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8001338:	6593      	str	r3, [r2, #88]	; 0x58
 800133a:	4b06      	ldr	r3, [pc, #24]	; (8001354 <HAL_I2C_MspInit+0xe0>)
 800133c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800133e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8001342:	60fb      	str	r3, [r7, #12]
 8001344:	68fb      	ldr	r3, [r7, #12]
}
 8001346:	bf00      	nop
 8001348:	3730      	adds	r7, #48	; 0x30
 800134a:	46bd      	mov	sp, r7
 800134c:	bd80      	pop	{r7, pc}
 800134e:	bf00      	nop
 8001350:	40005400 	.word	0x40005400
 8001354:	40021000 	.word	0x40021000
 8001358:	48000400 	.word	0x48000400
 800135c:	40005800 	.word	0x40005800

08001360 <HAL_OSPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hospi: OSPI handle pointer
* @retval None
*/
void HAL_OSPI_MspInit(OSPI_HandleTypeDef* hospi)
{
 8001360:	b580      	push	{r7, lr}
 8001362:	b08a      	sub	sp, #40	; 0x28
 8001364:	af00      	add	r7, sp, #0
 8001366:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001368:	f107 0314 	add.w	r3, r7, #20
 800136c:	2200      	movs	r2, #0
 800136e:	601a      	str	r2, [r3, #0]
 8001370:	605a      	str	r2, [r3, #4]
 8001372:	609a      	str	r2, [r3, #8]
 8001374:	60da      	str	r2, [r3, #12]
 8001376:	611a      	str	r2, [r3, #16]
  if(hospi->Instance==OCTOSPI1)
 8001378:	687b      	ldr	r3, [r7, #4]
 800137a:	681b      	ldr	r3, [r3, #0]
 800137c:	4a1d      	ldr	r2, [pc, #116]	; (80013f4 <HAL_OSPI_MspInit+0x94>)
 800137e:	4293      	cmp	r3, r2
 8001380:	d134      	bne.n	80013ec <HAL_OSPI_MspInit+0x8c>
  {
  /* USER CODE BEGIN OCTOSPI1_MspInit 0 */

  /* USER CODE END OCTOSPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_OSPIM_CLK_ENABLE();
 8001382:	4b1d      	ldr	r3, [pc, #116]	; (80013f8 <HAL_OSPI_MspInit+0x98>)
 8001384:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001386:	4a1c      	ldr	r2, [pc, #112]	; (80013f8 <HAL_OSPI_MspInit+0x98>)
 8001388:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800138c:	64d3      	str	r3, [r2, #76]	; 0x4c
 800138e:	4b1a      	ldr	r3, [pc, #104]	; (80013f8 <HAL_OSPI_MspInit+0x98>)
 8001390:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001392:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8001396:	613b      	str	r3, [r7, #16]
 8001398:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_OSPI1_CLK_ENABLE();
 800139a:	4b17      	ldr	r3, [pc, #92]	; (80013f8 <HAL_OSPI_MspInit+0x98>)
 800139c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800139e:	4a16      	ldr	r2, [pc, #88]	; (80013f8 <HAL_OSPI_MspInit+0x98>)
 80013a0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80013a4:	6513      	str	r3, [r2, #80]	; 0x50
 80013a6:	4b14      	ldr	r3, [pc, #80]	; (80013f8 <HAL_OSPI_MspInit+0x98>)
 80013a8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80013aa:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80013ae:	60fb      	str	r3, [r7, #12]
 80013b0:	68fb      	ldr	r3, [r7, #12]

    __HAL_RCC_GPIOE_CLK_ENABLE();
 80013b2:	4b11      	ldr	r3, [pc, #68]	; (80013f8 <HAL_OSPI_MspInit+0x98>)
 80013b4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80013b6:	4a10      	ldr	r2, [pc, #64]	; (80013f8 <HAL_OSPI_MspInit+0x98>)
 80013b8:	f043 0310 	orr.w	r3, r3, #16
 80013bc:	64d3      	str	r3, [r2, #76]	; 0x4c
 80013be:	4b0e      	ldr	r3, [pc, #56]	; (80013f8 <HAL_OSPI_MspInit+0x98>)
 80013c0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80013c2:	f003 0310 	and.w	r3, r3, #16
 80013c6:	60bb      	str	r3, [r7, #8]
 80013c8:	68bb      	ldr	r3, [r7, #8]
    PE12     ------> OCTOSPIM_P1_IO0
    PE13     ------> OCTOSPIM_P1_IO1
    PE14     ------> OCTOSPIM_P1_IO2
    PE15     ------> OCTOSPIM_P1_IO3
    */
    GPIO_InitStruct.Pin = QUADSPI_CLK_Pin|QUADSPI_NCS_Pin|OQUADSPI_BK1_IO0_Pin|QUADSPI_BK1_IO1_Pin
 80013ca:	f44f 437c 	mov.w	r3, #64512	; 0xfc00
 80013ce:	617b      	str	r3, [r7, #20]
                          |QUAD_SPI_BK1_IO2_Pin|QUAD_SPI_BK1_IO3_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80013d0:	2302      	movs	r3, #2
 80013d2:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80013d4:	2300      	movs	r3, #0
 80013d6:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80013d8:	2303      	movs	r3, #3
 80013da:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF10_OCTOSPIM_P1;
 80013dc:	230a      	movs	r3, #10
 80013de:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80013e0:	f107 0314 	add.w	r3, r7, #20
 80013e4:	4619      	mov	r1, r3
 80013e6:	4805      	ldr	r0, [pc, #20]	; (80013fc <HAL_OSPI_MspInit+0x9c>)
 80013e8:	f001 fc0c 	bl	8002c04 <HAL_GPIO_Init>
  /* USER CODE BEGIN OCTOSPI1_MspInit 1 */

  /* USER CODE END OCTOSPI1_MspInit 1 */
  }

}
 80013ec:	bf00      	nop
 80013ee:	3728      	adds	r7, #40	; 0x28
 80013f0:	46bd      	mov	sp, r7
 80013f2:	bd80      	pop	{r7, pc}
 80013f4:	a0001000 	.word	0xa0001000
 80013f8:	40021000 	.word	0x40021000
 80013fc:	48001000 	.word	0x48001000

08001400 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8001400:	b580      	push	{r7, lr}
 8001402:	b08c      	sub	sp, #48	; 0x30
 8001404:	af00      	add	r7, sp, #0
 8001406:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001408:	f107 031c 	add.w	r3, r7, #28
 800140c:	2200      	movs	r2, #0
 800140e:	601a      	str	r2, [r3, #0]
 8001410:	605a      	str	r2, [r3, #4]
 8001412:	609a      	str	r2, [r3, #8]
 8001414:	60da      	str	r2, [r3, #12]
 8001416:	611a      	str	r2, [r3, #16]
  if(hspi->Instance==SPI1)
 8001418:	687b      	ldr	r3, [r7, #4]
 800141a:	681b      	ldr	r3, [r3, #0]
 800141c:	4a2f      	ldr	r2, [pc, #188]	; (80014dc <HAL_SPI_MspInit+0xdc>)
 800141e:	4293      	cmp	r3, r2
 8001420:	d129      	bne.n	8001476 <HAL_SPI_MspInit+0x76>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8001422:	4b2f      	ldr	r3, [pc, #188]	; (80014e0 <HAL_SPI_MspInit+0xe0>)
 8001424:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001426:	4a2e      	ldr	r2, [pc, #184]	; (80014e0 <HAL_SPI_MspInit+0xe0>)
 8001428:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800142c:	6613      	str	r3, [r2, #96]	; 0x60
 800142e:	4b2c      	ldr	r3, [pc, #176]	; (80014e0 <HAL_SPI_MspInit+0xe0>)
 8001430:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001432:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8001436:	61bb      	str	r3, [r7, #24]
 8001438:	69bb      	ldr	r3, [r7, #24]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 800143a:	4b29      	ldr	r3, [pc, #164]	; (80014e0 <HAL_SPI_MspInit+0xe0>)
 800143c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800143e:	4a28      	ldr	r2, [pc, #160]	; (80014e0 <HAL_SPI_MspInit+0xe0>)
 8001440:	f043 0301 	orr.w	r3, r3, #1
 8001444:	64d3      	str	r3, [r2, #76]	; 0x4c
 8001446:	4b26      	ldr	r3, [pc, #152]	; (80014e0 <HAL_SPI_MspInit+0xe0>)
 8001448:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800144a:	f003 0301 	and.w	r3, r3, #1
 800144e:	617b      	str	r3, [r7, #20]
 8001450:	697b      	ldr	r3, [r7, #20]
    /**SPI1 GPIO Configuration
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI
    */
    GPIO_InitStruct.Pin = ARD_D13_Pin|ARD_D12_Pin|ARD_D11_Pin;
 8001452:	23e0      	movs	r3, #224	; 0xe0
 8001454:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001456:	2302      	movs	r3, #2
 8001458:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800145a:	2300      	movs	r3, #0
 800145c:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800145e:	2303      	movs	r3, #3
 8001460:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 8001462:	2305      	movs	r3, #5
 8001464:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001466:	f107 031c 	add.w	r3, r7, #28
 800146a:	4619      	mov	r1, r3
 800146c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001470:	f001 fbc8 	bl	8002c04 <HAL_GPIO_Init>
  /* USER CODE BEGIN SPI3_MspInit 1 */

  /* USER CODE END SPI3_MspInit 1 */
  }

}
 8001474:	e02d      	b.n	80014d2 <HAL_SPI_MspInit+0xd2>
  else if(hspi->Instance==SPI3)
 8001476:	687b      	ldr	r3, [r7, #4]
 8001478:	681b      	ldr	r3, [r3, #0]
 800147a:	4a1a      	ldr	r2, [pc, #104]	; (80014e4 <HAL_SPI_MspInit+0xe4>)
 800147c:	4293      	cmp	r3, r2
 800147e:	d128      	bne.n	80014d2 <HAL_SPI_MspInit+0xd2>
    __HAL_RCC_SPI3_CLK_ENABLE();
 8001480:	4b17      	ldr	r3, [pc, #92]	; (80014e0 <HAL_SPI_MspInit+0xe0>)
 8001482:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001484:	4a16      	ldr	r2, [pc, #88]	; (80014e0 <HAL_SPI_MspInit+0xe0>)
 8001486:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800148a:	6593      	str	r3, [r2, #88]	; 0x58
 800148c:	4b14      	ldr	r3, [pc, #80]	; (80014e0 <HAL_SPI_MspInit+0xe0>)
 800148e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001490:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8001494:	613b      	str	r3, [r7, #16]
 8001496:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8001498:	4b11      	ldr	r3, [pc, #68]	; (80014e0 <HAL_SPI_MspInit+0xe0>)
 800149a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800149c:	4a10      	ldr	r2, [pc, #64]	; (80014e0 <HAL_SPI_MspInit+0xe0>)
 800149e:	f043 0304 	orr.w	r3, r3, #4
 80014a2:	64d3      	str	r3, [r2, #76]	; 0x4c
 80014a4:	4b0e      	ldr	r3, [pc, #56]	; (80014e0 <HAL_SPI_MspInit+0xe0>)
 80014a6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80014a8:	f003 0304 	and.w	r3, r3, #4
 80014ac:	60fb      	str	r3, [r7, #12]
 80014ae:	68fb      	ldr	r3, [r7, #12]
    GPIO_InitStruct.Pin = INTERNAL_SPI3_SCK_Pin|INTERNAL_SPI3_MISO_Pin|INTERNAL_SPI3_MOSI_Pin;
 80014b0:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 80014b4:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80014b6:	2302      	movs	r3, #2
 80014b8:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80014ba:	2300      	movs	r3, #0
 80014bc:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80014be:	2303      	movs	r3, #3
 80014c0:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 80014c2:	2306      	movs	r3, #6
 80014c4:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80014c6:	f107 031c 	add.w	r3, r7, #28
 80014ca:	4619      	mov	r1, r3
 80014cc:	4806      	ldr	r0, [pc, #24]	; (80014e8 <HAL_SPI_MspInit+0xe8>)
 80014ce:	f001 fb99 	bl	8002c04 <HAL_GPIO_Init>
}
 80014d2:	bf00      	nop
 80014d4:	3730      	adds	r7, #48	; 0x30
 80014d6:	46bd      	mov	sp, r7
 80014d8:	bd80      	pop	{r7, pc}
 80014da:	bf00      	nop
 80014dc:	40013000 	.word	0x40013000
 80014e0:	40021000 	.word	0x40021000
 80014e4:	40003c00 	.word	0x40003c00
 80014e8:	48000800 	.word	0x48000800

080014ec <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 80014ec:	b580      	push	{r7, lr}
 80014ee:	b090      	sub	sp, #64	; 0x40
 80014f0:	af00      	add	r7, sp, #0
 80014f2:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80014f4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80014f8:	2200      	movs	r2, #0
 80014fa:	601a      	str	r2, [r3, #0]
 80014fc:	605a      	str	r2, [r3, #4]
 80014fe:	609a      	str	r2, [r3, #8]
 8001500:	60da      	str	r2, [r3, #12]
 8001502:	611a      	str	r2, [r3, #16]
  if(huart->Instance==UART4)
 8001504:	687b      	ldr	r3, [r7, #4]
 8001506:	681b      	ldr	r3, [r3, #0]
 8001508:	4a5d      	ldr	r2, [pc, #372]	; (8001680 <HAL_UART_MspInit+0x194>)
 800150a:	4293      	cmp	r3, r2
 800150c:	d129      	bne.n	8001562 <HAL_UART_MspInit+0x76>
  {
  /* USER CODE BEGIN UART4_MspInit 0 */

  /* USER CODE END UART4_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_UART4_CLK_ENABLE();
 800150e:	4b5d      	ldr	r3, [pc, #372]	; (8001684 <HAL_UART_MspInit+0x198>)
 8001510:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001512:	4a5c      	ldr	r2, [pc, #368]	; (8001684 <HAL_UART_MspInit+0x198>)
 8001514:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8001518:	6593      	str	r3, [r2, #88]	; 0x58
 800151a:	4b5a      	ldr	r3, [pc, #360]	; (8001684 <HAL_UART_MspInit+0x198>)
 800151c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800151e:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8001522:	62bb      	str	r3, [r7, #40]	; 0x28
 8001524:	6abb      	ldr	r3, [r7, #40]	; 0x28

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001526:	4b57      	ldr	r3, [pc, #348]	; (8001684 <HAL_UART_MspInit+0x198>)
 8001528:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800152a:	4a56      	ldr	r2, [pc, #344]	; (8001684 <HAL_UART_MspInit+0x198>)
 800152c:	f043 0301 	orr.w	r3, r3, #1
 8001530:	64d3      	str	r3, [r2, #76]	; 0x4c
 8001532:	4b54      	ldr	r3, [pc, #336]	; (8001684 <HAL_UART_MspInit+0x198>)
 8001534:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001536:	f003 0301 	and.w	r3, r3, #1
 800153a:	627b      	str	r3, [r7, #36]	; 0x24
 800153c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    /**UART4 GPIO Configuration
    PA0     ------> UART4_TX
    PA1     ------> UART4_RX
    */
    GPIO_InitStruct.Pin = ARD_D1_Pin|ARD_D0_Pin;
 800153e:	2303      	movs	r3, #3
 8001540:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001542:	2302      	movs	r3, #2
 8001544:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001546:	2300      	movs	r3, #0
 8001548:	637b      	str	r3, [r7, #52]	; 0x34
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800154a:	2303      	movs	r3, #3
 800154c:	63bb      	str	r3, [r7, #56]	; 0x38
    GPIO_InitStruct.Alternate = GPIO_AF8_UART4;
 800154e:	2308      	movs	r3, #8
 8001550:	63fb      	str	r3, [r7, #60]	; 0x3c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001552:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8001556:	4619      	mov	r1, r3
 8001558:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800155c:	f001 fb52 	bl	8002c04 <HAL_GPIO_Init>
  /* USER CODE BEGIN USART3_MspInit 1 */

  /* USER CODE END USART3_MspInit 1 */
  }

}
 8001560:	e089      	b.n	8001676 <HAL_UART_MspInit+0x18a>
  else if(huart->Instance==USART1)
 8001562:	687b      	ldr	r3, [r7, #4]
 8001564:	681b      	ldr	r3, [r3, #0]
 8001566:	4a48      	ldr	r2, [pc, #288]	; (8001688 <HAL_UART_MspInit+0x19c>)
 8001568:	4293      	cmp	r3, r2
 800156a:	d128      	bne.n	80015be <HAL_UART_MspInit+0xd2>
    __HAL_RCC_USART1_CLK_ENABLE();
 800156c:	4b45      	ldr	r3, [pc, #276]	; (8001684 <HAL_UART_MspInit+0x198>)
 800156e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001570:	4a44      	ldr	r2, [pc, #272]	; (8001684 <HAL_UART_MspInit+0x198>)
 8001572:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001576:	6613      	str	r3, [r2, #96]	; 0x60
 8001578:	4b42      	ldr	r3, [pc, #264]	; (8001684 <HAL_UART_MspInit+0x198>)
 800157a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800157c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001580:	623b      	str	r3, [r7, #32]
 8001582:	6a3b      	ldr	r3, [r7, #32]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8001584:	4b3f      	ldr	r3, [pc, #252]	; (8001684 <HAL_UART_MspInit+0x198>)
 8001586:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001588:	4a3e      	ldr	r2, [pc, #248]	; (8001684 <HAL_UART_MspInit+0x198>)
 800158a:	f043 0302 	orr.w	r3, r3, #2
 800158e:	64d3      	str	r3, [r2, #76]	; 0x4c
 8001590:	4b3c      	ldr	r3, [pc, #240]	; (8001684 <HAL_UART_MspInit+0x198>)
 8001592:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001594:	f003 0302 	and.w	r3, r3, #2
 8001598:	61fb      	str	r3, [r7, #28]
 800159a:	69fb      	ldr	r3, [r7, #28]
    GPIO_InitStruct.Pin = ST_LINK_UART1_TX_Pin|ST_LINK_UART1_RX_Pin;
 800159c:	23c0      	movs	r3, #192	; 0xc0
 800159e:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80015a0:	2302      	movs	r3, #2
 80015a2:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80015a4:	2300      	movs	r3, #0
 80015a6:	637b      	str	r3, [r7, #52]	; 0x34
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80015a8:	2303      	movs	r3, #3
 80015aa:	63bb      	str	r3, [r7, #56]	; 0x38
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 80015ac:	2307      	movs	r3, #7
 80015ae:	63fb      	str	r3, [r7, #60]	; 0x3c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80015b0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80015b4:	4619      	mov	r1, r3
 80015b6:	4835      	ldr	r0, [pc, #212]	; (800168c <HAL_UART_MspInit+0x1a0>)
 80015b8:	f001 fb24 	bl	8002c04 <HAL_GPIO_Init>
}
 80015bc:	e05b      	b.n	8001676 <HAL_UART_MspInit+0x18a>
  else if(huart->Instance==USART2)
 80015be:	687b      	ldr	r3, [r7, #4]
 80015c0:	681b      	ldr	r3, [r3, #0]
 80015c2:	4a33      	ldr	r2, [pc, #204]	; (8001690 <HAL_UART_MspInit+0x1a4>)
 80015c4:	4293      	cmp	r3, r2
 80015c6:	d128      	bne.n	800161a <HAL_UART_MspInit+0x12e>
    __HAL_RCC_USART2_CLK_ENABLE();
 80015c8:	4b2e      	ldr	r3, [pc, #184]	; (8001684 <HAL_UART_MspInit+0x198>)
 80015ca:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80015cc:	4a2d      	ldr	r2, [pc, #180]	; (8001684 <HAL_UART_MspInit+0x198>)
 80015ce:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80015d2:	6593      	str	r3, [r2, #88]	; 0x58
 80015d4:	4b2b      	ldr	r3, [pc, #172]	; (8001684 <HAL_UART_MspInit+0x198>)
 80015d6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80015d8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80015dc:	61bb      	str	r3, [r7, #24]
 80015de:	69bb      	ldr	r3, [r7, #24]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80015e0:	4b28      	ldr	r3, [pc, #160]	; (8001684 <HAL_UART_MspInit+0x198>)
 80015e2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80015e4:	4a27      	ldr	r2, [pc, #156]	; (8001684 <HAL_UART_MspInit+0x198>)
 80015e6:	f043 0308 	orr.w	r3, r3, #8
 80015ea:	64d3      	str	r3, [r2, #76]	; 0x4c
 80015ec:	4b25      	ldr	r3, [pc, #148]	; (8001684 <HAL_UART_MspInit+0x198>)
 80015ee:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80015f0:	f003 0308 	and.w	r3, r3, #8
 80015f4:	617b      	str	r3, [r7, #20]
 80015f6:	697b      	ldr	r3, [r7, #20]
    GPIO_InitStruct.Pin = PMOD_UART2_CTS_Pin|PMOD_UART2_RTS_Pin|PMOD_UART2_TX_Pin|PMOD_UART2_RX_Pin;
 80015f8:	2378      	movs	r3, #120	; 0x78
 80015fa:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80015fc:	2302      	movs	r3, #2
 80015fe:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001600:	2300      	movs	r3, #0
 8001602:	637b      	str	r3, [r7, #52]	; 0x34
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001604:	2303      	movs	r3, #3
 8001606:	63bb      	str	r3, [r7, #56]	; 0x38
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8001608:	2307      	movs	r3, #7
 800160a:	63fb      	str	r3, [r7, #60]	; 0x3c
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800160c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8001610:	4619      	mov	r1, r3
 8001612:	4820      	ldr	r0, [pc, #128]	; (8001694 <HAL_UART_MspInit+0x1a8>)
 8001614:	f001 faf6 	bl	8002c04 <HAL_GPIO_Init>
}
 8001618:	e02d      	b.n	8001676 <HAL_UART_MspInit+0x18a>
  else if(huart->Instance==USART3)
 800161a:	687b      	ldr	r3, [r7, #4]
 800161c:	681b      	ldr	r3, [r3, #0]
 800161e:	4a1e      	ldr	r2, [pc, #120]	; (8001698 <HAL_UART_MspInit+0x1ac>)
 8001620:	4293      	cmp	r3, r2
 8001622:	d128      	bne.n	8001676 <HAL_UART_MspInit+0x18a>
    __HAL_RCC_USART3_CLK_ENABLE();
 8001624:	4b17      	ldr	r3, [pc, #92]	; (8001684 <HAL_UART_MspInit+0x198>)
 8001626:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001628:	4a16      	ldr	r2, [pc, #88]	; (8001684 <HAL_UART_MspInit+0x198>)
 800162a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800162e:	6593      	str	r3, [r2, #88]	; 0x58
 8001630:	4b14      	ldr	r3, [pc, #80]	; (8001684 <HAL_UART_MspInit+0x198>)
 8001632:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001634:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8001638:	613b      	str	r3, [r7, #16]
 800163a:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800163c:	4b11      	ldr	r3, [pc, #68]	; (8001684 <HAL_UART_MspInit+0x198>)
 800163e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001640:	4a10      	ldr	r2, [pc, #64]	; (8001684 <HAL_UART_MspInit+0x198>)
 8001642:	f043 0308 	orr.w	r3, r3, #8
 8001646:	64d3      	str	r3, [r2, #76]	; 0x4c
 8001648:	4b0e      	ldr	r3, [pc, #56]	; (8001684 <HAL_UART_MspInit+0x198>)
 800164a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800164c:	f003 0308 	and.w	r3, r3, #8
 8001650:	60fb      	str	r3, [r7, #12]
 8001652:	68fb      	ldr	r3, [r7, #12]
    GPIO_InitStruct.Pin = INTERNAL_UART3_TX_Pin|INTERNAL_UART3_RX_Pin;
 8001654:	f44f 7340 	mov.w	r3, #768	; 0x300
 8001658:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800165a:	2302      	movs	r3, #2
 800165c:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800165e:	2300      	movs	r3, #0
 8001660:	637b      	str	r3, [r7, #52]	; 0x34
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001662:	2303      	movs	r3, #3
 8001664:	63bb      	str	r3, [r7, #56]	; 0x38
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8001666:	2307      	movs	r3, #7
 8001668:	63fb      	str	r3, [r7, #60]	; 0x3c
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800166a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800166e:	4619      	mov	r1, r3
 8001670:	4808      	ldr	r0, [pc, #32]	; (8001694 <HAL_UART_MspInit+0x1a8>)
 8001672:	f001 fac7 	bl	8002c04 <HAL_GPIO_Init>
}
 8001676:	bf00      	nop
 8001678:	3740      	adds	r7, #64	; 0x40
 800167a:	46bd      	mov	sp, r7
 800167c:	bd80      	pop	{r7, pc}
 800167e:	bf00      	nop
 8001680:	40004c00 	.word	0x40004c00
 8001684:	40021000 	.word	0x40021000
 8001688:	40013800 	.word	0x40013800
 800168c:	48000400 	.word	0x48000400
 8001690:	40004400 	.word	0x40004400
 8001694:	48000c00 	.word	0x48000c00
 8001698:	40004800 	.word	0x40004800

0800169c <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 800169c:	b480      	push	{r7}
 800169e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 80016a0:	e7fe      	b.n	80016a0 <NMI_Handler+0x4>

080016a2 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 80016a2:	b480      	push	{r7}
 80016a4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 80016a6:	e7fe      	b.n	80016a6 <HardFault_Handler+0x4>

080016a8 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 80016a8:	b480      	push	{r7}
 80016aa:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 80016ac:	e7fe      	b.n	80016ac <MemManage_Handler+0x4>

080016ae <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 80016ae:	b480      	push	{r7}
 80016b0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 80016b2:	e7fe      	b.n	80016b2 <BusFault_Handler+0x4>

080016b4 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 80016b4:	b480      	push	{r7}
 80016b6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 80016b8:	e7fe      	b.n	80016b8 <UsageFault_Handler+0x4>

080016ba <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 80016ba:	b480      	push	{r7}
 80016bc:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 80016be:	bf00      	nop
 80016c0:	46bd      	mov	sp, r7
 80016c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80016c6:	4770      	bx	lr

080016c8 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 80016c8:	b480      	push	{r7}
 80016ca:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 80016cc:	bf00      	nop
 80016ce:	46bd      	mov	sp, r7
 80016d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80016d4:	4770      	bx	lr

080016d6 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 80016d6:	b480      	push	{r7}
 80016d8:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 80016da:	bf00      	nop
 80016dc:	46bd      	mov	sp, r7
 80016de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80016e2:	4770      	bx	lr

080016e4 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 80016e4:	b580      	push	{r7, lr}
 80016e6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80016e8:	f000 f96a 	bl	80019c0 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 80016ec:	bf00      	nop
 80016ee:	bd80      	pop	{r7, pc}

080016f0 <EXTI9_5_IRQHandler>:

/**
  * @brief This function handles EXTI line[9:5] interrupts.
  */
void EXTI9_5_IRQHandler(void)
{
 80016f0:	b580      	push	{r7, lr}
 80016f2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI9_5_IRQn 0 */

  /* USER CODE END EXTI9_5_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_5);
 80016f4:	2020      	movs	r0, #32
 80016f6:	f001 fc2f 	bl	8002f58 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_6);
 80016fa:	2040      	movs	r0, #64	; 0x40
 80016fc:	f001 fc2c 	bl	8002f58 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_7);
 8001700:	2080      	movs	r0, #128	; 0x80
 8001702:	f001 fc29 	bl	8002f58 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_8);
 8001706:	f44f 7080 	mov.w	r0, #256	; 0x100
 800170a:	f001 fc25 	bl	8002f58 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI9_5_IRQn 1 */

  /* USER CODE END EXTI9_5_IRQn 1 */
}
 800170e:	bf00      	nop
 8001710:	bd80      	pop	{r7, pc}

08001712 <EXTI15_10_IRQHandler>:

/**
  * @brief This function handles EXTI line[15:10] interrupts.
  */
void EXTI15_10_IRQHandler(void)
{
 8001712:	b580      	push	{r7, lr}
 8001714:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI15_10_IRQn 0 */

  /* USER CODE END EXTI15_10_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_10);
 8001716:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800171a:	f001 fc1d 	bl	8002f58 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_11);
 800171e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8001722:	f001 fc19 	bl	8002f58 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_12);
 8001726:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800172a:	f001 fc15 	bl	8002f58 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);
 800172e:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8001732:	f001 fc11 	bl	8002f58 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_14);
 8001736:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800173a:	f001 fc0d 	bl	8002f58 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_15);
 800173e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8001742:	f001 fc09 	bl	8002f58 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI15_10_IRQn 1 */

  /* USER CODE END EXTI15_10_IRQn 1 */
}
 8001746:	bf00      	nop
 8001748:	bd80      	pop	{r7, pc}

0800174a <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 800174a:	b580      	push	{r7, lr}
 800174c:	b086      	sub	sp, #24
 800174e:	af00      	add	r7, sp, #0
 8001750:	60f8      	str	r0, [r7, #12]
 8001752:	60b9      	str	r1, [r7, #8]
 8001754:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001756:	2300      	movs	r3, #0
 8001758:	617b      	str	r3, [r7, #20]
 800175a:	e00a      	b.n	8001772 <_read+0x28>
	{
		*ptr++ = __io_getchar();
 800175c:	f3af 8000 	nop.w
 8001760:	4601      	mov	r1, r0
 8001762:	68bb      	ldr	r3, [r7, #8]
 8001764:	1c5a      	adds	r2, r3, #1
 8001766:	60ba      	str	r2, [r7, #8]
 8001768:	b2ca      	uxtb	r2, r1
 800176a:	701a      	strb	r2, [r3, #0]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800176c:	697b      	ldr	r3, [r7, #20]
 800176e:	3301      	adds	r3, #1
 8001770:	617b      	str	r3, [r7, #20]
 8001772:	697a      	ldr	r2, [r7, #20]
 8001774:	687b      	ldr	r3, [r7, #4]
 8001776:	429a      	cmp	r2, r3
 8001778:	dbf0      	blt.n	800175c <_read+0x12>
	}

return len;
 800177a:	687b      	ldr	r3, [r7, #4]
}
 800177c:	4618      	mov	r0, r3
 800177e:	3718      	adds	r7, #24
 8001780:	46bd      	mov	sp, r7
 8001782:	bd80      	pop	{r7, pc}

08001784 <_close>:
	}
	return len;
}

int _close(int file)
{
 8001784:	b480      	push	{r7}
 8001786:	b083      	sub	sp, #12
 8001788:	af00      	add	r7, sp, #0
 800178a:	6078      	str	r0, [r7, #4]
	return -1;
 800178c:	f04f 33ff 	mov.w	r3, #4294967295
}
 8001790:	4618      	mov	r0, r3
 8001792:	370c      	adds	r7, #12
 8001794:	46bd      	mov	sp, r7
 8001796:	f85d 7b04 	ldr.w	r7, [sp], #4
 800179a:	4770      	bx	lr

0800179c <_fstat>:


int _fstat(int file, struct stat *st)
{
 800179c:	b480      	push	{r7}
 800179e:	b083      	sub	sp, #12
 80017a0:	af00      	add	r7, sp, #0
 80017a2:	6078      	str	r0, [r7, #4]
 80017a4:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
 80017a6:	683b      	ldr	r3, [r7, #0]
 80017a8:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80017ac:	605a      	str	r2, [r3, #4]
	return 0;
 80017ae:	2300      	movs	r3, #0
}
 80017b0:	4618      	mov	r0, r3
 80017b2:	370c      	adds	r7, #12
 80017b4:	46bd      	mov	sp, r7
 80017b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017ba:	4770      	bx	lr

080017bc <_isatty>:

int _isatty(int file)
{
 80017bc:	b480      	push	{r7}
 80017be:	b083      	sub	sp, #12
 80017c0:	af00      	add	r7, sp, #0
 80017c2:	6078      	str	r0, [r7, #4]
	return 1;
 80017c4:	2301      	movs	r3, #1
}
 80017c6:	4618      	mov	r0, r3
 80017c8:	370c      	adds	r7, #12
 80017ca:	46bd      	mov	sp, r7
 80017cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017d0:	4770      	bx	lr

080017d2 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 80017d2:	b480      	push	{r7}
 80017d4:	b085      	sub	sp, #20
 80017d6:	af00      	add	r7, sp, #0
 80017d8:	60f8      	str	r0, [r7, #12]
 80017da:	60b9      	str	r1, [r7, #8]
 80017dc:	607a      	str	r2, [r7, #4]
	return 0;
 80017de:	2300      	movs	r3, #0
}
 80017e0:	4618      	mov	r0, r3
 80017e2:	3714      	adds	r7, #20
 80017e4:	46bd      	mov	sp, r7
 80017e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017ea:	4770      	bx	lr

080017ec <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 80017ec:	b580      	push	{r7, lr}
 80017ee:	b086      	sub	sp, #24
 80017f0:	af00      	add	r7, sp, #0
 80017f2:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 80017f4:	4a14      	ldr	r2, [pc, #80]	; (8001848 <_sbrk+0x5c>)
 80017f6:	4b15      	ldr	r3, [pc, #84]	; (800184c <_sbrk+0x60>)
 80017f8:	1ad3      	subs	r3, r2, r3
 80017fa:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 80017fc:	697b      	ldr	r3, [r7, #20]
 80017fe:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8001800:	4b13      	ldr	r3, [pc, #76]	; (8001850 <_sbrk+0x64>)
 8001802:	681b      	ldr	r3, [r3, #0]
 8001804:	2b00      	cmp	r3, #0
 8001806:	d102      	bne.n	800180e <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8001808:	4b11      	ldr	r3, [pc, #68]	; (8001850 <_sbrk+0x64>)
 800180a:	4a12      	ldr	r2, [pc, #72]	; (8001854 <_sbrk+0x68>)
 800180c:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 800180e:	4b10      	ldr	r3, [pc, #64]	; (8001850 <_sbrk+0x64>)
 8001810:	681a      	ldr	r2, [r3, #0]
 8001812:	687b      	ldr	r3, [r7, #4]
 8001814:	4413      	add	r3, r2
 8001816:	693a      	ldr	r2, [r7, #16]
 8001818:	429a      	cmp	r2, r3
 800181a:	d207      	bcs.n	800182c <_sbrk+0x40>
  {
    errno = ENOMEM;
 800181c:	f017 fd82 	bl	8019324 <__errno>
 8001820:	4602      	mov	r2, r0
 8001822:	230c      	movs	r3, #12
 8001824:	6013      	str	r3, [r2, #0]
    return (void *)-1;
 8001826:	f04f 33ff 	mov.w	r3, #4294967295
 800182a:	e009      	b.n	8001840 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 800182c:	4b08      	ldr	r3, [pc, #32]	; (8001850 <_sbrk+0x64>)
 800182e:	681b      	ldr	r3, [r3, #0]
 8001830:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 8001832:	4b07      	ldr	r3, [pc, #28]	; (8001850 <_sbrk+0x64>)
 8001834:	681a      	ldr	r2, [r3, #0]
 8001836:	687b      	ldr	r3, [r7, #4]
 8001838:	4413      	add	r3, r2
 800183a:	4a05      	ldr	r2, [pc, #20]	; (8001850 <_sbrk+0x64>)
 800183c:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 800183e:	68fb      	ldr	r3, [r7, #12]
}
 8001840:	4618      	mov	r0, r3
 8001842:	3718      	adds	r7, #24
 8001844:	46bd      	mov	sp, r7
 8001846:	bd80      	pop	{r7, pc}
 8001848:	200a0000 	.word	0x200a0000
 800184c:	00000400 	.word	0x00000400
 8001850:	200001fc 	.word	0x200001fc
 8001854:	200006d0 	.word	0x200006d0

08001858 <SystemInit>:
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
 8001858:	b480      	push	{r7}
 800185a:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800185c:	4b17      	ldr	r3, [pc, #92]	; (80018bc <SystemInit+0x64>)
 800185e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8001862:	4a16      	ldr	r2, [pc, #88]	; (80018bc <SystemInit+0x64>)
 8001864:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8001868:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 800186c:	4b14      	ldr	r3, [pc, #80]	; (80018c0 <SystemInit+0x68>)
 800186e:	681b      	ldr	r3, [r3, #0]
 8001870:	4a13      	ldr	r2, [pc, #76]	; (80018c0 <SystemInit+0x68>)
 8001872:	f043 0301 	orr.w	r3, r3, #1
 8001876:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;
 8001878:	4b11      	ldr	r3, [pc, #68]	; (80018c0 <SystemInit+0x68>)
 800187a:	2200      	movs	r2, #0
 800187c:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= 0xEAF6FFFFU;
 800187e:	4b10      	ldr	r3, [pc, #64]	; (80018c0 <SystemInit+0x68>)
 8001880:	681b      	ldr	r3, [r3, #0]
 8001882:	4a0f      	ldr	r2, [pc, #60]	; (80018c0 <SystemInit+0x68>)
 8001884:	f023 53a8 	bic.w	r3, r3, #352321536	; 0x15000000
 8001888:	f423 2310 	bic.w	r3, r3, #589824	; 0x90000
 800188c:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000U;
 800188e:	4b0c      	ldr	r3, [pc, #48]	; (80018c0 <SystemInit+0x68>)
 8001890:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001894:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8001896:	4b0a      	ldr	r3, [pc, #40]	; (80018c0 <SystemInit+0x68>)
 8001898:	681b      	ldr	r3, [r3, #0]
 800189a:	4a09      	ldr	r2, [pc, #36]	; (80018c0 <SystemInit+0x68>)
 800189c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80018a0:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000U;
 80018a2:	4b07      	ldr	r3, [pc, #28]	; (80018c0 <SystemInit+0x68>)
 80018a4:	2200      	movs	r2, #0
 80018a6:	619a      	str	r2, [r3, #24]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80018a8:	4b04      	ldr	r3, [pc, #16]	; (80018bc <SystemInit+0x64>)
 80018aa:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80018ae:	609a      	str	r2, [r3, #8]
#endif
}
 80018b0:	bf00      	nop
 80018b2:	46bd      	mov	sp, r7
 80018b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80018b8:	4770      	bx	lr
 80018ba:	bf00      	nop
 80018bc:	e000ed00 	.word	0xe000ed00
 80018c0:	40021000 	.word	0x40021000

080018c4 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Set stack pointer */
 80018c4:	f8df d034 	ldr.w	sp, [pc, #52]	; 80018fc <LoopForever+0x2>

/* Call the clock system initialization function.*/
    bl  SystemInit
 80018c8:	f7ff ffc6 	bl	8001858 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 80018cc:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 80018ce:	e003      	b.n	80018d8 <LoopCopyDataInit>

080018d0 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 80018d0:	4b0b      	ldr	r3, [pc, #44]	; (8001900 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 80018d2:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 80018d4:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 80018d6:	3104      	adds	r1, #4

080018d8 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 80018d8:	480a      	ldr	r0, [pc, #40]	; (8001904 <LoopForever+0xa>)
	ldr	r3, =_edata
 80018da:	4b0b      	ldr	r3, [pc, #44]	; (8001908 <LoopForever+0xe>)
	adds	r2, r0, r1
 80018dc:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 80018de:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 80018e0:	d3f6      	bcc.n	80018d0 <CopyDataInit>
	ldr	r2, =_sbss
 80018e2:	4a0a      	ldr	r2, [pc, #40]	; (800190c <LoopForever+0x12>)
	b	LoopFillZerobss
 80018e4:	e002      	b.n	80018ec <LoopFillZerobss>

080018e6 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 80018e6:	2300      	movs	r3, #0
	str	r3, [r2], #4
 80018e8:	f842 3b04 	str.w	r3, [r2], #4

080018ec <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 80018ec:	4b08      	ldr	r3, [pc, #32]	; (8001910 <LoopForever+0x16>)
	cmp	r2, r3
 80018ee:	429a      	cmp	r2, r3
	bcc	FillZerobss
 80018f0:	d3f9      	bcc.n	80018e6 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 80018f2:	f017 fd1d 	bl	8019330 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 80018f6:	f7fe fe89 	bl	800060c <main>

080018fa <LoopForever>:

LoopForever:
    b LoopForever
 80018fa:	e7fe      	b.n	80018fa <LoopForever>
  ldr   sp, =_estack    /* Set stack pointer */
 80018fc:	200a0000 	.word	0x200a0000
	ldr	r3, =_sidata
 8001900:	0801b62c 	.word	0x0801b62c
	ldr	r0, =_sdata
 8001904:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8001908:	200001dc 	.word	0x200001dc
	ldr	r2, =_sbss
 800190c:	200001dc 	.word	0x200001dc
	ldr	r3, = _ebss
 8001910:	200006d0 	.word	0x200006d0

08001914 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8001914:	e7fe      	b.n	8001914 <ADC1_IRQHandler>

08001916 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001916:	b580      	push	{r7, lr}
 8001918:	b082      	sub	sp, #8
 800191a:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 800191c:	2300      	movs	r3, #0
 800191e:	71fb      	strb	r3, [r7, #7]
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001920:	2003      	movs	r0, #3
 8001922:	f001 f821 	bl	8002968 <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8001926:	2000      	movs	r0, #0
 8001928:	f000 f80e 	bl	8001948 <HAL_InitTick>
 800192c:	4603      	mov	r3, r0
 800192e:	2b00      	cmp	r3, #0
 8001930:	d002      	beq.n	8001938 <HAL_Init+0x22>
  {
    status = HAL_ERROR;
 8001932:	2301      	movs	r3, #1
 8001934:	71fb      	strb	r3, [r7, #7]
 8001936:	e001      	b.n	800193c <HAL_Init+0x26>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 8001938:	f7ff fbf0 	bl	800111c <HAL_MspInit>
  }

  /* Return function status */
  return status;
 800193c:	79fb      	ldrb	r3, [r7, #7]
}
 800193e:	4618      	mov	r0, r3
 8001940:	3708      	adds	r7, #8
 8001942:	46bd      	mov	sp, r7
 8001944:	bd80      	pop	{r7, pc}
	...

08001948 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001948:	b580      	push	{r7, lr}
 800194a:	b084      	sub	sp, #16
 800194c:	af00      	add	r7, sp, #0
 800194e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
 8001950:	2300      	movs	r3, #0
 8001952:	73fb      	strb	r3, [r7, #15]

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that doesn't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
 8001954:	4b17      	ldr	r3, [pc, #92]	; (80019b4 <HAL_InitTick+0x6c>)
 8001956:	781b      	ldrb	r3, [r3, #0]
 8001958:	2b00      	cmp	r3, #0
 800195a:	d023      	beq.n	80019a4 <HAL_InitTick+0x5c>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / (uint32_t)uwTickFreq)) == 0U)
 800195c:	4b16      	ldr	r3, [pc, #88]	; (80019b8 <HAL_InitTick+0x70>)
 800195e:	681a      	ldr	r2, [r3, #0]
 8001960:	4b14      	ldr	r3, [pc, #80]	; (80019b4 <HAL_InitTick+0x6c>)
 8001962:	781b      	ldrb	r3, [r3, #0]
 8001964:	4619      	mov	r1, r3
 8001966:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800196a:	fbb3 f3f1 	udiv	r3, r3, r1
 800196e:	fbb2 f3f3 	udiv	r3, r2, r3
 8001972:	4618      	mov	r0, r3
 8001974:	f001 f82d 	bl	80029d2 <HAL_SYSTICK_Config>
 8001978:	4603      	mov	r3, r0
 800197a:	2b00      	cmp	r3, #0
 800197c:	d10f      	bne.n	800199e <HAL_InitTick+0x56>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800197e:	687b      	ldr	r3, [r7, #4]
 8001980:	2b0f      	cmp	r3, #15
 8001982:	d809      	bhi.n	8001998 <HAL_InitTick+0x50>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8001984:	2200      	movs	r2, #0
 8001986:	6879      	ldr	r1, [r7, #4]
 8001988:	f04f 30ff 	mov.w	r0, #4294967295
 800198c:	f000 fff7 	bl	800297e <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 8001990:	4a0a      	ldr	r2, [pc, #40]	; (80019bc <HAL_InitTick+0x74>)
 8001992:	687b      	ldr	r3, [r7, #4]
 8001994:	6013      	str	r3, [r2, #0]
 8001996:	e007      	b.n	80019a8 <HAL_InitTick+0x60>
      }
      else
      {
        status = HAL_ERROR;
 8001998:	2301      	movs	r3, #1
 800199a:	73fb      	strb	r3, [r7, #15]
 800199c:	e004      	b.n	80019a8 <HAL_InitTick+0x60>
      }
    }
    else
    {
      status = HAL_ERROR;
 800199e:	2301      	movs	r3, #1
 80019a0:	73fb      	strb	r3, [r7, #15]
 80019a2:	e001      	b.n	80019a8 <HAL_InitTick+0x60>
    }
  }
  else
  {
    status = HAL_ERROR;
 80019a4:	2301      	movs	r3, #1
 80019a6:	73fb      	strb	r3, [r7, #15]
  }

  /* Return function status */
  return status;
 80019a8:	7bfb      	ldrb	r3, [r7, #15]
}
 80019aa:	4618      	mov	r0, r3
 80019ac:	3710      	adds	r7, #16
 80019ae:	46bd      	mov	sp, r7
 80019b0:	bd80      	pop	{r7, pc}
 80019b2:	bf00      	nop
 80019b4:	20000008 	.word	0x20000008
 80019b8:	20000000 	.word	0x20000000
 80019bc:	20000004 	.word	0x20000004

080019c0 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 80019c0:	b480      	push	{r7}
 80019c2:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 80019c4:	4b06      	ldr	r3, [pc, #24]	; (80019e0 <HAL_IncTick+0x20>)
 80019c6:	781b      	ldrb	r3, [r3, #0]
 80019c8:	461a      	mov	r2, r3
 80019ca:	4b06      	ldr	r3, [pc, #24]	; (80019e4 <HAL_IncTick+0x24>)
 80019cc:	681b      	ldr	r3, [r3, #0]
 80019ce:	4413      	add	r3, r2
 80019d0:	4a04      	ldr	r2, [pc, #16]	; (80019e4 <HAL_IncTick+0x24>)
 80019d2:	6013      	str	r3, [r2, #0]
}
 80019d4:	bf00      	nop
 80019d6:	46bd      	mov	sp, r7
 80019d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80019dc:	4770      	bx	lr
 80019de:	bf00      	nop
 80019e0:	20000008 	.word	0x20000008
 80019e4:	200006c8 	.word	0x200006c8

080019e8 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 80019e8:	b480      	push	{r7}
 80019ea:	af00      	add	r7, sp, #0
  return uwTick;
 80019ec:	4b03      	ldr	r3, [pc, #12]	; (80019fc <HAL_GetTick+0x14>)
 80019ee:	681b      	ldr	r3, [r3, #0]
}
 80019f0:	4618      	mov	r0, r3
 80019f2:	46bd      	mov	sp, r7
 80019f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80019f8:	4770      	bx	lr
 80019fa:	bf00      	nop
 80019fc:	200006c8 	.word	0x200006c8

08001a00 <LL_ADC_SetCommonClock>:
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV128
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV256
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonClock(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t CommonClock)
{
 8001a00:	b480      	push	{r7}
 8001a02:	b083      	sub	sp, #12
 8001a04:	af00      	add	r7, sp, #0
 8001a06:	6078      	str	r0, [r7, #4]
 8001a08:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 8001a0a:	687b      	ldr	r3, [r7, #4]
 8001a0c:	689b      	ldr	r3, [r3, #8]
 8001a0e:	f423 127c 	bic.w	r2, r3, #4128768	; 0x3f0000
 8001a12:	683b      	ldr	r3, [r7, #0]
 8001a14:	431a      	orrs	r2, r3
 8001a16:	687b      	ldr	r3, [r7, #4]
 8001a18:	609a      	str	r2, [r3, #8]
}
 8001a1a:	bf00      	nop
 8001a1c:	370c      	adds	r7, #12
 8001a1e:	46bd      	mov	sp, r7
 8001a20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a24:	4770      	bx	lr

08001a26 <LL_ADC_SetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal)
{
 8001a26:	b480      	push	{r7}
 8001a28:	b083      	sub	sp, #12
 8001a2a:	af00      	add	r7, sp, #0
 8001a2c:	6078      	str	r0, [r7, #4]
 8001a2e:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8001a30:	687b      	ldr	r3, [r7, #4]
 8001a32:	689b      	ldr	r3, [r3, #8]
 8001a34:	f023 72e0 	bic.w	r2, r3, #29360128	; 0x1c00000
 8001a38:	683b      	ldr	r3, [r7, #0]
 8001a3a:	431a      	orrs	r2, r3
 8001a3c:	687b      	ldr	r3, [r7, #4]
 8001a3e:	609a      	str	r2, [r3, #8]
}
 8001a40:	bf00      	nop
 8001a42:	370c      	adds	r7, #12
 8001a44:	46bd      	mov	sp, r7
 8001a46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a4a:	4770      	bx	lr

08001a4c <LL_ADC_GetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  */
__STATIC_INLINE uint32_t LL_ADC_GetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON)
{
 8001a4c:	b480      	push	{r7}
 8001a4e:	b083      	sub	sp, #12
 8001a50:	af00      	add	r7, sp, #0
 8001a52:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8001a54:	687b      	ldr	r3, [r7, #4]
 8001a56:	689b      	ldr	r3, [r3, #8]
 8001a58:	f003 73e0 	and.w	r3, r3, #29360128	; 0x1c00000
}
 8001a5c:	4618      	mov	r0, r3
 8001a5e:	370c      	adds	r7, #12
 8001a60:	46bd      	mov	sp, r7
 8001a62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a66:	4770      	bx	lr

08001a68 <LL_ADC_SetOffset>:
  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
  * @param  OffsetLevel Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffset(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t Channel, uint32_t OffsetLevel)
{
 8001a68:	b480      	push	{r7}
 8001a6a:	b087      	sub	sp, #28
 8001a6c:	af00      	add	r7, sp, #0
 8001a6e:	60f8      	str	r0, [r7, #12]
 8001a70:	60b9      	str	r1, [r7, #8]
 8001a72:	607a      	str	r2, [r7, #4]
 8001a74:	603b      	str	r3, [r7, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8001a76:	68fb      	ldr	r3, [r7, #12]
 8001a78:	3360      	adds	r3, #96	; 0x60
 8001a7a:	461a      	mov	r2, r3
 8001a7c:	68bb      	ldr	r3, [r7, #8]
 8001a7e:	009b      	lsls	r3, r3, #2
 8001a80:	4413      	add	r3, r2
 8001a82:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 8001a84:	697b      	ldr	r3, [r7, #20]
 8001a86:	681a      	ldr	r2, [r3, #0]
 8001a88:	4b08      	ldr	r3, [pc, #32]	; (8001aac <LL_ADC_SetOffset+0x44>)
 8001a8a:	4013      	ands	r3, r2
 8001a8c:	687a      	ldr	r2, [r7, #4]
 8001a8e:	f002 41f8 	and.w	r1, r2, #2080374784	; 0x7c000000
 8001a92:	683a      	ldr	r2, [r7, #0]
 8001a94:	430a      	orrs	r2, r1
 8001a96:	4313      	orrs	r3, r2
 8001a98:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 8001a9c:	697b      	ldr	r3, [r7, #20]
 8001a9e:	601a      	str	r2, [r3, #0]
             ADC_OFR1_OFFSET1_EN | ADC_OFR1_OFFSET1_CH | ADC_OFR1_OFFSET1,
             ADC_OFR1_OFFSET1_EN | (Channel & ADC_CHANNEL_ID_NUMBER_MASK) | OffsetLevel);
}
 8001aa0:	bf00      	nop
 8001aa2:	371c      	adds	r7, #28
 8001aa4:	46bd      	mov	sp, r7
 8001aa6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001aaa:	4770      	bx	lr
 8001aac:	03fff000 	.word	0x03fff000

08001ab0 <LL_ADC_GetOffsetChannel>:
  *         (1, 2, 3, 4) For ADC channel read back from ADC register,
  *                      comparison with internal channel parameter to be done
  *                      using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
  */
__STATIC_INLINE uint32_t LL_ADC_GetOffsetChannel(ADC_TypeDef *ADCx, uint32_t Offsety)
{
 8001ab0:	b480      	push	{r7}
 8001ab2:	b085      	sub	sp, #20
 8001ab4:	af00      	add	r7, sp, #0
 8001ab6:	6078      	str	r0, [r7, #4]
 8001ab8:	6039      	str	r1, [r7, #0]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8001aba:	687b      	ldr	r3, [r7, #4]
 8001abc:	3360      	adds	r3, #96	; 0x60
 8001abe:	461a      	mov	r2, r3
 8001ac0:	683b      	ldr	r3, [r7, #0]
 8001ac2:	009b      	lsls	r3, r3, #2
 8001ac4:	4413      	add	r3, r2
 8001ac6:	60fb      	str	r3, [r7, #12]

  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8001ac8:	68fb      	ldr	r3, [r7, #12]
 8001aca:	681b      	ldr	r3, [r3, #0]
 8001acc:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
}
 8001ad0:	4618      	mov	r0, r3
 8001ad2:	3714      	adds	r7, #20
 8001ad4:	46bd      	mov	sp, r7
 8001ad6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ada:	4770      	bx	lr

08001adc <LL_ADC_SetOffsetState>:
  *         @arg @ref LL_ADC_OFFSET_DISABLE
  *         @arg @ref LL_ADC_OFFSET_ENABLE
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetState(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetState)
{
 8001adc:	b480      	push	{r7}
 8001ade:	b087      	sub	sp, #28
 8001ae0:	af00      	add	r7, sp, #0
 8001ae2:	60f8      	str	r0, [r7, #12]
 8001ae4:	60b9      	str	r1, [r7, #8]
 8001ae6:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8001ae8:	68fb      	ldr	r3, [r7, #12]
 8001aea:	3360      	adds	r3, #96	; 0x60
 8001aec:	461a      	mov	r2, r3
 8001aee:	68bb      	ldr	r3, [r7, #8]
 8001af0:	009b      	lsls	r3, r3, #2
 8001af2:	4413      	add	r3, r2
 8001af4:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 8001af6:	697b      	ldr	r3, [r7, #20]
 8001af8:	681b      	ldr	r3, [r3, #0]
 8001afa:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8001afe:	687b      	ldr	r3, [r7, #4]
 8001b00:	431a      	orrs	r2, r3
 8001b02:	697b      	ldr	r3, [r7, #20]
 8001b04:	601a      	str	r2, [r3, #0]
             ADC_OFR1_OFFSET1_EN,
             OffsetState);
}
 8001b06:	bf00      	nop
 8001b08:	371c      	adds	r7, #28
 8001b0a:	46bd      	mov	sp, r7
 8001b0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b10:	4770      	bx	lr

08001b12 <LL_ADC_SetSamplingTimeCommonConfig>:
  *         @arg @ref LL_ADC_SAMPLINGTIME_COMMON_DEFAULT
  *         @arg @ref LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetSamplingTimeCommonConfig(ADC_TypeDef *ADCx, uint32_t SamplingTimeCommonConfig)
{
 8001b12:	b480      	push	{r7}
 8001b14:	b083      	sub	sp, #12
 8001b16:	af00      	add	r7, sp, #0
 8001b18:	6078      	str	r0, [r7, #4]
 8001b1a:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8001b1c:	687b      	ldr	r3, [r7, #4]
 8001b1e:	695b      	ldr	r3, [r3, #20]
 8001b20:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8001b24:	683b      	ldr	r3, [r7, #0]
 8001b26:	431a      	orrs	r2, r3
 8001b28:	687b      	ldr	r3, [r7, #4]
 8001b2a:	615a      	str	r2, [r3, #20]
}
 8001b2c:	bf00      	nop
 8001b2e:	370c      	adds	r7, #12
 8001b30:	46bd      	mov	sp, r7
 8001b32:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b36:	4770      	bx	lr

08001b38 <LL_ADC_REG_SetSequencerRanks>:
  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)
{
 8001b38:	b480      	push	{r7}
 8001b3a:	b087      	sub	sp, #28
 8001b3c:	af00      	add	r7, sp, #0
 8001b3e:	60f8      	str	r0, [r7, #12]
 8001b40:	60b9      	str	r1, [r7, #8]
 8001b42:	607a      	str	r2, [r7, #4]
  /* Set bits with content of parameter "Channel" with bits position          */
  /* in register and register position depending on parameter "Rank".         */
  /* Parameters "Rank" and "Channel" are used with masks because containing   */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 8001b44:	68fb      	ldr	r3, [r7, #12]
 8001b46:	3330      	adds	r3, #48	; 0x30
 8001b48:	461a      	mov	r2, r3
 8001b4a:	68bb      	ldr	r3, [r7, #8]
 8001b4c:	0a1b      	lsrs	r3, r3, #8
 8001b4e:	009b      	lsls	r3, r3, #2
 8001b50:	f003 030c 	and.w	r3, r3, #12
 8001b54:	4413      	add	r3, r2
 8001b56:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 8001b58:	697b      	ldr	r3, [r7, #20]
 8001b5a:	681a      	ldr	r2, [r3, #0]
 8001b5c:	68bb      	ldr	r3, [r7, #8]
 8001b5e:	f003 031f 	and.w	r3, r3, #31
 8001b62:	211f      	movs	r1, #31
 8001b64:	fa01 f303 	lsl.w	r3, r1, r3
 8001b68:	43db      	mvns	r3, r3
 8001b6a:	401a      	ands	r2, r3
 8001b6c:	687b      	ldr	r3, [r7, #4]
 8001b6e:	0e9b      	lsrs	r3, r3, #26
 8001b70:	f003 011f 	and.w	r1, r3, #31
 8001b74:	68bb      	ldr	r3, [r7, #8]
 8001b76:	f003 031f 	and.w	r3, r3, #31
 8001b7a:	fa01 f303 	lsl.w	r3, r1, r3
 8001b7e:	431a      	orrs	r2, r3
 8001b80:	697b      	ldr	r3, [r7, #20]
 8001b82:	601a      	str	r2, [r3, #0]
             ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 << (Rank & ADC_REG_RANK_ID_SQRX_MASK),
             ((Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << (Rank & ADC_REG_RANK_ID_SQRX_MASK));
}
 8001b84:	bf00      	nop
 8001b86:	371c      	adds	r7, #28
 8001b88:	46bd      	mov	sp, r7
 8001b8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b8e:	4770      	bx	lr

08001b90 <LL_ADC_SetChannelSamplingTime>:
  *             can be replaced by 3.5 ADC clock cycles.
  *             Refer to function @ref LL_ADC_SetSamplingTimeCommonConfig().
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
{
 8001b90:	b480      	push	{r7}
 8001b92:	b087      	sub	sp, #28
 8001b94:	af00      	add	r7, sp, #0
 8001b96:	60f8      	str	r0, [r7, #12]
 8001b98:	60b9      	str	r1, [r7, #8]
 8001b9a:	607a      	str	r2, [r7, #4]
  /* Set bits with content of parameter "SamplingTime" with bits position     */
  /* in register and register position depending on parameter "Channel".      */
  /* Parameter "Channel" is used with masks because containing                */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8001b9c:	68fb      	ldr	r3, [r7, #12]
 8001b9e:	3314      	adds	r3, #20
 8001ba0:	461a      	mov	r2, r3
 8001ba2:	68bb      	ldr	r3, [r7, #8]
 8001ba4:	0e5b      	lsrs	r3, r3, #25
 8001ba6:	009b      	lsls	r3, r3, #2
 8001ba8:	f003 0304 	and.w	r3, r3, #4
 8001bac:	4413      	add	r3, r2
 8001bae:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 8001bb0:	697b      	ldr	r3, [r7, #20]
 8001bb2:	681a      	ldr	r2, [r3, #0]
 8001bb4:	68bb      	ldr	r3, [r7, #8]
 8001bb6:	0d1b      	lsrs	r3, r3, #20
 8001bb8:	f003 031f 	and.w	r3, r3, #31
 8001bbc:	2107      	movs	r1, #7
 8001bbe:	fa01 f303 	lsl.w	r3, r1, r3
 8001bc2:	43db      	mvns	r3, r3
 8001bc4:	401a      	ands	r2, r3
 8001bc6:	68bb      	ldr	r3, [r7, #8]
 8001bc8:	0d1b      	lsrs	r3, r3, #20
 8001bca:	f003 031f 	and.w	r3, r3, #31
 8001bce:	6879      	ldr	r1, [r7, #4]
 8001bd0:	fa01 f303 	lsl.w	r3, r1, r3
 8001bd4:	431a      	orrs	r2, r3
 8001bd6:	697b      	ldr	r3, [r7, #20]
 8001bd8:	601a      	str	r2, [r3, #0]
             ADC_SMPR1_SMP0 << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS),
             SamplingTime   << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS));
}
 8001bda:	bf00      	nop
 8001bdc:	371c      	adds	r7, #28
 8001bde:	46bd      	mov	sp, r7
 8001be0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001be4:	4770      	bx	lr
	...

08001be8 <LL_ADC_SetChannelSingleDiff>:
  *         @arg @ref LL_ADC_SINGLE_ENDED
  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSingleDiff(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SingleDiff)
{
 8001be8:	b480      	push	{r7}
 8001bea:	b085      	sub	sp, #20
 8001bec:	af00      	add	r7, sp, #0
 8001bee:	60f8      	str	r0, [r7, #12]
 8001bf0:	60b9      	str	r1, [r7, #8]
 8001bf2:	607a      	str	r2, [r7, #4]
  /* Bits of channels in single or differential mode are set only for         */
  /* differential mode (for single mode, mask of bits allowed to be set is    */
  /* shifted out of range of bits of channels in single or differential mode. */
  MODIFY_REG(ADCx->DIFSEL,
 8001bf4:	68fb      	ldr	r3, [r7, #12]
 8001bf6:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
 8001bfa:	68bb      	ldr	r3, [r7, #8]
 8001bfc:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8001c00:	43db      	mvns	r3, r3
 8001c02:	401a      	ands	r2, r3
 8001c04:	687b      	ldr	r3, [r7, #4]
 8001c06:	f003 0318 	and.w	r3, r3, #24
 8001c0a:	4908      	ldr	r1, [pc, #32]	; (8001c2c <LL_ADC_SetChannelSingleDiff+0x44>)
 8001c0c:	40d9      	lsrs	r1, r3
 8001c0e:	68bb      	ldr	r3, [r7, #8]
 8001c10:	400b      	ands	r3, r1
 8001c12:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8001c16:	431a      	orrs	r2, r3
 8001c18:	68fb      	ldr	r3, [r7, #12]
 8001c1a:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
             Channel & ADC_SINGLEDIFF_CHANNEL_MASK,
             (Channel & ADC_SINGLEDIFF_CHANNEL_MASK) & (ADC_DIFSEL_DIFSEL >> (SingleDiff & ADC_SINGLEDIFF_CHANNEL_SHIFT_MASK)));
}
 8001c1e:	bf00      	nop
 8001c20:	3714      	adds	r7, #20
 8001c22:	46bd      	mov	sp, r7
 8001c24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c28:	4770      	bx	lr
 8001c2a:	bf00      	nop
 8001c2c:	0007ffff 	.word	0x0007ffff

08001c30 <LL_ADC_DisableDeepPowerDown>:
  * @rmtoll CR       DEEPPWD        LL_ADC_DisableDeepPowerDown
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableDeepPowerDown(ADC_TypeDef *ADCx)
{
 8001c30:	b480      	push	{r7}
 8001c32:	b083      	sub	sp, #12
 8001c34:	af00      	add	r7, sp, #0
 8001c36:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 8001c38:	687b      	ldr	r3, [r7, #4]
 8001c3a:	689b      	ldr	r3, [r3, #8]
 8001c3c:	f023 4320 	bic.w	r3, r3, #2684354560	; 0xa0000000
 8001c40:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8001c44:	687a      	ldr	r2, [r7, #4]
 8001c46:	6093      	str	r3, [r2, #8]
}
 8001c48:	bf00      	nop
 8001c4a:	370c      	adds	r7, #12
 8001c4c:	46bd      	mov	sp, r7
 8001c4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c52:	4770      	bx	lr

08001c54 <LL_ADC_IsDeepPowerDownEnabled>:
  * @rmtoll CR       DEEPPWD        LL_ADC_IsDeepPowerDownEnabled
  * @param  ADCx ADC instance
  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(ADC_TypeDef *ADCx)
{
 8001c54:	b480      	push	{r7}
 8001c56:	b083      	sub	sp, #12
 8001c58:	af00      	add	r7, sp, #0
 8001c5a:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 8001c5c:	687b      	ldr	r3, [r7, #4]
 8001c5e:	689b      	ldr	r3, [r3, #8]
 8001c60:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8001c64:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8001c68:	d101      	bne.n	8001c6e <LL_ADC_IsDeepPowerDownEnabled+0x1a>
 8001c6a:	2301      	movs	r3, #1
 8001c6c:	e000      	b.n	8001c70 <LL_ADC_IsDeepPowerDownEnabled+0x1c>
 8001c6e:	2300      	movs	r3, #0
}
 8001c70:	4618      	mov	r0, r3
 8001c72:	370c      	adds	r7, #12
 8001c74:	46bd      	mov	sp, r7
 8001c76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c7a:	4770      	bx	lr

08001c7c <LL_ADC_EnableInternalRegulator>:
  * @rmtoll CR       ADVREGEN       LL_ADC_EnableInternalRegulator
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableInternalRegulator(ADC_TypeDef *ADCx)
{
 8001c7c:	b480      	push	{r7}
 8001c7e:	b083      	sub	sp, #12
 8001c80:	af00      	add	r7, sp, #0
 8001c82:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
 8001c84:	687b      	ldr	r3, [r7, #4]
 8001c86:	689b      	ldr	r3, [r3, #8]
 8001c88:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 8001c8c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8001c90:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
 8001c94:	687b      	ldr	r3, [r7, #4]
 8001c96:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADVREGEN);
}
 8001c98:	bf00      	nop
 8001c9a:	370c      	adds	r7, #12
 8001c9c:	46bd      	mov	sp, r7
 8001c9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ca2:	4770      	bx	lr

08001ca4 <LL_ADC_IsInternalRegulatorEnabled>:
  * @rmtoll CR       ADVREGEN       LL_ADC_IsInternalRegulatorEnabled
  * @param  ADCx ADC instance
  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(ADC_TypeDef *ADCx)
{
 8001ca4:	b480      	push	{r7}
 8001ca6:	b083      	sub	sp, #12
 8001ca8:	af00      	add	r7, sp, #0
 8001caa:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8001cac:	687b      	ldr	r3, [r7, #4]
 8001cae:	689b      	ldr	r3, [r3, #8]
 8001cb0:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001cb4:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8001cb8:	d101      	bne.n	8001cbe <LL_ADC_IsInternalRegulatorEnabled+0x1a>
 8001cba:	2301      	movs	r3, #1
 8001cbc:	e000      	b.n	8001cc0 <LL_ADC_IsInternalRegulatorEnabled+0x1c>
 8001cbe:	2300      	movs	r3, #0
}
 8001cc0:	4618      	mov	r0, r3
 8001cc2:	370c      	adds	r7, #12
 8001cc4:	46bd      	mov	sp, r7
 8001cc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001cca:	4770      	bx	lr

08001ccc <LL_ADC_IsEnabled>:
  * @rmtoll CR       ADEN           LL_ADC_IsEnabled
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(ADC_TypeDef *ADCx)
{
 8001ccc:	b480      	push	{r7}
 8001cce:	b083      	sub	sp, #12
 8001cd0:	af00      	add	r7, sp, #0
 8001cd2:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8001cd4:	687b      	ldr	r3, [r7, #4]
 8001cd6:	689b      	ldr	r3, [r3, #8]
 8001cd8:	f003 0301 	and.w	r3, r3, #1
 8001cdc:	2b01      	cmp	r3, #1
 8001cde:	d101      	bne.n	8001ce4 <LL_ADC_IsEnabled+0x18>
 8001ce0:	2301      	movs	r3, #1
 8001ce2:	e000      	b.n	8001ce6 <LL_ADC_IsEnabled+0x1a>
 8001ce4:	2300      	movs	r3, #0
}
 8001ce6:	4618      	mov	r0, r3
 8001ce8:	370c      	adds	r7, #12
 8001cea:	46bd      	mov	sp, r7
 8001cec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001cf0:	4770      	bx	lr

08001cf2 <LL_ADC_REG_IsConversionOngoing>:
  * @rmtoll CR       ADSTART        LL_ADC_REG_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
 8001cf2:	b480      	push	{r7}
 8001cf4:	b083      	sub	sp, #12
 8001cf6:	af00      	add	r7, sp, #0
 8001cf8:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8001cfa:	687b      	ldr	r3, [r7, #4]
 8001cfc:	689b      	ldr	r3, [r3, #8]
 8001cfe:	f003 0304 	and.w	r3, r3, #4
 8001d02:	2b04      	cmp	r3, #4
 8001d04:	d101      	bne.n	8001d0a <LL_ADC_REG_IsConversionOngoing+0x18>
 8001d06:	2301      	movs	r3, #1
 8001d08:	e000      	b.n	8001d0c <LL_ADC_REG_IsConversionOngoing+0x1a>
 8001d0a:	2300      	movs	r3, #0
}
 8001d0c:	4618      	mov	r0, r3
 8001d0e:	370c      	adds	r7, #12
 8001d10:	46bd      	mov	sp, r7
 8001d12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d16:	4770      	bx	lr

08001d18 <LL_ADC_INJ_IsConversionOngoing>:
  * @rmtoll CR       JADSTART       LL_ADC_INJ_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
{
 8001d18:	b480      	push	{r7}
 8001d1a:	b083      	sub	sp, #12
 8001d1c:	af00      	add	r7, sp, #0
 8001d1e:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8001d20:	687b      	ldr	r3, [r7, #4]
 8001d22:	689b      	ldr	r3, [r3, #8]
 8001d24:	f003 0308 	and.w	r3, r3, #8
 8001d28:	2b08      	cmp	r3, #8
 8001d2a:	d101      	bne.n	8001d30 <LL_ADC_INJ_IsConversionOngoing+0x18>
 8001d2c:	2301      	movs	r3, #1
 8001d2e:	e000      	b.n	8001d32 <LL_ADC_INJ_IsConversionOngoing+0x1a>
 8001d30:	2300      	movs	r3, #0
}
 8001d32:	4618      	mov	r0, r3
 8001d34:	370c      	adds	r7, #12
 8001d36:	46bd      	mov	sp, r7
 8001d38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d3c:	4770      	bx	lr
	...

08001d40 <HAL_ADC_Init>:
  *         without  disabling the other ADCs.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 8001d40:	b580      	push	{r7, lr}
 8001d42:	b088      	sub	sp, #32
 8001d44:	af00      	add	r7, sp, #0
 8001d46:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8001d48:	2300      	movs	r3, #0
 8001d4a:	77fb      	strb	r3, [r7, #31]
  uint32_t tmpCFGR;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 8001d4c:	2300      	movs	r3, #0
 8001d4e:	60bb      	str	r3, [r7, #8]
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;

  /* Check ADC handle */
  if (hadc == NULL)
 8001d50:	687b      	ldr	r3, [r7, #4]
 8001d52:	2b00      	cmp	r3, #0
 8001d54:	d101      	bne.n	8001d5a <HAL_ADC_Init+0x1a>
  {
    return HAL_ERROR;
 8001d56:	2301      	movs	r3, #1
 8001d58:	e12d      	b.n	8001fb6 <HAL_ADC_Init+0x276>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));

  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 8001d5a:	687b      	ldr	r3, [r7, #4]
 8001d5c:	691b      	ldr	r3, [r3, #16]
 8001d5e:	2b00      	cmp	r3, #0
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 8001d60:	687b      	ldr	r3, [r7, #4]
 8001d62:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001d64:	2b00      	cmp	r3, #0
 8001d66:	d109      	bne.n	8001d7c <HAL_ADC_Init+0x3c>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8001d68:	6878      	ldr	r0, [r7, #4]
 8001d6a:	f7ff f9fb 	bl	8001164 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 8001d6e:	687b      	ldr	r3, [r7, #4]
 8001d70:	2200      	movs	r2, #0
 8001d72:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 8001d74:	687b      	ldr	r3, [r7, #4]
 8001d76:	2200      	movs	r2, #0
 8001d78:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
  }

  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 8001d7c:	687b      	ldr	r3, [r7, #4]
 8001d7e:	681b      	ldr	r3, [r3, #0]
 8001d80:	4618      	mov	r0, r3
 8001d82:	f7ff ff67 	bl	8001c54 <LL_ADC_IsDeepPowerDownEnabled>
 8001d86:	4603      	mov	r3, r0
 8001d88:	2b00      	cmp	r3, #0
 8001d8a:	d004      	beq.n	8001d96 <HAL_ADC_Init+0x56>
  {
    /* Disable ADC deep power down mode */
    LL_ADC_DisableDeepPowerDown(hadc->Instance);
 8001d8c:	687b      	ldr	r3, [r7, #4]
 8001d8e:	681b      	ldr	r3, [r3, #0]
 8001d90:	4618      	mov	r0, r3
 8001d92:	f7ff ff4d 	bl	8001c30 <LL_ADC_DisableDeepPowerDown>
    /* System was in deep power down mode, calibration must
     be relaunched or a previously saved calibration factor
     re-applied once the ADC voltage regulator is enabled */
  }

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 8001d96:	687b      	ldr	r3, [r7, #4]
 8001d98:	681b      	ldr	r3, [r3, #0]
 8001d9a:	4618      	mov	r0, r3
 8001d9c:	f7ff ff82 	bl	8001ca4 <LL_ADC_IsInternalRegulatorEnabled>
 8001da0:	4603      	mov	r3, r0
 8001da2:	2b00      	cmp	r3, #0
 8001da4:	d113      	bne.n	8001dce <HAL_ADC_Init+0x8e>
  {
    /* Enable ADC internal voltage regulator */
    LL_ADC_EnableInternalRegulator(hadc->Instance);
 8001da6:	687b      	ldr	r3, [r7, #4]
 8001da8:	681b      	ldr	r3, [r3, #0]
 8001daa:	4618      	mov	r0, r3
 8001dac:	f7ff ff66 	bl	8001c7c <LL_ADC_EnableInternalRegulator>

    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 8001db0:	4b83      	ldr	r3, [pc, #524]	; (8001fc0 <HAL_ADC_Init+0x280>)
 8001db2:	681b      	ldr	r3, [r3, #0]
 8001db4:	099b      	lsrs	r3, r3, #6
 8001db6:	4a83      	ldr	r2, [pc, #524]	; (8001fc4 <HAL_ADC_Init+0x284>)
 8001db8:	fba2 2303 	umull	r2, r3, r2, r3
 8001dbc:	099b      	lsrs	r3, r3, #6
 8001dbe:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 8001dc0:	e002      	b.n	8001dc8 <HAL_ADC_Init+0x88>
    {
      wait_loop_index--;
 8001dc2:	68bb      	ldr	r3, [r7, #8]
 8001dc4:	3b01      	subs	r3, #1
 8001dc6:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 8001dc8:	68bb      	ldr	r3, [r7, #8]
 8001dca:	2b00      	cmp	r3, #0
 8001dcc:	d1f9      	bne.n	8001dc2 <HAL_ADC_Init+0x82>
  }

  /* Verification that ADC voltage regulator is correctly enabled, whether    */
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 8001dce:	687b      	ldr	r3, [r7, #4]
 8001dd0:	681b      	ldr	r3, [r3, #0]
 8001dd2:	4618      	mov	r0, r3
 8001dd4:	f7ff ff66 	bl	8001ca4 <LL_ADC_IsInternalRegulatorEnabled>
 8001dd8:	4603      	mov	r3, r0
 8001dda:	2b00      	cmp	r3, #0
 8001ddc:	d10d      	bne.n	8001dfa <HAL_ADC_Init+0xba>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001dde:	687b      	ldr	r3, [r7, #4]
 8001de0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001de2:	f043 0210 	orr.w	r2, r3, #16
 8001de6:	687b      	ldr	r3, [r7, #4]
 8001de8:	659a      	str	r2, [r3, #88]	; 0x58

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001dea:	687b      	ldr	r3, [r7, #4]
 8001dec:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8001dee:	f043 0201 	orr.w	r2, r3, #1
 8001df2:	687b      	ldr	r3, [r7, #4]
 8001df4:	65da      	str	r2, [r3, #92]	; 0x5c

    tmp_hal_status = HAL_ERROR;
 8001df6:	2301      	movs	r3, #1
 8001df8:	77fb      	strb	r3, [r7, #31]

  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8001dfa:	687b      	ldr	r3, [r7, #4]
 8001dfc:	681b      	ldr	r3, [r3, #0]
 8001dfe:	4618      	mov	r0, r3
 8001e00:	f7ff ff77 	bl	8001cf2 <LL_ADC_REG_IsConversionOngoing>
 8001e04:	6178      	str	r0, [r7, #20]

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8001e06:	687b      	ldr	r3, [r7, #4]
 8001e08:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001e0a:	f003 0310 	and.w	r3, r3, #16
 8001e0e:	2b00      	cmp	r3, #0
 8001e10:	f040 80c8 	bne.w	8001fa4 <HAL_ADC_Init+0x264>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
 8001e14:	697b      	ldr	r3, [r7, #20]
 8001e16:	2b00      	cmp	r3, #0
 8001e18:	f040 80c4 	bne.w	8001fa4 <HAL_ADC_Init+0x264>
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8001e1c:	687b      	ldr	r3, [r7, #4]
 8001e1e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001e20:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 8001e24:	f043 0202 	orr.w	r2, r3, #2
 8001e28:	687b      	ldr	r3, [r7, #4]
 8001e2a:	659a      	str	r2, [r3, #88]	; 0x58
    /* Configuration of common ADC parameters                                 */

    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - clock configuration                                                 */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8001e2c:	687b      	ldr	r3, [r7, #4]
 8001e2e:	681b      	ldr	r3, [r3, #0]
 8001e30:	4618      	mov	r0, r3
 8001e32:	f7ff ff4b 	bl	8001ccc <LL_ADC_IsEnabled>
 8001e36:	4603      	mov	r3, r0
 8001e38:	2b00      	cmp	r3, #0
 8001e3a:	d10b      	bne.n	8001e54 <HAL_ADC_Init+0x114>
    {
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8001e3c:	4862      	ldr	r0, [pc, #392]	; (8001fc8 <HAL_ADC_Init+0x288>)
 8001e3e:	f7ff ff45 	bl	8001ccc <LL_ADC_IsEnabled>
 8001e42:	4603      	mov	r3, r0
 8001e44:	2b00      	cmp	r3, #0
 8001e46:	d105      	bne.n	8001e54 <HAL_ADC_Init+0x114>
        /*     parameters: MDMA, DMACFG, DELAY, DUAL (set by API                */
        /*     HAL_ADCEx_MultiModeConfigChannel() )                             */
        /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
        /*     (set into HAL_ADC_ConfigChannel() or                             */
        /*     HAL_ADCEx_InjectedConfigChannel() )                              */
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 8001e48:	687b      	ldr	r3, [r7, #4]
 8001e4a:	685b      	ldr	r3, [r3, #4]
 8001e4c:	4619      	mov	r1, r3
 8001e4e:	485f      	ldr	r0, [pc, #380]	; (8001fcc <HAL_ADC_Init+0x28c>)
 8001e50:	f7ff fdd6 	bl	8001a00 <LL_ADC_SetCommonClock>
    /*  - external trigger polarity                Init.ExternalTrigConvEdge  */
    /*  - continuous conversion mode               Init.ContinuousConvMode    */
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8001e54:	687b      	ldr	r3, [r7, #4]
 8001e56:	7e5b      	ldrb	r3, [r3, #25]
 8001e58:	035a      	lsls	r2, r3, #13
                hadc->Init.Overrun                                                     |
 8001e5a:	687b      	ldr	r3, [r7, #4]
 8001e5c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8001e5e:	431a      	orrs	r2, r3
                hadc->Init.DataAlign                                                   |
 8001e60:	687b      	ldr	r3, [r7, #4]
 8001e62:	68db      	ldr	r3, [r3, #12]
                hadc->Init.Overrun                                                     |
 8001e64:	431a      	orrs	r2, r3
                hadc->Init.Resolution                                                  |
 8001e66:	687b      	ldr	r3, [r7, #4]
 8001e68:	689b      	ldr	r3, [r3, #8]
                hadc->Init.DataAlign                                                   |
 8001e6a:	431a      	orrs	r2, r3
                ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 8001e6c:	687b      	ldr	r3, [r7, #4]
 8001e6e:	f893 3020 	ldrb.w	r3, [r3, #32]
 8001e72:	041b      	lsls	r3, r3, #16
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8001e74:	4313      	orrs	r3, r2
 8001e76:	61bb      	str	r3, [r7, #24]

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8001e78:	687b      	ldr	r3, [r7, #4]
 8001e7a:	f893 3020 	ldrb.w	r3, [r3, #32]
 8001e7e:	2b01      	cmp	r3, #1
 8001e80:	d106      	bne.n	8001e90 <HAL_ADC_Init+0x150>
    {
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 8001e82:	687b      	ldr	r3, [r7, #4]
 8001e84:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001e86:	3b01      	subs	r3, #1
 8001e88:	045b      	lsls	r3, r3, #17
 8001e8a:	69ba      	ldr	r2, [r7, #24]
 8001e8c:	4313      	orrs	r3, r2
 8001e8e:	61bb      	str	r3, [r7, #24]
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8001e90:	687b      	ldr	r3, [r7, #4]
 8001e92:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001e94:	2b00      	cmp	r3, #0
 8001e96:	d009      	beq.n	8001eac <HAL_ADC_Init+0x16c>
    {
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8001e98:	687b      	ldr	r3, [r7, #4]
 8001e9a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001e9c:	f403 7270 	and.w	r2, r3, #960	; 0x3c0
                  | hadc->Init.ExternalTrigConvEdge
 8001ea0:	687b      	ldr	r3, [r7, #4]
 8001ea2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001ea4:	4313      	orrs	r3, r2
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8001ea6:	69ba      	ldr	r2, [r7, #24]
 8001ea8:	4313      	orrs	r3, r2
 8001eaa:	61bb      	str	r3, [r7, #24]
                 );
    }

    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
 8001eac:	687b      	ldr	r3, [r7, #4]
 8001eae:	681b      	ldr	r3, [r3, #0]
 8001eb0:	68da      	ldr	r2, [r3, #12]
 8001eb2:	4b47      	ldr	r3, [pc, #284]	; (8001fd0 <HAL_ADC_Init+0x290>)
 8001eb4:	4013      	ands	r3, r2
 8001eb6:	687a      	ldr	r2, [r7, #4]
 8001eb8:	6812      	ldr	r2, [r2, #0]
 8001eba:	69b9      	ldr	r1, [r7, #24]
 8001ebc:	430b      	orrs	r3, r1
 8001ebe:	60d3      	str	r3, [r2, #12]
    /* Parameters that can be updated when ADC is disabled or enabled without */
    /* conversion on going on regular and injected groups:                    */
    /*  - DMA continuous request          Init.DMAContinuousRequests          */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8001ec0:	687b      	ldr	r3, [r7, #4]
 8001ec2:	681b      	ldr	r3, [r3, #0]
 8001ec4:	4618      	mov	r0, r3
 8001ec6:	f7ff ff14 	bl	8001cf2 <LL_ADC_REG_IsConversionOngoing>
 8001eca:	6138      	str	r0, [r7, #16]
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 8001ecc:	687b      	ldr	r3, [r7, #4]
 8001ece:	681b      	ldr	r3, [r3, #0]
 8001ed0:	4618      	mov	r0, r3
 8001ed2:	f7ff ff21 	bl	8001d18 <LL_ADC_INJ_IsConversionOngoing>
 8001ed6:	60f8      	str	r0, [r7, #12]
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 8001ed8:	693b      	ldr	r3, [r7, #16]
 8001eda:	2b00      	cmp	r3, #0
 8001edc:	d140      	bne.n	8001f60 <HAL_ADC_Init+0x220>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 8001ede:	68fb      	ldr	r3, [r7, #12]
 8001ee0:	2b00      	cmp	r3, #0
 8001ee2:	d13d      	bne.n	8001f60 <HAL_ADC_Init+0x220>
       )
    {
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 8001ee4:	687b      	ldr	r3, [r7, #4]
 8001ee6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
                 ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 8001ee8:	687b      	ldr	r3, [r7, #4]
 8001eea:	7e1b      	ldrb	r3, [r3, #24]
 8001eec:	039b      	lsls	r3, r3, #14
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 8001eee:	431a      	orrs	r2, r3
                 ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 8001ef0:	687b      	ldr	r3, [r7, #4]
 8001ef2:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8001ef6:	005b      	lsls	r3, r3, #1
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 8001ef8:	4313      	orrs	r3, r2
 8001efa:	61bb      	str	r3, [r7, #24]

      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 8001efc:	687b      	ldr	r3, [r7, #4]
 8001efe:	681b      	ldr	r3, [r3, #0]
 8001f00:	68db      	ldr	r3, [r3, #12]
 8001f02:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8001f06:	f023 0306 	bic.w	r3, r3, #6
 8001f0a:	687a      	ldr	r2, [r7, #4]
 8001f0c:	6812      	ldr	r2, [r2, #0]
 8001f0e:	69b9      	ldr	r1, [r7, #24]
 8001f10:	430b      	orrs	r3, r1
 8001f12:	60d3      	str	r3, [r2, #12]

      if (hadc->Init.OversamplingMode == ENABLE)
 8001f14:	687b      	ldr	r3, [r7, #4]
 8001f16:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8001f1a:	2b01      	cmp	r3, #1
 8001f1c:	d118      	bne.n	8001f50 <HAL_ADC_Init+0x210>
        /* Configuration of Oversampler:                                      */
        /*  - Oversampling Ratio                                              */
        /*  - Right bit shift                                                 */
        /*  - Triggered mode                                                  */
        /*  - Oversampling mode (continued/resumed)                           */
        MODIFY_REG(hadc->Instance->CFGR2,
 8001f1e:	687b      	ldr	r3, [r7, #4]
 8001f20:	681b      	ldr	r3, [r3, #0]
 8001f22:	691b      	ldr	r3, [r3, #16]
 8001f24:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8001f28:	f023 0304 	bic.w	r3, r3, #4
 8001f2c:	687a      	ldr	r2, [r7, #4]
 8001f2e:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
 8001f30:	687a      	ldr	r2, [r7, #4]
 8001f32:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8001f34:	4311      	orrs	r1, r2
 8001f36:	687a      	ldr	r2, [r7, #4]
 8001f38:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8001f3a:	4311      	orrs	r1, r2
 8001f3c:	687a      	ldr	r2, [r7, #4]
 8001f3e:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8001f40:	430a      	orrs	r2, r1
 8001f42:	431a      	orrs	r2, r3
 8001f44:	687b      	ldr	r3, [r7, #4]
 8001f46:	681b      	ldr	r3, [r3, #0]
 8001f48:	f042 0201 	orr.w	r2, r2, #1
 8001f4c:	611a      	str	r2, [r3, #16]
 8001f4e:	e007      	b.n	8001f60 <HAL_ADC_Init+0x220>
                  );
      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 8001f50:	687b      	ldr	r3, [r7, #4]
 8001f52:	681b      	ldr	r3, [r3, #0]
 8001f54:	691a      	ldr	r2, [r3, #16]
 8001f56:	687b      	ldr	r3, [r7, #4]
 8001f58:	681b      	ldr	r3, [r3, #0]
 8001f5a:	f022 0201 	bic.w	r2, r2, #1
 8001f5e:	611a      	str	r2, [r3, #16]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 8001f60:	687b      	ldr	r3, [r7, #4]
 8001f62:	691b      	ldr	r3, [r3, #16]
 8001f64:	2b01      	cmp	r3, #1
 8001f66:	d10c      	bne.n	8001f82 <HAL_ADC_Init+0x242>
    {
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 8001f68:	687b      	ldr	r3, [r7, #4]
 8001f6a:	681b      	ldr	r3, [r3, #0]
 8001f6c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001f6e:	f023 010f 	bic.w	r1, r3, #15
 8001f72:	687b      	ldr	r3, [r7, #4]
 8001f74:	69db      	ldr	r3, [r3, #28]
 8001f76:	1e5a      	subs	r2, r3, #1
 8001f78:	687b      	ldr	r3, [r7, #4]
 8001f7a:	681b      	ldr	r3, [r3, #0]
 8001f7c:	430a      	orrs	r2, r1
 8001f7e:	631a      	str	r2, [r3, #48]	; 0x30
 8001f80:	e007      	b.n	8001f92 <HAL_ADC_Init+0x252>
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 8001f82:	687b      	ldr	r3, [r7, #4]
 8001f84:	681b      	ldr	r3, [r3, #0]
 8001f86:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001f88:	687b      	ldr	r3, [r7, #4]
 8001f8a:	681b      	ldr	r3, [r3, #0]
 8001f8c:	f022 020f 	bic.w	r2, r2, #15
 8001f90:	631a      	str	r2, [r3, #48]	; 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 8001f92:	687b      	ldr	r3, [r7, #4]
 8001f94:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001f96:	f023 0303 	bic.w	r3, r3, #3
 8001f9a:	f043 0201 	orr.w	r2, r3, #1
 8001f9e:	687b      	ldr	r3, [r7, #4]
 8001fa0:	659a      	str	r2, [r3, #88]	; 0x58
 8001fa2:	e007      	b.n	8001fb4 <HAL_ADC_Init+0x274>
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001fa4:	687b      	ldr	r3, [r7, #4]
 8001fa6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001fa8:	f043 0210 	orr.w	r2, r3, #16
 8001fac:	687b      	ldr	r3, [r7, #4]
 8001fae:	659a      	str	r2, [r3, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
 8001fb0:	2301      	movs	r3, #1
 8001fb2:	77fb      	strb	r3, [r7, #31]
  }

  /* Return function status */
  return tmp_hal_status;
 8001fb4:	7ffb      	ldrb	r3, [r7, #31]
}
 8001fb6:	4618      	mov	r0, r3
 8001fb8:	3720      	adds	r7, #32
 8001fba:	46bd      	mov	sp, r7
 8001fbc:	bd80      	pop	{r7, pc}
 8001fbe:	bf00      	nop
 8001fc0:	20000000 	.word	0x20000000
 8001fc4:	053e2d63 	.word	0x053e2d63
 8001fc8:	50040000 	.word	0x50040000
 8001fcc:	50040300 	.word	0x50040300
 8001fd0:	fff0c007 	.word	0xfff0c007

08001fd4 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *sConfig)
{
 8001fd4:	b580      	push	{r7, lr}
 8001fd6:	b0b6      	sub	sp, #216	; 0xd8
 8001fd8:	af00      	add	r7, sp, #0
 8001fda:	6078      	str	r0, [r7, #4]
 8001fdc:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8001fde:	2300      	movs	r3, #0
 8001fe0:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7
  uint32_t tmpOffsetShifted;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0UL;
 8001fe4:	2300      	movs	r3, #0
 8001fe6:	60fb      	str	r3, [r7, #12]
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfig->Channel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8001fe8:	687b      	ldr	r3, [r7, #4]
 8001fea:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 8001fee:	2b01      	cmp	r3, #1
 8001ff0:	d101      	bne.n	8001ff6 <HAL_ADC_ConfigChannel+0x22>
 8001ff2:	2302      	movs	r3, #2
 8001ff4:	e3d4      	b.n	80027a0 <HAL_ADC_ConfigChannel+0x7cc>
 8001ff6:	687b      	ldr	r3, [r7, #4]
 8001ff8:	2201      	movs	r2, #1
 8001ffa:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8001ffe:	687b      	ldr	r3, [r7, #4]
 8002000:	681b      	ldr	r3, [r3, #0]
 8002002:	4618      	mov	r0, r3
 8002004:	f7ff fe75 	bl	8001cf2 <LL_ADC_REG_IsConversionOngoing>
 8002008:	4603      	mov	r3, r0
 800200a:	2b00      	cmp	r3, #0
 800200c:	f040 83b9 	bne.w	8002782 <HAL_ADC_ConfigChannel+0x7ae>
    /* Correspondence for compatibility with legacy definition of             */
    /* sequencer ranks in direct number format. This correspondence can       */
    /* be done only on ranks 1 to 5 due to literal values.                    */
    /* Note: Sequencer ranks in direct number format are no more used         */
    /*       and are detected by activating USE_FULL_ASSERT feature.          */
    if (sConfig->Rank <= 5U)
 8002010:	683b      	ldr	r3, [r7, #0]
 8002012:	685b      	ldr	r3, [r3, #4]
 8002014:	2b05      	cmp	r3, #5
 8002016:	d824      	bhi.n	8002062 <HAL_ADC_ConfigChannel+0x8e>
    {
      switch (sConfig->Rank)
 8002018:	683b      	ldr	r3, [r7, #0]
 800201a:	685b      	ldr	r3, [r3, #4]
 800201c:	3b02      	subs	r3, #2
 800201e:	2b03      	cmp	r3, #3
 8002020:	d81b      	bhi.n	800205a <HAL_ADC_ConfigChannel+0x86>
 8002022:	a201      	add	r2, pc, #4	; (adr r2, 8002028 <HAL_ADC_ConfigChannel+0x54>)
 8002024:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002028:	08002039 	.word	0x08002039
 800202c:	08002041 	.word	0x08002041
 8002030:	08002049 	.word	0x08002049
 8002034:	08002051 	.word	0x08002051
      {
        case 2U:
          sConfig->Rank = ADC_REGULAR_RANK_2;
 8002038:	683b      	ldr	r3, [r7, #0]
 800203a:	220c      	movs	r2, #12
 800203c:	605a      	str	r2, [r3, #4]
          break;
 800203e:	e011      	b.n	8002064 <HAL_ADC_ConfigChannel+0x90>
        case 3U:
          sConfig->Rank = ADC_REGULAR_RANK_3;
 8002040:	683b      	ldr	r3, [r7, #0]
 8002042:	2212      	movs	r2, #18
 8002044:	605a      	str	r2, [r3, #4]
          break;
 8002046:	e00d      	b.n	8002064 <HAL_ADC_ConfigChannel+0x90>
        case 4U:
          sConfig->Rank = ADC_REGULAR_RANK_4;
 8002048:	683b      	ldr	r3, [r7, #0]
 800204a:	2218      	movs	r2, #24
 800204c:	605a      	str	r2, [r3, #4]
          break;
 800204e:	e009      	b.n	8002064 <HAL_ADC_ConfigChannel+0x90>
        case 5U:
          sConfig->Rank = ADC_REGULAR_RANK_5;
 8002050:	683b      	ldr	r3, [r7, #0]
 8002052:	f44f 7280 	mov.w	r2, #256	; 0x100
 8002056:	605a      	str	r2, [r3, #4]
          break;
 8002058:	e004      	b.n	8002064 <HAL_ADC_ConfigChannel+0x90>
        /* case 1U */
        default:
          sConfig->Rank = ADC_REGULAR_RANK_1;
 800205a:	683b      	ldr	r3, [r7, #0]
 800205c:	2206      	movs	r2, #6
 800205e:	605a      	str	r2, [r3, #4]
          break;
 8002060:	e000      	b.n	8002064 <HAL_ADC_ConfigChannel+0x90>
      }
    }
 8002062:	bf00      	nop
#endif

    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 8002064:	687b      	ldr	r3, [r7, #4]
 8002066:	6818      	ldr	r0, [r3, #0]
 8002068:	683b      	ldr	r3, [r7, #0]
 800206a:	6859      	ldr	r1, [r3, #4]
 800206c:	683b      	ldr	r3, [r7, #0]
 800206e:	681b      	ldr	r3, [r3, #0]
 8002070:	461a      	mov	r2, r3
 8002072:	f7ff fd61 	bl	8001b38 <LL_ADC_REG_SetSequencerRanks>
    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated when ADC is disabled or enabled without   */
    /* conversion on going on regular group:                                    */
    /*  - Channel sampling time                                                 */
    /*  - Channel offset                                                        */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8002076:	687b      	ldr	r3, [r7, #4]
 8002078:	681b      	ldr	r3, [r3, #0]
 800207a:	4618      	mov	r0, r3
 800207c:	f7ff fe39 	bl	8001cf2 <LL_ADC_REG_IsConversionOngoing>
 8002080:	f8c7 00d0 	str.w	r0, [r7, #208]	; 0xd0
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 8002084:	687b      	ldr	r3, [r7, #4]
 8002086:	681b      	ldr	r3, [r3, #0]
 8002088:	4618      	mov	r0, r3
 800208a:	f7ff fe45 	bl	8001d18 <LL_ADC_INJ_IsConversionOngoing>
 800208e:	f8c7 00cc 	str.w	r0, [r7, #204]	; 0xcc
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 8002092:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8002096:	2b00      	cmp	r3, #0
 8002098:	f040 81c1 	bne.w	800241e <HAL_ADC_ConfigChannel+0x44a>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 800209c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80020a0:	2b00      	cmp	r3, #0
 80020a2:	f040 81bc 	bne.w	800241e <HAL_ADC_ConfigChannel+0x44a>
       )
    {
#if defined(ADC_SMPR1_SMPPLUS)
      /* Manage specific case of sampling time 3.5 cycles replacing 2.5 cyles */
      if (sConfig->SamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 80020a6:	683b      	ldr	r3, [r7, #0]
 80020a8:	689b      	ldr	r3, [r3, #8]
 80020aa:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80020ae:	d10f      	bne.n	80020d0 <HAL_ADC_ConfigChannel+0xfc>
      {
        /* Set sampling time of the selected ADC channel */
        LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, LL_ADC_SAMPLINGTIME_2CYCLES_5);
 80020b0:	687b      	ldr	r3, [r7, #4]
 80020b2:	6818      	ldr	r0, [r3, #0]
 80020b4:	683b      	ldr	r3, [r7, #0]
 80020b6:	681b      	ldr	r3, [r3, #0]
 80020b8:	2200      	movs	r2, #0
 80020ba:	4619      	mov	r1, r3
 80020bc:	f7ff fd68 	bl	8001b90 <LL_ADC_SetChannelSamplingTime>

        /* Set ADC sampling time common configuration */
        LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5);
 80020c0:	687b      	ldr	r3, [r7, #4]
 80020c2:	681b      	ldr	r3, [r3, #0]
 80020c4:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 80020c8:	4618      	mov	r0, r3
 80020ca:	f7ff fd22 	bl	8001b12 <LL_ADC_SetSamplingTimeCommonConfig>
 80020ce:	e00e      	b.n	80020ee <HAL_ADC_ConfigChannel+0x11a>
      }
      else
      {
        /* Set sampling time of the selected ADC channel */
        LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 80020d0:	687b      	ldr	r3, [r7, #4]
 80020d2:	6818      	ldr	r0, [r3, #0]
 80020d4:	683b      	ldr	r3, [r7, #0]
 80020d6:	6819      	ldr	r1, [r3, #0]
 80020d8:	683b      	ldr	r3, [r7, #0]
 80020da:	689b      	ldr	r3, [r3, #8]
 80020dc:	461a      	mov	r2, r3
 80020de:	f7ff fd57 	bl	8001b90 <LL_ADC_SetChannelSamplingTime>

        /* Set ADC sampling time common configuration */
        LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_DEFAULT);
 80020e2:	687b      	ldr	r3, [r7, #4]
 80020e4:	681b      	ldr	r3, [r3, #0]
 80020e6:	2100      	movs	r1, #0
 80020e8:	4618      	mov	r0, r3
 80020ea:	f7ff fd12 	bl	8001b12 <LL_ADC_SetSamplingTimeCommonConfig>

      /* Configure the offset: offset enable/disable, channel, offset value */

      /* Shift the offset with respect to the selected ADC resolution. */
      /* Offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0 */
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 80020ee:	683b      	ldr	r3, [r7, #0]
 80020f0:	695a      	ldr	r2, [r3, #20]
 80020f2:	687b      	ldr	r3, [r7, #4]
 80020f4:	681b      	ldr	r3, [r3, #0]
 80020f6:	68db      	ldr	r3, [r3, #12]
 80020f8:	08db      	lsrs	r3, r3, #3
 80020fa:	f003 0303 	and.w	r3, r3, #3
 80020fe:	005b      	lsls	r3, r3, #1
 8002100:	fa02 f303 	lsl.w	r3, r2, r3
 8002104:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8

      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 8002108:	683b      	ldr	r3, [r7, #0]
 800210a:	691b      	ldr	r3, [r3, #16]
 800210c:	2b04      	cmp	r3, #4
 800210e:	d00a      	beq.n	8002126 <HAL_ADC_ConfigChannel+0x152>
      {
        /* Set ADC selected offset number */
        LL_ADC_SetOffset(hadc->Instance, sConfig->OffsetNumber, sConfig->Channel, tmpOffsetShifted);
 8002110:	687b      	ldr	r3, [r7, #4]
 8002112:	6818      	ldr	r0, [r3, #0]
 8002114:	683b      	ldr	r3, [r7, #0]
 8002116:	6919      	ldr	r1, [r3, #16]
 8002118:	683b      	ldr	r3, [r7, #0]
 800211a:	681a      	ldr	r2, [r3, #0]
 800211c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8002120:	f7ff fca2 	bl	8001a68 <LL_ADC_SetOffset>
 8002124:	e17b      	b.n	800241e <HAL_ADC_ConfigChannel+0x44a>
      }
      else
      {
        /* Scan each offset register to check if the selected channel is targeted. */
        /* If this is the case, the corresponding offset number is disabled.       */
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8002126:	687b      	ldr	r3, [r7, #4]
 8002128:	681b      	ldr	r3, [r3, #0]
 800212a:	2100      	movs	r1, #0
 800212c:	4618      	mov	r0, r3
 800212e:	f7ff fcbf 	bl	8001ab0 <LL_ADC_GetOffsetChannel>
 8002132:	4603      	mov	r3, r0
 8002134:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002138:	2b00      	cmp	r3, #0
 800213a:	d10a      	bne.n	8002152 <HAL_ADC_ConfigChannel+0x17e>
 800213c:	687b      	ldr	r3, [r7, #4]
 800213e:	681b      	ldr	r3, [r3, #0]
 8002140:	2100      	movs	r1, #0
 8002142:	4618      	mov	r0, r3
 8002144:	f7ff fcb4 	bl	8001ab0 <LL_ADC_GetOffsetChannel>
 8002148:	4603      	mov	r3, r0
 800214a:	0e9b      	lsrs	r3, r3, #26
 800214c:	f003 021f 	and.w	r2, r3, #31
 8002150:	e01e      	b.n	8002190 <HAL_ADC_ConfigChannel+0x1bc>
 8002152:	687b      	ldr	r3, [r7, #4]
 8002154:	681b      	ldr	r3, [r3, #0]
 8002156:	2100      	movs	r1, #0
 8002158:	4618      	mov	r0, r3
 800215a:	f7ff fca9 	bl	8001ab0 <LL_ADC_GetOffsetChannel>
 800215e:	4603      	mov	r3, r0
 8002160:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002164:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8002168:	fa93 f3a3 	rbit	r3, r3
 800216c:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
 8002170:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8002174:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
 8002178:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800217c:	2b00      	cmp	r3, #0
 800217e:	d101      	bne.n	8002184 <HAL_ADC_ConfigChannel+0x1b0>
  {
    return 32U;
 8002180:	2320      	movs	r3, #32
 8002182:	e004      	b.n	800218e <HAL_ADC_ConfigChannel+0x1ba>
  }
  return __builtin_clz(value);
 8002184:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8002188:	fab3 f383 	clz	r3, r3
 800218c:	b2db      	uxtb	r3, r3
 800218e:	461a      	mov	r2, r3
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8002190:	683b      	ldr	r3, [r7, #0]
 8002192:	681b      	ldr	r3, [r3, #0]
 8002194:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002198:	2b00      	cmp	r3, #0
 800219a:	d105      	bne.n	80021a8 <HAL_ADC_ConfigChannel+0x1d4>
 800219c:	683b      	ldr	r3, [r7, #0]
 800219e:	681b      	ldr	r3, [r3, #0]
 80021a0:	0e9b      	lsrs	r3, r3, #26
 80021a2:	f003 031f 	and.w	r3, r3, #31
 80021a6:	e018      	b.n	80021da <HAL_ADC_ConfigChannel+0x206>
 80021a8:	683b      	ldr	r3, [r7, #0]
 80021aa:	681b      	ldr	r3, [r3, #0]
 80021ac:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80021b0:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80021b4:	fa93 f3a3 	rbit	r3, r3
 80021b8:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  return result;
 80021bc:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80021c0:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  if (value == 0U)
 80021c4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80021c8:	2b00      	cmp	r3, #0
 80021ca:	d101      	bne.n	80021d0 <HAL_ADC_ConfigChannel+0x1fc>
    return 32U;
 80021cc:	2320      	movs	r3, #32
 80021ce:	e004      	b.n	80021da <HAL_ADC_ConfigChannel+0x206>
  return __builtin_clz(value);
 80021d0:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80021d4:	fab3 f383 	clz	r3, r3
 80021d8:	b2db      	uxtb	r3, r3
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 80021da:	429a      	cmp	r2, r3
 80021dc:	d106      	bne.n	80021ec <HAL_ADC_ConfigChannel+0x218>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_1, LL_ADC_OFFSET_DISABLE);
 80021de:	687b      	ldr	r3, [r7, #4]
 80021e0:	681b      	ldr	r3, [r3, #0]
 80021e2:	2200      	movs	r2, #0
 80021e4:	2100      	movs	r1, #0
 80021e6:	4618      	mov	r0, r3
 80021e8:	f7ff fc78 	bl	8001adc <LL_ADC_SetOffsetState>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 80021ec:	687b      	ldr	r3, [r7, #4]
 80021ee:	681b      	ldr	r3, [r3, #0]
 80021f0:	2101      	movs	r1, #1
 80021f2:	4618      	mov	r0, r3
 80021f4:	f7ff fc5c 	bl	8001ab0 <LL_ADC_GetOffsetChannel>
 80021f8:	4603      	mov	r3, r0
 80021fa:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80021fe:	2b00      	cmp	r3, #0
 8002200:	d10a      	bne.n	8002218 <HAL_ADC_ConfigChannel+0x244>
 8002202:	687b      	ldr	r3, [r7, #4]
 8002204:	681b      	ldr	r3, [r3, #0]
 8002206:	2101      	movs	r1, #1
 8002208:	4618      	mov	r0, r3
 800220a:	f7ff fc51 	bl	8001ab0 <LL_ADC_GetOffsetChannel>
 800220e:	4603      	mov	r3, r0
 8002210:	0e9b      	lsrs	r3, r3, #26
 8002212:	f003 021f 	and.w	r2, r3, #31
 8002216:	e01e      	b.n	8002256 <HAL_ADC_ConfigChannel+0x282>
 8002218:	687b      	ldr	r3, [r7, #4]
 800221a:	681b      	ldr	r3, [r3, #0]
 800221c:	2101      	movs	r1, #1
 800221e:	4618      	mov	r0, r3
 8002220:	f7ff fc46 	bl	8001ab0 <LL_ADC_GetOffsetChannel>
 8002224:	4603      	mov	r3, r0
 8002226:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800222a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800222e:	fa93 f3a3 	rbit	r3, r3
 8002232:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  return result;
 8002236:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800223a:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
  if (value == 0U)
 800223e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8002242:	2b00      	cmp	r3, #0
 8002244:	d101      	bne.n	800224a <HAL_ADC_ConfigChannel+0x276>
    return 32U;
 8002246:	2320      	movs	r3, #32
 8002248:	e004      	b.n	8002254 <HAL_ADC_ConfigChannel+0x280>
  return __builtin_clz(value);
 800224a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800224e:	fab3 f383 	clz	r3, r3
 8002252:	b2db      	uxtb	r3, r3
 8002254:	461a      	mov	r2, r3
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8002256:	683b      	ldr	r3, [r7, #0]
 8002258:	681b      	ldr	r3, [r3, #0]
 800225a:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800225e:	2b00      	cmp	r3, #0
 8002260:	d105      	bne.n	800226e <HAL_ADC_ConfigChannel+0x29a>
 8002262:	683b      	ldr	r3, [r7, #0]
 8002264:	681b      	ldr	r3, [r3, #0]
 8002266:	0e9b      	lsrs	r3, r3, #26
 8002268:	f003 031f 	and.w	r3, r3, #31
 800226c:	e018      	b.n	80022a0 <HAL_ADC_ConfigChannel+0x2cc>
 800226e:	683b      	ldr	r3, [r7, #0]
 8002270:	681b      	ldr	r3, [r3, #0]
 8002272:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002276:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800227a:	fa93 f3a3 	rbit	r3, r3
 800227e:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
  return result;
 8002282:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8002286:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  if (value == 0U)
 800228a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800228e:	2b00      	cmp	r3, #0
 8002290:	d101      	bne.n	8002296 <HAL_ADC_ConfigChannel+0x2c2>
    return 32U;
 8002292:	2320      	movs	r3, #32
 8002294:	e004      	b.n	80022a0 <HAL_ADC_ConfigChannel+0x2cc>
  return __builtin_clz(value);
 8002296:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800229a:	fab3 f383 	clz	r3, r3
 800229e:	b2db      	uxtb	r3, r3
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 80022a0:	429a      	cmp	r2, r3
 80022a2:	d106      	bne.n	80022b2 <HAL_ADC_ConfigChannel+0x2de>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_2, LL_ADC_OFFSET_DISABLE);
 80022a4:	687b      	ldr	r3, [r7, #4]
 80022a6:	681b      	ldr	r3, [r3, #0]
 80022a8:	2200      	movs	r2, #0
 80022aa:	2101      	movs	r1, #1
 80022ac:	4618      	mov	r0, r3
 80022ae:	f7ff fc15 	bl	8001adc <LL_ADC_SetOffsetState>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 80022b2:	687b      	ldr	r3, [r7, #4]
 80022b4:	681b      	ldr	r3, [r3, #0]
 80022b6:	2102      	movs	r1, #2
 80022b8:	4618      	mov	r0, r3
 80022ba:	f7ff fbf9 	bl	8001ab0 <LL_ADC_GetOffsetChannel>
 80022be:	4603      	mov	r3, r0
 80022c0:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80022c4:	2b00      	cmp	r3, #0
 80022c6:	d10a      	bne.n	80022de <HAL_ADC_ConfigChannel+0x30a>
 80022c8:	687b      	ldr	r3, [r7, #4]
 80022ca:	681b      	ldr	r3, [r3, #0]
 80022cc:	2102      	movs	r1, #2
 80022ce:	4618      	mov	r0, r3
 80022d0:	f7ff fbee 	bl	8001ab0 <LL_ADC_GetOffsetChannel>
 80022d4:	4603      	mov	r3, r0
 80022d6:	0e9b      	lsrs	r3, r3, #26
 80022d8:	f003 021f 	and.w	r2, r3, #31
 80022dc:	e01e      	b.n	800231c <HAL_ADC_ConfigChannel+0x348>
 80022de:	687b      	ldr	r3, [r7, #4]
 80022e0:	681b      	ldr	r3, [r3, #0]
 80022e2:	2102      	movs	r1, #2
 80022e4:	4618      	mov	r0, r3
 80022e6:	f7ff fbe3 	bl	8001ab0 <LL_ADC_GetOffsetChannel>
 80022ea:	4603      	mov	r3, r0
 80022ec:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80022f0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80022f4:	fa93 f3a3 	rbit	r3, r3
 80022f8:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  return result;
 80022fc:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8002300:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  if (value == 0U)
 8002304:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8002308:	2b00      	cmp	r3, #0
 800230a:	d101      	bne.n	8002310 <HAL_ADC_ConfigChannel+0x33c>
    return 32U;
 800230c:	2320      	movs	r3, #32
 800230e:	e004      	b.n	800231a <HAL_ADC_ConfigChannel+0x346>
  return __builtin_clz(value);
 8002310:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8002314:	fab3 f383 	clz	r3, r3
 8002318:	b2db      	uxtb	r3, r3
 800231a:	461a      	mov	r2, r3
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800231c:	683b      	ldr	r3, [r7, #0]
 800231e:	681b      	ldr	r3, [r3, #0]
 8002320:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002324:	2b00      	cmp	r3, #0
 8002326:	d105      	bne.n	8002334 <HAL_ADC_ConfigChannel+0x360>
 8002328:	683b      	ldr	r3, [r7, #0]
 800232a:	681b      	ldr	r3, [r3, #0]
 800232c:	0e9b      	lsrs	r3, r3, #26
 800232e:	f003 031f 	and.w	r3, r3, #31
 8002332:	e016      	b.n	8002362 <HAL_ADC_ConfigChannel+0x38e>
 8002334:	683b      	ldr	r3, [r7, #0]
 8002336:	681b      	ldr	r3, [r3, #0]
 8002338:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800233c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8002340:	fa93 f3a3 	rbit	r3, r3
 8002344:	67fb      	str	r3, [r7, #124]	; 0x7c
  return result;
 8002346:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8002348:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  if (value == 0U)
 800234c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8002350:	2b00      	cmp	r3, #0
 8002352:	d101      	bne.n	8002358 <HAL_ADC_ConfigChannel+0x384>
    return 32U;
 8002354:	2320      	movs	r3, #32
 8002356:	e004      	b.n	8002362 <HAL_ADC_ConfigChannel+0x38e>
  return __builtin_clz(value);
 8002358:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800235c:	fab3 f383 	clz	r3, r3
 8002360:	b2db      	uxtb	r3, r3
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 8002362:	429a      	cmp	r2, r3
 8002364:	d106      	bne.n	8002374 <HAL_ADC_ConfigChannel+0x3a0>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_3, LL_ADC_OFFSET_DISABLE);
 8002366:	687b      	ldr	r3, [r7, #4]
 8002368:	681b      	ldr	r3, [r3, #0]
 800236a:	2200      	movs	r2, #0
 800236c:	2102      	movs	r1, #2
 800236e:	4618      	mov	r0, r3
 8002370:	f7ff fbb4 	bl	8001adc <LL_ADC_SetOffsetState>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8002374:	687b      	ldr	r3, [r7, #4]
 8002376:	681b      	ldr	r3, [r3, #0]
 8002378:	2103      	movs	r1, #3
 800237a:	4618      	mov	r0, r3
 800237c:	f7ff fb98 	bl	8001ab0 <LL_ADC_GetOffsetChannel>
 8002380:	4603      	mov	r3, r0
 8002382:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002386:	2b00      	cmp	r3, #0
 8002388:	d10a      	bne.n	80023a0 <HAL_ADC_ConfigChannel+0x3cc>
 800238a:	687b      	ldr	r3, [r7, #4]
 800238c:	681b      	ldr	r3, [r3, #0]
 800238e:	2103      	movs	r1, #3
 8002390:	4618      	mov	r0, r3
 8002392:	f7ff fb8d 	bl	8001ab0 <LL_ADC_GetOffsetChannel>
 8002396:	4603      	mov	r3, r0
 8002398:	0e9b      	lsrs	r3, r3, #26
 800239a:	f003 021f 	and.w	r2, r3, #31
 800239e:	e017      	b.n	80023d0 <HAL_ADC_ConfigChannel+0x3fc>
 80023a0:	687b      	ldr	r3, [r7, #4]
 80023a2:	681b      	ldr	r3, [r3, #0]
 80023a4:	2103      	movs	r1, #3
 80023a6:	4618      	mov	r0, r3
 80023a8:	f7ff fb82 	bl	8001ab0 <LL_ADC_GetOffsetChannel>
 80023ac:	4603      	mov	r3, r0
 80023ae:	677b      	str	r3, [r7, #116]	; 0x74
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80023b0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80023b2:	fa93 f3a3 	rbit	r3, r3
 80023b6:	673b      	str	r3, [r7, #112]	; 0x70
  return result;
 80023b8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80023ba:	67bb      	str	r3, [r7, #120]	; 0x78
  if (value == 0U)
 80023bc:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80023be:	2b00      	cmp	r3, #0
 80023c0:	d101      	bne.n	80023c6 <HAL_ADC_ConfigChannel+0x3f2>
    return 32U;
 80023c2:	2320      	movs	r3, #32
 80023c4:	e003      	b.n	80023ce <HAL_ADC_ConfigChannel+0x3fa>
  return __builtin_clz(value);
 80023c6:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80023c8:	fab3 f383 	clz	r3, r3
 80023cc:	b2db      	uxtb	r3, r3
 80023ce:	461a      	mov	r2, r3
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80023d0:	683b      	ldr	r3, [r7, #0]
 80023d2:	681b      	ldr	r3, [r3, #0]
 80023d4:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80023d8:	2b00      	cmp	r3, #0
 80023da:	d105      	bne.n	80023e8 <HAL_ADC_ConfigChannel+0x414>
 80023dc:	683b      	ldr	r3, [r7, #0]
 80023de:	681b      	ldr	r3, [r3, #0]
 80023e0:	0e9b      	lsrs	r3, r3, #26
 80023e2:	f003 031f 	and.w	r3, r3, #31
 80023e6:	e011      	b.n	800240c <HAL_ADC_ConfigChannel+0x438>
 80023e8:	683b      	ldr	r3, [r7, #0]
 80023ea:	681b      	ldr	r3, [r3, #0]
 80023ec:	66bb      	str	r3, [r7, #104]	; 0x68
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80023ee:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80023f0:	fa93 f3a3 	rbit	r3, r3
 80023f4:	667b      	str	r3, [r7, #100]	; 0x64
  return result;
 80023f6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80023f8:	66fb      	str	r3, [r7, #108]	; 0x6c
  if (value == 0U)
 80023fa:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80023fc:	2b00      	cmp	r3, #0
 80023fe:	d101      	bne.n	8002404 <HAL_ADC_ConfigChannel+0x430>
    return 32U;
 8002400:	2320      	movs	r3, #32
 8002402:	e003      	b.n	800240c <HAL_ADC_ConfigChannel+0x438>
  return __builtin_clz(value);
 8002404:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8002406:	fab3 f383 	clz	r3, r3
 800240a:	b2db      	uxtb	r3, r3
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 800240c:	429a      	cmp	r2, r3
 800240e:	d106      	bne.n	800241e <HAL_ADC_ConfigChannel+0x44a>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_4, LL_ADC_OFFSET_DISABLE);
 8002410:	687b      	ldr	r3, [r7, #4]
 8002412:	681b      	ldr	r3, [r3, #0]
 8002414:	2200      	movs	r2, #0
 8002416:	2103      	movs	r1, #3
 8002418:	4618      	mov	r0, r3
 800241a:	f7ff fb5f 	bl	8001adc <LL_ADC_SetOffsetState>
    }

    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 800241e:	687b      	ldr	r3, [r7, #4]
 8002420:	681b      	ldr	r3, [r3, #0]
 8002422:	4618      	mov	r0, r3
 8002424:	f7ff fc52 	bl	8001ccc <LL_ADC_IsEnabled>
 8002428:	4603      	mov	r3, r0
 800242a:	2b00      	cmp	r3, #0
 800242c:	f040 8140 	bne.w	80026b0 <HAL_ADC_ConfigChannel+0x6dc>
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 8002430:	687b      	ldr	r3, [r7, #4]
 8002432:	6818      	ldr	r0, [r3, #0]
 8002434:	683b      	ldr	r3, [r7, #0]
 8002436:	6819      	ldr	r1, [r3, #0]
 8002438:	683b      	ldr	r3, [r7, #0]
 800243a:	68db      	ldr	r3, [r3, #12]
 800243c:	461a      	mov	r2, r3
 800243e:	f7ff fbd3 	bl	8001be8 <LL_ADC_SetChannelSingleDiff>

      /* Configuration of differential mode */
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 8002442:	683b      	ldr	r3, [r7, #0]
 8002444:	68db      	ldr	r3, [r3, #12]
 8002446:	4a8f      	ldr	r2, [pc, #572]	; (8002684 <HAL_ADC_ConfigChannel+0x6b0>)
 8002448:	4293      	cmp	r3, r2
 800244a:	f040 8131 	bne.w	80026b0 <HAL_ADC_ConfigChannel+0x6dc>
      {
        /* Set sampling time of the selected ADC channel */
        /* Note: ADC channel number masked with value "0x1F" to ensure shift value within 32 bits range */
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800244e:	687b      	ldr	r3, [r7, #4]
 8002450:	6818      	ldr	r0, [r3, #0]
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8002452:	683b      	ldr	r3, [r7, #0]
 8002454:	681b      	ldr	r3, [r3, #0]
 8002456:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800245a:	2b00      	cmp	r3, #0
 800245c:	d10b      	bne.n	8002476 <HAL_ADC_ConfigChannel+0x4a2>
 800245e:	683b      	ldr	r3, [r7, #0]
 8002460:	681b      	ldr	r3, [r3, #0]
 8002462:	0e9b      	lsrs	r3, r3, #26
 8002464:	3301      	adds	r3, #1
 8002466:	f003 031f 	and.w	r3, r3, #31
 800246a:	2b09      	cmp	r3, #9
 800246c:	bf94      	ite	ls
 800246e:	2301      	movls	r3, #1
 8002470:	2300      	movhi	r3, #0
 8002472:	b2db      	uxtb	r3, r3
 8002474:	e019      	b.n	80024aa <HAL_ADC_ConfigChannel+0x4d6>
 8002476:	683b      	ldr	r3, [r7, #0]
 8002478:	681b      	ldr	r3, [r3, #0]
 800247a:	65fb      	str	r3, [r7, #92]	; 0x5c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800247c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800247e:	fa93 f3a3 	rbit	r3, r3
 8002482:	65bb      	str	r3, [r7, #88]	; 0x58
  return result;
 8002484:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002486:	663b      	str	r3, [r7, #96]	; 0x60
  if (value == 0U)
 8002488:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800248a:	2b00      	cmp	r3, #0
 800248c:	d101      	bne.n	8002492 <HAL_ADC_ConfigChannel+0x4be>
    return 32U;
 800248e:	2320      	movs	r3, #32
 8002490:	e003      	b.n	800249a <HAL_ADC_ConfigChannel+0x4c6>
  return __builtin_clz(value);
 8002492:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8002494:	fab3 f383 	clz	r3, r3
 8002498:	b2db      	uxtb	r3, r3
 800249a:	3301      	adds	r3, #1
 800249c:	f003 031f 	and.w	r3, r3, #31
 80024a0:	2b09      	cmp	r3, #9
 80024a2:	bf94      	ite	ls
 80024a4:	2301      	movls	r3, #1
 80024a6:	2300      	movhi	r3, #0
 80024a8:	b2db      	uxtb	r3, r3
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 80024aa:	2b00      	cmp	r3, #0
 80024ac:	d079      	beq.n	80025a2 <HAL_ADC_ConfigChannel+0x5ce>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 80024ae:	683b      	ldr	r3, [r7, #0]
 80024b0:	681b      	ldr	r3, [r3, #0]
 80024b2:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80024b6:	2b00      	cmp	r3, #0
 80024b8:	d107      	bne.n	80024ca <HAL_ADC_ConfigChannel+0x4f6>
 80024ba:	683b      	ldr	r3, [r7, #0]
 80024bc:	681b      	ldr	r3, [r3, #0]
 80024be:	0e9b      	lsrs	r3, r3, #26
 80024c0:	3301      	adds	r3, #1
 80024c2:	069b      	lsls	r3, r3, #26
 80024c4:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 80024c8:	e015      	b.n	80024f6 <HAL_ADC_ConfigChannel+0x522>
 80024ca:	683b      	ldr	r3, [r7, #0]
 80024cc:	681b      	ldr	r3, [r3, #0]
 80024ce:	653b      	str	r3, [r7, #80]	; 0x50
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80024d0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80024d2:	fa93 f3a3 	rbit	r3, r3
 80024d6:	64fb      	str	r3, [r7, #76]	; 0x4c
  return result;
 80024d8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80024da:	657b      	str	r3, [r7, #84]	; 0x54
  if (value == 0U)
 80024dc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80024de:	2b00      	cmp	r3, #0
 80024e0:	d101      	bne.n	80024e6 <HAL_ADC_ConfigChannel+0x512>
    return 32U;
 80024e2:	2320      	movs	r3, #32
 80024e4:	e003      	b.n	80024ee <HAL_ADC_ConfigChannel+0x51a>
  return __builtin_clz(value);
 80024e6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80024e8:	fab3 f383 	clz	r3, r3
 80024ec:	b2db      	uxtb	r3, r3
 80024ee:	3301      	adds	r3, #1
 80024f0:	069b      	lsls	r3, r3, #26
 80024f2:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 80024f6:	683b      	ldr	r3, [r7, #0]
 80024f8:	681b      	ldr	r3, [r3, #0]
 80024fa:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80024fe:	2b00      	cmp	r3, #0
 8002500:	d109      	bne.n	8002516 <HAL_ADC_ConfigChannel+0x542>
 8002502:	683b      	ldr	r3, [r7, #0]
 8002504:	681b      	ldr	r3, [r3, #0]
 8002506:	0e9b      	lsrs	r3, r3, #26
 8002508:	3301      	adds	r3, #1
 800250a:	f003 031f 	and.w	r3, r3, #31
 800250e:	2101      	movs	r1, #1
 8002510:	fa01 f303 	lsl.w	r3, r1, r3
 8002514:	e017      	b.n	8002546 <HAL_ADC_ConfigChannel+0x572>
 8002516:	683b      	ldr	r3, [r7, #0]
 8002518:	681b      	ldr	r3, [r3, #0]
 800251a:	647b      	str	r3, [r7, #68]	; 0x44
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800251c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800251e:	fa93 f3a3 	rbit	r3, r3
 8002522:	643b      	str	r3, [r7, #64]	; 0x40
  return result;
 8002524:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002526:	64bb      	str	r3, [r7, #72]	; 0x48
  if (value == 0U)
 8002528:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800252a:	2b00      	cmp	r3, #0
 800252c:	d101      	bne.n	8002532 <HAL_ADC_ConfigChannel+0x55e>
    return 32U;
 800252e:	2320      	movs	r3, #32
 8002530:	e003      	b.n	800253a <HAL_ADC_ConfigChannel+0x566>
  return __builtin_clz(value);
 8002532:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002534:	fab3 f383 	clz	r3, r3
 8002538:	b2db      	uxtb	r3, r3
 800253a:	3301      	adds	r3, #1
 800253c:	f003 031f 	and.w	r3, r3, #31
 8002540:	2101      	movs	r1, #1
 8002542:	fa01 f303 	lsl.w	r3, r1, r3
 8002546:	ea42 0103 	orr.w	r1, r2, r3
 800254a:	683b      	ldr	r3, [r7, #0]
 800254c:	681b      	ldr	r3, [r3, #0]
 800254e:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002552:	2b00      	cmp	r3, #0
 8002554:	d10a      	bne.n	800256c <HAL_ADC_ConfigChannel+0x598>
 8002556:	683b      	ldr	r3, [r7, #0]
 8002558:	681b      	ldr	r3, [r3, #0]
 800255a:	0e9b      	lsrs	r3, r3, #26
 800255c:	3301      	adds	r3, #1
 800255e:	f003 021f 	and.w	r2, r3, #31
 8002562:	4613      	mov	r3, r2
 8002564:	005b      	lsls	r3, r3, #1
 8002566:	4413      	add	r3, r2
 8002568:	051b      	lsls	r3, r3, #20
 800256a:	e018      	b.n	800259e <HAL_ADC_ConfigChannel+0x5ca>
 800256c:	683b      	ldr	r3, [r7, #0]
 800256e:	681b      	ldr	r3, [r3, #0]
 8002570:	63bb      	str	r3, [r7, #56]	; 0x38
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002572:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8002574:	fa93 f3a3 	rbit	r3, r3
 8002578:	637b      	str	r3, [r7, #52]	; 0x34
  return result;
 800257a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800257c:	63fb      	str	r3, [r7, #60]	; 0x3c
  if (value == 0U)
 800257e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002580:	2b00      	cmp	r3, #0
 8002582:	d101      	bne.n	8002588 <HAL_ADC_ConfigChannel+0x5b4>
    return 32U;
 8002584:	2320      	movs	r3, #32
 8002586:	e003      	b.n	8002590 <HAL_ADC_ConfigChannel+0x5bc>
  return __builtin_clz(value);
 8002588:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800258a:	fab3 f383 	clz	r3, r3
 800258e:	b2db      	uxtb	r3, r3
 8002590:	3301      	adds	r3, #1
 8002592:	f003 021f 	and.w	r2, r3, #31
 8002596:	4613      	mov	r3, r2
 8002598:	005b      	lsls	r3, r3, #1
 800259a:	4413      	add	r3, r2
 800259c:	051b      	lsls	r3, r3, #20
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800259e:	430b      	orrs	r3, r1
 80025a0:	e081      	b.n	80026a6 <HAL_ADC_ConfigChannel+0x6d2>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 80025a2:	683b      	ldr	r3, [r7, #0]
 80025a4:	681b      	ldr	r3, [r3, #0]
 80025a6:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80025aa:	2b00      	cmp	r3, #0
 80025ac:	d107      	bne.n	80025be <HAL_ADC_ConfigChannel+0x5ea>
 80025ae:	683b      	ldr	r3, [r7, #0]
 80025b0:	681b      	ldr	r3, [r3, #0]
 80025b2:	0e9b      	lsrs	r3, r3, #26
 80025b4:	3301      	adds	r3, #1
 80025b6:	069b      	lsls	r3, r3, #26
 80025b8:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 80025bc:	e015      	b.n	80025ea <HAL_ADC_ConfigChannel+0x616>
 80025be:	683b      	ldr	r3, [r7, #0]
 80025c0:	681b      	ldr	r3, [r3, #0]
 80025c2:	62fb      	str	r3, [r7, #44]	; 0x2c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80025c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80025c6:	fa93 f3a3 	rbit	r3, r3
 80025ca:	62bb      	str	r3, [r7, #40]	; 0x28
  return result;
 80025cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80025ce:	633b      	str	r3, [r7, #48]	; 0x30
  if (value == 0U)
 80025d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80025d2:	2b00      	cmp	r3, #0
 80025d4:	d101      	bne.n	80025da <HAL_ADC_ConfigChannel+0x606>
    return 32U;
 80025d6:	2320      	movs	r3, #32
 80025d8:	e003      	b.n	80025e2 <HAL_ADC_ConfigChannel+0x60e>
  return __builtin_clz(value);
 80025da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80025dc:	fab3 f383 	clz	r3, r3
 80025e0:	b2db      	uxtb	r3, r3
 80025e2:	3301      	adds	r3, #1
 80025e4:	069b      	lsls	r3, r3, #26
 80025e6:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 80025ea:	683b      	ldr	r3, [r7, #0]
 80025ec:	681b      	ldr	r3, [r3, #0]
 80025ee:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80025f2:	2b00      	cmp	r3, #0
 80025f4:	d109      	bne.n	800260a <HAL_ADC_ConfigChannel+0x636>
 80025f6:	683b      	ldr	r3, [r7, #0]
 80025f8:	681b      	ldr	r3, [r3, #0]
 80025fa:	0e9b      	lsrs	r3, r3, #26
 80025fc:	3301      	adds	r3, #1
 80025fe:	f003 031f 	and.w	r3, r3, #31
 8002602:	2101      	movs	r1, #1
 8002604:	fa01 f303 	lsl.w	r3, r1, r3
 8002608:	e017      	b.n	800263a <HAL_ADC_ConfigChannel+0x666>
 800260a:	683b      	ldr	r3, [r7, #0]
 800260c:	681b      	ldr	r3, [r3, #0]
 800260e:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002610:	6a3b      	ldr	r3, [r7, #32]
 8002612:	fa93 f3a3 	rbit	r3, r3
 8002616:	61fb      	str	r3, [r7, #28]
  return result;
 8002618:	69fb      	ldr	r3, [r7, #28]
 800261a:	627b      	str	r3, [r7, #36]	; 0x24
  if (value == 0U)
 800261c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800261e:	2b00      	cmp	r3, #0
 8002620:	d101      	bne.n	8002626 <HAL_ADC_ConfigChannel+0x652>
    return 32U;
 8002622:	2320      	movs	r3, #32
 8002624:	e003      	b.n	800262e <HAL_ADC_ConfigChannel+0x65a>
  return __builtin_clz(value);
 8002626:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002628:	fab3 f383 	clz	r3, r3
 800262c:	b2db      	uxtb	r3, r3
 800262e:	3301      	adds	r3, #1
 8002630:	f003 031f 	and.w	r3, r3, #31
 8002634:	2101      	movs	r1, #1
 8002636:	fa01 f303 	lsl.w	r3, r1, r3
 800263a:	ea42 0103 	orr.w	r1, r2, r3
 800263e:	683b      	ldr	r3, [r7, #0]
 8002640:	681b      	ldr	r3, [r3, #0]
 8002642:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002646:	2b00      	cmp	r3, #0
 8002648:	d10d      	bne.n	8002666 <HAL_ADC_ConfigChannel+0x692>
 800264a:	683b      	ldr	r3, [r7, #0]
 800264c:	681b      	ldr	r3, [r3, #0]
 800264e:	0e9b      	lsrs	r3, r3, #26
 8002650:	3301      	adds	r3, #1
 8002652:	f003 021f 	and.w	r2, r3, #31
 8002656:	4613      	mov	r3, r2
 8002658:	005b      	lsls	r3, r3, #1
 800265a:	4413      	add	r3, r2
 800265c:	3b1e      	subs	r3, #30
 800265e:	051b      	lsls	r3, r3, #20
 8002660:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8002664:	e01e      	b.n	80026a4 <HAL_ADC_ConfigChannel+0x6d0>
 8002666:	683b      	ldr	r3, [r7, #0]
 8002668:	681b      	ldr	r3, [r3, #0]
 800266a:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800266c:	697b      	ldr	r3, [r7, #20]
 800266e:	fa93 f3a3 	rbit	r3, r3
 8002672:	613b      	str	r3, [r7, #16]
  return result;
 8002674:	693b      	ldr	r3, [r7, #16]
 8002676:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 8002678:	69bb      	ldr	r3, [r7, #24]
 800267a:	2b00      	cmp	r3, #0
 800267c:	d104      	bne.n	8002688 <HAL_ADC_ConfigChannel+0x6b4>
    return 32U;
 800267e:	2320      	movs	r3, #32
 8002680:	e006      	b.n	8002690 <HAL_ADC_ConfigChannel+0x6bc>
 8002682:	bf00      	nop
 8002684:	407f0000 	.word	0x407f0000
  return __builtin_clz(value);
 8002688:	69bb      	ldr	r3, [r7, #24]
 800268a:	fab3 f383 	clz	r3, r3
 800268e:	b2db      	uxtb	r3, r3
 8002690:	3301      	adds	r3, #1
 8002692:	f003 021f 	and.w	r2, r3, #31
 8002696:	4613      	mov	r3, r2
 8002698:	005b      	lsls	r3, r3, #1
 800269a:	4413      	add	r3, r2
 800269c:	3b1e      	subs	r3, #30
 800269e:	051b      	lsls	r3, r3, #20
 80026a0:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 80026a4:	430b      	orrs	r3, r1
 80026a6:	683a      	ldr	r2, [r7, #0]
 80026a8:	6892      	ldr	r2, [r2, #8]
 80026aa:	4619      	mov	r1, r3
 80026ac:	f7ff fa70 	bl	8001b90 <LL_ADC_SetChannelSamplingTime>
    /* If internal channel selected, enable dedicated internal buffers and    */
    /* paths.                                                                 */
    /* Note: these internal measurement paths can be disabled using           */
    /* HAL_ADC_DeInit().                                                      */

    if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 80026b0:	683b      	ldr	r3, [r7, #0]
 80026b2:	681a      	ldr	r2, [r3, #0]
 80026b4:	4b3c      	ldr	r3, [pc, #240]	; (80027a8 <HAL_ADC_ConfigChannel+0x7d4>)
 80026b6:	4013      	ands	r3, r2
 80026b8:	2b00      	cmp	r3, #0
 80026ba:	d06b      	beq.n	8002794 <HAL_ADC_ConfigChannel+0x7c0>
    {
      tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 80026bc:	483b      	ldr	r0, [pc, #236]	; (80027ac <HAL_ADC_ConfigChannel+0x7d8>)
 80026be:	f7ff f9c5 	bl	8001a4c <LL_ADC_GetCommonPathInternalCh>
 80026c2:	f8c7 00c4 	str.w	r0, [r7, #196]	; 0xc4

      /* If the requested internal measurement path has already been enabled, */
      /* bypass the configuration processing.                                 */
      if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80026c6:	683b      	ldr	r3, [r7, #0]
 80026c8:	681b      	ldr	r3, [r3, #0]
 80026ca:	4a39      	ldr	r2, [pc, #228]	; (80027b0 <HAL_ADC_ConfigChannel+0x7dc>)
 80026cc:	4293      	cmp	r3, r2
 80026ce:	d126      	bne.n	800271e <HAL_ADC_ConfigChannel+0x74a>
          && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 80026d0:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80026d4:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80026d8:	2b00      	cmp	r3, #0
 80026da:	d120      	bne.n	800271e <HAL_ADC_ConfigChannel+0x74a>
      {
        if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 80026dc:	687b      	ldr	r3, [r7, #4]
 80026de:	681b      	ldr	r3, [r3, #0]
 80026e0:	4a34      	ldr	r2, [pc, #208]	; (80027b4 <HAL_ADC_ConfigChannel+0x7e0>)
 80026e2:	4293      	cmp	r3, r2
 80026e4:	d156      	bne.n	8002794 <HAL_ADC_ConfigChannel+0x7c0>
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 80026e6:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80026ea:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80026ee:	4619      	mov	r1, r3
 80026f0:	482e      	ldr	r0, [pc, #184]	; (80027ac <HAL_ADC_ConfigChannel+0x7d8>)
 80026f2:	f7ff f998 	bl	8001a26 <LL_ADC_SetCommonPathInternalCh>
          /* Delay for temperature sensor stabilization time */
          /* Wait loop initialization and execution */
          /* Note: Variable divided by 2 to compensate partially              */
          /*       CPU processing cycles, scaling in us split to not          */
          /*       exceed 32 bits register capacity and handle low frequency. */
          wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 80026f6:	4b30      	ldr	r3, [pc, #192]	; (80027b8 <HAL_ADC_ConfigChannel+0x7e4>)
 80026f8:	681b      	ldr	r3, [r3, #0]
 80026fa:	099b      	lsrs	r3, r3, #6
 80026fc:	4a2f      	ldr	r2, [pc, #188]	; (80027bc <HAL_ADC_ConfigChannel+0x7e8>)
 80026fe:	fba2 2303 	umull	r2, r3, r2, r3
 8002702:	099a      	lsrs	r2, r3, #6
 8002704:	4613      	mov	r3, r2
 8002706:	005b      	lsls	r3, r3, #1
 8002708:	4413      	add	r3, r2
 800270a:	009b      	lsls	r3, r3, #2
 800270c:	60fb      	str	r3, [r7, #12]
          while (wait_loop_index != 0UL)
 800270e:	e002      	b.n	8002716 <HAL_ADC_ConfigChannel+0x742>
          {
            wait_loop_index--;
 8002710:	68fb      	ldr	r3, [r7, #12]
 8002712:	3b01      	subs	r3, #1
 8002714:	60fb      	str	r3, [r7, #12]
          while (wait_loop_index != 0UL)
 8002716:	68fb      	ldr	r3, [r7, #12]
 8002718:	2b00      	cmp	r3, #0
 800271a:	d1f9      	bne.n	8002710 <HAL_ADC_ConfigChannel+0x73c>
        if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 800271c:	e03a      	b.n	8002794 <HAL_ADC_ConfigChannel+0x7c0>
          }
        }
      }
      else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 800271e:	683b      	ldr	r3, [r7, #0]
 8002720:	681b      	ldr	r3, [r3, #0]
 8002722:	4a27      	ldr	r2, [pc, #156]	; (80027c0 <HAL_ADC_ConfigChannel+0x7ec>)
 8002724:	4293      	cmp	r3, r2
 8002726:	d113      	bne.n	8002750 <HAL_ADC_ConfigChannel+0x77c>
 8002728:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800272c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8002730:	2b00      	cmp	r3, #0
 8002732:	d10d      	bne.n	8002750 <HAL_ADC_ConfigChannel+0x77c>
      {
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8002734:	687b      	ldr	r3, [r7, #4]
 8002736:	681b      	ldr	r3, [r3, #0]
 8002738:	4a1e      	ldr	r2, [pc, #120]	; (80027b4 <HAL_ADC_ConfigChannel+0x7e0>)
 800273a:	4293      	cmp	r3, r2
 800273c:	d12a      	bne.n	8002794 <HAL_ADC_ConfigChannel+0x7c0>
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 800273e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8002742:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002746:	4619      	mov	r1, r3
 8002748:	4818      	ldr	r0, [pc, #96]	; (80027ac <HAL_ADC_ConfigChannel+0x7d8>)
 800274a:	f7ff f96c 	bl	8001a26 <LL_ADC_SetCommonPathInternalCh>
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 800274e:	e021      	b.n	8002794 <HAL_ADC_ConfigChannel+0x7c0>
                                         LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
        }
      }
      else if ((sConfig->Channel == ADC_CHANNEL_VREFINT)
 8002750:	683b      	ldr	r3, [r7, #0]
 8002752:	681b      	ldr	r3, [r3, #0]
 8002754:	4a1b      	ldr	r2, [pc, #108]	; (80027c4 <HAL_ADC_ConfigChannel+0x7f0>)
 8002756:	4293      	cmp	r3, r2
 8002758:	d11c      	bne.n	8002794 <HAL_ADC_ConfigChannel+0x7c0>
               && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 800275a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800275e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8002762:	2b00      	cmp	r3, #0
 8002764:	d116      	bne.n	8002794 <HAL_ADC_ConfigChannel+0x7c0>
      {
        if (ADC_VREFINT_INSTANCE(hadc))
 8002766:	687b      	ldr	r3, [r7, #4]
 8002768:	681b      	ldr	r3, [r3, #0]
 800276a:	4a12      	ldr	r2, [pc, #72]	; (80027b4 <HAL_ADC_ConfigChannel+0x7e0>)
 800276c:	4293      	cmp	r3, r2
 800276e:	d111      	bne.n	8002794 <HAL_ADC_ConfigChannel+0x7c0>
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8002770:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8002774:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8002778:	4619      	mov	r1, r3
 800277a:	480c      	ldr	r0, [pc, #48]	; (80027ac <HAL_ADC_ConfigChannel+0x7d8>)
 800277c:	f7ff f953 	bl	8001a26 <LL_ADC_SetCommonPathInternalCh>
 8002780:	e008      	b.n	8002794 <HAL_ADC_ConfigChannel+0x7c0>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8002782:	687b      	ldr	r3, [r7, #4]
 8002784:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8002786:	f043 0220 	orr.w	r2, r3, #32
 800278a:	687b      	ldr	r3, [r7, #4]
 800278c:	659a      	str	r2, [r3, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
 800278e:	2301      	movs	r3, #1
 8002790:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8002794:	687b      	ldr	r3, [r7, #4]
 8002796:	2200      	movs	r2, #0
 8002798:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

  /* Return function status */
  return tmp_hal_status;
 800279c:	f897 30d7 	ldrb.w	r3, [r7, #215]	; 0xd7
}
 80027a0:	4618      	mov	r0, r3
 80027a2:	37d8      	adds	r7, #216	; 0xd8
 80027a4:	46bd      	mov	sp, r7
 80027a6:	bd80      	pop	{r7, pc}
 80027a8:	80080000 	.word	0x80080000
 80027ac:	50040300 	.word	0x50040300
 80027b0:	c7520000 	.word	0xc7520000
 80027b4:	50040000 	.word	0x50040000
 80027b8:	20000000 	.word	0x20000000
 80027bc:	053e2d63 	.word	0x053e2d63
 80027c0:	cb840000 	.word	0xcb840000
 80027c4:	80000001 	.word	0x80000001

080027c8 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80027c8:	b480      	push	{r7}
 80027ca:	b085      	sub	sp, #20
 80027cc:	af00      	add	r7, sp, #0
 80027ce:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80027d0:	687b      	ldr	r3, [r7, #4]
 80027d2:	f003 0307 	and.w	r3, r3, #7
 80027d6:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80027d8:	4b0c      	ldr	r3, [pc, #48]	; (800280c <__NVIC_SetPriorityGrouping+0x44>)
 80027da:	68db      	ldr	r3, [r3, #12]
 80027dc:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80027de:	68ba      	ldr	r2, [r7, #8]
 80027e0:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 80027e4:	4013      	ands	r3, r2
 80027e6:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80027e8:	68fb      	ldr	r3, [r7, #12]
 80027ea:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80027ec:	68bb      	ldr	r3, [r7, #8]
 80027ee:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 80027f0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80027f4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80027f8:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 80027fa:	4a04      	ldr	r2, [pc, #16]	; (800280c <__NVIC_SetPriorityGrouping+0x44>)
 80027fc:	68bb      	ldr	r3, [r7, #8]
 80027fe:	60d3      	str	r3, [r2, #12]
}
 8002800:	bf00      	nop
 8002802:	3714      	adds	r7, #20
 8002804:	46bd      	mov	sp, r7
 8002806:	f85d 7b04 	ldr.w	r7, [sp], #4
 800280a:	4770      	bx	lr
 800280c:	e000ed00 	.word	0xe000ed00

08002810 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8002810:	b480      	push	{r7}
 8002812:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8002814:	4b04      	ldr	r3, [pc, #16]	; (8002828 <__NVIC_GetPriorityGrouping+0x18>)
 8002816:	68db      	ldr	r3, [r3, #12]
 8002818:	0a1b      	lsrs	r3, r3, #8
 800281a:	f003 0307 	and.w	r3, r3, #7
}
 800281e:	4618      	mov	r0, r3
 8002820:	46bd      	mov	sp, r7
 8002822:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002826:	4770      	bx	lr
 8002828:	e000ed00 	.word	0xe000ed00

0800282c <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800282c:	b480      	push	{r7}
 800282e:	b083      	sub	sp, #12
 8002830:	af00      	add	r7, sp, #0
 8002832:	4603      	mov	r3, r0
 8002834:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8002836:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800283a:	2b00      	cmp	r3, #0
 800283c:	db0b      	blt.n	8002856 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800283e:	79fb      	ldrb	r3, [r7, #7]
 8002840:	f003 021f 	and.w	r2, r3, #31
 8002844:	4907      	ldr	r1, [pc, #28]	; (8002864 <__NVIC_EnableIRQ+0x38>)
 8002846:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800284a:	095b      	lsrs	r3, r3, #5
 800284c:	2001      	movs	r0, #1
 800284e:	fa00 f202 	lsl.w	r2, r0, r2
 8002852:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8002856:	bf00      	nop
 8002858:	370c      	adds	r7, #12
 800285a:	46bd      	mov	sp, r7
 800285c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002860:	4770      	bx	lr
 8002862:	bf00      	nop
 8002864:	e000e100 	.word	0xe000e100

08002868 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8002868:	b480      	push	{r7}
 800286a:	b083      	sub	sp, #12
 800286c:	af00      	add	r7, sp, #0
 800286e:	4603      	mov	r3, r0
 8002870:	6039      	str	r1, [r7, #0]
 8002872:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8002874:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8002878:	2b00      	cmp	r3, #0
 800287a:	db0a      	blt.n	8002892 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800287c:	683b      	ldr	r3, [r7, #0]
 800287e:	b2da      	uxtb	r2, r3
 8002880:	490c      	ldr	r1, [pc, #48]	; (80028b4 <__NVIC_SetPriority+0x4c>)
 8002882:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8002886:	0112      	lsls	r2, r2, #4
 8002888:	b2d2      	uxtb	r2, r2
 800288a:	440b      	add	r3, r1
 800288c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8002890:	e00a      	b.n	80028a8 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002892:	683b      	ldr	r3, [r7, #0]
 8002894:	b2da      	uxtb	r2, r3
 8002896:	4908      	ldr	r1, [pc, #32]	; (80028b8 <__NVIC_SetPriority+0x50>)
 8002898:	79fb      	ldrb	r3, [r7, #7]
 800289a:	f003 030f 	and.w	r3, r3, #15
 800289e:	3b04      	subs	r3, #4
 80028a0:	0112      	lsls	r2, r2, #4
 80028a2:	b2d2      	uxtb	r2, r2
 80028a4:	440b      	add	r3, r1
 80028a6:	761a      	strb	r2, [r3, #24]
}
 80028a8:	bf00      	nop
 80028aa:	370c      	adds	r7, #12
 80028ac:	46bd      	mov	sp, r7
 80028ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80028b2:	4770      	bx	lr
 80028b4:	e000e100 	.word	0xe000e100
 80028b8:	e000ed00 	.word	0xe000ed00

080028bc <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80028bc:	b480      	push	{r7}
 80028be:	b089      	sub	sp, #36	; 0x24
 80028c0:	af00      	add	r7, sp, #0
 80028c2:	60f8      	str	r0, [r7, #12]
 80028c4:	60b9      	str	r1, [r7, #8]
 80028c6:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 80028c8:	68fb      	ldr	r3, [r7, #12]
 80028ca:	f003 0307 	and.w	r3, r3, #7
 80028ce:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80028d0:	69fb      	ldr	r3, [r7, #28]
 80028d2:	f1c3 0307 	rsb	r3, r3, #7
 80028d6:	2b04      	cmp	r3, #4
 80028d8:	bf28      	it	cs
 80028da:	2304      	movcs	r3, #4
 80028dc:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80028de:	69fb      	ldr	r3, [r7, #28]
 80028e0:	3304      	adds	r3, #4
 80028e2:	2b06      	cmp	r3, #6
 80028e4:	d902      	bls.n	80028ec <NVIC_EncodePriority+0x30>
 80028e6:	69fb      	ldr	r3, [r7, #28]
 80028e8:	3b03      	subs	r3, #3
 80028ea:	e000      	b.n	80028ee <NVIC_EncodePriority+0x32>
 80028ec:	2300      	movs	r3, #0
 80028ee:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80028f0:	f04f 32ff 	mov.w	r2, #4294967295
 80028f4:	69bb      	ldr	r3, [r7, #24]
 80028f6:	fa02 f303 	lsl.w	r3, r2, r3
 80028fa:	43da      	mvns	r2, r3
 80028fc:	68bb      	ldr	r3, [r7, #8]
 80028fe:	401a      	ands	r2, r3
 8002900:	697b      	ldr	r3, [r7, #20]
 8002902:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8002904:	f04f 31ff 	mov.w	r1, #4294967295
 8002908:	697b      	ldr	r3, [r7, #20]
 800290a:	fa01 f303 	lsl.w	r3, r1, r3
 800290e:	43d9      	mvns	r1, r3
 8002910:	687b      	ldr	r3, [r7, #4]
 8002912:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002914:	4313      	orrs	r3, r2
         );
}
 8002916:	4618      	mov	r0, r3
 8002918:	3724      	adds	r7, #36	; 0x24
 800291a:	46bd      	mov	sp, r7
 800291c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002920:	4770      	bx	lr
	...

08002924 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8002924:	b580      	push	{r7, lr}
 8002926:	b082      	sub	sp, #8
 8002928:	af00      	add	r7, sp, #0
 800292a:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800292c:	687b      	ldr	r3, [r7, #4]
 800292e:	3b01      	subs	r3, #1
 8002930:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8002934:	d301      	bcc.n	800293a <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8002936:	2301      	movs	r3, #1
 8002938:	e00f      	b.n	800295a <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800293a:	4a0a      	ldr	r2, [pc, #40]	; (8002964 <SysTick_Config+0x40>)
 800293c:	687b      	ldr	r3, [r7, #4]
 800293e:	3b01      	subs	r3, #1
 8002940:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8002942:	210f      	movs	r1, #15
 8002944:	f04f 30ff 	mov.w	r0, #4294967295
 8002948:	f7ff ff8e 	bl	8002868 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800294c:	4b05      	ldr	r3, [pc, #20]	; (8002964 <SysTick_Config+0x40>)
 800294e:	2200      	movs	r2, #0
 8002950:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8002952:	4b04      	ldr	r3, [pc, #16]	; (8002964 <SysTick_Config+0x40>)
 8002954:	2207      	movs	r2, #7
 8002956:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8002958:	2300      	movs	r3, #0
}
 800295a:	4618      	mov	r0, r3
 800295c:	3708      	adds	r7, #8
 800295e:	46bd      	mov	sp, r7
 8002960:	bd80      	pop	{r7, pc}
 8002962:	bf00      	nop
 8002964:	e000e010 	.word	0xe000e010

08002968 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8002968:	b580      	push	{r7, lr}
 800296a:	b082      	sub	sp, #8
 800296c:	af00      	add	r7, sp, #0
 800296e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8002970:	6878      	ldr	r0, [r7, #4]
 8002972:	f7ff ff29 	bl	80027c8 <__NVIC_SetPriorityGrouping>
}
 8002976:	bf00      	nop
 8002978:	3708      	adds	r7, #8
 800297a:	46bd      	mov	sp, r7
 800297c:	bd80      	pop	{r7, pc}

0800297e <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800297e:	b580      	push	{r7, lr}
 8002980:	b086      	sub	sp, #24
 8002982:	af00      	add	r7, sp, #0
 8002984:	4603      	mov	r3, r0
 8002986:	60b9      	str	r1, [r7, #8]
 8002988:	607a      	str	r2, [r7, #4]
 800298a:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00;
 800298c:	2300      	movs	r3, #0
 800298e:	617b      	str	r3, [r7, #20]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 8002990:	f7ff ff3e 	bl	8002810 <__NVIC_GetPriorityGrouping>
 8002994:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8002996:	687a      	ldr	r2, [r7, #4]
 8002998:	68b9      	ldr	r1, [r7, #8]
 800299a:	6978      	ldr	r0, [r7, #20]
 800299c:	f7ff ff8e 	bl	80028bc <NVIC_EncodePriority>
 80029a0:	4602      	mov	r2, r0
 80029a2:	f997 300f 	ldrsb.w	r3, [r7, #15]
 80029a6:	4611      	mov	r1, r2
 80029a8:	4618      	mov	r0, r3
 80029aa:	f7ff ff5d 	bl	8002868 <__NVIC_SetPriority>
}
 80029ae:	bf00      	nop
 80029b0:	3718      	adds	r7, #24
 80029b2:	46bd      	mov	sp, r7
 80029b4:	bd80      	pop	{r7, pc}

080029b6 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32l4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80029b6:	b580      	push	{r7, lr}
 80029b8:	b082      	sub	sp, #8
 80029ba:	af00      	add	r7, sp, #0
 80029bc:	4603      	mov	r3, r0
 80029be:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 80029c0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80029c4:	4618      	mov	r0, r3
 80029c6:	f7ff ff31 	bl	800282c <__NVIC_EnableIRQ>
}
 80029ca:	bf00      	nop
 80029cc:	3708      	adds	r7, #8
 80029ce:	46bd      	mov	sp, r7
 80029d0:	bd80      	pop	{r7, pc}

080029d2 <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80029d2:	b580      	push	{r7, lr}
 80029d4:	b082      	sub	sp, #8
 80029d6:	af00      	add	r7, sp, #0
 80029d8:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 80029da:	6878      	ldr	r0, [r7, #4]
 80029dc:	f7ff ffa2 	bl	8002924 <SysTick_Config>
 80029e0:	4603      	mov	r3, r0
}
 80029e2:	4618      	mov	r0, r3
 80029e4:	3708      	adds	r7, #8
 80029e6:	46bd      	mov	sp, r7
 80029e8:	bd80      	pop	{r7, pc}
	...

080029ec <HAL_DFSDM_ChannelInit>:
  *         in the DFSDM_ChannelInitTypeDef structure and initialize the associated handle.
  * @param  hdfsdm_channel DFSDM channel handle.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DFSDM_ChannelInit(DFSDM_Channel_HandleTypeDef *hdfsdm_channel)
{
 80029ec:	b580      	push	{r7, lr}
 80029ee:	b082      	sub	sp, #8
 80029f0:	af00      	add	r7, sp, #0
 80029f2:	6078      	str	r0, [r7, #4]
  /* Check DFSDM Channel handle */
  if (hdfsdm_channel == NULL)
 80029f4:	687b      	ldr	r3, [r7, #4]
 80029f6:	2b00      	cmp	r3, #0
 80029f8:	d101      	bne.n	80029fe <HAL_DFSDM_ChannelInit+0x12>
  {
    return HAL_ERROR;
 80029fa:	2301      	movs	r3, #1
 80029fc:	e0ac      	b.n	8002b58 <HAL_DFSDM_ChannelInit+0x16c>
  assert_param(IS_DFSDM_CHANNEL_FILTER_OVS_RATIO(hdfsdm_channel->Init.Awd.Oversampling));
  assert_param(IS_DFSDM_CHANNEL_OFFSET(hdfsdm_channel->Init.Offset));
  assert_param(IS_DFSDM_CHANNEL_RIGHT_BIT_SHIFT(hdfsdm_channel->Init.RightBitShift));

  /* Check that channel has not been already initialized */
  if (a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] != NULL)
 80029fe:	687b      	ldr	r3, [r7, #4]
 8002a00:	681b      	ldr	r3, [r3, #0]
 8002a02:	4618      	mov	r0, r3
 8002a04:	f000 f8b2 	bl	8002b6c <DFSDM_GetChannelFromInstance>
 8002a08:	4602      	mov	r2, r0
 8002a0a:	4b55      	ldr	r3, [pc, #340]	; (8002b60 <HAL_DFSDM_ChannelInit+0x174>)
 8002a0c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8002a10:	2b00      	cmp	r3, #0
 8002a12:	d001      	beq.n	8002a18 <HAL_DFSDM_ChannelInit+0x2c>
  {
    return HAL_ERROR;
 8002a14:	2301      	movs	r3, #1
 8002a16:	e09f      	b.n	8002b58 <HAL_DFSDM_ChannelInit+0x16c>
    hdfsdm_channel->MspInitCallback = HAL_DFSDM_ChannelMspInit;
  }
  hdfsdm_channel->MspInitCallback(hdfsdm_channel);
#else
  /* Call MSP init function */
  HAL_DFSDM_ChannelMspInit(hdfsdm_channel);
 8002a18:	6878      	ldr	r0, [r7, #4]
 8002a1a:	f7fe fbe3 	bl	80011e4 <HAL_DFSDM_ChannelMspInit>
#endif

  /* Update the channel counter */
  v_dfsdm1ChannelCounter++;
 8002a1e:	4b51      	ldr	r3, [pc, #324]	; (8002b64 <HAL_DFSDM_ChannelInit+0x178>)
 8002a20:	681b      	ldr	r3, [r3, #0]
 8002a22:	3301      	adds	r3, #1
 8002a24:	4a4f      	ldr	r2, [pc, #316]	; (8002b64 <HAL_DFSDM_ChannelInit+0x178>)
 8002a26:	6013      	str	r3, [r2, #0]

  /* Configure output serial clock and enable global DFSDM interface only for first channel */
  if (v_dfsdm1ChannelCounter == 1U)
 8002a28:	4b4e      	ldr	r3, [pc, #312]	; (8002b64 <HAL_DFSDM_ChannelInit+0x178>)
 8002a2a:	681b      	ldr	r3, [r3, #0]
 8002a2c:	2b01      	cmp	r3, #1
 8002a2e:	d125      	bne.n	8002a7c <HAL_DFSDM_ChannelInit+0x90>
  {
    assert_param(IS_DFSDM_CHANNEL_OUTPUT_CLOCK(hdfsdm_channel->Init.OutputClock.Selection));
    /* Set the output serial clock source */
    DFSDM1_Channel0->CHCFGR1 &= ~(DFSDM_CHCFGR1_CKOUTSRC);
 8002a30:	4b4d      	ldr	r3, [pc, #308]	; (8002b68 <HAL_DFSDM_ChannelInit+0x17c>)
 8002a32:	681b      	ldr	r3, [r3, #0]
 8002a34:	4a4c      	ldr	r2, [pc, #304]	; (8002b68 <HAL_DFSDM_ChannelInit+0x17c>)
 8002a36:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8002a3a:	6013      	str	r3, [r2, #0]
    DFSDM1_Channel0->CHCFGR1 |= hdfsdm_channel->Init.OutputClock.Selection;
 8002a3c:	4b4a      	ldr	r3, [pc, #296]	; (8002b68 <HAL_DFSDM_ChannelInit+0x17c>)
 8002a3e:	681a      	ldr	r2, [r3, #0]
 8002a40:	687b      	ldr	r3, [r7, #4]
 8002a42:	689b      	ldr	r3, [r3, #8]
 8002a44:	4948      	ldr	r1, [pc, #288]	; (8002b68 <HAL_DFSDM_ChannelInit+0x17c>)
 8002a46:	4313      	orrs	r3, r2
 8002a48:	600b      	str	r3, [r1, #0]

    /* Reset clock divider */
    DFSDM1_Channel0->CHCFGR1 &= ~(DFSDM_CHCFGR1_CKOUTDIV);
 8002a4a:	4b47      	ldr	r3, [pc, #284]	; (8002b68 <HAL_DFSDM_ChannelInit+0x17c>)
 8002a4c:	681b      	ldr	r3, [r3, #0]
 8002a4e:	4a46      	ldr	r2, [pc, #280]	; (8002b68 <HAL_DFSDM_ChannelInit+0x17c>)
 8002a50:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
 8002a54:	6013      	str	r3, [r2, #0]
    if (hdfsdm_channel->Init.OutputClock.Activation == ENABLE)
 8002a56:	687b      	ldr	r3, [r7, #4]
 8002a58:	791b      	ldrb	r3, [r3, #4]
 8002a5a:	2b01      	cmp	r3, #1
 8002a5c:	d108      	bne.n	8002a70 <HAL_DFSDM_ChannelInit+0x84>
    {
      assert_param(IS_DFSDM_CHANNEL_OUTPUT_CLOCK_DIVIDER(hdfsdm_channel->Init.OutputClock.Divider));
      /* Set the output clock divider */
      DFSDM1_Channel0->CHCFGR1 |= (uint32_t)((hdfsdm_channel->Init.OutputClock.Divider - 1U) <<
 8002a5e:	4b42      	ldr	r3, [pc, #264]	; (8002b68 <HAL_DFSDM_ChannelInit+0x17c>)
 8002a60:	681a      	ldr	r2, [r3, #0]
 8002a62:	687b      	ldr	r3, [r7, #4]
 8002a64:	68db      	ldr	r3, [r3, #12]
 8002a66:	3b01      	subs	r3, #1
 8002a68:	041b      	lsls	r3, r3, #16
 8002a6a:	493f      	ldr	r1, [pc, #252]	; (8002b68 <HAL_DFSDM_ChannelInit+0x17c>)
 8002a6c:	4313      	orrs	r3, r2
 8002a6e:	600b      	str	r3, [r1, #0]
                                             DFSDM_CHCFGR1_CKOUTDIV_Pos);
    }

    /* enable the DFSDM global interface */
    DFSDM1_Channel0->CHCFGR1 |= DFSDM_CHCFGR1_DFSDMEN;
 8002a70:	4b3d      	ldr	r3, [pc, #244]	; (8002b68 <HAL_DFSDM_ChannelInit+0x17c>)
 8002a72:	681b      	ldr	r3, [r3, #0]
 8002a74:	4a3c      	ldr	r2, [pc, #240]	; (8002b68 <HAL_DFSDM_ChannelInit+0x17c>)
 8002a76:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8002a7a:	6013      	str	r3, [r2, #0]
  }

  /* Set channel input parameters */
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_DATPACK | DFSDM_CHCFGR1_DATMPX |
 8002a7c:	687b      	ldr	r3, [r7, #4]
 8002a7e:	681b      	ldr	r3, [r3, #0]
 8002a80:	681a      	ldr	r2, [r3, #0]
 8002a82:	687b      	ldr	r3, [r7, #4]
 8002a84:	681b      	ldr	r3, [r3, #0]
 8002a86:	f422 4271 	bic.w	r2, r2, #61696	; 0xf100
 8002a8a:	601a      	str	r2, [r3, #0]
                                         DFSDM_CHCFGR1_CHINSEL);
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer |
 8002a8c:	687b      	ldr	r3, [r7, #4]
 8002a8e:	681b      	ldr	r3, [r3, #0]
 8002a90:	6819      	ldr	r1, [r3, #0]
 8002a92:	687b      	ldr	r3, [r7, #4]
 8002a94:	691a      	ldr	r2, [r3, #16]
                                        hdfsdm_channel->Init.Input.DataPacking |
 8002a96:	687b      	ldr	r3, [r7, #4]
 8002a98:	695b      	ldr	r3, [r3, #20]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer |
 8002a9a:	431a      	orrs	r2, r3
                                        hdfsdm_channel->Init.Input.Pins);
 8002a9c:	687b      	ldr	r3, [r7, #4]
 8002a9e:	699b      	ldr	r3, [r3, #24]
                                        hdfsdm_channel->Init.Input.DataPacking |
 8002aa0:	431a      	orrs	r2, r3
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer |
 8002aa2:	687b      	ldr	r3, [r7, #4]
 8002aa4:	681b      	ldr	r3, [r3, #0]
 8002aa6:	430a      	orrs	r2, r1
 8002aa8:	601a      	str	r2, [r3, #0]

  /* Set serial interface parameters */
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_SITP | DFSDM_CHCFGR1_SPICKSEL);
 8002aaa:	687b      	ldr	r3, [r7, #4]
 8002aac:	681b      	ldr	r3, [r3, #0]
 8002aae:	681a      	ldr	r2, [r3, #0]
 8002ab0:	687b      	ldr	r3, [r7, #4]
 8002ab2:	681b      	ldr	r3, [r3, #0]
 8002ab4:	f022 020f 	bic.w	r2, r2, #15
 8002ab8:	601a      	str	r2, [r3, #0]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.SerialInterface.Type |
 8002aba:	687b      	ldr	r3, [r7, #4]
 8002abc:	681b      	ldr	r3, [r3, #0]
 8002abe:	6819      	ldr	r1, [r3, #0]
 8002ac0:	687b      	ldr	r3, [r7, #4]
 8002ac2:	69da      	ldr	r2, [r3, #28]
                                        hdfsdm_channel->Init.SerialInterface.SpiClock);
 8002ac4:	687b      	ldr	r3, [r7, #4]
 8002ac6:	6a1b      	ldr	r3, [r3, #32]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.SerialInterface.Type |
 8002ac8:	431a      	orrs	r2, r3
 8002aca:	687b      	ldr	r3, [r7, #4]
 8002acc:	681b      	ldr	r3, [r3, #0]
 8002ace:	430a      	orrs	r2, r1
 8002ad0:	601a      	str	r2, [r3, #0]

  /* Set analog watchdog parameters */
  hdfsdm_channel->Instance->CHAWSCDR &= ~(DFSDM_CHAWSCDR_AWFORD | DFSDM_CHAWSCDR_AWFOSR);
 8002ad2:	687b      	ldr	r3, [r7, #4]
 8002ad4:	681b      	ldr	r3, [r3, #0]
 8002ad6:	689a      	ldr	r2, [r3, #8]
 8002ad8:	687b      	ldr	r3, [r7, #4]
 8002ada:	681b      	ldr	r3, [r3, #0]
 8002adc:	f422 025f 	bic.w	r2, r2, #14614528	; 0xdf0000
 8002ae0:	609a      	str	r2, [r3, #8]
  hdfsdm_channel->Instance->CHAWSCDR |= (hdfsdm_channel->Init.Awd.FilterOrder |
 8002ae2:	687b      	ldr	r3, [r7, #4]
 8002ae4:	681b      	ldr	r3, [r3, #0]
 8002ae6:	6899      	ldr	r1, [r3, #8]
 8002ae8:	687b      	ldr	r3, [r7, #4]
 8002aea:	6a5a      	ldr	r2, [r3, #36]	; 0x24
                                         ((hdfsdm_channel->Init.Awd.Oversampling - 1U) << DFSDM_CHAWSCDR_AWFOSR_Pos));
 8002aec:	687b      	ldr	r3, [r7, #4]
 8002aee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002af0:	3b01      	subs	r3, #1
 8002af2:	041b      	lsls	r3, r3, #16
  hdfsdm_channel->Instance->CHAWSCDR |= (hdfsdm_channel->Init.Awd.FilterOrder |
 8002af4:	431a      	orrs	r2, r3
 8002af6:	687b      	ldr	r3, [r7, #4]
 8002af8:	681b      	ldr	r3, [r3, #0]
 8002afa:	430a      	orrs	r2, r1
 8002afc:	609a      	str	r2, [r3, #8]

  /* Set channel offset and right bit shift */
  hdfsdm_channel->Instance->CHCFGR2 &= ~(DFSDM_CHCFGR2_OFFSET | DFSDM_CHCFGR2_DTRBS);
 8002afe:	687b      	ldr	r3, [r7, #4]
 8002b00:	681b      	ldr	r3, [r3, #0]
 8002b02:	685a      	ldr	r2, [r3, #4]
 8002b04:	687b      	ldr	r3, [r7, #4]
 8002b06:	681b      	ldr	r3, [r3, #0]
 8002b08:	f002 0207 	and.w	r2, r2, #7
 8002b0c:	605a      	str	r2, [r3, #4]
  hdfsdm_channel->Instance->CHCFGR2 |= (((uint32_t) hdfsdm_channel->Init.Offset << DFSDM_CHCFGR2_OFFSET_Pos) |
 8002b0e:	687b      	ldr	r3, [r7, #4]
 8002b10:	681b      	ldr	r3, [r3, #0]
 8002b12:	6859      	ldr	r1, [r3, #4]
 8002b14:	687b      	ldr	r3, [r7, #4]
 8002b16:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002b18:	021a      	lsls	r2, r3, #8
                                        (hdfsdm_channel->Init.RightBitShift << DFSDM_CHCFGR2_DTRBS_Pos));
 8002b1a:	687b      	ldr	r3, [r7, #4]
 8002b1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002b1e:	00db      	lsls	r3, r3, #3
  hdfsdm_channel->Instance->CHCFGR2 |= (((uint32_t) hdfsdm_channel->Init.Offset << DFSDM_CHCFGR2_OFFSET_Pos) |
 8002b20:	431a      	orrs	r2, r3
 8002b22:	687b      	ldr	r3, [r7, #4]
 8002b24:	681b      	ldr	r3, [r3, #0]
 8002b26:	430a      	orrs	r2, r1
 8002b28:	605a      	str	r2, [r3, #4]

  /* Enable DFSDM channel */
  hdfsdm_channel->Instance->CHCFGR1 |= DFSDM_CHCFGR1_CHEN;
 8002b2a:	687b      	ldr	r3, [r7, #4]
 8002b2c:	681b      	ldr	r3, [r3, #0]
 8002b2e:	681a      	ldr	r2, [r3, #0]
 8002b30:	687b      	ldr	r3, [r7, #4]
 8002b32:	681b      	ldr	r3, [r3, #0]
 8002b34:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8002b38:	601a      	str	r2, [r3, #0]

  /* Set DFSDM Channel to ready state */
  hdfsdm_channel->State = HAL_DFSDM_CHANNEL_STATE_READY;
 8002b3a:	687b      	ldr	r3, [r7, #4]
 8002b3c:	2201      	movs	r2, #1
 8002b3e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Store channel handle in DFSDM channel handle table */
  a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] = hdfsdm_channel;
 8002b42:	687b      	ldr	r3, [r7, #4]
 8002b44:	681b      	ldr	r3, [r3, #0]
 8002b46:	4618      	mov	r0, r3
 8002b48:	f000 f810 	bl	8002b6c <DFSDM_GetChannelFromInstance>
 8002b4c:	4601      	mov	r1, r0
 8002b4e:	4a04      	ldr	r2, [pc, #16]	; (8002b60 <HAL_DFSDM_ChannelInit+0x174>)
 8002b50:	687b      	ldr	r3, [r7, #4]
 8002b52:	f842 3021 	str.w	r3, [r2, r1, lsl #2]

  return HAL_OK;
 8002b56:	2300      	movs	r3, #0
}
 8002b58:	4618      	mov	r0, r3
 8002b5a:	3708      	adds	r7, #8
 8002b5c:	46bd      	mov	sp, r7
 8002b5e:	bd80      	pop	{r7, pc}
 8002b60:	20000204 	.word	0x20000204
 8002b64:	20000200 	.word	0x20000200
 8002b68:	40016000 	.word	0x40016000

08002b6c <DFSDM_GetChannelFromInstance>:
  * @brief  This function allows to get the channel number from channel instance.
  * @param  Instance DFSDM channel instance.
  * @retval Channel number.
  */
static uint32_t DFSDM_GetChannelFromInstance(const DFSDM_Channel_TypeDef *Instance)
{
 8002b6c:	b480      	push	{r7}
 8002b6e:	b085      	sub	sp, #20
 8002b70:	af00      	add	r7, sp, #0
 8002b72:	6078      	str	r0, [r7, #4]
  uint32_t channel;

  /* Get channel from instance */
  if (Instance == DFSDM1_Channel0)
 8002b74:	687b      	ldr	r3, [r7, #4]
 8002b76:	4a1c      	ldr	r2, [pc, #112]	; (8002be8 <DFSDM_GetChannelFromInstance+0x7c>)
 8002b78:	4293      	cmp	r3, r2
 8002b7a:	d102      	bne.n	8002b82 <DFSDM_GetChannelFromInstance+0x16>
  {
    channel = 0;
 8002b7c:	2300      	movs	r3, #0
 8002b7e:	60fb      	str	r3, [r7, #12]
 8002b80:	e02b      	b.n	8002bda <DFSDM_GetChannelFromInstance+0x6e>
  }
  else if (Instance == DFSDM1_Channel1)
 8002b82:	687b      	ldr	r3, [r7, #4]
 8002b84:	4a19      	ldr	r2, [pc, #100]	; (8002bec <DFSDM_GetChannelFromInstance+0x80>)
 8002b86:	4293      	cmp	r3, r2
 8002b88:	d102      	bne.n	8002b90 <DFSDM_GetChannelFromInstance+0x24>
  {
    channel = 1;
 8002b8a:	2301      	movs	r3, #1
 8002b8c:	60fb      	str	r3, [r7, #12]
 8002b8e:	e024      	b.n	8002bda <DFSDM_GetChannelFromInstance+0x6e>
  }
  else if (Instance == DFSDM1_Channel2)
 8002b90:	687b      	ldr	r3, [r7, #4]
 8002b92:	4a17      	ldr	r2, [pc, #92]	; (8002bf0 <DFSDM_GetChannelFromInstance+0x84>)
 8002b94:	4293      	cmp	r3, r2
 8002b96:	d102      	bne.n	8002b9e <DFSDM_GetChannelFromInstance+0x32>
  {
    channel = 2;
 8002b98:	2302      	movs	r3, #2
 8002b9a:	60fb      	str	r3, [r7, #12]
 8002b9c:	e01d      	b.n	8002bda <DFSDM_GetChannelFromInstance+0x6e>
  }
#if defined(STM32L471xx) || defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx) || \
    defined(STM32L496xx) || defined(STM32L4A6xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  else if (Instance == DFSDM1_Channel4)
 8002b9e:	687b      	ldr	r3, [r7, #4]
 8002ba0:	4a14      	ldr	r2, [pc, #80]	; (8002bf4 <DFSDM_GetChannelFromInstance+0x88>)
 8002ba2:	4293      	cmp	r3, r2
 8002ba4:	d102      	bne.n	8002bac <DFSDM_GetChannelFromInstance+0x40>
  {
    channel = 4;
 8002ba6:	2304      	movs	r3, #4
 8002ba8:	60fb      	str	r3, [r7, #12]
 8002baa:	e016      	b.n	8002bda <DFSDM_GetChannelFromInstance+0x6e>
  }
  else if (Instance == DFSDM1_Channel5)
 8002bac:	687b      	ldr	r3, [r7, #4]
 8002bae:	4a12      	ldr	r2, [pc, #72]	; (8002bf8 <DFSDM_GetChannelFromInstance+0x8c>)
 8002bb0:	4293      	cmp	r3, r2
 8002bb2:	d102      	bne.n	8002bba <DFSDM_GetChannelFromInstance+0x4e>
  {
    channel = 5;
 8002bb4:	2305      	movs	r3, #5
 8002bb6:	60fb      	str	r3, [r7, #12]
 8002bb8:	e00f      	b.n	8002bda <DFSDM_GetChannelFromInstance+0x6e>
  }
  else if (Instance == DFSDM1_Channel6)
 8002bba:	687b      	ldr	r3, [r7, #4]
 8002bbc:	4a0f      	ldr	r2, [pc, #60]	; (8002bfc <DFSDM_GetChannelFromInstance+0x90>)
 8002bbe:	4293      	cmp	r3, r2
 8002bc0:	d102      	bne.n	8002bc8 <DFSDM_GetChannelFromInstance+0x5c>
  {
    channel = 6;
 8002bc2:	2306      	movs	r3, #6
 8002bc4:	60fb      	str	r3, [r7, #12]
 8002bc6:	e008      	b.n	8002bda <DFSDM_GetChannelFromInstance+0x6e>
  }
  else if (Instance == DFSDM1_Channel7)
 8002bc8:	687b      	ldr	r3, [r7, #4]
 8002bca:	4a0d      	ldr	r2, [pc, #52]	; (8002c00 <DFSDM_GetChannelFromInstance+0x94>)
 8002bcc:	4293      	cmp	r3, r2
 8002bce:	d102      	bne.n	8002bd6 <DFSDM_GetChannelFromInstance+0x6a>
  {
    channel = 7;
 8002bd0:	2307      	movs	r3, #7
 8002bd2:	60fb      	str	r3, [r7, #12]
 8002bd4:	e001      	b.n	8002bda <DFSDM_GetChannelFromInstance+0x6e>
  }
#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx || STM32L496xx || STM32L4A6xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
  else /* DFSDM1_Channel3 */
  {
    channel = 3;
 8002bd6:	2303      	movs	r3, #3
 8002bd8:	60fb      	str	r3, [r7, #12]
  }

  return channel;
 8002bda:	68fb      	ldr	r3, [r7, #12]
}
 8002bdc:	4618      	mov	r0, r3
 8002bde:	3714      	adds	r7, #20
 8002be0:	46bd      	mov	sp, r7
 8002be2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002be6:	4770      	bx	lr
 8002be8:	40016000 	.word	0x40016000
 8002bec:	40016020 	.word	0x40016020
 8002bf0:	40016040 	.word	0x40016040
 8002bf4:	40016080 	.word	0x40016080
 8002bf8:	400160a0 	.word	0x400160a0
 8002bfc:	400160c0 	.word	0x400160c0
 8002c00:	400160e0 	.word	0x400160e0

08002c04 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8002c04:	b480      	push	{r7}
 8002c06:	b087      	sub	sp, #28
 8002c08:	af00      	add	r7, sp, #0
 8002c0a:	6078      	str	r0, [r7, #4]
 8002c0c:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
 8002c0e:	2300      	movs	r3, #0
 8002c10:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8002c12:	e166      	b.n	8002ee2 <HAL_GPIO_Init+0x2de>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8002c14:	683b      	ldr	r3, [r7, #0]
 8002c16:	681a      	ldr	r2, [r3, #0]
 8002c18:	2101      	movs	r1, #1
 8002c1a:	697b      	ldr	r3, [r7, #20]
 8002c1c:	fa01 f303 	lsl.w	r3, r1, r3
 8002c20:	4013      	ands	r3, r2
 8002c22:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
 8002c24:	68fb      	ldr	r3, [r7, #12]
 8002c26:	2b00      	cmp	r3, #0
 8002c28:	f000 8158 	beq.w	8002edc <HAL_GPIO_Init+0x2d8>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8002c2c:	683b      	ldr	r3, [r7, #0]
 8002c2e:	685b      	ldr	r3, [r3, #4]
 8002c30:	2b01      	cmp	r3, #1
 8002c32:	d00b      	beq.n	8002c4c <HAL_GPIO_Init+0x48>
 8002c34:	683b      	ldr	r3, [r7, #0]
 8002c36:	685b      	ldr	r3, [r3, #4]
 8002c38:	2b02      	cmp	r3, #2
 8002c3a:	d007      	beq.n	8002c4c <HAL_GPIO_Init+0x48>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8002c3c:	683b      	ldr	r3, [r7, #0]
 8002c3e:	685b      	ldr	r3, [r3, #4]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8002c40:	2b11      	cmp	r3, #17
 8002c42:	d003      	beq.n	8002c4c <HAL_GPIO_Init+0x48>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8002c44:	683b      	ldr	r3, [r7, #0]
 8002c46:	685b      	ldr	r3, [r3, #4]
 8002c48:	2b12      	cmp	r3, #18
 8002c4a:	d130      	bne.n	8002cae <HAL_GPIO_Init+0xaa>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8002c4c:	687b      	ldr	r3, [r7, #4]
 8002c4e:	689b      	ldr	r3, [r3, #8]
 8002c50:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 8002c52:	697b      	ldr	r3, [r7, #20]
 8002c54:	005b      	lsls	r3, r3, #1
 8002c56:	2203      	movs	r2, #3
 8002c58:	fa02 f303 	lsl.w	r3, r2, r3
 8002c5c:	43db      	mvns	r3, r3
 8002c5e:	693a      	ldr	r2, [r7, #16]
 8002c60:	4013      	ands	r3, r2
 8002c62:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2u));
 8002c64:	683b      	ldr	r3, [r7, #0]
 8002c66:	68da      	ldr	r2, [r3, #12]
 8002c68:	697b      	ldr	r3, [r7, #20]
 8002c6a:	005b      	lsls	r3, r3, #1
 8002c6c:	fa02 f303 	lsl.w	r3, r2, r3
 8002c70:	693a      	ldr	r2, [r7, #16]
 8002c72:	4313      	orrs	r3, r2
 8002c74:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 8002c76:	687b      	ldr	r3, [r7, #4]
 8002c78:	693a      	ldr	r2, [r7, #16]
 8002c7a:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8002c7c:	687b      	ldr	r3, [r7, #4]
 8002c7e:	685b      	ldr	r3, [r3, #4]
 8002c80:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8002c82:	2201      	movs	r2, #1
 8002c84:	697b      	ldr	r3, [r7, #20]
 8002c86:	fa02 f303 	lsl.w	r3, r2, r3
 8002c8a:	43db      	mvns	r3, r3
 8002c8c:	693a      	ldr	r2, [r7, #16]
 8002c8e:	4013      	ands	r3, r2
 8002c90:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 8002c92:	683b      	ldr	r3, [r7, #0]
 8002c94:	685b      	ldr	r3, [r3, #4]
 8002c96:	091b      	lsrs	r3, r3, #4
 8002c98:	f003 0201 	and.w	r2, r3, #1
 8002c9c:	697b      	ldr	r3, [r7, #20]
 8002c9e:	fa02 f303 	lsl.w	r3, r2, r3
 8002ca2:	693a      	ldr	r2, [r7, #16]
 8002ca4:	4313      	orrs	r3, r2
 8002ca6:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 8002ca8:	687b      	ldr	r3, [r7, #4]
 8002caa:	693a      	ldr	r2, [r7, #16]
 8002cac:	605a      	str	r2, [r3, #4]
      }

#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8002cae:	687b      	ldr	r3, [r7, #4]
 8002cb0:	68db      	ldr	r3, [r3, #12]
 8002cb2:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 8002cb4:	697b      	ldr	r3, [r7, #20]
 8002cb6:	005b      	lsls	r3, r3, #1
 8002cb8:	2203      	movs	r2, #3
 8002cba:	fa02 f303 	lsl.w	r3, r2, r3
 8002cbe:	43db      	mvns	r3, r3
 8002cc0:	693a      	ldr	r2, [r7, #16]
 8002cc2:	4013      	ands	r3, r2
 8002cc4:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 8002cc6:	683b      	ldr	r3, [r7, #0]
 8002cc8:	689a      	ldr	r2, [r3, #8]
 8002cca:	697b      	ldr	r3, [r7, #20]
 8002ccc:	005b      	lsls	r3, r3, #1
 8002cce:	fa02 f303 	lsl.w	r3, r2, r3
 8002cd2:	693a      	ldr	r2, [r7, #16]
 8002cd4:	4313      	orrs	r3, r2
 8002cd6:	613b      	str	r3, [r7, #16]
      GPIOx->PUPDR = temp;
 8002cd8:	687b      	ldr	r3, [r7, #4]
 8002cda:	693a      	ldr	r2, [r7, #16]
 8002cdc:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8002cde:	683b      	ldr	r3, [r7, #0]
 8002ce0:	685b      	ldr	r3, [r3, #4]
 8002ce2:	2b02      	cmp	r3, #2
 8002ce4:	d003      	beq.n	8002cee <HAL_GPIO_Init+0xea>
 8002ce6:	683b      	ldr	r3, [r7, #0]
 8002ce8:	685b      	ldr	r3, [r3, #4]
 8002cea:	2b12      	cmp	r3, #18
 8002cec:	d123      	bne.n	8002d36 <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
 8002cee:	697b      	ldr	r3, [r7, #20]
 8002cf0:	08da      	lsrs	r2, r3, #3
 8002cf2:	687b      	ldr	r3, [r7, #4]
 8002cf4:	3208      	adds	r2, #8
 8002cf6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8002cfa:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 8002cfc:	697b      	ldr	r3, [r7, #20]
 8002cfe:	f003 0307 	and.w	r3, r3, #7
 8002d02:	009b      	lsls	r3, r3, #2
 8002d04:	220f      	movs	r2, #15
 8002d06:	fa02 f303 	lsl.w	r3, r2, r3
 8002d0a:	43db      	mvns	r3, r3
 8002d0c:	693a      	ldr	r2, [r7, #16]
 8002d0e:	4013      	ands	r3, r2
 8002d10:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 8002d12:	683b      	ldr	r3, [r7, #0]
 8002d14:	691a      	ldr	r2, [r3, #16]
 8002d16:	697b      	ldr	r3, [r7, #20]
 8002d18:	f003 0307 	and.w	r3, r3, #7
 8002d1c:	009b      	lsls	r3, r3, #2
 8002d1e:	fa02 f303 	lsl.w	r3, r2, r3
 8002d22:	693a      	ldr	r2, [r7, #16]
 8002d24:	4313      	orrs	r3, r2
 8002d26:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
 8002d28:	697b      	ldr	r3, [r7, #20]
 8002d2a:	08da      	lsrs	r2, r3, #3
 8002d2c:	687b      	ldr	r3, [r7, #4]
 8002d2e:	3208      	adds	r2, #8
 8002d30:	6939      	ldr	r1, [r7, #16]
 8002d32:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8002d36:	687b      	ldr	r3, [r7, #4]
 8002d38:	681b      	ldr	r3, [r3, #0]
 8002d3a:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 8002d3c:	697b      	ldr	r3, [r7, #20]
 8002d3e:	005b      	lsls	r3, r3, #1
 8002d40:	2203      	movs	r2, #3
 8002d42:	fa02 f303 	lsl.w	r3, r2, r3
 8002d46:	43db      	mvns	r3, r3
 8002d48:	693a      	ldr	r2, [r7, #16]
 8002d4a:	4013      	ands	r3, r2
 8002d4c:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 8002d4e:	683b      	ldr	r3, [r7, #0]
 8002d50:	685b      	ldr	r3, [r3, #4]
 8002d52:	f003 0203 	and.w	r2, r3, #3
 8002d56:	697b      	ldr	r3, [r7, #20]
 8002d58:	005b      	lsls	r3, r3, #1
 8002d5a:	fa02 f303 	lsl.w	r3, r2, r3
 8002d5e:	693a      	ldr	r2, [r7, #16]
 8002d60:	4313      	orrs	r3, r2
 8002d62:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 8002d64:	687b      	ldr	r3, [r7, #4]
 8002d66:	693a      	ldr	r2, [r7, #16]
 8002d68:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8002d6a:	683b      	ldr	r3, [r7, #0]
 8002d6c:	685b      	ldr	r3, [r3, #4]
 8002d6e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002d72:	2b00      	cmp	r3, #0
 8002d74:	f000 80b2 	beq.w	8002edc <HAL_GPIO_Init+0x2d8>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002d78:	4b61      	ldr	r3, [pc, #388]	; (8002f00 <HAL_GPIO_Init+0x2fc>)
 8002d7a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8002d7c:	4a60      	ldr	r2, [pc, #384]	; (8002f00 <HAL_GPIO_Init+0x2fc>)
 8002d7e:	f043 0301 	orr.w	r3, r3, #1
 8002d82:	6613      	str	r3, [r2, #96]	; 0x60
 8002d84:	4b5e      	ldr	r3, [pc, #376]	; (8002f00 <HAL_GPIO_Init+0x2fc>)
 8002d86:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8002d88:	f003 0301 	and.w	r3, r3, #1
 8002d8c:	60bb      	str	r3, [r7, #8]
 8002d8e:	68bb      	ldr	r3, [r7, #8]

        temp = SYSCFG->EXTICR[position >> 2u];
 8002d90:	4a5c      	ldr	r2, [pc, #368]	; (8002f04 <HAL_GPIO_Init+0x300>)
 8002d92:	697b      	ldr	r3, [r7, #20]
 8002d94:	089b      	lsrs	r3, r3, #2
 8002d96:	3302      	adds	r3, #2
 8002d98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8002d9c:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8002d9e:	697b      	ldr	r3, [r7, #20]
 8002da0:	f003 0303 	and.w	r3, r3, #3
 8002da4:	009b      	lsls	r3, r3, #2
 8002da6:	220f      	movs	r2, #15
 8002da8:	fa02 f303 	lsl.w	r3, r2, r3
 8002dac:	43db      	mvns	r3, r3
 8002dae:	693a      	ldr	r2, [r7, #16]
 8002db0:	4013      	ands	r3, r2
 8002db2:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8002db4:	687b      	ldr	r3, [r7, #4]
 8002db6:	f1b3 4f90 	cmp.w	r3, #1207959552	; 0x48000000
 8002dba:	d02b      	beq.n	8002e14 <HAL_GPIO_Init+0x210>
 8002dbc:	687b      	ldr	r3, [r7, #4]
 8002dbe:	4a52      	ldr	r2, [pc, #328]	; (8002f08 <HAL_GPIO_Init+0x304>)
 8002dc0:	4293      	cmp	r3, r2
 8002dc2:	d025      	beq.n	8002e10 <HAL_GPIO_Init+0x20c>
 8002dc4:	687b      	ldr	r3, [r7, #4]
 8002dc6:	4a51      	ldr	r2, [pc, #324]	; (8002f0c <HAL_GPIO_Init+0x308>)
 8002dc8:	4293      	cmp	r3, r2
 8002dca:	d01f      	beq.n	8002e0c <HAL_GPIO_Init+0x208>
 8002dcc:	687b      	ldr	r3, [r7, #4]
 8002dce:	4a50      	ldr	r2, [pc, #320]	; (8002f10 <HAL_GPIO_Init+0x30c>)
 8002dd0:	4293      	cmp	r3, r2
 8002dd2:	d019      	beq.n	8002e08 <HAL_GPIO_Init+0x204>
 8002dd4:	687b      	ldr	r3, [r7, #4]
 8002dd6:	4a4f      	ldr	r2, [pc, #316]	; (8002f14 <HAL_GPIO_Init+0x310>)
 8002dd8:	4293      	cmp	r3, r2
 8002dda:	d013      	beq.n	8002e04 <HAL_GPIO_Init+0x200>
 8002ddc:	687b      	ldr	r3, [r7, #4]
 8002dde:	4a4e      	ldr	r2, [pc, #312]	; (8002f18 <HAL_GPIO_Init+0x314>)
 8002de0:	4293      	cmp	r3, r2
 8002de2:	d00d      	beq.n	8002e00 <HAL_GPIO_Init+0x1fc>
 8002de4:	687b      	ldr	r3, [r7, #4]
 8002de6:	4a4d      	ldr	r2, [pc, #308]	; (8002f1c <HAL_GPIO_Init+0x318>)
 8002de8:	4293      	cmp	r3, r2
 8002dea:	d007      	beq.n	8002dfc <HAL_GPIO_Init+0x1f8>
 8002dec:	687b      	ldr	r3, [r7, #4]
 8002dee:	4a4c      	ldr	r2, [pc, #304]	; (8002f20 <HAL_GPIO_Init+0x31c>)
 8002df0:	4293      	cmp	r3, r2
 8002df2:	d101      	bne.n	8002df8 <HAL_GPIO_Init+0x1f4>
 8002df4:	2307      	movs	r3, #7
 8002df6:	e00e      	b.n	8002e16 <HAL_GPIO_Init+0x212>
 8002df8:	2308      	movs	r3, #8
 8002dfa:	e00c      	b.n	8002e16 <HAL_GPIO_Init+0x212>
 8002dfc:	2306      	movs	r3, #6
 8002dfe:	e00a      	b.n	8002e16 <HAL_GPIO_Init+0x212>
 8002e00:	2305      	movs	r3, #5
 8002e02:	e008      	b.n	8002e16 <HAL_GPIO_Init+0x212>
 8002e04:	2304      	movs	r3, #4
 8002e06:	e006      	b.n	8002e16 <HAL_GPIO_Init+0x212>
 8002e08:	2303      	movs	r3, #3
 8002e0a:	e004      	b.n	8002e16 <HAL_GPIO_Init+0x212>
 8002e0c:	2302      	movs	r3, #2
 8002e0e:	e002      	b.n	8002e16 <HAL_GPIO_Init+0x212>
 8002e10:	2301      	movs	r3, #1
 8002e12:	e000      	b.n	8002e16 <HAL_GPIO_Init+0x212>
 8002e14:	2300      	movs	r3, #0
 8002e16:	697a      	ldr	r2, [r7, #20]
 8002e18:	f002 0203 	and.w	r2, r2, #3
 8002e1c:	0092      	lsls	r2, r2, #2
 8002e1e:	4093      	lsls	r3, r2
 8002e20:	693a      	ldr	r2, [r7, #16]
 8002e22:	4313      	orrs	r3, r2
 8002e24:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2u] = temp;
 8002e26:	4937      	ldr	r1, [pc, #220]	; (8002f04 <HAL_GPIO_Init+0x300>)
 8002e28:	697b      	ldr	r3, [r7, #20]
 8002e2a:	089b      	lsrs	r3, r3, #2
 8002e2c:	3302      	adds	r3, #2
 8002e2e:	693a      	ldr	r2, [r7, #16]
 8002e30:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8002e34:	4b3b      	ldr	r3, [pc, #236]	; (8002f24 <HAL_GPIO_Init+0x320>)
 8002e36:	681b      	ldr	r3, [r3, #0]
 8002e38:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8002e3a:	68fb      	ldr	r3, [r7, #12]
 8002e3c:	43db      	mvns	r3, r3
 8002e3e:	693a      	ldr	r2, [r7, #16]
 8002e40:	4013      	ands	r3, r2
 8002e42:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8002e44:	683b      	ldr	r3, [r7, #0]
 8002e46:	685b      	ldr	r3, [r3, #4]
 8002e48:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8002e4c:	2b00      	cmp	r3, #0
 8002e4e:	d003      	beq.n	8002e58 <HAL_GPIO_Init+0x254>
        {
          temp |= iocurrent;
 8002e50:	693a      	ldr	r2, [r7, #16]
 8002e52:	68fb      	ldr	r3, [r7, #12]
 8002e54:	4313      	orrs	r3, r2
 8002e56:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
 8002e58:	4a32      	ldr	r2, [pc, #200]	; (8002f24 <HAL_GPIO_Init+0x320>)
 8002e5a:	693b      	ldr	r3, [r7, #16]
 8002e5c:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR1;
 8002e5e:	4b31      	ldr	r3, [pc, #196]	; (8002f24 <HAL_GPIO_Init+0x320>)
 8002e60:	685b      	ldr	r3, [r3, #4]
 8002e62:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8002e64:	68fb      	ldr	r3, [r7, #12]
 8002e66:	43db      	mvns	r3, r3
 8002e68:	693a      	ldr	r2, [r7, #16]
 8002e6a:	4013      	ands	r3, r2
 8002e6c:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8002e6e:	683b      	ldr	r3, [r7, #0]
 8002e70:	685b      	ldr	r3, [r3, #4]
 8002e72:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8002e76:	2b00      	cmp	r3, #0
 8002e78:	d003      	beq.n	8002e82 <HAL_GPIO_Init+0x27e>
        {
          temp |= iocurrent;
 8002e7a:	693a      	ldr	r2, [r7, #16]
 8002e7c:	68fb      	ldr	r3, [r7, #12]
 8002e7e:	4313      	orrs	r3, r2
 8002e80:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
 8002e82:	4a28      	ldr	r2, [pc, #160]	; (8002f24 <HAL_GPIO_Init+0x320>)
 8002e84:	693b      	ldr	r3, [r7, #16]
 8002e86:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8002e88:	4b26      	ldr	r3, [pc, #152]	; (8002f24 <HAL_GPIO_Init+0x320>)
 8002e8a:	689b      	ldr	r3, [r3, #8]
 8002e8c:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8002e8e:	68fb      	ldr	r3, [r7, #12]
 8002e90:	43db      	mvns	r3, r3
 8002e92:	693a      	ldr	r2, [r7, #16]
 8002e94:	4013      	ands	r3, r2
 8002e96:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8002e98:	683b      	ldr	r3, [r7, #0]
 8002e9a:	685b      	ldr	r3, [r3, #4]
 8002e9c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8002ea0:	2b00      	cmp	r3, #0
 8002ea2:	d003      	beq.n	8002eac <HAL_GPIO_Init+0x2a8>
        {
          temp |= iocurrent;
 8002ea4:	693a      	ldr	r2, [r7, #16]
 8002ea6:	68fb      	ldr	r3, [r7, #12]
 8002ea8:	4313      	orrs	r3, r2
 8002eaa:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
 8002eac:	4a1d      	ldr	r2, [pc, #116]	; (8002f24 <HAL_GPIO_Init+0x320>)
 8002eae:	693b      	ldr	r3, [r7, #16]
 8002eb0:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR1;
 8002eb2:	4b1c      	ldr	r3, [pc, #112]	; (8002f24 <HAL_GPIO_Init+0x320>)
 8002eb4:	68db      	ldr	r3, [r3, #12]
 8002eb6:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8002eb8:	68fb      	ldr	r3, [r7, #12]
 8002eba:	43db      	mvns	r3, r3
 8002ebc:	693a      	ldr	r2, [r7, #16]
 8002ebe:	4013      	ands	r3, r2
 8002ec0:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8002ec2:	683b      	ldr	r3, [r7, #0]
 8002ec4:	685b      	ldr	r3, [r3, #4]
 8002ec6:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8002eca:	2b00      	cmp	r3, #0
 8002ecc:	d003      	beq.n	8002ed6 <HAL_GPIO_Init+0x2d2>
        {
          temp |= iocurrent;
 8002ece:	693a      	ldr	r2, [r7, #16]
 8002ed0:	68fb      	ldr	r3, [r7, #12]
 8002ed2:	4313      	orrs	r3, r2
 8002ed4:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
 8002ed6:	4a13      	ldr	r2, [pc, #76]	; (8002f24 <HAL_GPIO_Init+0x320>)
 8002ed8:	693b      	ldr	r3, [r7, #16]
 8002eda:	60d3      	str	r3, [r2, #12]
      }
    }

    position++;
 8002edc:	697b      	ldr	r3, [r7, #20]
 8002ede:	3301      	adds	r3, #1
 8002ee0:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8002ee2:	683b      	ldr	r3, [r7, #0]
 8002ee4:	681a      	ldr	r2, [r3, #0]
 8002ee6:	697b      	ldr	r3, [r7, #20]
 8002ee8:	fa22 f303 	lsr.w	r3, r2, r3
 8002eec:	2b00      	cmp	r3, #0
 8002eee:	f47f ae91 	bne.w	8002c14 <HAL_GPIO_Init+0x10>
  }
}
 8002ef2:	bf00      	nop
 8002ef4:	371c      	adds	r7, #28
 8002ef6:	46bd      	mov	sp, r7
 8002ef8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002efc:	4770      	bx	lr
 8002efe:	bf00      	nop
 8002f00:	40021000 	.word	0x40021000
 8002f04:	40010000 	.word	0x40010000
 8002f08:	48000400 	.word	0x48000400
 8002f0c:	48000800 	.word	0x48000800
 8002f10:	48000c00 	.word	0x48000c00
 8002f14:	48001000 	.word	0x48001000
 8002f18:	48001400 	.word	0x48001400
 8002f1c:	48001800 	.word	0x48001800
 8002f20:	48001c00 	.word	0x48001c00
 8002f24:	40010400 	.word	0x40010400

08002f28 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8002f28:	b480      	push	{r7}
 8002f2a:	b083      	sub	sp, #12
 8002f2c:	af00      	add	r7, sp, #0
 8002f2e:	6078      	str	r0, [r7, #4]
 8002f30:	460b      	mov	r3, r1
 8002f32:	807b      	strh	r3, [r7, #2]
 8002f34:	4613      	mov	r3, r2
 8002f36:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8002f38:	787b      	ldrb	r3, [r7, #1]
 8002f3a:	2b00      	cmp	r3, #0
 8002f3c:	d003      	beq.n	8002f46 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8002f3e:	887a      	ldrh	r2, [r7, #2]
 8002f40:	687b      	ldr	r3, [r7, #4]
 8002f42:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 8002f44:	e002      	b.n	8002f4c <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8002f46:	887a      	ldrh	r2, [r7, #2]
 8002f48:	687b      	ldr	r3, [r7, #4]
 8002f4a:	629a      	str	r2, [r3, #40]	; 0x28
}
 8002f4c:	bf00      	nop
 8002f4e:	370c      	adds	r7, #12
 8002f50:	46bd      	mov	sp, r7
 8002f52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f56:	4770      	bx	lr

08002f58 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 8002f58:	b580      	push	{r7, lr}
 8002f5a:	b082      	sub	sp, #8
 8002f5c:	af00      	add	r7, sp, #0
 8002f5e:	4603      	mov	r3, r0
 8002f60:	80fb      	strh	r3, [r7, #6]
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 8002f62:	4b08      	ldr	r3, [pc, #32]	; (8002f84 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
 8002f64:	695a      	ldr	r2, [r3, #20]
 8002f66:	88fb      	ldrh	r3, [r7, #6]
 8002f68:	4013      	ands	r3, r2
 8002f6a:	2b00      	cmp	r3, #0
 8002f6c:	d006      	beq.n	8002f7c <HAL_GPIO_EXTI_IRQHandler+0x24>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8002f6e:	4a05      	ldr	r2, [pc, #20]	; (8002f84 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
 8002f70:	88fb      	ldrh	r3, [r7, #6]
 8002f72:	6153      	str	r3, [r2, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8002f74:	88fb      	ldrh	r3, [r7, #6]
 8002f76:	4618      	mov	r0, r3
 8002f78:	f000 f806 	bl	8002f88 <HAL_GPIO_EXTI_Callback>
  }
}
 8002f7c:	bf00      	nop
 8002f7e:	3708      	adds	r7, #8
 8002f80:	46bd      	mov	sp, r7
 8002f82:	bd80      	pop	{r7, pc}
 8002f84:	40010400 	.word	0x40010400

08002f88 <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callback.
  * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 8002f88:	b480      	push	{r7}
 8002f8a:	b083      	sub	sp, #12
 8002f8c:	af00      	add	r7, sp, #0
 8002f8e:	4603      	mov	r3, r0
 8002f90:	80fb      	strh	r3, [r7, #6]
  UNUSED(GPIO_Pin);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */
}
 8002f92:	bf00      	nop
 8002f94:	370c      	adds	r7, #12
 8002f96:	46bd      	mov	sp, r7
 8002f98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f9c:	4770      	bx	lr

08002f9e <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 8002f9e:	b580      	push	{r7, lr}
 8002fa0:	b082      	sub	sp, #8
 8002fa2:	af00      	add	r7, sp, #0
 8002fa4:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 8002fa6:	687b      	ldr	r3, [r7, #4]
 8002fa8:	2b00      	cmp	r3, #0
 8002faa:	d101      	bne.n	8002fb0 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 8002fac:	2301      	movs	r3, #1
 8002fae:	e081      	b.n	80030b4 <HAL_I2C_Init+0x116>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 8002fb0:	687b      	ldr	r3, [r7, #4]
 8002fb2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8002fb6:	b2db      	uxtb	r3, r3
 8002fb8:	2b00      	cmp	r3, #0
 8002fba:	d106      	bne.n	8002fca <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 8002fbc:	687b      	ldr	r3, [r7, #4]
 8002fbe:	2200      	movs	r2, #0
 8002fc0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
 8002fc4:	6878      	ldr	r0, [r7, #4]
 8002fc6:	f7fe f955 	bl	8001274 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 8002fca:	687b      	ldr	r3, [r7, #4]
 8002fcc:	2224      	movs	r2, #36	; 0x24
 8002fce:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 8002fd2:	687b      	ldr	r3, [r7, #4]
 8002fd4:	681b      	ldr	r3, [r3, #0]
 8002fd6:	681a      	ldr	r2, [r3, #0]
 8002fd8:	687b      	ldr	r3, [r7, #4]
 8002fda:	681b      	ldr	r3, [r3, #0]
 8002fdc:	f022 0201 	bic.w	r2, r2, #1
 8002fe0:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8002fe2:	687b      	ldr	r3, [r7, #4]
 8002fe4:	685a      	ldr	r2, [r3, #4]
 8002fe6:	687b      	ldr	r3, [r7, #4]
 8002fe8:	681b      	ldr	r3, [r3, #0]
 8002fea:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8002fee:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8002ff0:	687b      	ldr	r3, [r7, #4]
 8002ff2:	681b      	ldr	r3, [r3, #0]
 8002ff4:	689a      	ldr	r2, [r3, #8]
 8002ff6:	687b      	ldr	r3, [r7, #4]
 8002ff8:	681b      	ldr	r3, [r3, #0]
 8002ffa:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8002ffe:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8003000:	687b      	ldr	r3, [r7, #4]
 8003002:	68db      	ldr	r3, [r3, #12]
 8003004:	2b01      	cmp	r3, #1
 8003006:	d107      	bne.n	8003018 <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8003008:	687b      	ldr	r3, [r7, #4]
 800300a:	689a      	ldr	r2, [r3, #8]
 800300c:	687b      	ldr	r3, [r7, #4]
 800300e:	681b      	ldr	r3, [r3, #0]
 8003010:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003014:	609a      	str	r2, [r3, #8]
 8003016:	e006      	b.n	8003026 <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8003018:	687b      	ldr	r3, [r7, #4]
 800301a:	689a      	ldr	r2, [r3, #8]
 800301c:	687b      	ldr	r3, [r7, #4]
 800301e:	681b      	ldr	r3, [r3, #0]
 8003020:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
 8003024:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8003026:	687b      	ldr	r3, [r7, #4]
 8003028:	68db      	ldr	r3, [r3, #12]
 800302a:	2b02      	cmp	r3, #2
 800302c:	d104      	bne.n	8003038 <HAL_I2C_Init+0x9a>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 800302e:	687b      	ldr	r3, [r7, #4]
 8003030:	681b      	ldr	r3, [r3, #0]
 8003032:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8003036:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8003038:	687b      	ldr	r3, [r7, #4]
 800303a:	681b      	ldr	r3, [r3, #0]
 800303c:	685b      	ldr	r3, [r3, #4]
 800303e:	687a      	ldr	r2, [r7, #4]
 8003040:	6812      	ldr	r2, [r2, #0]
 8003042:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8003046:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800304a:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 800304c:	687b      	ldr	r3, [r7, #4]
 800304e:	681b      	ldr	r3, [r3, #0]
 8003050:	68da      	ldr	r2, [r3, #12]
 8003052:	687b      	ldr	r3, [r7, #4]
 8003054:	681b      	ldr	r3, [r3, #0]
 8003056:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800305a:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 800305c:	687b      	ldr	r3, [r7, #4]
 800305e:	691a      	ldr	r2, [r3, #16]
 8003060:	687b      	ldr	r3, [r7, #4]
 8003062:	695b      	ldr	r3, [r3, #20]
 8003064:	ea42 0103 	orr.w	r1, r2, r3
 8003068:	687b      	ldr	r3, [r7, #4]
 800306a:	699b      	ldr	r3, [r3, #24]
 800306c:	021a      	lsls	r2, r3, #8
 800306e:	687b      	ldr	r3, [r7, #4]
 8003070:	681b      	ldr	r3, [r3, #0]
 8003072:	430a      	orrs	r2, r1
 8003074:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8003076:	687b      	ldr	r3, [r7, #4]
 8003078:	69d9      	ldr	r1, [r3, #28]
 800307a:	687b      	ldr	r3, [r7, #4]
 800307c:	6a1a      	ldr	r2, [r3, #32]
 800307e:	687b      	ldr	r3, [r7, #4]
 8003080:	681b      	ldr	r3, [r3, #0]
 8003082:	430a      	orrs	r2, r1
 8003084:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 8003086:	687b      	ldr	r3, [r7, #4]
 8003088:	681b      	ldr	r3, [r3, #0]
 800308a:	681a      	ldr	r2, [r3, #0]
 800308c:	687b      	ldr	r3, [r7, #4]
 800308e:	681b      	ldr	r3, [r3, #0]
 8003090:	f042 0201 	orr.w	r2, r2, #1
 8003094:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8003096:	687b      	ldr	r3, [r7, #4]
 8003098:	2200      	movs	r2, #0
 800309a:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 800309c:	687b      	ldr	r3, [r7, #4]
 800309e:	2220      	movs	r2, #32
 80030a0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 80030a4:	687b      	ldr	r3, [r7, #4]
 80030a6:	2200      	movs	r2, #0
 80030a8:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80030aa:	687b      	ldr	r3, [r7, #4]
 80030ac:	2200      	movs	r2, #0
 80030ae:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  return HAL_OK;
 80030b2:	2300      	movs	r3, #0
}
 80030b4:	4618      	mov	r0, r3
 80030b6:	3708      	adds	r7, #8
 80030b8:	46bd      	mov	sp, r7
 80030ba:	bd80      	pop	{r7, pc}

080030bc <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 80030bc:	b480      	push	{r7}
 80030be:	b083      	sub	sp, #12
 80030c0:	af00      	add	r7, sp, #0
 80030c2:	6078      	str	r0, [r7, #4]
 80030c4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 80030c6:	687b      	ldr	r3, [r7, #4]
 80030c8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 80030cc:	b2db      	uxtb	r3, r3
 80030ce:	2b20      	cmp	r3, #32
 80030d0:	d138      	bne.n	8003144 <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 80030d2:	687b      	ldr	r3, [r7, #4]
 80030d4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 80030d8:	2b01      	cmp	r3, #1
 80030da:	d101      	bne.n	80030e0 <HAL_I2CEx_ConfigAnalogFilter+0x24>
 80030dc:	2302      	movs	r3, #2
 80030de:	e032      	b.n	8003146 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
 80030e0:	687b      	ldr	r3, [r7, #4]
 80030e2:	2201      	movs	r2, #1
 80030e4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
 80030e8:	687b      	ldr	r3, [r7, #4]
 80030ea:	2224      	movs	r2, #36	; 0x24
 80030ec:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 80030f0:	687b      	ldr	r3, [r7, #4]
 80030f2:	681b      	ldr	r3, [r3, #0]
 80030f4:	681a      	ldr	r2, [r3, #0]
 80030f6:	687b      	ldr	r3, [r7, #4]
 80030f8:	681b      	ldr	r3, [r3, #0]
 80030fa:	f022 0201 	bic.w	r2, r2, #1
 80030fe:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 8003100:	687b      	ldr	r3, [r7, #4]
 8003102:	681b      	ldr	r3, [r3, #0]
 8003104:	681a      	ldr	r2, [r3, #0]
 8003106:	687b      	ldr	r3, [r7, #4]
 8003108:	681b      	ldr	r3, [r3, #0]
 800310a:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800310e:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 8003110:	687b      	ldr	r3, [r7, #4]
 8003112:	681b      	ldr	r3, [r3, #0]
 8003114:	6819      	ldr	r1, [r3, #0]
 8003116:	687b      	ldr	r3, [r7, #4]
 8003118:	681b      	ldr	r3, [r3, #0]
 800311a:	683a      	ldr	r2, [r7, #0]
 800311c:	430a      	orrs	r2, r1
 800311e:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 8003120:	687b      	ldr	r3, [r7, #4]
 8003122:	681b      	ldr	r3, [r3, #0]
 8003124:	681a      	ldr	r2, [r3, #0]
 8003126:	687b      	ldr	r3, [r7, #4]
 8003128:	681b      	ldr	r3, [r3, #0]
 800312a:	f042 0201 	orr.w	r2, r2, #1
 800312e:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 8003130:	687b      	ldr	r3, [r7, #4]
 8003132:	2220      	movs	r2, #32
 8003134:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8003138:	687b      	ldr	r3, [r7, #4]
 800313a:	2200      	movs	r2, #0
 800313c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
 8003140:	2300      	movs	r3, #0
 8003142:	e000      	b.n	8003146 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
 8003144:	2302      	movs	r3, #2
  }
}
 8003146:	4618      	mov	r0, r3
 8003148:	370c      	adds	r7, #12
 800314a:	46bd      	mov	sp, r7
 800314c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003150:	4770      	bx	lr

08003152 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 8003152:	b480      	push	{r7}
 8003154:	b085      	sub	sp, #20
 8003156:	af00      	add	r7, sp, #0
 8003158:	6078      	str	r0, [r7, #4]
 800315a:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800315c:	687b      	ldr	r3, [r7, #4]
 800315e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8003162:	b2db      	uxtb	r3, r3
 8003164:	2b20      	cmp	r3, #32
 8003166:	d139      	bne.n	80031dc <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8003168:	687b      	ldr	r3, [r7, #4]
 800316a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800316e:	2b01      	cmp	r3, #1
 8003170:	d101      	bne.n	8003176 <HAL_I2CEx_ConfigDigitalFilter+0x24>
 8003172:	2302      	movs	r3, #2
 8003174:	e033      	b.n	80031de <HAL_I2CEx_ConfigDigitalFilter+0x8c>
 8003176:	687b      	ldr	r3, [r7, #4]
 8003178:	2201      	movs	r2, #1
 800317a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
 800317e:	687b      	ldr	r3, [r7, #4]
 8003180:	2224      	movs	r2, #36	; 0x24
 8003182:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8003186:	687b      	ldr	r3, [r7, #4]
 8003188:	681b      	ldr	r3, [r3, #0]
 800318a:	681a      	ldr	r2, [r3, #0]
 800318c:	687b      	ldr	r3, [r7, #4]
 800318e:	681b      	ldr	r3, [r3, #0]
 8003190:	f022 0201 	bic.w	r2, r2, #1
 8003194:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 8003196:	687b      	ldr	r3, [r7, #4]
 8003198:	681b      	ldr	r3, [r3, #0]
 800319a:	681b      	ldr	r3, [r3, #0]
 800319c:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 800319e:	68fb      	ldr	r3, [r7, #12]
 80031a0:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 80031a4:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 80031a6:	683b      	ldr	r3, [r7, #0]
 80031a8:	021b      	lsls	r3, r3, #8
 80031aa:	68fa      	ldr	r2, [r7, #12]
 80031ac:	4313      	orrs	r3, r2
 80031ae:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 80031b0:	687b      	ldr	r3, [r7, #4]
 80031b2:	681b      	ldr	r3, [r3, #0]
 80031b4:	68fa      	ldr	r2, [r7, #12]
 80031b6:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 80031b8:	687b      	ldr	r3, [r7, #4]
 80031ba:	681b      	ldr	r3, [r3, #0]
 80031bc:	681a      	ldr	r2, [r3, #0]
 80031be:	687b      	ldr	r3, [r7, #4]
 80031c0:	681b      	ldr	r3, [r3, #0]
 80031c2:	f042 0201 	orr.w	r2, r2, #1
 80031c6:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 80031c8:	687b      	ldr	r3, [r7, #4]
 80031ca:	2220      	movs	r2, #32
 80031cc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80031d0:	687b      	ldr	r3, [r7, #4]
 80031d2:	2200      	movs	r2, #0
 80031d4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
 80031d8:	2300      	movs	r3, #0
 80031da:	e000      	b.n	80031de <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
 80031dc:	2302      	movs	r3, #2
  }
}
 80031de:	4618      	mov	r0, r3
 80031e0:	3714      	adds	r7, #20
 80031e2:	46bd      	mov	sp, r7
 80031e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80031e8:	4770      	bx	lr
	...

080031ec <HAL_OSPI_Init>:
  *         in the OSPI_InitTypeDef and initialize the associated handle.
  * @param  hospi : OSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_Init (OSPI_HandleTypeDef *hospi)
{
 80031ec:	b580      	push	{r7, lr}
 80031ee:	b086      	sub	sp, #24
 80031f0:	af02      	add	r7, sp, #8
 80031f2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 80031f4:	2300      	movs	r3, #0
 80031f6:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
 80031f8:	f7fe fbf6 	bl	80019e8 <HAL_GetTick>
 80031fc:	60b8      	str	r0, [r7, #8]

  /* Check the OSPI handle allocation */
  if (hospi == NULL)
 80031fe:	687b      	ldr	r3, [r7, #4]
 8003200:	2b00      	cmp	r3, #0
 8003202:	d102      	bne.n	800320a <HAL_OSPI_Init+0x1e>
  {
    status = HAL_ERROR;
 8003204:	2301      	movs	r3, #1
 8003206:	73fb      	strb	r3, [r7, #15]
 8003208:	e092      	b.n	8003330 <HAL_OSPI_Init+0x144>
#if   defined (OCTOSPI_DCR3_MAXTRAN)
    assert_param(IS_OSPI_MAXTRAN        (hospi->Init.MaxTran));
#endif

    /* Initialize error code */
    hospi->ErrorCode = HAL_OSPI_ERROR_NONE;
 800320a:	687b      	ldr	r3, [r7, #4]
 800320c:	2200      	movs	r2, #0
 800320e:	649a      	str	r2, [r3, #72]	; 0x48

    /* Check if the state is the reset state */
    if (hospi->State == HAL_OSPI_STATE_RESET)
 8003210:	687b      	ldr	r3, [r7, #4]
 8003212:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003214:	2b00      	cmp	r3, #0
 8003216:	f040 808b 	bne.w	8003330 <HAL_OSPI_Init+0x144>

      /* Init the low level hardware */
      hospi->MspInitCallback(hospi);
#else
      /* Initialization of the low level hardware */
      HAL_OSPI_MspInit(hospi);
 800321a:	6878      	ldr	r0, [r7, #4]
 800321c:	f7fe f8a0 	bl	8001360 <HAL_OSPI_MspInit>
#endif

      /* Configure the default timeout for the OSPI memory access */
      (void)HAL_OSPI_SetTimeout(hospi, HAL_OSPI_TIMEOUT_DEFAULT_VALUE);
 8003220:	f241 3188 	movw	r1, #5000	; 0x1388
 8003224:	6878      	ldr	r0, [r7, #4]
 8003226:	f000 f88b 	bl	8003340 <HAL_OSPI_SetTimeout>

      /* Configure memory type, device size, chip select high time, delay block bypass, free running clock, clock mode */
      MODIFY_REG(hospi->Instance->DCR1,
 800322a:	687b      	ldr	r3, [r7, #4]
 800322c:	681b      	ldr	r3, [r3, #0]
 800322e:	689a      	ldr	r2, [r3, #8]
 8003230:	4b42      	ldr	r3, [pc, #264]	; (800333c <HAL_OSPI_Init+0x150>)
 8003232:	4013      	ands	r3, r2
 8003234:	687a      	ldr	r2, [r7, #4]
 8003236:	68d1      	ldr	r1, [r2, #12]
 8003238:	687a      	ldr	r2, [r7, #4]
 800323a:	6912      	ldr	r2, [r2, #16]
 800323c:	3a01      	subs	r2, #1
 800323e:	0412      	lsls	r2, r2, #16
 8003240:	4311      	orrs	r1, r2
 8003242:	687a      	ldr	r2, [r7, #4]
 8003244:	6952      	ldr	r2, [r2, #20]
 8003246:	3a01      	subs	r2, #1
 8003248:	0212      	lsls	r2, r2, #8
 800324a:	4311      	orrs	r1, r2
 800324c:	687a      	ldr	r2, [r7, #4]
 800324e:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8003250:	4311      	orrs	r1, r2
 8003252:	687a      	ldr	r2, [r7, #4]
 8003254:	69d2      	ldr	r2, [r2, #28]
 8003256:	4311      	orrs	r1, r2
 8003258:	687a      	ldr	r2, [r7, #4]
 800325a:	6812      	ldr	r2, [r2, #0]
 800325c:	430b      	orrs	r3, r1
 800325e:	6093      	str	r3, [r2, #8]
#if   defined (OCTOSPI_DCR3_MAXTRAN)
      /* Configure chip select boundary and maximun transfer */
      hospi->Instance->DCR3 = ((hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos) | (hospi->Init.MaxTran << OCTOSPI_DCR3_MAXTRAN_Pos));
#else
      /* Configure chip select boundary */
      hospi->Instance->DCR3 = (hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos);
 8003260:	687b      	ldr	r3, [r7, #4]
 8003262:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8003264:	687b      	ldr	r3, [r7, #4]
 8003266:	681b      	ldr	r3, [r3, #0]
 8003268:	0412      	lsls	r2, r2, #16
 800326a:	611a      	str	r2, [r3, #16]
      /* Configure refresh */
      hospi->Instance->DCR4 = hospi->Init.Refresh;
#endif

      /* Configure FIFO threshold */
      MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FTHRES, ((hospi->Init.FifoThreshold - 1U) << OCTOSPI_CR_FTHRES_Pos));
 800326c:	687b      	ldr	r3, [r7, #4]
 800326e:	681b      	ldr	r3, [r3, #0]
 8003270:	681b      	ldr	r3, [r3, #0]
 8003272:	f423 51f8 	bic.w	r1, r3, #7936	; 0x1f00
 8003276:	687b      	ldr	r3, [r7, #4]
 8003278:	685b      	ldr	r3, [r3, #4]
 800327a:	3b01      	subs	r3, #1
 800327c:	021a      	lsls	r2, r3, #8
 800327e:	687b      	ldr	r3, [r7, #4]
 8003280:	681b      	ldr	r3, [r3, #0]
 8003282:	430a      	orrs	r2, r1
 8003284:	601a      	str	r2, [r3, #0]

      /* Wait till busy flag is reset */
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 8003286:	687b      	ldr	r3, [r7, #4]
 8003288:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800328a:	9300      	str	r3, [sp, #0]
 800328c:	68bb      	ldr	r3, [r7, #8]
 800328e:	2200      	movs	r2, #0
 8003290:	2120      	movs	r1, #32
 8003292:	6878      	ldr	r0, [r7, #4]
 8003294:	f000 fbb8 	bl	8003a08 <OSPI_WaitFlagStateUntilTimeout>
 8003298:	4603      	mov	r3, r0
 800329a:	73fb      	strb	r3, [r7, #15]

      if (status == HAL_OK)
 800329c:	7bfb      	ldrb	r3, [r7, #15]
 800329e:	2b00      	cmp	r3, #0
 80032a0:	d146      	bne.n	8003330 <HAL_OSPI_Init+0x144>
      {
        /* Configure clock prescaler */
        MODIFY_REG(hospi->Instance->DCR2, OCTOSPI_DCR2_PRESCALER, ((hospi->Init.ClockPrescaler - 1U) << OCTOSPI_DCR2_PRESCALER_Pos));
 80032a2:	687b      	ldr	r3, [r7, #4]
 80032a4:	681b      	ldr	r3, [r3, #0]
 80032a6:	68db      	ldr	r3, [r3, #12]
 80032a8:	f023 01ff 	bic.w	r1, r3, #255	; 0xff
 80032ac:	687b      	ldr	r3, [r7, #4]
 80032ae:	6a1b      	ldr	r3, [r3, #32]
 80032b0:	1e5a      	subs	r2, r3, #1
 80032b2:	687b      	ldr	r3, [r7, #4]
 80032b4:	681b      	ldr	r3, [r3, #0]
 80032b6:	430a      	orrs	r2, r1
 80032b8:	60da      	str	r2, [r3, #12]

        /* Configure Dual Quad mode */
        MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_DQM, hospi->Init.DualQuad);
 80032ba:	687b      	ldr	r3, [r7, #4]
 80032bc:	681b      	ldr	r3, [r3, #0]
 80032be:	681b      	ldr	r3, [r3, #0]
 80032c0:	f023 0140 	bic.w	r1, r3, #64	; 0x40
 80032c4:	687b      	ldr	r3, [r7, #4]
 80032c6:	689a      	ldr	r2, [r3, #8]
 80032c8:	687b      	ldr	r3, [r7, #4]
 80032ca:	681b      	ldr	r3, [r3, #0]
 80032cc:	430a      	orrs	r2, r1
 80032ce:	601a      	str	r2, [r3, #0]

        /* Configure sample shifting and delay hold quarter cycle */
        MODIFY_REG(hospi->Instance->TCR, (OCTOSPI_TCR_SSHIFT | OCTOSPI_TCR_DHQC), (hospi->Init.SampleShifting | hospi->Init.DelayHoldQuarterCycle));
 80032d0:	687b      	ldr	r3, [r7, #4]
 80032d2:	681b      	ldr	r3, [r3, #0]
 80032d4:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 80032d8:	f023 41a0 	bic.w	r1, r3, #1342177280	; 0x50000000
 80032dc:	687b      	ldr	r3, [r7, #4]
 80032de:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80032e0:	687b      	ldr	r3, [r7, #4]
 80032e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80032e4:	431a      	orrs	r2, r3
 80032e6:	687b      	ldr	r3, [r7, #4]
 80032e8:	681b      	ldr	r3, [r3, #0]
 80032ea:	430a      	orrs	r2, r1
 80032ec:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108

        /* Enable OctoSPI */
        __HAL_OSPI_ENABLE(hospi);
 80032f0:	687b      	ldr	r3, [r7, #4]
 80032f2:	681b      	ldr	r3, [r3, #0]
 80032f4:	681a      	ldr	r2, [r3, #0]
 80032f6:	687b      	ldr	r3, [r7, #4]
 80032f8:	681b      	ldr	r3, [r3, #0]
 80032fa:	f042 0201 	orr.w	r2, r2, #1
 80032fe:	601a      	str	r2, [r3, #0]

        /* Enable free running clock if needed : must be done after OSPI enable */
        if (hospi->Init.FreeRunningClock == HAL_OSPI_FREERUNCLK_ENABLE)
 8003300:	687b      	ldr	r3, [r7, #4]
 8003302:	699b      	ldr	r3, [r3, #24]
 8003304:	2b02      	cmp	r3, #2
 8003306:	d107      	bne.n	8003318 <HAL_OSPI_Init+0x12c>
        {
          SET_BIT(hospi->Instance->DCR1, OCTOSPI_DCR1_FRCK);
 8003308:	687b      	ldr	r3, [r7, #4]
 800330a:	681b      	ldr	r3, [r3, #0]
 800330c:	689a      	ldr	r2, [r3, #8]
 800330e:	687b      	ldr	r3, [r7, #4]
 8003310:	681b      	ldr	r3, [r3, #0]
 8003312:	f042 0202 	orr.w	r2, r2, #2
 8003316:	609a      	str	r2, [r3, #8]
        }

        /* Initialize the OSPI state */
        if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 8003318:	687b      	ldr	r3, [r7, #4]
 800331a:	68db      	ldr	r3, [r3, #12]
 800331c:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8003320:	d103      	bne.n	800332a <HAL_OSPI_Init+0x13e>
        {
          hospi->State = HAL_OSPI_STATE_HYPERBUS_INIT;
 8003322:	687b      	ldr	r3, [r7, #4]
 8003324:	2201      	movs	r2, #1
 8003326:	645a      	str	r2, [r3, #68]	; 0x44
 8003328:	e002      	b.n	8003330 <HAL_OSPI_Init+0x144>
        }
        else
        {
          hospi->State = HAL_OSPI_STATE_READY;
 800332a:	687b      	ldr	r3, [r7, #4]
 800332c:	2202      	movs	r2, #2
 800332e:	645a      	str	r2, [r3, #68]	; 0x44
      }
    }
  }

  /* Return function status */
  return status;
 8003330:	7bfb      	ldrb	r3, [r7, #15]
}
 8003332:	4618      	mov	r0, r3
 8003334:	3710      	adds	r7, #16
 8003336:	46bd      	mov	sp, r7
 8003338:	bd80      	pop	{r7, pc}
 800333a:	bf00      	nop
 800333c:	f8e0f8f4 	.word	0xf8e0f8f4

08003340 <HAL_OSPI_SetTimeout>:
  * @param  hospi   : OSPI handle.
  * @param  Timeout : Timeout for the memory access.
  * @retval None
  */
HAL_StatusTypeDef HAL_OSPI_SetTimeout(OSPI_HandleTypeDef *hospi, uint32_t Timeout)
{
 8003340:	b480      	push	{r7}
 8003342:	b083      	sub	sp, #12
 8003344:	af00      	add	r7, sp, #0
 8003346:	6078      	str	r0, [r7, #4]
 8003348:	6039      	str	r1, [r7, #0]
  hospi->Timeout = Timeout;
 800334a:	687b      	ldr	r3, [r7, #4]
 800334c:	683a      	ldr	r2, [r7, #0]
 800334e:	64da      	str	r2, [r3, #76]	; 0x4c
  return HAL_OK;
 8003350:	2300      	movs	r3, #0
}
 8003352:	4618      	mov	r0, r3
 8003354:	370c      	adds	r7, #12
 8003356:	46bd      	mov	sp, r7
 8003358:	f85d 7b04 	ldr.w	r7, [sp], #4
 800335c:	4770      	bx	lr
	...

08003360 <HAL_OSPIM_Config>:
  * @param  cfg     : Configuration of the IO Manager for the instance
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPIM_Config(OSPI_HandleTypeDef *hospi, OSPIM_CfgTypeDef *cfg, uint32_t Timeout)
{
 8003360:	b580      	push	{r7, lr}
 8003362:	b092      	sub	sp, #72	; 0x48
 8003364:	af00      	add	r7, sp, #0
 8003366:	60f8      	str	r0, [r7, #12]
 8003368:	60b9      	str	r1, [r7, #8]
 800336a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 800336c:	2300      	movs	r3, #0
 800336e:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
  uint32_t instance;
  uint8_t index, ospi_enabled = 0U, other_instance;
 8003372:	2300      	movs	r3, #0
 8003374:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
  assert_param(IS_OSPIM_IO_PORT(cfg->IOHighPort));
#if   defined (OCTOSPIM_CR_MUXEN)
  assert_param(IS_OSPIM_REQ2ACKTIME(cfg->Req2AckTime));
#endif

  if (hospi->Instance == OCTOSPI1)
 8003378:	68fb      	ldr	r3, [r7, #12]
 800337a:	681b      	ldr	r3, [r3, #0]
 800337c:	4a08      	ldr	r2, [pc, #32]	; (80033a0 <HAL_OSPIM_Config+0x40>)
 800337e:	4293      	cmp	r3, r2
 8003380:	d105      	bne.n	800338e <HAL_OSPIM_Config+0x2e>
  {
    instance = 0U;
 8003382:	2300      	movs	r3, #0
 8003384:	643b      	str	r3, [r7, #64]	; 0x40
    other_instance = 1U;
 8003386:	2301      	movs	r3, #1
 8003388:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d
 800338c:	e004      	b.n	8003398 <HAL_OSPIM_Config+0x38>
  }
  else
  {
    instance = 1U;
 800338e:	2301      	movs	r3, #1
 8003390:	643b      	str	r3, [r7, #64]	; 0x40
    other_instance = 0U;
 8003392:	2300      	movs	r3, #0
 8003394:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d
  }

  /**************** Get current configuration of the instances ****************/
  for (index = 0U; index < OSPI_NB_INSTANCE; index++)
 8003398:	2300      	movs	r3, #0
 800339a:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
 800339e:	e01f      	b.n	80033e0 <HAL_OSPIM_Config+0x80>
 80033a0:	a0001000 	.word	0xa0001000
  {
    if (OSPIM_GetConfig(index+1U, &(IOM_cfg[index])) != HAL_OK)
 80033a4:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 80033a8:	3301      	adds	r3, #1
 80033aa:	b2d8      	uxtb	r0, r3
 80033ac:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 80033b0:	f107 0114 	add.w	r1, r7, #20
 80033b4:	4613      	mov	r3, r2
 80033b6:	009b      	lsls	r3, r3, #2
 80033b8:	4413      	add	r3, r2
 80033ba:	009b      	lsls	r3, r3, #2
 80033bc:	440b      	add	r3, r1
 80033be:	4619      	mov	r1, r3
 80033c0:	f000 fb5a 	bl	8003a78 <OSPIM_GetConfig>
 80033c4:	4603      	mov	r3, r0
 80033c6:	2b00      	cmp	r3, #0
 80033c8:	d005      	beq.n	80033d6 <HAL_OSPIM_Config+0x76>
    {
      status = HAL_ERROR;
 80033ca:	2301      	movs	r3, #1
 80033cc:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
 80033d0:	68fb      	ldr	r3, [r7, #12]
 80033d2:	2208      	movs	r2, #8
 80033d4:	649a      	str	r2, [r3, #72]	; 0x48
  for (index = 0U; index < OSPI_NB_INSTANCE; index++)
 80033d6:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 80033da:	3301      	adds	r3, #1
 80033dc:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
 80033e0:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 80033e4:	2b01      	cmp	r3, #1
 80033e6:	d9dd      	bls.n	80033a4 <HAL_OSPIM_Config+0x44>
    }
  }

  if (status == HAL_OK)
 80033e8:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80033ec:	2b00      	cmp	r3, #0
 80033ee:	f040 82fe 	bne.w	80039ee <HAL_OSPIM_Config+0x68e>
  {
    /********** Disable both OctoSPI to configure OctoSPI IO Manager **********/
    if ((OCTOSPI1->CR & OCTOSPI_CR_EN) != 0U)
 80033f2:	4bcd      	ldr	r3, [pc, #820]	; (8003728 <HAL_OSPIM_Config+0x3c8>)
 80033f4:	681b      	ldr	r3, [r3, #0]
 80033f6:	f003 0301 	and.w	r3, r3, #1
 80033fa:	2b00      	cmp	r3, #0
 80033fc:	d00b      	beq.n	8003416 <HAL_OSPIM_Config+0xb6>
    {
      CLEAR_BIT(OCTOSPI1->CR, OCTOSPI_CR_EN);
 80033fe:	4bca      	ldr	r3, [pc, #808]	; (8003728 <HAL_OSPIM_Config+0x3c8>)
 8003400:	681b      	ldr	r3, [r3, #0]
 8003402:	4ac9      	ldr	r2, [pc, #804]	; (8003728 <HAL_OSPIM_Config+0x3c8>)
 8003404:	f023 0301 	bic.w	r3, r3, #1
 8003408:	6013      	str	r3, [r2, #0]
      ospi_enabled |= 0x1U;
 800340a:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 800340e:	f043 0301 	orr.w	r3, r3, #1
 8003412:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
    }
    if ((OCTOSPI2->CR & OCTOSPI_CR_EN) != 0U)
 8003416:	4bc5      	ldr	r3, [pc, #788]	; (800372c <HAL_OSPIM_Config+0x3cc>)
 8003418:	681b      	ldr	r3, [r3, #0]
 800341a:	f003 0301 	and.w	r3, r3, #1
 800341e:	2b00      	cmp	r3, #0
 8003420:	d00b      	beq.n	800343a <HAL_OSPIM_Config+0xda>
    {
      CLEAR_BIT(OCTOSPI2->CR, OCTOSPI_CR_EN);
 8003422:	4bc2      	ldr	r3, [pc, #776]	; (800372c <HAL_OSPIM_Config+0x3cc>)
 8003424:	681b      	ldr	r3, [r3, #0]
 8003426:	4ac1      	ldr	r2, [pc, #772]	; (800372c <HAL_OSPIM_Config+0x3cc>)
 8003428:	f023 0301 	bic.w	r3, r3, #1
 800342c:	6013      	str	r3, [r2, #0]
      ospi_enabled |= 0x2U;
 800342e:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 8003432:	f043 0302 	orr.w	r3, r3, #2
 8003436:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
    }

    /***************** Deactivation of previous configuration *****************/
    CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].NCSPort-1U)], OCTOSPIM_PCR_NCSEN);
 800343a:	49bd      	ldr	r1, [pc, #756]	; (8003730 <HAL_OSPIM_Config+0x3d0>)
 800343c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800343e:	4613      	mov	r3, r2
 8003440:	009b      	lsls	r3, r3, #2
 8003442:	4413      	add	r3, r2
 8003444:	009b      	lsls	r3, r3, #2
 8003446:	f107 0248 	add.w	r2, r7, #72	; 0x48
 800344a:	4413      	add	r3, r2
 800344c:	3b2c      	subs	r3, #44	; 0x2c
 800344e:	681b      	ldr	r3, [r3, #0]
 8003450:	3b01      	subs	r3, #1
 8003452:	009b      	lsls	r3, r3, #2
 8003454:	440b      	add	r3, r1
 8003456:	6859      	ldr	r1, [r3, #4]
 8003458:	48b5      	ldr	r0, [pc, #724]	; (8003730 <HAL_OSPIM_Config+0x3d0>)
 800345a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800345c:	4613      	mov	r3, r2
 800345e:	009b      	lsls	r3, r3, #2
 8003460:	4413      	add	r3, r2
 8003462:	009b      	lsls	r3, r3, #2
 8003464:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8003468:	4413      	add	r3, r2
 800346a:	3b2c      	subs	r3, #44	; 0x2c
 800346c:	681b      	ldr	r3, [r3, #0]
 800346e:	3b01      	subs	r3, #1
 8003470:	f421 7280 	bic.w	r2, r1, #256	; 0x100
 8003474:	009b      	lsls	r3, r3, #2
 8003476:	4403      	add	r3, r0
 8003478:	605a      	str	r2, [r3, #4]
      }
    }
    else
    {
#endif
      if (IOM_cfg[instance].ClkPort != 0U)
 800347a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800347c:	4613      	mov	r3, r2
 800347e:	009b      	lsls	r3, r3, #2
 8003480:	4413      	add	r3, r2
 8003482:	009b      	lsls	r3, r3, #2
 8003484:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8003488:	4413      	add	r3, r2
 800348a:	3b34      	subs	r3, #52	; 0x34
 800348c:	681b      	ldr	r3, [r3, #0]
 800348e:	2b00      	cmp	r3, #0
 8003490:	f000 80ac 	beq.w	80035ec <HAL_OSPIM_Config+0x28c>
      {
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].ClkPort-1U)], OCTOSPIM_PCR_CLKEN);
 8003494:	49a6      	ldr	r1, [pc, #664]	; (8003730 <HAL_OSPIM_Config+0x3d0>)
 8003496:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8003498:	4613      	mov	r3, r2
 800349a:	009b      	lsls	r3, r3, #2
 800349c:	4413      	add	r3, r2
 800349e:	009b      	lsls	r3, r3, #2
 80034a0:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80034a4:	4413      	add	r3, r2
 80034a6:	3b34      	subs	r3, #52	; 0x34
 80034a8:	681b      	ldr	r3, [r3, #0]
 80034aa:	3b01      	subs	r3, #1
 80034ac:	009b      	lsls	r3, r3, #2
 80034ae:	440b      	add	r3, r1
 80034b0:	6859      	ldr	r1, [r3, #4]
 80034b2:	489f      	ldr	r0, [pc, #636]	; (8003730 <HAL_OSPIM_Config+0x3d0>)
 80034b4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80034b6:	4613      	mov	r3, r2
 80034b8:	009b      	lsls	r3, r3, #2
 80034ba:	4413      	add	r3, r2
 80034bc:	009b      	lsls	r3, r3, #2
 80034be:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80034c2:	4413      	add	r3, r2
 80034c4:	3b34      	subs	r3, #52	; 0x34
 80034c6:	681b      	ldr	r3, [r3, #0]
 80034c8:	3b01      	subs	r3, #1
 80034ca:	f021 0201 	bic.w	r2, r1, #1
 80034ce:	009b      	lsls	r3, r3, #2
 80034d0:	4403      	add	r3, r0
 80034d2:	605a      	str	r2, [r3, #4]
        if (IOM_cfg[instance].DQSPort != 0U)
 80034d4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80034d6:	4613      	mov	r3, r2
 80034d8:	009b      	lsls	r3, r3, #2
 80034da:	4413      	add	r3, r2
 80034dc:	009b      	lsls	r3, r3, #2
 80034de:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80034e2:	4413      	add	r3, r2
 80034e4:	3b30      	subs	r3, #48	; 0x30
 80034e6:	681b      	ldr	r3, [r3, #0]
 80034e8:	2b00      	cmp	r3, #0
 80034ea:	d01f      	beq.n	800352c <HAL_OSPIM_Config+0x1cc>
        {
          CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].DQSPort-1U)], OCTOSPIM_PCR_DQSEN);
 80034ec:	4990      	ldr	r1, [pc, #576]	; (8003730 <HAL_OSPIM_Config+0x3d0>)
 80034ee:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80034f0:	4613      	mov	r3, r2
 80034f2:	009b      	lsls	r3, r3, #2
 80034f4:	4413      	add	r3, r2
 80034f6:	009b      	lsls	r3, r3, #2
 80034f8:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80034fc:	4413      	add	r3, r2
 80034fe:	3b30      	subs	r3, #48	; 0x30
 8003500:	681b      	ldr	r3, [r3, #0]
 8003502:	3b01      	subs	r3, #1
 8003504:	009b      	lsls	r3, r3, #2
 8003506:	440b      	add	r3, r1
 8003508:	6859      	ldr	r1, [r3, #4]
 800350a:	4889      	ldr	r0, [pc, #548]	; (8003730 <HAL_OSPIM_Config+0x3d0>)
 800350c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800350e:	4613      	mov	r3, r2
 8003510:	009b      	lsls	r3, r3, #2
 8003512:	4413      	add	r3, r2
 8003514:	009b      	lsls	r3, r3, #2
 8003516:	f107 0248 	add.w	r2, r7, #72	; 0x48
 800351a:	4413      	add	r3, r2
 800351c:	3b30      	subs	r3, #48	; 0x30
 800351e:	681b      	ldr	r3, [r3, #0]
 8003520:	3b01      	subs	r3, #1
 8003522:	f021 0210 	bic.w	r2, r1, #16
 8003526:	009b      	lsls	r3, r3, #2
 8003528:	4403      	add	r3, r0
 800352a:	605a      	str	r2, [r3, #4]
        }
        if (IOM_cfg[instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
 800352c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800352e:	4613      	mov	r3, r2
 8003530:	009b      	lsls	r3, r3, #2
 8003532:	4413      	add	r3, r2
 8003534:	009b      	lsls	r3, r3, #2
 8003536:	f107 0248 	add.w	r2, r7, #72	; 0x48
 800353a:	4413      	add	r3, r2
 800353c:	3b28      	subs	r3, #40	; 0x28
 800353e:	681b      	ldr	r3, [r3, #0]
 8003540:	2b00      	cmp	r3, #0
 8003542:	d023      	beq.n	800358c <HAL_OSPIM_Config+0x22c>
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[instance].IOLowPort-1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOLEN);
 8003544:	497a      	ldr	r1, [pc, #488]	; (8003730 <HAL_OSPIM_Config+0x3d0>)
 8003546:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8003548:	4613      	mov	r3, r2
 800354a:	009b      	lsls	r3, r3, #2
 800354c:	4413      	add	r3, r2
 800354e:	009b      	lsls	r3, r3, #2
 8003550:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8003554:	4413      	add	r3, r2
 8003556:	3b28      	subs	r3, #40	; 0x28
 8003558:	681b      	ldr	r3, [r3, #0]
 800355a:	3b01      	subs	r3, #1
 800355c:	f003 0301 	and.w	r3, r3, #1
 8003560:	009b      	lsls	r3, r3, #2
 8003562:	440b      	add	r3, r1
 8003564:	6859      	ldr	r1, [r3, #4]
 8003566:	4872      	ldr	r0, [pc, #456]	; (8003730 <HAL_OSPIM_Config+0x3d0>)
 8003568:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800356a:	4613      	mov	r3, r2
 800356c:	009b      	lsls	r3, r3, #2
 800356e:	4413      	add	r3, r2
 8003570:	009b      	lsls	r3, r3, #2
 8003572:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8003576:	4413      	add	r3, r2
 8003578:	3b28      	subs	r3, #40	; 0x28
 800357a:	681b      	ldr	r3, [r3, #0]
 800357c:	3b01      	subs	r3, #1
 800357e:	f003 0301 	and.w	r3, r3, #1
 8003582:	f421 3280 	bic.w	r2, r1, #65536	; 0x10000
 8003586:	009b      	lsls	r3, r3, #2
 8003588:	4403      	add	r3, r0
 800358a:	605a      	str	r2, [r3, #4]
        }
        if (IOM_cfg[instance].IOHighPort != HAL_OSPIM_IOPORT_NONE)
 800358c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800358e:	4613      	mov	r3, r2
 8003590:	009b      	lsls	r3, r3, #2
 8003592:	4413      	add	r3, r2
 8003594:	009b      	lsls	r3, r3, #2
 8003596:	f107 0248 	add.w	r2, r7, #72	; 0x48
 800359a:	4413      	add	r3, r2
 800359c:	3b24      	subs	r3, #36	; 0x24
 800359e:	681b      	ldr	r3, [r3, #0]
 80035a0:	2b00      	cmp	r3, #0
 80035a2:	d023      	beq.n	80035ec <HAL_OSPIM_Config+0x28c>
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[instance].IOHighPort-1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOHEN);
 80035a4:	4962      	ldr	r1, [pc, #392]	; (8003730 <HAL_OSPIM_Config+0x3d0>)
 80035a6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80035a8:	4613      	mov	r3, r2
 80035aa:	009b      	lsls	r3, r3, #2
 80035ac:	4413      	add	r3, r2
 80035ae:	009b      	lsls	r3, r3, #2
 80035b0:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80035b4:	4413      	add	r3, r2
 80035b6:	3b24      	subs	r3, #36	; 0x24
 80035b8:	681b      	ldr	r3, [r3, #0]
 80035ba:	3b01      	subs	r3, #1
 80035bc:	f003 0301 	and.w	r3, r3, #1
 80035c0:	009b      	lsls	r3, r3, #2
 80035c2:	440b      	add	r3, r1
 80035c4:	6859      	ldr	r1, [r3, #4]
 80035c6:	485a      	ldr	r0, [pc, #360]	; (8003730 <HAL_OSPIM_Config+0x3d0>)
 80035c8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80035ca:	4613      	mov	r3, r2
 80035cc:	009b      	lsls	r3, r3, #2
 80035ce:	4413      	add	r3, r2
 80035d0:	009b      	lsls	r3, r3, #2
 80035d2:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80035d6:	4413      	add	r3, r2
 80035d8:	3b24      	subs	r3, #36	; 0x24
 80035da:	681b      	ldr	r3, [r3, #0]
 80035dc:	3b01      	subs	r3, #1
 80035de:	f003 0301 	and.w	r3, r3, #1
 80035e2:	f021 7280 	bic.w	r2, r1, #16777216	; 0x1000000
 80035e6:	009b      	lsls	r3, r3, #2
 80035e8:	4403      	add	r3, r0
 80035ea:	605a      	str	r2, [r3, #4]
#if   defined (OCTOSPIM_CR_MUXEN)
    }
#endif

    /********************* Deactivation of other instance *********************/
    if ((cfg->ClkPort == IOM_cfg[other_instance].ClkPort) || (cfg->DQSPort == IOM_cfg[other_instance].DQSPort)     ||
 80035ec:	68bb      	ldr	r3, [r7, #8]
 80035ee:	6819      	ldr	r1, [r3, #0]
 80035f0:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 80035f4:	4613      	mov	r3, r2
 80035f6:	009b      	lsls	r3, r3, #2
 80035f8:	4413      	add	r3, r2
 80035fa:	009b      	lsls	r3, r3, #2
 80035fc:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8003600:	4413      	add	r3, r2
 8003602:	3b34      	subs	r3, #52	; 0x34
 8003604:	681b      	ldr	r3, [r3, #0]
 8003606:	4299      	cmp	r1, r3
 8003608:	d03c      	beq.n	8003684 <HAL_OSPIM_Config+0x324>
 800360a:	68bb      	ldr	r3, [r7, #8]
 800360c:	6859      	ldr	r1, [r3, #4]
 800360e:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 8003612:	4613      	mov	r3, r2
 8003614:	009b      	lsls	r3, r3, #2
 8003616:	4413      	add	r3, r2
 8003618:	009b      	lsls	r3, r3, #2
 800361a:	f107 0248 	add.w	r2, r7, #72	; 0x48
 800361e:	4413      	add	r3, r2
 8003620:	3b30      	subs	r3, #48	; 0x30
 8003622:	681b      	ldr	r3, [r3, #0]
 8003624:	4299      	cmp	r1, r3
 8003626:	d02d      	beq.n	8003684 <HAL_OSPIM_Config+0x324>
        (cfg->NCSPort == IOM_cfg[other_instance].NCSPort) || (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) ||
 8003628:	68bb      	ldr	r3, [r7, #8]
 800362a:	6899      	ldr	r1, [r3, #8]
 800362c:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 8003630:	4613      	mov	r3, r2
 8003632:	009b      	lsls	r3, r3, #2
 8003634:	4413      	add	r3, r2
 8003636:	009b      	lsls	r3, r3, #2
 8003638:	f107 0248 	add.w	r2, r7, #72	; 0x48
 800363c:	4413      	add	r3, r2
 800363e:	3b2c      	subs	r3, #44	; 0x2c
 8003640:	681b      	ldr	r3, [r3, #0]
    if ((cfg->ClkPort == IOM_cfg[other_instance].ClkPort) || (cfg->DQSPort == IOM_cfg[other_instance].DQSPort)     ||
 8003642:	4299      	cmp	r1, r3
 8003644:	d01e      	beq.n	8003684 <HAL_OSPIM_Config+0x324>
        (cfg->NCSPort == IOM_cfg[other_instance].NCSPort) || (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) ||
 8003646:	68bb      	ldr	r3, [r7, #8]
 8003648:	68d9      	ldr	r1, [r3, #12]
 800364a:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 800364e:	4613      	mov	r3, r2
 8003650:	009b      	lsls	r3, r3, #2
 8003652:	4413      	add	r3, r2
 8003654:	009b      	lsls	r3, r3, #2
 8003656:	f107 0248 	add.w	r2, r7, #72	; 0x48
 800365a:	4413      	add	r3, r2
 800365c:	3b28      	subs	r3, #40	; 0x28
 800365e:	681b      	ldr	r3, [r3, #0]
 8003660:	4299      	cmp	r1, r3
 8003662:	d00f      	beq.n	8003684 <HAL_OSPIM_Config+0x324>
        (cfg->IOHighPort == IOM_cfg[other_instance].IOHighPort))
 8003664:	68bb      	ldr	r3, [r7, #8]
 8003666:	6919      	ldr	r1, [r3, #16]
 8003668:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 800366c:	4613      	mov	r3, r2
 800366e:	009b      	lsls	r3, r3, #2
 8003670:	4413      	add	r3, r2
 8003672:	009b      	lsls	r3, r3, #2
 8003674:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8003678:	4413      	add	r3, r2
 800367a:	3b24      	subs	r3, #36	; 0x24
 800367c:	681b      	ldr	r3, [r3, #0]
        (cfg->NCSPort == IOM_cfg[other_instance].NCSPort) || (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) ||
 800367e:	4299      	cmp	r1, r3
 8003680:	f040 80e0 	bne.w	8003844 <HAL_OSPIM_Config+0x4e4>
        SET_BIT(OCTOSPIM->CR, OCTOSPIM_CR_MUXEN);
      }
      else
      {
#endif
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].ClkPort-1U)], OCTOSPIM_PCR_CLKEN);
 8003684:	492a      	ldr	r1, [pc, #168]	; (8003730 <HAL_OSPIM_Config+0x3d0>)
 8003686:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 800368a:	4613      	mov	r3, r2
 800368c:	009b      	lsls	r3, r3, #2
 800368e:	4413      	add	r3, r2
 8003690:	009b      	lsls	r3, r3, #2
 8003692:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8003696:	4413      	add	r3, r2
 8003698:	3b34      	subs	r3, #52	; 0x34
 800369a:	681b      	ldr	r3, [r3, #0]
 800369c:	3b01      	subs	r3, #1
 800369e:	009b      	lsls	r3, r3, #2
 80036a0:	440b      	add	r3, r1
 80036a2:	6859      	ldr	r1, [r3, #4]
 80036a4:	4822      	ldr	r0, [pc, #136]	; (8003730 <HAL_OSPIM_Config+0x3d0>)
 80036a6:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 80036aa:	4613      	mov	r3, r2
 80036ac:	009b      	lsls	r3, r3, #2
 80036ae:	4413      	add	r3, r2
 80036b0:	009b      	lsls	r3, r3, #2
 80036b2:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80036b6:	4413      	add	r3, r2
 80036b8:	3b34      	subs	r3, #52	; 0x34
 80036ba:	681b      	ldr	r3, [r3, #0]
 80036bc:	3b01      	subs	r3, #1
 80036be:	f021 0201 	bic.w	r2, r1, #1
 80036c2:	009b      	lsls	r3, r3, #2
 80036c4:	4403      	add	r3, r0
 80036c6:	605a      	str	r2, [r3, #4]
        if (IOM_cfg[other_instance].DQSPort != 0U)
 80036c8:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 80036cc:	4613      	mov	r3, r2
 80036ce:	009b      	lsls	r3, r3, #2
 80036d0:	4413      	add	r3, r2
 80036d2:	009b      	lsls	r3, r3, #2
 80036d4:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80036d8:	4413      	add	r3, r2
 80036da:	3b30      	subs	r3, #48	; 0x30
 80036dc:	681b      	ldr	r3, [r3, #0]
 80036de:	2b00      	cmp	r3, #0
 80036e0:	d028      	beq.n	8003734 <HAL_OSPIM_Config+0x3d4>
        {
          CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].DQSPort-1U)], OCTOSPIM_PCR_DQSEN);
 80036e2:	4913      	ldr	r1, [pc, #76]	; (8003730 <HAL_OSPIM_Config+0x3d0>)
 80036e4:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 80036e8:	4613      	mov	r3, r2
 80036ea:	009b      	lsls	r3, r3, #2
 80036ec:	4413      	add	r3, r2
 80036ee:	009b      	lsls	r3, r3, #2
 80036f0:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80036f4:	4413      	add	r3, r2
 80036f6:	3b30      	subs	r3, #48	; 0x30
 80036f8:	681b      	ldr	r3, [r3, #0]
 80036fa:	3b01      	subs	r3, #1
 80036fc:	009b      	lsls	r3, r3, #2
 80036fe:	440b      	add	r3, r1
 8003700:	6859      	ldr	r1, [r3, #4]
 8003702:	480b      	ldr	r0, [pc, #44]	; (8003730 <HAL_OSPIM_Config+0x3d0>)
 8003704:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 8003708:	4613      	mov	r3, r2
 800370a:	009b      	lsls	r3, r3, #2
 800370c:	4413      	add	r3, r2
 800370e:	009b      	lsls	r3, r3, #2
 8003710:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8003714:	4413      	add	r3, r2
 8003716:	3b30      	subs	r3, #48	; 0x30
 8003718:	681b      	ldr	r3, [r3, #0]
 800371a:	3b01      	subs	r3, #1
 800371c:	f021 0210 	bic.w	r2, r1, #16
 8003720:	009b      	lsls	r3, r3, #2
 8003722:	4403      	add	r3, r0
 8003724:	605a      	str	r2, [r3, #4]
 8003726:	e005      	b.n	8003734 <HAL_OSPIM_Config+0x3d4>
 8003728:	a0001000 	.word	0xa0001000
 800372c:	a0001400 	.word	0xa0001400
 8003730:	50061c00 	.word	0x50061c00
        }
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].NCSPort-1U)], OCTOSPIM_PCR_NCSEN);
 8003734:	49b1      	ldr	r1, [pc, #708]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 8003736:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 800373a:	4613      	mov	r3, r2
 800373c:	009b      	lsls	r3, r3, #2
 800373e:	4413      	add	r3, r2
 8003740:	009b      	lsls	r3, r3, #2
 8003742:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8003746:	4413      	add	r3, r2
 8003748:	3b2c      	subs	r3, #44	; 0x2c
 800374a:	681b      	ldr	r3, [r3, #0]
 800374c:	3b01      	subs	r3, #1
 800374e:	009b      	lsls	r3, r3, #2
 8003750:	440b      	add	r3, r1
 8003752:	6859      	ldr	r1, [r3, #4]
 8003754:	48a9      	ldr	r0, [pc, #676]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 8003756:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 800375a:	4613      	mov	r3, r2
 800375c:	009b      	lsls	r3, r3, #2
 800375e:	4413      	add	r3, r2
 8003760:	009b      	lsls	r3, r3, #2
 8003762:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8003766:	4413      	add	r3, r2
 8003768:	3b2c      	subs	r3, #44	; 0x2c
 800376a:	681b      	ldr	r3, [r3, #0]
 800376c:	3b01      	subs	r3, #1
 800376e:	f421 7280 	bic.w	r2, r1, #256	; 0x100
 8003772:	009b      	lsls	r3, r3, #2
 8003774:	4403      	add	r3, r0
 8003776:	605a      	str	r2, [r3, #4]
        if (IOM_cfg[other_instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
 8003778:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 800377c:	4613      	mov	r3, r2
 800377e:	009b      	lsls	r3, r3, #2
 8003780:	4413      	add	r3, r2
 8003782:	009b      	lsls	r3, r3, #2
 8003784:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8003788:	4413      	add	r3, r2
 800378a:	3b28      	subs	r3, #40	; 0x28
 800378c:	681b      	ldr	r3, [r3, #0]
 800378e:	2b00      	cmp	r3, #0
 8003790:	d025      	beq.n	80037de <HAL_OSPIM_Config+0x47e>
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOLowPort-1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOLEN);
 8003792:	499a      	ldr	r1, [pc, #616]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 8003794:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 8003798:	4613      	mov	r3, r2
 800379a:	009b      	lsls	r3, r3, #2
 800379c:	4413      	add	r3, r2
 800379e:	009b      	lsls	r3, r3, #2
 80037a0:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80037a4:	4413      	add	r3, r2
 80037a6:	3b28      	subs	r3, #40	; 0x28
 80037a8:	681b      	ldr	r3, [r3, #0]
 80037aa:	3b01      	subs	r3, #1
 80037ac:	f003 0301 	and.w	r3, r3, #1
 80037b0:	009b      	lsls	r3, r3, #2
 80037b2:	440b      	add	r3, r1
 80037b4:	6859      	ldr	r1, [r3, #4]
 80037b6:	4891      	ldr	r0, [pc, #580]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 80037b8:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 80037bc:	4613      	mov	r3, r2
 80037be:	009b      	lsls	r3, r3, #2
 80037c0:	4413      	add	r3, r2
 80037c2:	009b      	lsls	r3, r3, #2
 80037c4:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80037c8:	4413      	add	r3, r2
 80037ca:	3b28      	subs	r3, #40	; 0x28
 80037cc:	681b      	ldr	r3, [r3, #0]
 80037ce:	3b01      	subs	r3, #1
 80037d0:	f003 0301 	and.w	r3, r3, #1
 80037d4:	f421 3280 	bic.w	r2, r1, #65536	; 0x10000
 80037d8:	009b      	lsls	r3, r3, #2
 80037da:	4403      	add	r3, r0
 80037dc:	605a      	str	r2, [r3, #4]
        }
        if (IOM_cfg[other_instance].IOHighPort != HAL_OSPIM_IOPORT_NONE)
 80037de:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 80037e2:	4613      	mov	r3, r2
 80037e4:	009b      	lsls	r3, r3, #2
 80037e6:	4413      	add	r3, r2
 80037e8:	009b      	lsls	r3, r3, #2
 80037ea:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80037ee:	4413      	add	r3, r2
 80037f0:	3b24      	subs	r3, #36	; 0x24
 80037f2:	681b      	ldr	r3, [r3, #0]
 80037f4:	2b00      	cmp	r3, #0
 80037f6:	d025      	beq.n	8003844 <HAL_OSPIM_Config+0x4e4>
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOHighPort-1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOHEN);
 80037f8:	4980      	ldr	r1, [pc, #512]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 80037fa:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 80037fe:	4613      	mov	r3, r2
 8003800:	009b      	lsls	r3, r3, #2
 8003802:	4413      	add	r3, r2
 8003804:	009b      	lsls	r3, r3, #2
 8003806:	f107 0248 	add.w	r2, r7, #72	; 0x48
 800380a:	4413      	add	r3, r2
 800380c:	3b24      	subs	r3, #36	; 0x24
 800380e:	681b      	ldr	r3, [r3, #0]
 8003810:	3b01      	subs	r3, #1
 8003812:	f003 0301 	and.w	r3, r3, #1
 8003816:	009b      	lsls	r3, r3, #2
 8003818:	440b      	add	r3, r1
 800381a:	6859      	ldr	r1, [r3, #4]
 800381c:	4877      	ldr	r0, [pc, #476]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 800381e:	f897 203d 	ldrb.w	r2, [r7, #61]	; 0x3d
 8003822:	4613      	mov	r3, r2
 8003824:	009b      	lsls	r3, r3, #2
 8003826:	4413      	add	r3, r2
 8003828:	009b      	lsls	r3, r3, #2
 800382a:	f107 0248 	add.w	r2, r7, #72	; 0x48
 800382e:	4413      	add	r3, r2
 8003830:	3b24      	subs	r3, #36	; 0x24
 8003832:	681b      	ldr	r3, [r3, #0]
 8003834:	3b01      	subs	r3, #1
 8003836:	f003 0301 	and.w	r3, r3, #1
 800383a:	f021 7280 	bic.w	r2, r1, #16777216	; 0x1000000
 800383e:	009b      	lsls	r3, r3, #2
 8003840:	4403      	add	r3, r0
 8003842:	605a      	str	r2, [r3, #4]
      }
#endif
    }

    /******************** Activation of new configuration *********************/
    MODIFY_REG(OCTOSPIM->PCR[(cfg->NCSPort-1U)], (OCTOSPIM_PCR_NCSEN | OCTOSPIM_PCR_NCSSRC), (OCTOSPIM_PCR_NCSEN | (instance << OCTOSPIM_PCR_NCSSRC_Pos)));
 8003844:	4a6d      	ldr	r2, [pc, #436]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 8003846:	68bb      	ldr	r3, [r7, #8]
 8003848:	689b      	ldr	r3, [r3, #8]
 800384a:	3b01      	subs	r3, #1
 800384c:	009b      	lsls	r3, r3, #2
 800384e:	4413      	add	r3, r2
 8003850:	685b      	ldr	r3, [r3, #4]
 8003852:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8003856:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8003858:	025b      	lsls	r3, r3, #9
 800385a:	431a      	orrs	r2, r3
 800385c:	4967      	ldr	r1, [pc, #412]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 800385e:	68bb      	ldr	r3, [r7, #8]
 8003860:	689b      	ldr	r3, [r3, #8]
 8003862:	3b01      	subs	r3, #1
 8003864:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8003868:	009b      	lsls	r3, r3, #2
 800386a:	440b      	add	r3, r1
 800386c:	605a      	str	r2, [r3, #4]
      }
    }
    else
    {
#endif
      MODIFY_REG(OCTOSPIM->PCR[(cfg->ClkPort-1U)], (OCTOSPIM_PCR_CLKEN | OCTOSPIM_PCR_CLKSRC), (OCTOSPIM_PCR_CLKEN | (instance << OCTOSPIM_PCR_CLKSRC_Pos)));
 800386e:	4a63      	ldr	r2, [pc, #396]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 8003870:	68bb      	ldr	r3, [r7, #8]
 8003872:	681b      	ldr	r3, [r3, #0]
 8003874:	3b01      	subs	r3, #1
 8003876:	009b      	lsls	r3, r3, #2
 8003878:	4413      	add	r3, r2
 800387a:	685b      	ldr	r3, [r3, #4]
 800387c:	f023 0203 	bic.w	r2, r3, #3
 8003880:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8003882:	005b      	lsls	r3, r3, #1
 8003884:	431a      	orrs	r2, r3
 8003886:	495d      	ldr	r1, [pc, #372]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 8003888:	68bb      	ldr	r3, [r7, #8]
 800388a:	681b      	ldr	r3, [r3, #0]
 800388c:	3b01      	subs	r3, #1
 800388e:	f042 0201 	orr.w	r2, r2, #1
 8003892:	009b      	lsls	r3, r3, #2
 8003894:	440b      	add	r3, r1
 8003896:	605a      	str	r2, [r3, #4]
      if (cfg->DQSPort != 0U)
 8003898:	68bb      	ldr	r3, [r7, #8]
 800389a:	685b      	ldr	r3, [r3, #4]
 800389c:	2b00      	cmp	r3, #0
 800389e:	d014      	beq.n	80038ca <HAL_OSPIM_Config+0x56a>
      {
        MODIFY_REG(OCTOSPIM->PCR[(cfg->DQSPort-1U)], (OCTOSPIM_PCR_DQSEN | OCTOSPIM_PCR_DQSSRC), (OCTOSPIM_PCR_DQSEN | (instance << OCTOSPIM_PCR_DQSSRC_Pos)));
 80038a0:	4a56      	ldr	r2, [pc, #344]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 80038a2:	68bb      	ldr	r3, [r7, #8]
 80038a4:	685b      	ldr	r3, [r3, #4]
 80038a6:	3b01      	subs	r3, #1
 80038a8:	009b      	lsls	r3, r3, #2
 80038aa:	4413      	add	r3, r2
 80038ac:	685b      	ldr	r3, [r3, #4]
 80038ae:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 80038b2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80038b4:	015b      	lsls	r3, r3, #5
 80038b6:	431a      	orrs	r2, r3
 80038b8:	4950      	ldr	r1, [pc, #320]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 80038ba:	68bb      	ldr	r3, [r7, #8]
 80038bc:	685b      	ldr	r3, [r3, #4]
 80038be:	3b01      	subs	r3, #1
 80038c0:	f042 0210 	orr.w	r2, r2, #16
 80038c4:	009b      	lsls	r3, r3, #2
 80038c6:	440b      	add	r3, r1
 80038c8:	605a      	str	r2, [r3, #4]
      }

      if ((cfg->IOLowPort & OCTOSPIM_PCR_IOLEN) != 0U)
 80038ca:	68bb      	ldr	r3, [r7, #8]
 80038cc:	68db      	ldr	r3, [r3, #12]
 80038ce:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80038d2:	2b00      	cmp	r3, #0
 80038d4:	d019      	beq.n	800390a <HAL_OSPIM_Config+0x5aa>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort-1U)& OSPI_IOM_PORT_MASK)], (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC),
 80038d6:	4a49      	ldr	r2, [pc, #292]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 80038d8:	68bb      	ldr	r3, [r7, #8]
 80038da:	68db      	ldr	r3, [r3, #12]
 80038dc:	3b01      	subs	r3, #1
 80038de:	f003 0301 	and.w	r3, r3, #1
 80038e2:	009b      	lsls	r3, r3, #2
 80038e4:	4413      	add	r3, r2
 80038e6:	685b      	ldr	r3, [r3, #4]
 80038e8:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
 80038ec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80038ee:	049b      	lsls	r3, r3, #18
 80038f0:	431a      	orrs	r2, r3
 80038f2:	4942      	ldr	r1, [pc, #264]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 80038f4:	68bb      	ldr	r3, [r7, #8]
 80038f6:	68db      	ldr	r3, [r3, #12]
 80038f8:	3b01      	subs	r3, #1
 80038fa:	f003 0301 	and.w	r3, r3, #1
 80038fe:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8003902:	009b      	lsls	r3, r3, #2
 8003904:	440b      	add	r3, r1
 8003906:	605a      	str	r2, [r3, #4]
 8003908:	e01c      	b.n	8003944 <HAL_OSPIM_Config+0x5e4>
                   (OCTOSPIM_PCR_IOLEN | (instance << (OCTOSPIM_PCR_IOLSRC_Pos+1U))));
      }
      else if (cfg->IOLowPort != HAL_OSPIM_IOPORT_NONE)
 800390a:	68bb      	ldr	r3, [r7, #8]
 800390c:	68db      	ldr	r3, [r3, #12]
 800390e:	2b00      	cmp	r3, #0
 8003910:	d018      	beq.n	8003944 <HAL_OSPIM_Config+0x5e4>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort-1U)& OSPI_IOM_PORT_MASK)], (OCTOSPIM_PCR_IOHEN | OCTOSPIM_PCR_IOHSRC),
 8003912:	4a3a      	ldr	r2, [pc, #232]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 8003914:	68bb      	ldr	r3, [r7, #8]
 8003916:	68db      	ldr	r3, [r3, #12]
 8003918:	3b01      	subs	r3, #1
 800391a:	f003 0301 	and.w	r3, r3, #1
 800391e:	009b      	lsls	r3, r3, #2
 8003920:	4413      	add	r3, r2
 8003922:	685b      	ldr	r3, [r3, #4]
 8003924:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
 8003928:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800392a:	069b      	lsls	r3, r3, #26
 800392c:	431a      	orrs	r2, r3
 800392e:	4933      	ldr	r1, [pc, #204]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 8003930:	68bb      	ldr	r3, [r7, #8]
 8003932:	68db      	ldr	r3, [r3, #12]
 8003934:	3b01      	subs	r3, #1
 8003936:	f003 0301 	and.w	r3, r3, #1
 800393a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800393e:	009b      	lsls	r3, r3, #2
 8003940:	440b      	add	r3, r1
 8003942:	605a      	str	r2, [r3, #4]
      else
      {
         /* Nothing to do */
      }

      if ((cfg->IOHighPort & OCTOSPIM_PCR_IOLEN) != 0U)
 8003944:	68bb      	ldr	r3, [r7, #8]
 8003946:	691b      	ldr	r3, [r3, #16]
 8003948:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800394c:	2b00      	cmp	r3, #0
 800394e:	d019      	beq.n	8003984 <HAL_OSPIM_Config+0x624>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort-1U)& OSPI_IOM_PORT_MASK)], (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC),
 8003950:	4a2a      	ldr	r2, [pc, #168]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 8003952:	68bb      	ldr	r3, [r7, #8]
 8003954:	691b      	ldr	r3, [r3, #16]
 8003956:	3b01      	subs	r3, #1
 8003958:	f003 0301 	and.w	r3, r3, #1
 800395c:	009b      	lsls	r3, r3, #2
 800395e:	4413      	add	r3, r2
 8003960:	685b      	ldr	r3, [r3, #4]
 8003962:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
 8003966:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8003968:	049b      	lsls	r3, r3, #18
 800396a:	431a      	orrs	r2, r3
 800396c:	4923      	ldr	r1, [pc, #140]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 800396e:	68bb      	ldr	r3, [r7, #8]
 8003970:	691b      	ldr	r3, [r3, #16]
 8003972:	3b01      	subs	r3, #1
 8003974:	f003 0301 	and.w	r3, r3, #1
 8003978:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
 800397c:	009b      	lsls	r3, r3, #2
 800397e:	440b      	add	r3, r1
 8003980:	605a      	str	r2, [r3, #4]
 8003982:	e01c      	b.n	80039be <HAL_OSPIM_Config+0x65e>
                   (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC_0 | (instance << (OCTOSPIM_PCR_IOLSRC_Pos+1U))));
      }
      else if (cfg->IOHighPort != HAL_OSPIM_IOPORT_NONE)
 8003984:	68bb      	ldr	r3, [r7, #8]
 8003986:	691b      	ldr	r3, [r3, #16]
 8003988:	2b00      	cmp	r3, #0
 800398a:	d018      	beq.n	80039be <HAL_OSPIM_Config+0x65e>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort-1U)& OSPI_IOM_PORT_MASK)], (OCTOSPIM_PCR_IOHEN | OCTOSPIM_PCR_IOHSRC),
 800398c:	4a1b      	ldr	r2, [pc, #108]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 800398e:	68bb      	ldr	r3, [r7, #8]
 8003990:	691b      	ldr	r3, [r3, #16]
 8003992:	3b01      	subs	r3, #1
 8003994:	f003 0301 	and.w	r3, r3, #1
 8003998:	009b      	lsls	r3, r3, #2
 800399a:	4413      	add	r3, r2
 800399c:	685b      	ldr	r3, [r3, #4]
 800399e:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
 80039a2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80039a4:	069b      	lsls	r3, r3, #26
 80039a6:	431a      	orrs	r2, r3
 80039a8:	4914      	ldr	r1, [pc, #80]	; (80039fc <HAL_OSPIM_Config+0x69c>)
 80039aa:	68bb      	ldr	r3, [r7, #8]
 80039ac:	691b      	ldr	r3, [r3, #16]
 80039ae:	3b01      	subs	r3, #1
 80039b0:	f003 0301 	and.w	r3, r3, #1
 80039b4:	f042 7240 	orr.w	r2, r2, #50331648	; 0x3000000
 80039b8:	009b      	lsls	r3, r3, #2
 80039ba:	440b      	add	r3, r1
 80039bc:	605a      	str	r2, [r3, #4]
#if   defined (OCTOSPIM_CR_MUXEN)
    }
#endif

    /******* Re-enable both OctoSPI after configure OctoSPI IO Manager ********/
    if ((ospi_enabled & 0x1U) != 0U)
 80039be:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 80039c2:	f003 0301 	and.w	r3, r3, #1
 80039c6:	2b00      	cmp	r3, #0
 80039c8:	d005      	beq.n	80039d6 <HAL_OSPIM_Config+0x676>
    {
      SET_BIT(OCTOSPI1->CR, OCTOSPI_CR_EN);
 80039ca:	4b0d      	ldr	r3, [pc, #52]	; (8003a00 <HAL_OSPIM_Config+0x6a0>)
 80039cc:	681b      	ldr	r3, [r3, #0]
 80039ce:	4a0c      	ldr	r2, [pc, #48]	; (8003a00 <HAL_OSPIM_Config+0x6a0>)
 80039d0:	f043 0301 	orr.w	r3, r3, #1
 80039d4:	6013      	str	r3, [r2, #0]
    }
    if ((ospi_enabled & 0x2U) != 0U)
 80039d6:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 80039da:	f003 0302 	and.w	r3, r3, #2
 80039de:	2b00      	cmp	r3, #0
 80039e0:	d005      	beq.n	80039ee <HAL_OSPIM_Config+0x68e>
    {
      SET_BIT(OCTOSPI2->CR, OCTOSPI_CR_EN);
 80039e2:	4b08      	ldr	r3, [pc, #32]	; (8003a04 <HAL_OSPIM_Config+0x6a4>)
 80039e4:	681b      	ldr	r3, [r3, #0]
 80039e6:	4a07      	ldr	r2, [pc, #28]	; (8003a04 <HAL_OSPIM_Config+0x6a4>)
 80039e8:	f043 0301 	orr.w	r3, r3, #1
 80039ec:	6013      	str	r3, [r2, #0]
    }
  }

  /* Return function status */
  return status;
 80039ee:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
}
 80039f2:	4618      	mov	r0, r3
 80039f4:	3748      	adds	r7, #72	; 0x48
 80039f6:	46bd      	mov	sp, r7
 80039f8:	bd80      	pop	{r7, pc}
 80039fa:	bf00      	nop
 80039fc:	50061c00 	.word	0x50061c00
 8003a00:	a0001000 	.word	0xa0001000
 8003a04:	a0001400 	.word	0xa0001400

08003a08 <OSPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart : Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef OSPI_WaitFlagStateUntilTimeout(OSPI_HandleTypeDef *hospi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
 8003a08:	b580      	push	{r7, lr}
 8003a0a:	b084      	sub	sp, #16
 8003a0c:	af00      	add	r7, sp, #0
 8003a0e:	60f8      	str	r0, [r7, #12]
 8003a10:	60b9      	str	r1, [r7, #8]
 8003a12:	603b      	str	r3, [r7, #0]
 8003a14:	4613      	mov	r3, r2
 8003a16:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while((__HAL_OSPI_GET_FLAG(hospi, Flag)) != State)
 8003a18:	e01a      	b.n	8003a50 <OSPI_WaitFlagStateUntilTimeout+0x48>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8003a1a:	69bb      	ldr	r3, [r7, #24]
 8003a1c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8003a20:	d016      	beq.n	8003a50 <OSPI_WaitFlagStateUntilTimeout+0x48>
    {
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8003a22:	f7fd ffe1 	bl	80019e8 <HAL_GetTick>
 8003a26:	4602      	mov	r2, r0
 8003a28:	683b      	ldr	r3, [r7, #0]
 8003a2a:	1ad3      	subs	r3, r2, r3
 8003a2c:	69ba      	ldr	r2, [r7, #24]
 8003a2e:	429a      	cmp	r2, r3
 8003a30:	d302      	bcc.n	8003a38 <OSPI_WaitFlagStateUntilTimeout+0x30>
 8003a32:	69bb      	ldr	r3, [r7, #24]
 8003a34:	2b00      	cmp	r3, #0
 8003a36:	d10b      	bne.n	8003a50 <OSPI_WaitFlagStateUntilTimeout+0x48>
      {
        hospi->State     = HAL_OSPI_STATE_ERROR;
 8003a38:	68fb      	ldr	r3, [r7, #12]
 8003a3a:	f44f 7200 	mov.w	r2, #512	; 0x200
 8003a3e:	645a      	str	r2, [r3, #68]	; 0x44
        hospi->ErrorCode |= HAL_OSPI_ERROR_TIMEOUT;
 8003a40:	68fb      	ldr	r3, [r7, #12]
 8003a42:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8003a44:	f043 0201 	orr.w	r2, r3, #1
 8003a48:	68fb      	ldr	r3, [r7, #12]
 8003a4a:	649a      	str	r2, [r3, #72]	; 0x48

        return HAL_ERROR;
 8003a4c:	2301      	movs	r3, #1
 8003a4e:	e00e      	b.n	8003a6e <OSPI_WaitFlagStateUntilTimeout+0x66>
  while((__HAL_OSPI_GET_FLAG(hospi, Flag)) != State)
 8003a50:	68fb      	ldr	r3, [r7, #12]
 8003a52:	681b      	ldr	r3, [r3, #0]
 8003a54:	6a1a      	ldr	r2, [r3, #32]
 8003a56:	68bb      	ldr	r3, [r7, #8]
 8003a58:	4013      	ands	r3, r2
 8003a5a:	2b00      	cmp	r3, #0
 8003a5c:	bf14      	ite	ne
 8003a5e:	2301      	movne	r3, #1
 8003a60:	2300      	moveq	r3, #0
 8003a62:	b2db      	uxtb	r3, r3
 8003a64:	461a      	mov	r2, r3
 8003a66:	79fb      	ldrb	r3, [r7, #7]
 8003a68:	429a      	cmp	r2, r3
 8003a6a:	d1d6      	bne.n	8003a1a <OSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 8003a6c:	2300      	movs	r3, #0
}
 8003a6e:	4618      	mov	r0, r3
 8003a70:	3710      	adds	r7, #16
 8003a72:	46bd      	mov	sp, r7
 8003a74:	bd80      	pop	{r7, pc}
	...

08003a78 <OSPIM_GetConfig>:
  * @param  instance_nb : number of the instance
  * @param  cfg         : configuration of the IO Manager for the instance
  * @retval HAL status
  */
static HAL_StatusTypeDef OSPIM_GetConfig(uint8_t instance_nb, OSPIM_CfgTypeDef *cfg)
{
 8003a78:	b480      	push	{r7}
 8003a7a:	b087      	sub	sp, #28
 8003a7c:	af00      	add	r7, sp, #0
 8003a7e:	4603      	mov	r3, r0
 8003a80:	6039      	str	r1, [r7, #0]
 8003a82:	71fb      	strb	r3, [r7, #7]
  HAL_StatusTypeDef status = HAL_OK;
 8003a84:	2300      	movs	r3, #0
 8003a86:	75fb      	strb	r3, [r7, #23]
  uint32_t reg, value = 0U;
 8003a88:	2300      	movs	r3, #0
 8003a8a:	613b      	str	r3, [r7, #16]
  uint32_t index;

  if ((instance_nb == 0U) || (instance_nb > OSPI_NB_INSTANCE) || (cfg == NULL))
 8003a8c:	79fb      	ldrb	r3, [r7, #7]
 8003a8e:	2b00      	cmp	r3, #0
 8003a90:	d005      	beq.n	8003a9e <OSPIM_GetConfig+0x26>
 8003a92:	79fb      	ldrb	r3, [r7, #7]
 8003a94:	2b02      	cmp	r3, #2
 8003a96:	d802      	bhi.n	8003a9e <OSPIM_GetConfig+0x26>
 8003a98:	683b      	ldr	r3, [r7, #0]
 8003a9a:	2b00      	cmp	r3, #0
 8003a9c:	d102      	bne.n	8003aa4 <OSPIM_GetConfig+0x2c>
  {
    /* Invalid parameter -> error returned */
    status = HAL_ERROR;
 8003a9e:	2301      	movs	r3, #1
 8003aa0:	75fb      	strb	r3, [r7, #23]
 8003aa2:	e08e      	b.n	8003bc2 <OSPIM_GetConfig+0x14a>
  }
  else
  {
    /* Initialize the structure */
    cfg->ClkPort    = 0U;
 8003aa4:	683b      	ldr	r3, [r7, #0]
 8003aa6:	2200      	movs	r2, #0
 8003aa8:	601a      	str	r2, [r3, #0]
    cfg->DQSPort    = 0U;
 8003aaa:	683b      	ldr	r3, [r7, #0]
 8003aac:	2200      	movs	r2, #0
 8003aae:	605a      	str	r2, [r3, #4]
    cfg->NCSPort    = 0U;
 8003ab0:	683b      	ldr	r3, [r7, #0]
 8003ab2:	2200      	movs	r2, #0
 8003ab4:	609a      	str	r2, [r3, #8]
    cfg->IOLowPort  = 0U;
 8003ab6:	683b      	ldr	r3, [r7, #0]
 8003ab8:	2200      	movs	r2, #0
 8003aba:	60da      	str	r2, [r3, #12]
    cfg->IOHighPort = 0U;
 8003abc:	683b      	ldr	r3, [r7, #0]
 8003abe:	2200      	movs	r2, #0
 8003ac0:	611a      	str	r2, [r3, #16]

    if (instance_nb == 2U)
 8003ac2:	79fb      	ldrb	r3, [r7, #7]
 8003ac4:	2b02      	cmp	r3, #2
 8003ac6:	d101      	bne.n	8003acc <OSPIM_GetConfig+0x54>
    {
#if   defined (OCTOSPIM_CR_MUXEN)
      if ((OCTOSPIM->CR & OCTOSPIM_CR_MUXEN) == 0U)
      {
#endif
        value = (OCTOSPIM_PCR_CLKSRC | OCTOSPIM_PCR_DQSSRC | OCTOSPIM_PCR_NCSSRC | OCTOSPIM_PCR_IOLSRC_1 | OCTOSPIM_PCR_IOHSRC_1);
 8003ac8:	4b41      	ldr	r3, [pc, #260]	; (8003bd0 <OSPIM_GetConfig+0x158>)
 8003aca:	613b      	str	r3, [r7, #16]
      }
#endif
    }

    /* Get the information about the instance */
    for (index = 0U; index < OSPI_IOM_NB_PORTS; index ++)
 8003acc:	2300      	movs	r3, #0
 8003ace:	60fb      	str	r3, [r7, #12]
 8003ad0:	e074      	b.n	8003bbc <OSPIM_GetConfig+0x144>
    {
      reg = OCTOSPIM->PCR[index];
 8003ad2:	4a40      	ldr	r2, [pc, #256]	; (8003bd4 <OSPIM_GetConfig+0x15c>)
 8003ad4:	68fb      	ldr	r3, [r7, #12]
 8003ad6:	009b      	lsls	r3, r3, #2
 8003ad8:	4413      	add	r3, r2
 8003ada:	685b      	ldr	r3, [r3, #4]
 8003adc:	60bb      	str	r3, [r7, #8]

      if ((reg & OCTOSPIM_PCR_CLKEN) != 0U)
 8003ade:	68bb      	ldr	r3, [r7, #8]
 8003ae0:	f003 0301 	and.w	r3, r3, #1
 8003ae4:	2b00      	cmp	r3, #0
 8003ae6:	d00a      	beq.n	8003afe <OSPIM_GetConfig+0x86>
      {
        /* The clock is enabled on this port */
        if ((reg & OCTOSPIM_PCR_CLKSRC) == (value & OCTOSPIM_PCR_CLKSRC))
 8003ae8:	68ba      	ldr	r2, [r7, #8]
 8003aea:	693b      	ldr	r3, [r7, #16]
 8003aec:	4053      	eors	r3, r2
 8003aee:	f003 0302 	and.w	r3, r3, #2
 8003af2:	2b00      	cmp	r3, #0
 8003af4:	d103      	bne.n	8003afe <OSPIM_GetConfig+0x86>
        {
          /* The clock correspond to the instance passed as parameter */
          cfg->ClkPort = index+1U;
 8003af6:	68fb      	ldr	r3, [r7, #12]
 8003af8:	1c5a      	adds	r2, r3, #1
 8003afa:	683b      	ldr	r3, [r7, #0]
 8003afc:	601a      	str	r2, [r3, #0]
        }
      }

      if ((reg & OCTOSPIM_PCR_DQSEN) != 0U)
 8003afe:	68bb      	ldr	r3, [r7, #8]
 8003b00:	f003 0310 	and.w	r3, r3, #16
 8003b04:	2b00      	cmp	r3, #0
 8003b06:	d00a      	beq.n	8003b1e <OSPIM_GetConfig+0xa6>
      {
        /* The DQS is enabled on this port */
        if ((reg & OCTOSPIM_PCR_DQSSRC) == (value & OCTOSPIM_PCR_DQSSRC))
 8003b08:	68ba      	ldr	r2, [r7, #8]
 8003b0a:	693b      	ldr	r3, [r7, #16]
 8003b0c:	4053      	eors	r3, r2
 8003b0e:	f003 0320 	and.w	r3, r3, #32
 8003b12:	2b00      	cmp	r3, #0
 8003b14:	d103      	bne.n	8003b1e <OSPIM_GetConfig+0xa6>
        {
          /* The DQS correspond to the instance passed as parameter */
          cfg->DQSPort = index+1U;
 8003b16:	68fb      	ldr	r3, [r7, #12]
 8003b18:	1c5a      	adds	r2, r3, #1
 8003b1a:	683b      	ldr	r3, [r7, #0]
 8003b1c:	605a      	str	r2, [r3, #4]
        }
      }

      if ((reg & OCTOSPIM_PCR_NCSEN) != 0U)
 8003b1e:	68bb      	ldr	r3, [r7, #8]
 8003b20:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8003b24:	2b00      	cmp	r3, #0
 8003b26:	d00a      	beq.n	8003b3e <OSPIM_GetConfig+0xc6>
      {
        /* The nCS is enabled on this port */
        if ((reg & OCTOSPIM_PCR_NCSSRC) == (value & OCTOSPIM_PCR_NCSSRC))
 8003b28:	68ba      	ldr	r2, [r7, #8]
 8003b2a:	693b      	ldr	r3, [r7, #16]
 8003b2c:	4053      	eors	r3, r2
 8003b2e:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8003b32:	2b00      	cmp	r3, #0
 8003b34:	d103      	bne.n	8003b3e <OSPIM_GetConfig+0xc6>
        {
          /* The nCS correspond to the instance passed as parameter */
          cfg->NCSPort = index+1U;
 8003b36:	68fb      	ldr	r3, [r7, #12]
 8003b38:	1c5a      	adds	r2, r3, #1
 8003b3a:	683b      	ldr	r3, [r7, #0]
 8003b3c:	609a      	str	r2, [r3, #8]
        }
      }

      if ((reg & OCTOSPIM_PCR_IOLEN) != 0U)
 8003b3e:	68bb      	ldr	r3, [r7, #8]
 8003b40:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8003b44:	2b00      	cmp	r3, #0
 8003b46:	d018      	beq.n	8003b7a <OSPIM_GetConfig+0x102>
      {
        /* The IO Low is enabled on this port */
        if ((reg & OCTOSPIM_PCR_IOLSRC_1) == (value & OCTOSPIM_PCR_IOLSRC_1))
 8003b48:	68ba      	ldr	r2, [r7, #8]
 8003b4a:	693b      	ldr	r3, [r7, #16]
 8003b4c:	4053      	eors	r3, r2
 8003b4e:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8003b52:	2b00      	cmp	r3, #0
 8003b54:	d111      	bne.n	8003b7a <OSPIM_GetConfig+0x102>
        {
          /* The IO Low correspond to the instance passed as parameter */
          if ((reg & OCTOSPIM_PCR_IOLSRC_0) == 0U)
 8003b56:	68bb      	ldr	r3, [r7, #8]
 8003b58:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003b5c:	2b00      	cmp	r3, #0
 8003b5e:	d106      	bne.n	8003b6e <OSPIM_GetConfig+0xf6>
          {
            cfg->IOLowPort = (OCTOSPIM_PCR_IOLEN | (index+1U));
 8003b60:	68fb      	ldr	r3, [r7, #12]
 8003b62:	3301      	adds	r3, #1
 8003b64:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8003b68:	683b      	ldr	r3, [r7, #0]
 8003b6a:	60da      	str	r2, [r3, #12]
 8003b6c:	e005      	b.n	8003b7a <OSPIM_GetConfig+0x102>
          }
          else
          {
            cfg->IOLowPort = (OCTOSPIM_PCR_IOHEN | (index+1U));
 8003b6e:	68fb      	ldr	r3, [r7, #12]
 8003b70:	3301      	adds	r3, #1
 8003b72:	f043 7280 	orr.w	r2, r3, #16777216	; 0x1000000
 8003b76:	683b      	ldr	r3, [r7, #0]
 8003b78:	60da      	str	r2, [r3, #12]
          }
        }
      }

      if ((reg & OCTOSPIM_PCR_IOHEN) != 0U)
 8003b7a:	68bb      	ldr	r3, [r7, #8]
 8003b7c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8003b80:	2b00      	cmp	r3, #0
 8003b82:	d018      	beq.n	8003bb6 <OSPIM_GetConfig+0x13e>
      {
        /* The IO High is enabled on this port */
        if ((reg & OCTOSPIM_PCR_IOHSRC_1) == (value & OCTOSPIM_PCR_IOHSRC_1))
 8003b84:	68ba      	ldr	r2, [r7, #8]
 8003b86:	693b      	ldr	r3, [r7, #16]
 8003b88:	4053      	eors	r3, r2
 8003b8a:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8003b8e:	2b00      	cmp	r3, #0
 8003b90:	d111      	bne.n	8003bb6 <OSPIM_GetConfig+0x13e>
        {
          /* The IO High correspond to the instance passed as parameter */
          if ((reg & OCTOSPIM_PCR_IOHSRC_0) == 0U)
 8003b92:	68bb      	ldr	r3, [r7, #8]
 8003b94:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8003b98:	2b00      	cmp	r3, #0
 8003b9a:	d106      	bne.n	8003baa <OSPIM_GetConfig+0x132>
          {
            cfg->IOHighPort = (OCTOSPIM_PCR_IOLEN | (index+1U));
 8003b9c:	68fb      	ldr	r3, [r7, #12]
 8003b9e:	3301      	adds	r3, #1
 8003ba0:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8003ba4:	683b      	ldr	r3, [r7, #0]
 8003ba6:	611a      	str	r2, [r3, #16]
 8003ba8:	e005      	b.n	8003bb6 <OSPIM_GetConfig+0x13e>
          }
          else
          {
            cfg->IOHighPort = (OCTOSPIM_PCR_IOHEN | (index+1U));
 8003baa:	68fb      	ldr	r3, [r7, #12]
 8003bac:	3301      	adds	r3, #1
 8003bae:	f043 7280 	orr.w	r2, r3, #16777216	; 0x1000000
 8003bb2:	683b      	ldr	r3, [r7, #0]
 8003bb4:	611a      	str	r2, [r3, #16]
    for (index = 0U; index < OSPI_IOM_NB_PORTS; index ++)
 8003bb6:	68fb      	ldr	r3, [r7, #12]
 8003bb8:	3301      	adds	r3, #1
 8003bba:	60fb      	str	r3, [r7, #12]
 8003bbc:	68fb      	ldr	r3, [r7, #12]
 8003bbe:	2b01      	cmp	r3, #1
 8003bc0:	d987      	bls.n	8003ad2 <OSPIM_GetConfig+0x5a>
      }
    }
  }

  /* Return function status */
  return status;
 8003bc2:	7dfb      	ldrb	r3, [r7, #23]
}
 8003bc4:	4618      	mov	r0, r3
 8003bc6:	371c      	adds	r7, #28
 8003bc8:	46bd      	mov	sp, r7
 8003bca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003bce:	4770      	bx	lr
 8003bd0:	04040222 	.word	0x04040222
 8003bd4:	50061c00 	.word	0x50061c00

08003bd8 <HAL_PWR_EnableBkUpAccess>:
  * @note  LSEON bit that switches on and off the LSE crystal belongs as well to the
  *        back-up domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
 8003bd8:	b480      	push	{r7}
 8003bda:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8003bdc:	4b05      	ldr	r3, [pc, #20]	; (8003bf4 <HAL_PWR_EnableBkUpAccess+0x1c>)
 8003bde:	681b      	ldr	r3, [r3, #0]
 8003be0:	4a04      	ldr	r2, [pc, #16]	; (8003bf4 <HAL_PWR_EnableBkUpAccess+0x1c>)
 8003be2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003be6:	6013      	str	r3, [r2, #0]
}
 8003be8:	bf00      	nop
 8003bea:	46bd      	mov	sp, r7
 8003bec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003bf0:	4770      	bx	lr
 8003bf2:	bf00      	nop
 8003bf4:	40007000 	.word	0x40007000

08003bf8 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1 or PWR_REGULATOR_VOLTAGE_SCALE2
  *         or PWR_REGULATOR_VOLTAGE_SCALE1_BOOST when applicable)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
 8003bf8:	b480      	push	{r7}
 8003bfa:	af00      	add	r7, sp, #0
#if defined(PWR_CR5_R1MODE)
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8003bfc:	4b0d      	ldr	r3, [pc, #52]	; (8003c34 <HAL_PWREx_GetVoltageRange+0x3c>)
 8003bfe:	681b      	ldr	r3, [r3, #0]
 8003c00:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8003c04:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8003c08:	d102      	bne.n	8003c10 <HAL_PWREx_GetVoltageRange+0x18>
    {
      return PWR_REGULATOR_VOLTAGE_SCALE2;
 8003c0a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003c0e:	e00b      	b.n	8003c28 <HAL_PWREx_GetVoltageRange+0x30>
    }
    else if (READ_BIT(PWR->CR5, PWR_CR5_R1MODE) == PWR_CR5_R1MODE)
 8003c10:	4b08      	ldr	r3, [pc, #32]	; (8003c34 <HAL_PWREx_GetVoltageRange+0x3c>)
 8003c12:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8003c16:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8003c1a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003c1e:	d102      	bne.n	8003c26 <HAL_PWREx_GetVoltageRange+0x2e>
    {
      /* PWR_CR5_R1MODE bit set means that Range 1 Boost is disabled */
      return PWR_REGULATOR_VOLTAGE_SCALE1;
 8003c20:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003c24:	e000      	b.n	8003c28 <HAL_PWREx_GetVoltageRange+0x30>
    }
    else
    {
      return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
 8003c26:	2300      	movs	r3, #0
    }
#else
  return  (PWR->CR1 & PWR_CR1_VOS);
#endif
}
 8003c28:	4618      	mov	r0, r3
 8003c2a:	46bd      	mov	sp, r7
 8003c2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003c30:	4770      	bx	lr
 8003c32:	bf00      	nop
 8003c34:	40007000 	.word	0x40007000

08003c38 <HAL_PWREx_ControlVoltageScaling>:
  *        cleared before returning the status. If the flag is not cleared within
  *        50 microseconds, HAL_TIMEOUT status is reported.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 8003c38:	b480      	push	{r7}
 8003c3a:	b085      	sub	sp, #20
 8003c3c:	af00      	add	r7, sp, #0
 8003c3e:	6078      	str	r0, [r7, #4]
  uint32_t wait_loop_index;

  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));

#if defined(PWR_CR5_R1MODE)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
 8003c40:	687b      	ldr	r3, [r7, #4]
 8003c42:	2b00      	cmp	r3, #0
 8003c44:	d141      	bne.n	8003cca <HAL_PWREx_ControlVoltageScaling+0x92>
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8003c46:	4b4b      	ldr	r3, [pc, #300]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003c48:	681b      	ldr	r3, [r3, #0]
 8003c4a:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8003c4e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8003c52:	d131      	bne.n	8003cb8 <HAL_PWREx_ControlVoltageScaling+0x80>
    {
      /* Make sure Range 1 Boost is enabled */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8003c54:	4b47      	ldr	r3, [pc, #284]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003c56:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8003c5a:	4a46      	ldr	r2, [pc, #280]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003c5c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003c60:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8003c64:	4b43      	ldr	r3, [pc, #268]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003c66:	681b      	ldr	r3, [r3, #0]
 8003c68:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8003c6c:	4a41      	ldr	r2, [pc, #260]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003c6e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8003c72:	6013      	str	r3, [r2, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 8003c74:	4b40      	ldr	r3, [pc, #256]	; (8003d78 <HAL_PWREx_ControlVoltageScaling+0x140>)
 8003c76:	681b      	ldr	r3, [r3, #0]
 8003c78:	2232      	movs	r2, #50	; 0x32
 8003c7a:	fb02 f303 	mul.w	r3, r2, r3
 8003c7e:	4a3f      	ldr	r2, [pc, #252]	; (8003d7c <HAL_PWREx_ControlVoltageScaling+0x144>)
 8003c80:	fba2 2303 	umull	r2, r3, r2, r3
 8003c84:	0c9b      	lsrs	r3, r3, #18
 8003c86:	3301      	adds	r3, #1
 8003c88:	60fb      	str	r3, [r7, #12]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8003c8a:	e002      	b.n	8003c92 <HAL_PWREx_ControlVoltageScaling+0x5a>
      {
        wait_loop_index--;
 8003c8c:	68fb      	ldr	r3, [r7, #12]
 8003c8e:	3b01      	subs	r3, #1
 8003c90:	60fb      	str	r3, [r7, #12]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8003c92:	4b38      	ldr	r3, [pc, #224]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003c94:	695b      	ldr	r3, [r3, #20]
 8003c96:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8003c9a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8003c9e:	d102      	bne.n	8003ca6 <HAL_PWREx_ControlVoltageScaling+0x6e>
 8003ca0:	68fb      	ldr	r3, [r7, #12]
 8003ca2:	2b00      	cmp	r3, #0
 8003ca4:	d1f2      	bne.n	8003c8c <HAL_PWREx_ControlVoltageScaling+0x54>
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8003ca6:	4b33      	ldr	r3, [pc, #204]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003ca8:	695b      	ldr	r3, [r3, #20]
 8003caa:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8003cae:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8003cb2:	d158      	bne.n	8003d66 <HAL_PWREx_ControlVoltageScaling+0x12e>
      {
        return HAL_TIMEOUT;
 8003cb4:	2303      	movs	r3, #3
 8003cb6:	e057      	b.n	8003d68 <HAL_PWREx_ControlVoltageScaling+0x130>
    }
    /* If current range is range 1 normal or boost mode */
    else
    {
      /* Enable Range 1 Boost (no issue if bit already reset) */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8003cb8:	4b2e      	ldr	r3, [pc, #184]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003cba:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8003cbe:	4a2d      	ldr	r2, [pc, #180]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003cc0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003cc4:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
 8003cc8:	e04d      	b.n	8003d66 <HAL_PWREx_ControlVoltageScaling+0x12e>
    }
  }
  else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8003cca:	687b      	ldr	r3, [r7, #4]
 8003ccc:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8003cd0:	d141      	bne.n	8003d56 <HAL_PWREx_ControlVoltageScaling+0x11e>
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8003cd2:	4b28      	ldr	r3, [pc, #160]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003cd4:	681b      	ldr	r3, [r3, #0]
 8003cd6:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8003cda:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8003cde:	d131      	bne.n	8003d44 <HAL_PWREx_ControlVoltageScaling+0x10c>
    {
      /* Make sure Range 1 Boost is disabled */
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8003ce0:	4b24      	ldr	r3, [pc, #144]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003ce2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8003ce6:	4a23      	ldr	r2, [pc, #140]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003ce8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003cec:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8003cf0:	4b20      	ldr	r3, [pc, #128]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003cf2:	681b      	ldr	r3, [r3, #0]
 8003cf4:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8003cf8:	4a1e      	ldr	r2, [pc, #120]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003cfa:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8003cfe:	6013      	str	r3, [r2, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 8003d00:	4b1d      	ldr	r3, [pc, #116]	; (8003d78 <HAL_PWREx_ControlVoltageScaling+0x140>)
 8003d02:	681b      	ldr	r3, [r3, #0]
 8003d04:	2232      	movs	r2, #50	; 0x32
 8003d06:	fb02 f303 	mul.w	r3, r2, r3
 8003d0a:	4a1c      	ldr	r2, [pc, #112]	; (8003d7c <HAL_PWREx_ControlVoltageScaling+0x144>)
 8003d0c:	fba2 2303 	umull	r2, r3, r2, r3
 8003d10:	0c9b      	lsrs	r3, r3, #18
 8003d12:	3301      	adds	r3, #1
 8003d14:	60fb      	str	r3, [r7, #12]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8003d16:	e002      	b.n	8003d1e <HAL_PWREx_ControlVoltageScaling+0xe6>
      {
        wait_loop_index--;
 8003d18:	68fb      	ldr	r3, [r7, #12]
 8003d1a:	3b01      	subs	r3, #1
 8003d1c:	60fb      	str	r3, [r7, #12]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8003d1e:	4b15      	ldr	r3, [pc, #84]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003d20:	695b      	ldr	r3, [r3, #20]
 8003d22:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8003d26:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8003d2a:	d102      	bne.n	8003d32 <HAL_PWREx_ControlVoltageScaling+0xfa>
 8003d2c:	68fb      	ldr	r3, [r7, #12]
 8003d2e:	2b00      	cmp	r3, #0
 8003d30:	d1f2      	bne.n	8003d18 <HAL_PWREx_ControlVoltageScaling+0xe0>
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8003d32:	4b10      	ldr	r3, [pc, #64]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003d34:	695b      	ldr	r3, [r3, #20]
 8003d36:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8003d3a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8003d3e:	d112      	bne.n	8003d66 <HAL_PWREx_ControlVoltageScaling+0x12e>
      {
        return HAL_TIMEOUT;
 8003d40:	2303      	movs	r3, #3
 8003d42:	e011      	b.n	8003d68 <HAL_PWREx_ControlVoltageScaling+0x130>
    }
     /* If current range is range 1 normal or boost mode */
    else
    {
      /* Disable Range 1 Boost (no issue if bit already set) */
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8003d44:	4b0b      	ldr	r3, [pc, #44]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003d46:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8003d4a:	4a0a      	ldr	r2, [pc, #40]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003d4c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003d50:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
 8003d54:	e007      	b.n	8003d66 <HAL_PWREx_ControlVoltageScaling+0x12e>
    }
  }
  else
  {
    /* Set Range 2 */
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 8003d56:	4b07      	ldr	r3, [pc, #28]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003d58:	681b      	ldr	r3, [r3, #0]
 8003d5a:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8003d5e:	4a05      	ldr	r2, [pc, #20]	; (8003d74 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8003d60:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8003d64:	6013      	str	r3, [r2, #0]
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
#endif

  return HAL_OK;
 8003d66:	2300      	movs	r3, #0
}
 8003d68:	4618      	mov	r0, r3
 8003d6a:	3714      	adds	r7, #20
 8003d6c:	46bd      	mov	sp, r7
 8003d6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d72:	4770      	bx	lr
 8003d74:	40007000 	.word	0x40007000
 8003d78:	20000000 	.word	0x20000000
 8003d7c:	431bde83 	.word	0x431bde83

08003d80 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8003d80:	b580      	push	{r7, lr}
 8003d82:	b088      	sub	sp, #32
 8003d84:	af00      	add	r7, sp, #0
 8003d86:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8003d88:	687b      	ldr	r3, [r7, #4]
 8003d8a:	2b00      	cmp	r3, #0
 8003d8c:	d102      	bne.n	8003d94 <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
 8003d8e:	2301      	movs	r3, #1
 8003d90:	f000 bc16 	b.w	80045c0 <HAL_RCC_OscConfig+0x840>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8003d94:	4ba0      	ldr	r3, [pc, #640]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003d96:	689b      	ldr	r3, [r3, #8]
 8003d98:	f003 030c 	and.w	r3, r3, #12
 8003d9c:	61bb      	str	r3, [r7, #24]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8003d9e:	4b9e      	ldr	r3, [pc, #632]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003da0:	68db      	ldr	r3, [r3, #12]
 8003da2:	f003 0303 	and.w	r3, r3, #3
 8003da6:	617b      	str	r3, [r7, #20]

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8003da8:	687b      	ldr	r3, [r7, #4]
 8003daa:	681b      	ldr	r3, [r3, #0]
 8003dac:	f003 0310 	and.w	r3, r3, #16
 8003db0:	2b00      	cmp	r3, #0
 8003db2:	f000 80e4 	beq.w	8003f7e <HAL_RCC_OscConfig+0x1fe>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* Check if MSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8003db6:	69bb      	ldr	r3, [r7, #24]
 8003db8:	2b00      	cmp	r3, #0
 8003dba:	d007      	beq.n	8003dcc <HAL_RCC_OscConfig+0x4c>
 8003dbc:	69bb      	ldr	r3, [r7, #24]
 8003dbe:	2b0c      	cmp	r3, #12
 8003dc0:	f040 808b 	bne.w	8003eda <HAL_RCC_OscConfig+0x15a>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_MSI)))
 8003dc4:	697b      	ldr	r3, [r7, #20]
 8003dc6:	2b01      	cmp	r3, #1
 8003dc8:	f040 8087 	bne.w	8003eda <HAL_RCC_OscConfig+0x15a>
    {
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8003dcc:	4b92      	ldr	r3, [pc, #584]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003dce:	681b      	ldr	r3, [r3, #0]
 8003dd0:	f003 0302 	and.w	r3, r3, #2
 8003dd4:	2b00      	cmp	r3, #0
 8003dd6:	d005      	beq.n	8003de4 <HAL_RCC_OscConfig+0x64>
 8003dd8:	687b      	ldr	r3, [r7, #4]
 8003dda:	699b      	ldr	r3, [r3, #24]
 8003ddc:	2b00      	cmp	r3, #0
 8003dde:	d101      	bne.n	8003de4 <HAL_RCC_OscConfig+0x64>
      {
        return HAL_ERROR;
 8003de0:	2301      	movs	r3, #1
 8003de2:	e3ed      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8003de4:	687b      	ldr	r3, [r7, #4]
 8003de6:	6a1a      	ldr	r2, [r3, #32]
 8003de8:	4b8b      	ldr	r3, [pc, #556]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003dea:	681b      	ldr	r3, [r3, #0]
 8003dec:	f003 0308 	and.w	r3, r3, #8
 8003df0:	2b00      	cmp	r3, #0
 8003df2:	d004      	beq.n	8003dfe <HAL_RCC_OscConfig+0x7e>
 8003df4:	4b88      	ldr	r3, [pc, #544]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003df6:	681b      	ldr	r3, [r3, #0]
 8003df8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8003dfc:	e005      	b.n	8003e0a <HAL_RCC_OscConfig+0x8a>
 8003dfe:	4b86      	ldr	r3, [pc, #536]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003e00:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003e04:	091b      	lsrs	r3, r3, #4
 8003e06:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8003e0a:	4293      	cmp	r3, r2
 8003e0c:	d223      	bcs.n	8003e56 <HAL_RCC_OscConfig+0xd6>
        {
          /* First increase number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8003e0e:	687b      	ldr	r3, [r7, #4]
 8003e10:	6a1b      	ldr	r3, [r3, #32]
 8003e12:	4618      	mov	r0, r3
 8003e14:	f000 fdc8 	bl	80049a8 <RCC_SetFlashLatencyFromMSIRange>
 8003e18:	4603      	mov	r3, r0
 8003e1a:	2b00      	cmp	r3, #0
 8003e1c:	d001      	beq.n	8003e22 <HAL_RCC_OscConfig+0xa2>
          {
            return HAL_ERROR;
 8003e1e:	2301      	movs	r3, #1
 8003e20:	e3ce      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8003e22:	4b7d      	ldr	r3, [pc, #500]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003e24:	681b      	ldr	r3, [r3, #0]
 8003e26:	4a7c      	ldr	r2, [pc, #496]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003e28:	f043 0308 	orr.w	r3, r3, #8
 8003e2c:	6013      	str	r3, [r2, #0]
 8003e2e:	4b7a      	ldr	r3, [pc, #488]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003e30:	681b      	ldr	r3, [r3, #0]
 8003e32:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8003e36:	687b      	ldr	r3, [r7, #4]
 8003e38:	6a1b      	ldr	r3, [r3, #32]
 8003e3a:	4977      	ldr	r1, [pc, #476]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003e3c:	4313      	orrs	r3, r2
 8003e3e:	600b      	str	r3, [r1, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8003e40:	4b75      	ldr	r3, [pc, #468]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003e42:	685b      	ldr	r3, [r3, #4]
 8003e44:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 8003e48:	687b      	ldr	r3, [r7, #4]
 8003e4a:	69db      	ldr	r3, [r3, #28]
 8003e4c:	021b      	lsls	r3, r3, #8
 8003e4e:	4972      	ldr	r1, [pc, #456]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003e50:	4313      	orrs	r3, r2
 8003e52:	604b      	str	r3, [r1, #4]
 8003e54:	e025      	b.n	8003ea2 <HAL_RCC_OscConfig+0x122>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8003e56:	4b70      	ldr	r3, [pc, #448]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003e58:	681b      	ldr	r3, [r3, #0]
 8003e5a:	4a6f      	ldr	r2, [pc, #444]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003e5c:	f043 0308 	orr.w	r3, r3, #8
 8003e60:	6013      	str	r3, [r2, #0]
 8003e62:	4b6d      	ldr	r3, [pc, #436]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003e64:	681b      	ldr	r3, [r3, #0]
 8003e66:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8003e6a:	687b      	ldr	r3, [r7, #4]
 8003e6c:	6a1b      	ldr	r3, [r3, #32]
 8003e6e:	496a      	ldr	r1, [pc, #424]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003e70:	4313      	orrs	r3, r2
 8003e72:	600b      	str	r3, [r1, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8003e74:	4b68      	ldr	r3, [pc, #416]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003e76:	685b      	ldr	r3, [r3, #4]
 8003e78:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 8003e7c:	687b      	ldr	r3, [r7, #4]
 8003e7e:	69db      	ldr	r3, [r3, #28]
 8003e80:	021b      	lsls	r3, r3, #8
 8003e82:	4965      	ldr	r1, [pc, #404]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003e84:	4313      	orrs	r3, r2
 8003e86:	604b      	str	r3, [r1, #4]

          /* Decrease number of wait states update if necessary */
          /* Only possible when MSI is the System clock source  */
          if(sysclk_source == RCC_CFGR_SWS_MSI)
 8003e88:	69bb      	ldr	r3, [r7, #24]
 8003e8a:	2b00      	cmp	r3, #0
 8003e8c:	d109      	bne.n	8003ea2 <HAL_RCC_OscConfig+0x122>
          {
            if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8003e8e:	687b      	ldr	r3, [r7, #4]
 8003e90:	6a1b      	ldr	r3, [r3, #32]
 8003e92:	4618      	mov	r0, r3
 8003e94:	f000 fd88 	bl	80049a8 <RCC_SetFlashLatencyFromMSIRange>
 8003e98:	4603      	mov	r3, r0
 8003e9a:	2b00      	cmp	r3, #0
 8003e9c:	d001      	beq.n	8003ea2 <HAL_RCC_OscConfig+0x122>
            {
              return HAL_ERROR;
 8003e9e:	2301      	movs	r3, #1
 8003ea0:	e38e      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
            }
          }
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8003ea2:	f000 fcbf 	bl	8004824 <HAL_RCC_GetSysClockFreq>
 8003ea6:	4601      	mov	r1, r0
 8003ea8:	4b5b      	ldr	r3, [pc, #364]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003eaa:	689b      	ldr	r3, [r3, #8]
 8003eac:	091b      	lsrs	r3, r3, #4
 8003eae:	f003 030f 	and.w	r3, r3, #15
 8003eb2:	4a5a      	ldr	r2, [pc, #360]	; (800401c <HAL_RCC_OscConfig+0x29c>)
 8003eb4:	5cd3      	ldrb	r3, [r2, r3]
 8003eb6:	f003 031f 	and.w	r3, r3, #31
 8003eba:	fa21 f303 	lsr.w	r3, r1, r3
 8003ebe:	4a58      	ldr	r2, [pc, #352]	; (8004020 <HAL_RCC_OscConfig+0x2a0>)
 8003ec0:	6013      	str	r3, [r2, #0]

        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick(uwTickPrio);
 8003ec2:	4b58      	ldr	r3, [pc, #352]	; (8004024 <HAL_RCC_OscConfig+0x2a4>)
 8003ec4:	681b      	ldr	r3, [r3, #0]
 8003ec6:	4618      	mov	r0, r3
 8003ec8:	f7fd fd3e 	bl	8001948 <HAL_InitTick>
 8003ecc:	4603      	mov	r3, r0
 8003ece:	73fb      	strb	r3, [r7, #15]
        if(status != HAL_OK)
 8003ed0:	7bfb      	ldrb	r3, [r7, #15]
 8003ed2:	2b00      	cmp	r3, #0
 8003ed4:	d052      	beq.n	8003f7c <HAL_RCC_OscConfig+0x1fc>
        {
          return status;
 8003ed6:	7bfb      	ldrb	r3, [r7, #15]
 8003ed8:	e372      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
      }
    }
    else
    {
      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8003eda:	687b      	ldr	r3, [r7, #4]
 8003edc:	699b      	ldr	r3, [r3, #24]
 8003ede:	2b00      	cmp	r3, #0
 8003ee0:	d032      	beq.n	8003f48 <HAL_RCC_OscConfig+0x1c8>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8003ee2:	4b4d      	ldr	r3, [pc, #308]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003ee4:	681b      	ldr	r3, [r3, #0]
 8003ee6:	4a4c      	ldr	r2, [pc, #304]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003ee8:	f043 0301 	orr.w	r3, r3, #1
 8003eec:	6013      	str	r3, [r2, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
 8003eee:	f7fd fd7b 	bl	80019e8 <HAL_GetTick>
 8003ef2:	6138      	str	r0, [r7, #16]

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8003ef4:	e008      	b.n	8003f08 <HAL_RCC_OscConfig+0x188>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8003ef6:	f7fd fd77 	bl	80019e8 <HAL_GetTick>
 8003efa:	4602      	mov	r2, r0
 8003efc:	693b      	ldr	r3, [r7, #16]
 8003efe:	1ad3      	subs	r3, r2, r3
 8003f00:	2b02      	cmp	r3, #2
 8003f02:	d901      	bls.n	8003f08 <HAL_RCC_OscConfig+0x188>
          {
            return HAL_TIMEOUT;
 8003f04:	2303      	movs	r3, #3
 8003f06:	e35b      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8003f08:	4b43      	ldr	r3, [pc, #268]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003f0a:	681b      	ldr	r3, [r3, #0]
 8003f0c:	f003 0302 	and.w	r3, r3, #2
 8003f10:	2b00      	cmp	r3, #0
 8003f12:	d0f0      	beq.n	8003ef6 <HAL_RCC_OscConfig+0x176>
          }
        }
         /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8003f14:	4b40      	ldr	r3, [pc, #256]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003f16:	681b      	ldr	r3, [r3, #0]
 8003f18:	4a3f      	ldr	r2, [pc, #252]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003f1a:	f043 0308 	orr.w	r3, r3, #8
 8003f1e:	6013      	str	r3, [r2, #0]
 8003f20:	4b3d      	ldr	r3, [pc, #244]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003f22:	681b      	ldr	r3, [r3, #0]
 8003f24:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8003f28:	687b      	ldr	r3, [r7, #4]
 8003f2a:	6a1b      	ldr	r3, [r3, #32]
 8003f2c:	493a      	ldr	r1, [pc, #232]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003f2e:	4313      	orrs	r3, r2
 8003f30:	600b      	str	r3, [r1, #0]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8003f32:	4b39      	ldr	r3, [pc, #228]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003f34:	685b      	ldr	r3, [r3, #4]
 8003f36:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 8003f3a:	687b      	ldr	r3, [r7, #4]
 8003f3c:	69db      	ldr	r3, [r3, #28]
 8003f3e:	021b      	lsls	r3, r3, #8
 8003f40:	4935      	ldr	r1, [pc, #212]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003f42:	4313      	orrs	r3, r2
 8003f44:	604b      	str	r3, [r1, #4]
 8003f46:	e01a      	b.n	8003f7e <HAL_RCC_OscConfig+0x1fe>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 8003f48:	4b33      	ldr	r3, [pc, #204]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003f4a:	681b      	ldr	r3, [r3, #0]
 8003f4c:	4a32      	ldr	r2, [pc, #200]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003f4e:	f023 0301 	bic.w	r3, r3, #1
 8003f52:	6013      	str	r3, [r2, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
 8003f54:	f7fd fd48 	bl	80019e8 <HAL_GetTick>
 8003f58:	6138      	str	r0, [r7, #16]

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 8003f5a:	e008      	b.n	8003f6e <HAL_RCC_OscConfig+0x1ee>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8003f5c:	f7fd fd44 	bl	80019e8 <HAL_GetTick>
 8003f60:	4602      	mov	r2, r0
 8003f62:	693b      	ldr	r3, [r7, #16]
 8003f64:	1ad3      	subs	r3, r2, r3
 8003f66:	2b02      	cmp	r3, #2
 8003f68:	d901      	bls.n	8003f6e <HAL_RCC_OscConfig+0x1ee>
          {
            return HAL_TIMEOUT;
 8003f6a:	2303      	movs	r3, #3
 8003f6c:	e328      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 8003f6e:	4b2a      	ldr	r3, [pc, #168]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003f70:	681b      	ldr	r3, [r3, #0]
 8003f72:	f003 0302 	and.w	r3, r3, #2
 8003f76:	2b00      	cmp	r3, #0
 8003f78:	d1f0      	bne.n	8003f5c <HAL_RCC_OscConfig+0x1dc>
 8003f7a:	e000      	b.n	8003f7e <HAL_RCC_OscConfig+0x1fe>
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8003f7c:	bf00      	nop
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8003f7e:	687b      	ldr	r3, [r7, #4]
 8003f80:	681b      	ldr	r3, [r3, #0]
 8003f82:	f003 0301 	and.w	r3, r3, #1
 8003f86:	2b00      	cmp	r3, #0
 8003f88:	d073      	beq.n	8004072 <HAL_RCC_OscConfig+0x2f2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((sysclk_source == RCC_CFGR_SWS_HSE) ||
 8003f8a:	69bb      	ldr	r3, [r7, #24]
 8003f8c:	2b08      	cmp	r3, #8
 8003f8e:	d005      	beq.n	8003f9c <HAL_RCC_OscConfig+0x21c>
 8003f90:	69bb      	ldr	r3, [r7, #24]
 8003f92:	2b0c      	cmp	r3, #12
 8003f94:	d10e      	bne.n	8003fb4 <HAL_RCC_OscConfig+0x234>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSE)))
 8003f96:	697b      	ldr	r3, [r7, #20]
 8003f98:	2b03      	cmp	r3, #3
 8003f9a:	d10b      	bne.n	8003fb4 <HAL_RCC_OscConfig+0x234>
    {
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8003f9c:	4b1e      	ldr	r3, [pc, #120]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003f9e:	681b      	ldr	r3, [r3, #0]
 8003fa0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003fa4:	2b00      	cmp	r3, #0
 8003fa6:	d063      	beq.n	8004070 <HAL_RCC_OscConfig+0x2f0>
 8003fa8:	687b      	ldr	r3, [r7, #4]
 8003faa:	685b      	ldr	r3, [r3, #4]
 8003fac:	2b00      	cmp	r3, #0
 8003fae:	d15f      	bne.n	8004070 <HAL_RCC_OscConfig+0x2f0>
      {
        return HAL_ERROR;
 8003fb0:	2301      	movs	r3, #1
 8003fb2:	e305      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8003fb4:	687b      	ldr	r3, [r7, #4]
 8003fb6:	685b      	ldr	r3, [r3, #4]
 8003fb8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003fbc:	d106      	bne.n	8003fcc <HAL_RCC_OscConfig+0x24c>
 8003fbe:	4b16      	ldr	r3, [pc, #88]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003fc0:	681b      	ldr	r3, [r3, #0]
 8003fc2:	4a15      	ldr	r2, [pc, #84]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003fc4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003fc8:	6013      	str	r3, [r2, #0]
 8003fca:	e01d      	b.n	8004008 <HAL_RCC_OscConfig+0x288>
 8003fcc:	687b      	ldr	r3, [r7, #4]
 8003fce:	685b      	ldr	r3, [r3, #4]
 8003fd0:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8003fd4:	d10c      	bne.n	8003ff0 <HAL_RCC_OscConfig+0x270>
 8003fd6:	4b10      	ldr	r3, [pc, #64]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003fd8:	681b      	ldr	r3, [r3, #0]
 8003fda:	4a0f      	ldr	r2, [pc, #60]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003fdc:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8003fe0:	6013      	str	r3, [r2, #0]
 8003fe2:	4b0d      	ldr	r3, [pc, #52]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003fe4:	681b      	ldr	r3, [r3, #0]
 8003fe6:	4a0c      	ldr	r2, [pc, #48]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003fe8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003fec:	6013      	str	r3, [r2, #0]
 8003fee:	e00b      	b.n	8004008 <HAL_RCC_OscConfig+0x288>
 8003ff0:	4b09      	ldr	r3, [pc, #36]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003ff2:	681b      	ldr	r3, [r3, #0]
 8003ff4:	4a08      	ldr	r2, [pc, #32]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003ff6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003ffa:	6013      	str	r3, [r2, #0]
 8003ffc:	4b06      	ldr	r3, [pc, #24]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8003ffe:	681b      	ldr	r3, [r3, #0]
 8004000:	4a05      	ldr	r2, [pc, #20]	; (8004018 <HAL_RCC_OscConfig+0x298>)
 8004002:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8004006:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8004008:	687b      	ldr	r3, [r7, #4]
 800400a:	685b      	ldr	r3, [r3, #4]
 800400c:	2b00      	cmp	r3, #0
 800400e:	d01b      	beq.n	8004048 <HAL_RCC_OscConfig+0x2c8>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004010:	f7fd fcea 	bl	80019e8 <HAL_GetTick>
 8004014:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8004016:	e010      	b.n	800403a <HAL_RCC_OscConfig+0x2ba>
 8004018:	40021000 	.word	0x40021000
 800401c:	0801ab88 	.word	0x0801ab88
 8004020:	20000000 	.word	0x20000000
 8004024:	20000004 	.word	0x20000004
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8004028:	f7fd fcde 	bl	80019e8 <HAL_GetTick>
 800402c:	4602      	mov	r2, r0
 800402e:	693b      	ldr	r3, [r7, #16]
 8004030:	1ad3      	subs	r3, r2, r3
 8004032:	2b64      	cmp	r3, #100	; 0x64
 8004034:	d901      	bls.n	800403a <HAL_RCC_OscConfig+0x2ba>
          {
            return HAL_TIMEOUT;
 8004036:	2303      	movs	r3, #3
 8004038:	e2c2      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800403a:	4baf      	ldr	r3, [pc, #700]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 800403c:	681b      	ldr	r3, [r3, #0]
 800403e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004042:	2b00      	cmp	r3, #0
 8004044:	d0f0      	beq.n	8004028 <HAL_RCC_OscConfig+0x2a8>
 8004046:	e014      	b.n	8004072 <HAL_RCC_OscConfig+0x2f2>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004048:	f7fd fcce 	bl	80019e8 <HAL_GetTick>
 800404c:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 800404e:	e008      	b.n	8004062 <HAL_RCC_OscConfig+0x2e2>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8004050:	f7fd fcca 	bl	80019e8 <HAL_GetTick>
 8004054:	4602      	mov	r2, r0
 8004056:	693b      	ldr	r3, [r7, #16]
 8004058:	1ad3      	subs	r3, r2, r3
 800405a:	2b64      	cmp	r3, #100	; 0x64
 800405c:	d901      	bls.n	8004062 <HAL_RCC_OscConfig+0x2e2>
          {
            return HAL_TIMEOUT;
 800405e:	2303      	movs	r3, #3
 8004060:	e2ae      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8004062:	4ba5      	ldr	r3, [pc, #660]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004064:	681b      	ldr	r3, [r3, #0]
 8004066:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800406a:	2b00      	cmp	r3, #0
 800406c:	d1f0      	bne.n	8004050 <HAL_RCC_OscConfig+0x2d0>
 800406e:	e000      	b.n	8004072 <HAL_RCC_OscConfig+0x2f2>
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8004070:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8004072:	687b      	ldr	r3, [r7, #4]
 8004074:	681b      	ldr	r3, [r3, #0]
 8004076:	f003 0302 	and.w	r3, r3, #2
 800407a:	2b00      	cmp	r3, #0
 800407c:	d060      	beq.n	8004140 <HAL_RCC_OscConfig+0x3c0>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_CFGR_SWS_HSI) ||
 800407e:	69bb      	ldr	r3, [r7, #24]
 8004080:	2b04      	cmp	r3, #4
 8004082:	d005      	beq.n	8004090 <HAL_RCC_OscConfig+0x310>
 8004084:	69bb      	ldr	r3, [r7, #24]
 8004086:	2b0c      	cmp	r3, #12
 8004088:	d119      	bne.n	80040be <HAL_RCC_OscConfig+0x33e>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSI)))
 800408a:	697b      	ldr	r3, [r7, #20]
 800408c:	2b02      	cmp	r3, #2
 800408e:	d116      	bne.n	80040be <HAL_RCC_OscConfig+0x33e>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8004090:	4b99      	ldr	r3, [pc, #612]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004092:	681b      	ldr	r3, [r3, #0]
 8004094:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8004098:	2b00      	cmp	r3, #0
 800409a:	d005      	beq.n	80040a8 <HAL_RCC_OscConfig+0x328>
 800409c:	687b      	ldr	r3, [r7, #4]
 800409e:	68db      	ldr	r3, [r3, #12]
 80040a0:	2b00      	cmp	r3, #0
 80040a2:	d101      	bne.n	80040a8 <HAL_RCC_OscConfig+0x328>
      {
        return HAL_ERROR;
 80040a4:	2301      	movs	r3, #1
 80040a6:	e28b      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80040a8:	4b93      	ldr	r3, [pc, #588]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 80040aa:	685b      	ldr	r3, [r3, #4]
 80040ac:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
 80040b0:	687b      	ldr	r3, [r7, #4]
 80040b2:	691b      	ldr	r3, [r3, #16]
 80040b4:	061b      	lsls	r3, r3, #24
 80040b6:	4990      	ldr	r1, [pc, #576]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 80040b8:	4313      	orrs	r3, r2
 80040ba:	604b      	str	r3, [r1, #4]
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80040bc:	e040      	b.n	8004140 <HAL_RCC_OscConfig+0x3c0>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80040be:	687b      	ldr	r3, [r7, #4]
 80040c0:	68db      	ldr	r3, [r3, #12]
 80040c2:	2b00      	cmp	r3, #0
 80040c4:	d023      	beq.n	800410e <HAL_RCC_OscConfig+0x38e>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80040c6:	4b8c      	ldr	r3, [pc, #560]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 80040c8:	681b      	ldr	r3, [r3, #0]
 80040ca:	4a8b      	ldr	r2, [pc, #556]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 80040cc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80040d0:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80040d2:	f7fd fc89 	bl	80019e8 <HAL_GetTick>
 80040d6:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80040d8:	e008      	b.n	80040ec <HAL_RCC_OscConfig+0x36c>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80040da:	f7fd fc85 	bl	80019e8 <HAL_GetTick>
 80040de:	4602      	mov	r2, r0
 80040e0:	693b      	ldr	r3, [r7, #16]
 80040e2:	1ad3      	subs	r3, r2, r3
 80040e4:	2b02      	cmp	r3, #2
 80040e6:	d901      	bls.n	80040ec <HAL_RCC_OscConfig+0x36c>
          {
            return HAL_TIMEOUT;
 80040e8:	2303      	movs	r3, #3
 80040ea:	e269      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80040ec:	4b82      	ldr	r3, [pc, #520]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 80040ee:	681b      	ldr	r3, [r3, #0]
 80040f0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80040f4:	2b00      	cmp	r3, #0
 80040f6:	d0f0      	beq.n	80040da <HAL_RCC_OscConfig+0x35a>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80040f8:	4b7f      	ldr	r3, [pc, #508]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 80040fa:	685b      	ldr	r3, [r3, #4]
 80040fc:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
 8004100:	687b      	ldr	r3, [r7, #4]
 8004102:	691b      	ldr	r3, [r3, #16]
 8004104:	061b      	lsls	r3, r3, #24
 8004106:	497c      	ldr	r1, [pc, #496]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004108:	4313      	orrs	r3, r2
 800410a:	604b      	str	r3, [r1, #4]
 800410c:	e018      	b.n	8004140 <HAL_RCC_OscConfig+0x3c0>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800410e:	4b7a      	ldr	r3, [pc, #488]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004110:	681b      	ldr	r3, [r3, #0]
 8004112:	4a79      	ldr	r2, [pc, #484]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004114:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8004118:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800411a:	f7fd fc65 	bl	80019e8 <HAL_GetTick>
 800411e:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8004120:	e008      	b.n	8004134 <HAL_RCC_OscConfig+0x3b4>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8004122:	f7fd fc61 	bl	80019e8 <HAL_GetTick>
 8004126:	4602      	mov	r2, r0
 8004128:	693b      	ldr	r3, [r7, #16]
 800412a:	1ad3      	subs	r3, r2, r3
 800412c:	2b02      	cmp	r3, #2
 800412e:	d901      	bls.n	8004134 <HAL_RCC_OscConfig+0x3b4>
          {
            return HAL_TIMEOUT;
 8004130:	2303      	movs	r3, #3
 8004132:	e245      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8004134:	4b70      	ldr	r3, [pc, #448]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004136:	681b      	ldr	r3, [r3, #0]
 8004138:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800413c:	2b00      	cmp	r3, #0
 800413e:	d1f0      	bne.n	8004122 <HAL_RCC_OscConfig+0x3a2>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8004140:	687b      	ldr	r3, [r7, #4]
 8004142:	681b      	ldr	r3, [r3, #0]
 8004144:	f003 0308 	and.w	r3, r3, #8
 8004148:	2b00      	cmp	r3, #0
 800414a:	d03c      	beq.n	80041c6 <HAL_RCC_OscConfig+0x446>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800414c:	687b      	ldr	r3, [r7, #4]
 800414e:	695b      	ldr	r3, [r3, #20]
 8004150:	2b00      	cmp	r3, #0
 8004152:	d01c      	beq.n	800418e <HAL_RCC_OscConfig+0x40e>
        MODIFY_REG(RCC->CSR, RCC_CSR_LSIPREDIV, RCC_OscInitStruct->LSIDiv);
      }
#endif /* RCC_CSR_LSIPREDIV */

      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8004154:	4b68      	ldr	r3, [pc, #416]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004156:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800415a:	4a67      	ldr	r2, [pc, #412]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 800415c:	f043 0301 	orr.w	r3, r3, #1
 8004160:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004164:	f7fd fc40 	bl	80019e8 <HAL_GetTick>
 8004168:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 800416a:	e008      	b.n	800417e <HAL_RCC_OscConfig+0x3fe>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800416c:	f7fd fc3c 	bl	80019e8 <HAL_GetTick>
 8004170:	4602      	mov	r2, r0
 8004172:	693b      	ldr	r3, [r7, #16]
 8004174:	1ad3      	subs	r3, r2, r3
 8004176:	2b02      	cmp	r3, #2
 8004178:	d901      	bls.n	800417e <HAL_RCC_OscConfig+0x3fe>
        {
          return HAL_TIMEOUT;
 800417a:	2303      	movs	r3, #3
 800417c:	e220      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 800417e:	4b5e      	ldr	r3, [pc, #376]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004180:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8004184:	f003 0302 	and.w	r3, r3, #2
 8004188:	2b00      	cmp	r3, #0
 800418a:	d0ef      	beq.n	800416c <HAL_RCC_OscConfig+0x3ec>
 800418c:	e01b      	b.n	80041c6 <HAL_RCC_OscConfig+0x446>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800418e:	4b5a      	ldr	r3, [pc, #360]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004190:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8004194:	4a58      	ldr	r2, [pc, #352]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004196:	f023 0301 	bic.w	r3, r3, #1
 800419a:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800419e:	f7fd fc23 	bl	80019e8 <HAL_GetTick>
 80041a2:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is disabled */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 80041a4:	e008      	b.n	80041b8 <HAL_RCC_OscConfig+0x438>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80041a6:	f7fd fc1f 	bl	80019e8 <HAL_GetTick>
 80041aa:	4602      	mov	r2, r0
 80041ac:	693b      	ldr	r3, [r7, #16]
 80041ae:	1ad3      	subs	r3, r2, r3
 80041b0:	2b02      	cmp	r3, #2
 80041b2:	d901      	bls.n	80041b8 <HAL_RCC_OscConfig+0x438>
        {
          return HAL_TIMEOUT;
 80041b4:	2303      	movs	r3, #3
 80041b6:	e203      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 80041b8:	4b4f      	ldr	r3, [pc, #316]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 80041ba:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80041be:	f003 0302 	and.w	r3, r3, #2
 80041c2:	2b00      	cmp	r3, #0
 80041c4:	d1ef      	bne.n	80041a6 <HAL_RCC_OscConfig+0x426>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80041c6:	687b      	ldr	r3, [r7, #4]
 80041c8:	681b      	ldr	r3, [r3, #0]
 80041ca:	f003 0304 	and.w	r3, r3, #4
 80041ce:	2b00      	cmp	r3, #0
 80041d0:	f000 80a6 	beq.w	8004320 <HAL_RCC_OscConfig+0x5a0>
  {
    FlagStatus       pwrclkchanged = RESET;
 80041d4:	2300      	movs	r3, #0
 80041d6:	77fb      	strb	r3, [r7, #31]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 80041d8:	4b47      	ldr	r3, [pc, #284]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 80041da:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80041dc:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80041e0:	2b00      	cmp	r3, #0
 80041e2:	d10d      	bne.n	8004200 <HAL_RCC_OscConfig+0x480>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80041e4:	4b44      	ldr	r3, [pc, #272]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 80041e6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80041e8:	4a43      	ldr	r2, [pc, #268]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 80041ea:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80041ee:	6593      	str	r3, [r2, #88]	; 0x58
 80041f0:	4b41      	ldr	r3, [pc, #260]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 80041f2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80041f4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80041f8:	60bb      	str	r3, [r7, #8]
 80041fa:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 80041fc:	2301      	movs	r3, #1
 80041fe:	77fb      	strb	r3, [r7, #31]
    }

    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8004200:	4b3e      	ldr	r3, [pc, #248]	; (80042fc <HAL_RCC_OscConfig+0x57c>)
 8004202:	681b      	ldr	r3, [r3, #0]
 8004204:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004208:	2b00      	cmp	r3, #0
 800420a:	d118      	bne.n	800423e <HAL_RCC_OscConfig+0x4be>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 800420c:	4b3b      	ldr	r3, [pc, #236]	; (80042fc <HAL_RCC_OscConfig+0x57c>)
 800420e:	681b      	ldr	r3, [r3, #0]
 8004210:	4a3a      	ldr	r2, [pc, #232]	; (80042fc <HAL_RCC_OscConfig+0x57c>)
 8004212:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004216:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8004218:	f7fd fbe6 	bl	80019e8 <HAL_GetTick>
 800421c:	6138      	str	r0, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800421e:	e008      	b.n	8004232 <HAL_RCC_OscConfig+0x4b2>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8004220:	f7fd fbe2 	bl	80019e8 <HAL_GetTick>
 8004224:	4602      	mov	r2, r0
 8004226:	693b      	ldr	r3, [r7, #16]
 8004228:	1ad3      	subs	r3, r2, r3
 800422a:	2b02      	cmp	r3, #2
 800422c:	d901      	bls.n	8004232 <HAL_RCC_OscConfig+0x4b2>
        {
          return HAL_TIMEOUT;
 800422e:	2303      	movs	r3, #3
 8004230:	e1c6      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8004232:	4b32      	ldr	r3, [pc, #200]	; (80042fc <HAL_RCC_OscConfig+0x57c>)
 8004234:	681b      	ldr	r3, [r3, #0]
 8004236:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800423a:	2b00      	cmp	r3, #0
 800423c:	d0f0      	beq.n	8004220 <HAL_RCC_OscConfig+0x4a0>
    {
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
    }
#else
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800423e:	687b      	ldr	r3, [r7, #4]
 8004240:	689b      	ldr	r3, [r3, #8]
 8004242:	2b01      	cmp	r3, #1
 8004244:	d108      	bne.n	8004258 <HAL_RCC_OscConfig+0x4d8>
 8004246:	4b2c      	ldr	r3, [pc, #176]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004248:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800424c:	4a2a      	ldr	r2, [pc, #168]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 800424e:	f043 0301 	orr.w	r3, r3, #1
 8004252:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8004256:	e024      	b.n	80042a2 <HAL_RCC_OscConfig+0x522>
 8004258:	687b      	ldr	r3, [r7, #4]
 800425a:	689b      	ldr	r3, [r3, #8]
 800425c:	2b05      	cmp	r3, #5
 800425e:	d110      	bne.n	8004282 <HAL_RCC_OscConfig+0x502>
 8004260:	4b25      	ldr	r3, [pc, #148]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004262:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004266:	4a24      	ldr	r2, [pc, #144]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004268:	f043 0304 	orr.w	r3, r3, #4
 800426c:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8004270:	4b21      	ldr	r3, [pc, #132]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004272:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004276:	4a20      	ldr	r2, [pc, #128]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004278:	f043 0301 	orr.w	r3, r3, #1
 800427c:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8004280:	e00f      	b.n	80042a2 <HAL_RCC_OscConfig+0x522>
 8004282:	4b1d      	ldr	r3, [pc, #116]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004284:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004288:	4a1b      	ldr	r2, [pc, #108]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 800428a:	f023 0301 	bic.w	r3, r3, #1
 800428e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8004292:	4b19      	ldr	r3, [pc, #100]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 8004294:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004298:	4a17      	ldr	r2, [pc, #92]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 800429a:	f023 0304 	bic.w	r3, r3, #4
 800429e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#endif /* RCC_BDCR_LSESYSDIS */

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 80042a2:	687b      	ldr	r3, [r7, #4]
 80042a4:	689b      	ldr	r3, [r3, #8]
 80042a6:	2b00      	cmp	r3, #0
 80042a8:	d016      	beq.n	80042d8 <HAL_RCC_OscConfig+0x558>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80042aa:	f7fd fb9d 	bl	80019e8 <HAL_GetTick>
 80042ae:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80042b0:	e00a      	b.n	80042c8 <HAL_RCC_OscConfig+0x548>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80042b2:	f7fd fb99 	bl	80019e8 <HAL_GetTick>
 80042b6:	4602      	mov	r2, r0
 80042b8:	693b      	ldr	r3, [r7, #16]
 80042ba:	1ad3      	subs	r3, r2, r3
 80042bc:	f241 3288 	movw	r2, #5000	; 0x1388
 80042c0:	4293      	cmp	r3, r2
 80042c2:	d901      	bls.n	80042c8 <HAL_RCC_OscConfig+0x548>
        {
          return HAL_TIMEOUT;
 80042c4:	2303      	movs	r3, #3
 80042c6:	e17b      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80042c8:	4b0b      	ldr	r3, [pc, #44]	; (80042f8 <HAL_RCC_OscConfig+0x578>)
 80042ca:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80042ce:	f003 0302 	and.w	r3, r3, #2
 80042d2:	2b00      	cmp	r3, #0
 80042d4:	d0ed      	beq.n	80042b2 <HAL_RCC_OscConfig+0x532>
 80042d6:	e01a      	b.n	800430e <HAL_RCC_OscConfig+0x58e>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80042d8:	f7fd fb86 	bl	80019e8 <HAL_GetTick>
 80042dc:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 80042de:	e00f      	b.n	8004300 <HAL_RCC_OscConfig+0x580>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80042e0:	f7fd fb82 	bl	80019e8 <HAL_GetTick>
 80042e4:	4602      	mov	r2, r0
 80042e6:	693b      	ldr	r3, [r7, #16]
 80042e8:	1ad3      	subs	r3, r2, r3
 80042ea:	f241 3288 	movw	r2, #5000	; 0x1388
 80042ee:	4293      	cmp	r3, r2
 80042f0:	d906      	bls.n	8004300 <HAL_RCC_OscConfig+0x580>
        {
          return HAL_TIMEOUT;
 80042f2:	2303      	movs	r3, #3
 80042f4:	e164      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
 80042f6:	bf00      	nop
 80042f8:	40021000 	.word	0x40021000
 80042fc:	40007000 	.word	0x40007000
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8004300:	4ba8      	ldr	r3, [pc, #672]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004302:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004306:	f003 0302 	and.w	r3, r3, #2
 800430a:	2b00      	cmp	r3, #0
 800430c:	d1e8      	bne.n	80042e0 <HAL_RCC_OscConfig+0x560>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSDIS);
#endif /* RCC_BDCR_LSESYSDIS */
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 800430e:	7ffb      	ldrb	r3, [r7, #31]
 8004310:	2b01      	cmp	r3, #1
 8004312:	d105      	bne.n	8004320 <HAL_RCC_OscConfig+0x5a0>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8004314:	4ba3      	ldr	r3, [pc, #652]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004316:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8004318:	4aa2      	ldr	r2, [pc, #648]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 800431a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800431e:	6593      	str	r3, [r2, #88]	; 0x58
    }
  }
#if defined(RCC_HSI48_SUPPORT)
  /*------------------------------ HSI48 Configuration -----------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8004320:	687b      	ldr	r3, [r7, #4]
 8004322:	681b      	ldr	r3, [r3, #0]
 8004324:	f003 0320 	and.w	r3, r3, #32
 8004328:	2b00      	cmp	r3, #0
 800432a:	d03c      	beq.n	80043a6 <HAL_RCC_OscConfig+0x626>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the LSI State */
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 800432c:	687b      	ldr	r3, [r7, #4]
 800432e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004330:	2b00      	cmp	r3, #0
 8004332:	d01c      	beq.n	800436e <HAL_RCC_OscConfig+0x5ee>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 8004334:	4b9b      	ldr	r3, [pc, #620]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004336:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800433a:	4a9a      	ldr	r2, [pc, #616]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 800433c:	f043 0301 	orr.w	r3, r3, #1
 8004340:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004344:	f7fd fb50 	bl	80019e8 <HAL_GetTick>
 8004348:	6138      	str	r0, [r7, #16]

      /* Wait till HSI48 is ready */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 800434a:	e008      	b.n	800435e <HAL_RCC_OscConfig+0x5de>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800434c:	f7fd fb4c 	bl	80019e8 <HAL_GetTick>
 8004350:	4602      	mov	r2, r0
 8004352:	693b      	ldr	r3, [r7, #16]
 8004354:	1ad3      	subs	r3, r2, r3
 8004356:	2b02      	cmp	r3, #2
 8004358:	d901      	bls.n	800435e <HAL_RCC_OscConfig+0x5de>
        {
          return HAL_TIMEOUT;
 800435a:	2303      	movs	r3, #3
 800435c:	e130      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 800435e:	4b91      	ldr	r3, [pc, #580]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004360:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8004364:	f003 0302 	and.w	r3, r3, #2
 8004368:	2b00      	cmp	r3, #0
 800436a:	d0ef      	beq.n	800434c <HAL_RCC_OscConfig+0x5cc>
 800436c:	e01b      	b.n	80043a6 <HAL_RCC_OscConfig+0x626>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 800436e:	4b8d      	ldr	r3, [pc, #564]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004370:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8004374:	4a8b      	ldr	r2, [pc, #556]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004376:	f023 0301 	bic.w	r3, r3, #1
 800437a:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800437e:	f7fd fb33 	bl	80019e8 <HAL_GetTick>
 8004382:	6138      	str	r0, [r7, #16]

      /* Wait till HSI48 is disabled */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8004384:	e008      	b.n	8004398 <HAL_RCC_OscConfig+0x618>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8004386:	f7fd fb2f 	bl	80019e8 <HAL_GetTick>
 800438a:	4602      	mov	r2, r0
 800438c:	693b      	ldr	r3, [r7, #16]
 800438e:	1ad3      	subs	r3, r2, r3
 8004390:	2b02      	cmp	r3, #2
 8004392:	d901      	bls.n	8004398 <HAL_RCC_OscConfig+0x618>
        {
          return HAL_TIMEOUT;
 8004394:	2303      	movs	r3, #3
 8004396:	e113      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8004398:	4b82      	ldr	r3, [pc, #520]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 800439a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800439e:	f003 0302 	and.w	r3, r3, #2
 80043a2:	2b00      	cmp	r3, #0
 80043a4:	d1ef      	bne.n	8004386 <HAL_RCC_OscConfig+0x606>
#endif /* RCC_HSI48_SUPPORT */
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 80043a6:	687b      	ldr	r3, [r7, #4]
 80043a8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80043aa:	2b00      	cmp	r3, #0
 80043ac:	f000 8107 	beq.w	80045be <HAL_RCC_OscConfig+0x83e>
  {
    /* PLL On ? */
    if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 80043b0:	687b      	ldr	r3, [r7, #4]
 80043b2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80043b4:	2b02      	cmp	r3, #2
 80043b6:	f040 80cb 	bne.w	8004550 <HAL_RCC_OscConfig+0x7d0>
#endif /* RCC_PLLP_SUPPORT */
      assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

      /* Do nothing if PLL configuration is the unchanged */
      pll_config = RCC->PLLCFGR;
 80043ba:	4b7a      	ldr	r3, [pc, #488]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 80043bc:	68db      	ldr	r3, [r3, #12]
 80043be:	617b      	str	r3, [r7, #20]
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 80043c0:	697b      	ldr	r3, [r7, #20]
 80043c2:	f003 0203 	and.w	r2, r3, #3
 80043c6:	687b      	ldr	r3, [r7, #4]
 80043c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80043ca:	429a      	cmp	r2, r3
 80043cc:	d12c      	bne.n	8004428 <HAL_RCC_OscConfig+0x6a8>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 80043ce:	697b      	ldr	r3, [r7, #20]
 80043d0:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 80043d4:	687b      	ldr	r3, [r7, #4]
 80043d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80043d8:	3b01      	subs	r3, #1
 80043da:	011b      	lsls	r3, r3, #4
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 80043dc:	429a      	cmp	r2, r3
 80043de:	d123      	bne.n	8004428 <HAL_RCC_OscConfig+0x6a8>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 80043e0:	697b      	ldr	r3, [r7, #20]
 80043e2:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
 80043e6:	687b      	ldr	r3, [r7, #4]
 80043e8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80043ea:	021b      	lsls	r3, r3, #8
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 80043ec:	429a      	cmp	r2, r3
 80043ee:	d11b      	bne.n	8004428 <HAL_RCC_OscConfig+0x6a8>
#if defined(RCC_PLLP_SUPPORT)
#if defined(RCC_PLLP_DIV_2_31_SUPPORT)
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 80043f0:	697b      	ldr	r3, [r7, #20]
 80043f2:	f003 4278 	and.w	r2, r3, #4160749568	; 0xf8000000
 80043f6:	687b      	ldr	r3, [r7, #4]
 80043f8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80043fa:	06db      	lsls	r3, r3, #27
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 80043fc:	429a      	cmp	r2, r3
 80043fe:	d113      	bne.n	8004428 <HAL_RCC_OscConfig+0x6a8>
#else
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLP)    != ((RCC_OscInitStruct->PLL.PLLP == RCC_PLLP_DIV7) ? 0U : 1U)) ||
#endif
#endif
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8004400:	697b      	ldr	r3, [r7, #20]
 8004402:	f403 02c0 	and.w	r2, r3, #6291456	; 0x600000
 8004406:	687b      	ldr	r3, [r7, #4]
 8004408:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800440a:	085b      	lsrs	r3, r3, #1
 800440c:	3b01      	subs	r3, #1
 800440e:	055b      	lsls	r3, r3, #21
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8004410:	429a      	cmp	r2, r3
 8004412:	d109      	bne.n	8004428 <HAL_RCC_OscConfig+0x6a8>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)    != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 8004414:	697b      	ldr	r3, [r7, #20]
 8004416:	f003 62c0 	and.w	r2, r3, #100663296	; 0x6000000
 800441a:	687b      	ldr	r3, [r7, #4]
 800441c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800441e:	085b      	lsrs	r3, r3, #1
 8004420:	3b01      	subs	r3, #1
 8004422:	065b      	lsls	r3, r3, #25
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8004424:	429a      	cmp	r2, r3
 8004426:	d06d      	beq.n	8004504 <HAL_RCC_OscConfig+0x784>
      {
        /* Check if the PLL is used as system clock or not */
        if(sysclk_source != RCC_CFGR_SWS_PLL)
 8004428:	69bb      	ldr	r3, [r7, #24]
 800442a:	2b0c      	cmp	r3, #12
 800442c:	d068      	beq.n	8004500 <HAL_RCC_OscConfig+0x780>
        {
#if defined(RCC_PLLSAI1_SUPPORT) || defined(RCC_PLLSAI2_SUPPORT)
          /* Check if main PLL can be updated */
          /* Not possible if the source is shared by other enabled PLLSAIx */
          if((READ_BIT(RCC->CR, RCC_CR_PLLSAI1ON) != 0U)
 800442e:	4b5d      	ldr	r3, [pc, #372]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004430:	681b      	ldr	r3, [r3, #0]
 8004432:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8004436:	2b00      	cmp	r3, #0
 8004438:	d105      	bne.n	8004446 <HAL_RCC_OscConfig+0x6c6>
#if defined(RCC_PLLSAI2_SUPPORT)
             || (READ_BIT(RCC->CR, RCC_CR_PLLSAI2ON) != 0U)
 800443a:	4b5a      	ldr	r3, [pc, #360]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 800443c:	681b      	ldr	r3, [r3, #0]
 800443e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8004442:	2b00      	cmp	r3, #0
 8004444:	d001      	beq.n	800444a <HAL_RCC_OscConfig+0x6ca>
#endif
            )
          {
            return HAL_ERROR;
 8004446:	2301      	movs	r3, #1
 8004448:	e0ba      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
          }
          else
#endif /* RCC_PLLSAI1_SUPPORT || RCC_PLLSAI2_SUPPORT */
          {
            /* Disable the main PLL. */
            __HAL_RCC_PLL_DISABLE();
 800444a:	4b56      	ldr	r3, [pc, #344]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 800444c:	681b      	ldr	r3, [r3, #0]
 800444e:	4a55      	ldr	r2, [pc, #340]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004450:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8004454:	6013      	str	r3, [r2, #0]

            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 8004456:	f7fd fac7 	bl	80019e8 <HAL_GetTick>
 800445a:	6138      	str	r0, [r7, #16]

            /* Wait till PLL is ready */
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 800445c:	e008      	b.n	8004470 <HAL_RCC_OscConfig+0x6f0>
            {
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800445e:	f7fd fac3 	bl	80019e8 <HAL_GetTick>
 8004462:	4602      	mov	r2, r0
 8004464:	693b      	ldr	r3, [r7, #16]
 8004466:	1ad3      	subs	r3, r2, r3
 8004468:	2b02      	cmp	r3, #2
 800446a:	d901      	bls.n	8004470 <HAL_RCC_OscConfig+0x6f0>
              {
                return HAL_TIMEOUT;
 800446c:	2303      	movs	r3, #3
 800446e:	e0a7      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8004470:	4b4c      	ldr	r3, [pc, #304]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004472:	681b      	ldr	r3, [r3, #0]
 8004474:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8004478:	2b00      	cmp	r3, #0
 800447a:	d1f0      	bne.n	800445e <HAL_RCC_OscConfig+0x6de>
              }
            }

            /* Configure the main PLL clock source, multiplication and division factors. */
            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800447c:	4b49      	ldr	r3, [pc, #292]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 800447e:	68da      	ldr	r2, [r3, #12]
 8004480:	4b49      	ldr	r3, [pc, #292]	; (80045a8 <HAL_RCC_OscConfig+0x828>)
 8004482:	4013      	ands	r3, r2
 8004484:	687a      	ldr	r2, [r7, #4]
 8004486:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8004488:	687a      	ldr	r2, [r7, #4]
 800448a:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800448c:	3a01      	subs	r2, #1
 800448e:	0112      	lsls	r2, r2, #4
 8004490:	4311      	orrs	r1, r2
 8004492:	687a      	ldr	r2, [r7, #4]
 8004494:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8004496:	0212      	lsls	r2, r2, #8
 8004498:	4311      	orrs	r1, r2
 800449a:	687a      	ldr	r2, [r7, #4]
 800449c:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 800449e:	0852      	lsrs	r2, r2, #1
 80044a0:	3a01      	subs	r2, #1
 80044a2:	0552      	lsls	r2, r2, #21
 80044a4:	4311      	orrs	r1, r2
 80044a6:	687a      	ldr	r2, [r7, #4]
 80044a8:	6c12      	ldr	r2, [r2, #64]	; 0x40
 80044aa:	0852      	lsrs	r2, r2, #1
 80044ac:	3a01      	subs	r2, #1
 80044ae:	0652      	lsls	r2, r2, #25
 80044b0:	4311      	orrs	r1, r2
 80044b2:	687a      	ldr	r2, [r7, #4]
 80044b4:	6b92      	ldr	r2, [r2, #56]	; 0x38
 80044b6:	06d2      	lsls	r2, r2, #27
 80044b8:	430a      	orrs	r2, r1
 80044ba:	493a      	ldr	r1, [pc, #232]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 80044bc:	4313      	orrs	r3, r2
 80044be:	60cb      	str	r3, [r1, #12]
#endif
                                 RCC_OscInitStruct->PLL.PLLQ,
                                 RCC_OscInitStruct->PLL.PLLR);

            /* Enable the main PLL. */
            __HAL_RCC_PLL_ENABLE();
 80044c0:	4b38      	ldr	r3, [pc, #224]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 80044c2:	681b      	ldr	r3, [r3, #0]
 80044c4:	4a37      	ldr	r2, [pc, #220]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 80044c6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80044ca:	6013      	str	r3, [r2, #0]

            /* Enable PLL System Clock output. */
            __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 80044cc:	4b35      	ldr	r3, [pc, #212]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 80044ce:	68db      	ldr	r3, [r3, #12]
 80044d0:	4a34      	ldr	r2, [pc, #208]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 80044d2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80044d6:	60d3      	str	r3, [r2, #12]

            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 80044d8:	f7fd fa86 	bl	80019e8 <HAL_GetTick>
 80044dc:	6138      	str	r0, [r7, #16]

            /* Wait till PLL is ready */
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 80044de:	e008      	b.n	80044f2 <HAL_RCC_OscConfig+0x772>
            {
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80044e0:	f7fd fa82 	bl	80019e8 <HAL_GetTick>
 80044e4:	4602      	mov	r2, r0
 80044e6:	693b      	ldr	r3, [r7, #16]
 80044e8:	1ad3      	subs	r3, r2, r3
 80044ea:	2b02      	cmp	r3, #2
 80044ec:	d901      	bls.n	80044f2 <HAL_RCC_OscConfig+0x772>
              {
                return HAL_TIMEOUT;
 80044ee:	2303      	movs	r3, #3
 80044f0:	e066      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 80044f2:	4b2c      	ldr	r3, [pc, #176]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 80044f4:	681b      	ldr	r3, [r3, #0]
 80044f6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80044fa:	2b00      	cmp	r3, #0
 80044fc:	d0f0      	beq.n	80044e0 <HAL_RCC_OscConfig+0x760>
        if(sysclk_source != RCC_CFGR_SWS_PLL)
 80044fe:	e05e      	b.n	80045be <HAL_RCC_OscConfig+0x83e>
          }
        }
        else
        {
          /* PLL is already used as System core clock */
          return HAL_ERROR;
 8004500:	2301      	movs	r3, #1
 8004502:	e05d      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
      }
      else
      {
        /* PLL configuration is unchanged */
        /* Re-enable PLL if it was disabled (ie. low power mode) */
        if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8004504:	4b27      	ldr	r3, [pc, #156]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004506:	681b      	ldr	r3, [r3, #0]
 8004508:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800450c:	2b00      	cmp	r3, #0
 800450e:	d156      	bne.n	80045be <HAL_RCC_OscConfig+0x83e>
        {
          /* Enable the main PLL. */
          __HAL_RCC_PLL_ENABLE();
 8004510:	4b24      	ldr	r3, [pc, #144]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004512:	681b      	ldr	r3, [r3, #0]
 8004514:	4a23      	ldr	r2, [pc, #140]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004516:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800451a:	6013      	str	r3, [r2, #0]

          /* Enable PLL System Clock output. */
          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 800451c:	4b21      	ldr	r3, [pc, #132]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 800451e:	68db      	ldr	r3, [r3, #12]
 8004520:	4a20      	ldr	r2, [pc, #128]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004522:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8004526:	60d3      	str	r3, [r2, #12]

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 8004528:	f7fd fa5e 	bl	80019e8 <HAL_GetTick>
 800452c:	6138      	str	r0, [r7, #16]

          /* Wait till PLL is ready */
          while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800452e:	e008      	b.n	8004542 <HAL_RCC_OscConfig+0x7c2>
          {
            if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8004530:	f7fd fa5a 	bl	80019e8 <HAL_GetTick>
 8004534:	4602      	mov	r2, r0
 8004536:	693b      	ldr	r3, [r7, #16]
 8004538:	1ad3      	subs	r3, r2, r3
 800453a:	2b02      	cmp	r3, #2
 800453c:	d901      	bls.n	8004542 <HAL_RCC_OscConfig+0x7c2>
            {
              return HAL_TIMEOUT;
 800453e:	2303      	movs	r3, #3
 8004540:	e03e      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
          while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8004542:	4b18      	ldr	r3, [pc, #96]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004544:	681b      	ldr	r3, [r3, #0]
 8004546:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800454a:	2b00      	cmp	r3, #0
 800454c:	d0f0      	beq.n	8004530 <HAL_RCC_OscConfig+0x7b0>
 800454e:	e036      	b.n	80045be <HAL_RCC_OscConfig+0x83e>
      }
    }
    else
    {
      /* Check that PLL is not used as system clock or not */
      if(sysclk_source != RCC_CFGR_SWS_PLL)
 8004550:	69bb      	ldr	r3, [r7, #24]
 8004552:	2b0c      	cmp	r3, #12
 8004554:	d031      	beq.n	80045ba <HAL_RCC_OscConfig+0x83a>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8004556:	4b13      	ldr	r3, [pc, #76]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004558:	681b      	ldr	r3, [r3, #0]
 800455a:	4a12      	ldr	r2, [pc, #72]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 800455c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8004560:	6013      	str	r3, [r2, #0]

        /* Disable all PLL outputs to save power if no PLLs on */
#if defined(RCC_PLLSAI1_SUPPORT) && defined(RCC_CR_PLLSAI2RDY)
        if(READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
 8004562:	4b10      	ldr	r3, [pc, #64]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004564:	681b      	ldr	r3, [r3, #0]
 8004566:	f003 5320 	and.w	r3, r3, #671088640	; 0x28000000
 800456a:	2b00      	cmp	r3, #0
 800456c:	d105      	bne.n	800457a <HAL_RCC_OscConfig+0x7fa>
        {
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 800456e:	4b0d      	ldr	r3, [pc, #52]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004570:	68db      	ldr	r3, [r3, #12]
 8004572:	4a0c      	ldr	r2, [pc, #48]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004574:	f023 0303 	bic.w	r3, r3, #3
 8004578:	60d3      	str	r3, [r2, #12]
#else
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
#endif /* RCC_PLLSAI1_SUPPORT && RCC_CR_PLLSAI2RDY */

#if defined(RCC_PLLSAI2_SUPPORT)
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 800457a:	4b0a      	ldr	r3, [pc, #40]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 800457c:	68db      	ldr	r3, [r3, #12]
 800457e:	4a09      	ldr	r2, [pc, #36]	; (80045a4 <HAL_RCC_OscConfig+0x824>)
 8004580:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8004584:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8004588:	60d3      	str	r3, [r2, #12]
#else
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK);
#endif /* RCC_PLLSAI2_SUPPORT */

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800458a:	f7fd fa2d 	bl	80019e8 <HAL_GetTick>
 800458e:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8004590:	e00c      	b.n	80045ac <HAL_RCC_OscConfig+0x82c>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8004592:	f7fd fa29 	bl	80019e8 <HAL_GetTick>
 8004596:	4602      	mov	r2, r0
 8004598:	693b      	ldr	r3, [r7, #16]
 800459a:	1ad3      	subs	r3, r2, r3
 800459c:	2b02      	cmp	r3, #2
 800459e:	d905      	bls.n	80045ac <HAL_RCC_OscConfig+0x82c>
          {
            return HAL_TIMEOUT;
 80045a0:	2303      	movs	r3, #3
 80045a2:	e00d      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
 80045a4:	40021000 	.word	0x40021000
 80045a8:	019d800c 	.word	0x019d800c
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80045ac:	4b06      	ldr	r3, [pc, #24]	; (80045c8 <HAL_RCC_OscConfig+0x848>)
 80045ae:	681b      	ldr	r3, [r3, #0]
 80045b0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80045b4:	2b00      	cmp	r3, #0
 80045b6:	d1ec      	bne.n	8004592 <HAL_RCC_OscConfig+0x812>
 80045b8:	e001      	b.n	80045be <HAL_RCC_OscConfig+0x83e>
        }
      }
      else
      {
        /* PLL is already used as System core clock */
        return HAL_ERROR;
 80045ba:	2301      	movs	r3, #1
 80045bc:	e000      	b.n	80045c0 <HAL_RCC_OscConfig+0x840>
      }
    }
  }
  return HAL_OK;
 80045be:	2300      	movs	r3, #0
}
 80045c0:	4618      	mov	r0, r3
 80045c2:	3720      	adds	r7, #32
 80045c4:	46bd      	mov	sp, r7
 80045c6:	bd80      	pop	{r7, pc}
 80045c8:	40021000 	.word	0x40021000

080045cc <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80045cc:	b580      	push	{r7, lr}
 80045ce:	b086      	sub	sp, #24
 80045d0:	af00      	add	r7, sp, #0
 80045d2:	6078      	str	r0, [r7, #4]
 80045d4:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  uint32_t hpre = RCC_SYSCLK_DIV1;
 80045d6:	2300      	movs	r3, #0
 80045d8:	617b      	str	r3, [r7, #20]
#endif
  HAL_StatusTypeDef status;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 80045da:	687b      	ldr	r3, [r7, #4]
 80045dc:	2b00      	cmp	r3, #0
 80045de:	d101      	bne.n	80045e4 <HAL_RCC_ClockConfig+0x18>
  {
    return HAL_ERROR;
 80045e0:	2301      	movs	r3, #1
 80045e2:	e10f      	b.n	8004804 <HAL_RCC_ClockConfig+0x238>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 80045e4:	4b89      	ldr	r3, [pc, #548]	; (800480c <HAL_RCC_ClockConfig+0x240>)
 80045e6:	681b      	ldr	r3, [r3, #0]
 80045e8:	f003 030f 	and.w	r3, r3, #15
 80045ec:	683a      	ldr	r2, [r7, #0]
 80045ee:	429a      	cmp	r2, r3
 80045f0:	d910      	bls.n	8004614 <HAL_RCC_ClockConfig+0x48>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80045f2:	4b86      	ldr	r3, [pc, #536]	; (800480c <HAL_RCC_ClockConfig+0x240>)
 80045f4:	681b      	ldr	r3, [r3, #0]
 80045f6:	f023 020f 	bic.w	r2, r3, #15
 80045fa:	4984      	ldr	r1, [pc, #528]	; (800480c <HAL_RCC_ClockConfig+0x240>)
 80045fc:	683b      	ldr	r3, [r7, #0]
 80045fe:	4313      	orrs	r3, r2
 8004600:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8004602:	4b82      	ldr	r3, [pc, #520]	; (800480c <HAL_RCC_ClockConfig+0x240>)
 8004604:	681b      	ldr	r3, [r3, #0]
 8004606:	f003 030f 	and.w	r3, r3, #15
 800460a:	683a      	ldr	r2, [r7, #0]
 800460c:	429a      	cmp	r2, r3
 800460e:	d001      	beq.n	8004614 <HAL_RCC_ClockConfig+0x48>
    {
      return HAL_ERROR;
 8004610:	2301      	movs	r3, #1
 8004612:	e0f7      	b.n	8004804 <HAL_RCC_ClockConfig+0x238>
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8004614:	687b      	ldr	r3, [r7, #4]
 8004616:	681b      	ldr	r3, [r3, #0]
 8004618:	f003 0301 	and.w	r3, r3, #1
 800461c:	2b00      	cmp	r3, #0
 800461e:	f000 8089 	beq.w	8004734 <HAL_RCC_ClockConfig+0x168>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* PLL is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8004622:	687b      	ldr	r3, [r7, #4]
 8004624:	685b      	ldr	r3, [r3, #4]
 8004626:	2b03      	cmp	r3, #3
 8004628:	d133      	bne.n	8004692 <HAL_RCC_ClockConfig+0xc6>
    {
      /* Check the PLL ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800462a:	4b79      	ldr	r3, [pc, #484]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 800462c:	681b      	ldr	r3, [r3, #0]
 800462e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8004632:	2b00      	cmp	r3, #0
 8004634:	d101      	bne.n	800463a <HAL_RCC_ClockConfig+0x6e>
      {
        return HAL_ERROR;
 8004636:	2301      	movs	r3, #1
 8004638:	e0e4      	b.n	8004804 <HAL_RCC_ClockConfig+0x238>
      }
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
      /* Undershoot management when selection PLL as SYSCLK source and frequency above 80Mhz */
      /* Compute target PLL output frequency */
      if(RCC_GetSysClockFreqFromPLLSource() > 80000000U)
 800463a:	f000 fa0f 	bl	8004a5c <RCC_GetSysClockFreqFromPLLSource>
 800463e:	4602      	mov	r2, r0
 8004640:	4b74      	ldr	r3, [pc, #464]	; (8004814 <HAL_RCC_ClockConfig+0x248>)
 8004642:	429a      	cmp	r2, r3
 8004644:	d955      	bls.n	80046f2 <HAL_RCC_ClockConfig+0x126>
      {
        if(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
 8004646:	4b72      	ldr	r3, [pc, #456]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 8004648:	689b      	ldr	r3, [r3, #8]
 800464a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800464e:	2b00      	cmp	r3, #0
 8004650:	d10a      	bne.n	8004668 <HAL_RCC_ClockConfig+0x9c>
        {
          /* Intermediate step with HCLK prescaler 2 necessary before to go over 80Mhz */
          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 8004652:	4b6f      	ldr	r3, [pc, #444]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 8004654:	689b      	ldr	r3, [r3, #8]
 8004656:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800465a:	4a6d      	ldr	r2, [pc, #436]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 800465c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004660:	6093      	str	r3, [r2, #8]
          hpre = RCC_SYSCLK_DIV2;
 8004662:	2380      	movs	r3, #128	; 0x80
 8004664:	617b      	str	r3, [r7, #20]
 8004666:	e044      	b.n	80046f2 <HAL_RCC_ClockConfig+0x126>
        }
        else if((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) && (RCC_ClkInitStruct->AHBCLKDivider == RCC_SYSCLK_DIV1))
 8004668:	687b      	ldr	r3, [r7, #4]
 800466a:	681b      	ldr	r3, [r3, #0]
 800466c:	f003 0302 	and.w	r3, r3, #2
 8004670:	2b00      	cmp	r3, #0
 8004672:	d03e      	beq.n	80046f2 <HAL_RCC_ClockConfig+0x126>
 8004674:	687b      	ldr	r3, [r7, #4]
 8004676:	689b      	ldr	r3, [r3, #8]
 8004678:	2b00      	cmp	r3, #0
 800467a:	d13a      	bne.n	80046f2 <HAL_RCC_ClockConfig+0x126>
        {
          /* Intermediate step with HCLK prescaler 2 necessary before to go over 80Mhz */
          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 800467c:	4b64      	ldr	r3, [pc, #400]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 800467e:	689b      	ldr	r3, [r3, #8]
 8004680:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8004684:	4a62      	ldr	r2, [pc, #392]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 8004686:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800468a:	6093      	str	r3, [r2, #8]
          hpre = RCC_SYSCLK_DIV2;
 800468c:	2380      	movs	r3, #128	; 0x80
 800468e:	617b      	str	r3, [r7, #20]
 8004690:	e02f      	b.n	80046f2 <HAL_RCC_ClockConfig+0x126>
#endif
    }
    else
    {
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8004692:	687b      	ldr	r3, [r7, #4]
 8004694:	685b      	ldr	r3, [r3, #4]
 8004696:	2b02      	cmp	r3, #2
 8004698:	d107      	bne.n	80046aa <HAL_RCC_ClockConfig+0xde>
      {
        /* Check the HSE ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800469a:	4b5d      	ldr	r3, [pc, #372]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 800469c:	681b      	ldr	r3, [r3, #0]
 800469e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80046a2:	2b00      	cmp	r3, #0
 80046a4:	d115      	bne.n	80046d2 <HAL_RCC_ClockConfig+0x106>
        {
          return HAL_ERROR;
 80046a6:	2301      	movs	r3, #1
 80046a8:	e0ac      	b.n	8004804 <HAL_RCC_ClockConfig+0x238>
        }
      }
      /* MSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 80046aa:	687b      	ldr	r3, [r7, #4]
 80046ac:	685b      	ldr	r3, [r3, #4]
 80046ae:	2b00      	cmp	r3, #0
 80046b0:	d107      	bne.n	80046c2 <HAL_RCC_ClockConfig+0xf6>
      {
        /* Check the MSI ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 80046b2:	4b57      	ldr	r3, [pc, #348]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 80046b4:	681b      	ldr	r3, [r3, #0]
 80046b6:	f003 0302 	and.w	r3, r3, #2
 80046ba:	2b00      	cmp	r3, #0
 80046bc:	d109      	bne.n	80046d2 <HAL_RCC_ClockConfig+0x106>
        {
          return HAL_ERROR;
 80046be:	2301      	movs	r3, #1
 80046c0:	e0a0      	b.n	8004804 <HAL_RCC_ClockConfig+0x238>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80046c2:	4b53      	ldr	r3, [pc, #332]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 80046c4:	681b      	ldr	r3, [r3, #0]
 80046c6:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80046ca:	2b00      	cmp	r3, #0
 80046cc:	d101      	bne.n	80046d2 <HAL_RCC_ClockConfig+0x106>
        {
          return HAL_ERROR;
 80046ce:	2301      	movs	r3, #1
 80046d0:	e098      	b.n	8004804 <HAL_RCC_ClockConfig+0x238>
        }
      }
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
      /* Overshoot management when going down from PLL as SYSCLK source and frequency above 80Mhz */
      if(HAL_RCC_GetSysClockFreq() > 80000000U)
 80046d2:	f000 f8a7 	bl	8004824 <HAL_RCC_GetSysClockFreq>
 80046d6:	4602      	mov	r2, r0
 80046d8:	4b4e      	ldr	r3, [pc, #312]	; (8004814 <HAL_RCC_ClockConfig+0x248>)
 80046da:	429a      	cmp	r2, r3
 80046dc:	d909      	bls.n	80046f2 <HAL_RCC_ClockConfig+0x126>
      {
        /* Intermediate step with HCLK prescaler 2 necessary before to go under 80Mhz */
        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 80046de:	4b4c      	ldr	r3, [pc, #304]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 80046e0:	689b      	ldr	r3, [r3, #8]
 80046e2:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80046e6:	4a4a      	ldr	r2, [pc, #296]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 80046e8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80046ec:	6093      	str	r3, [r2, #8]
        hpre = RCC_SYSCLK_DIV2;
 80046ee:	2380      	movs	r3, #128	; 0x80
 80046f0:	617b      	str	r3, [r7, #20]
      }
#endif

    }

    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 80046f2:	4b47      	ldr	r3, [pc, #284]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 80046f4:	689b      	ldr	r3, [r3, #8]
 80046f6:	f023 0203 	bic.w	r2, r3, #3
 80046fa:	687b      	ldr	r3, [r7, #4]
 80046fc:	685b      	ldr	r3, [r3, #4]
 80046fe:	4944      	ldr	r1, [pc, #272]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 8004700:	4313      	orrs	r3, r2
 8004702:	608b      	str	r3, [r1, #8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8004704:	f7fd f970 	bl	80019e8 <HAL_GetTick>
 8004708:	6138      	str	r0, [r7, #16]

    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800470a:	e00a      	b.n	8004722 <HAL_RCC_ClockConfig+0x156>
    {
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800470c:	f7fd f96c 	bl	80019e8 <HAL_GetTick>
 8004710:	4602      	mov	r2, r0
 8004712:	693b      	ldr	r3, [r7, #16]
 8004714:	1ad3      	subs	r3, r2, r3
 8004716:	f241 3288 	movw	r2, #5000	; 0x1388
 800471a:	4293      	cmp	r3, r2
 800471c:	d901      	bls.n	8004722 <HAL_RCC_ClockConfig+0x156>
      {
        return HAL_TIMEOUT;
 800471e:	2303      	movs	r3, #3
 8004720:	e070      	b.n	8004804 <HAL_RCC_ClockConfig+0x238>
    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8004722:	4b3b      	ldr	r3, [pc, #236]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 8004724:	689b      	ldr	r3, [r3, #8]
 8004726:	f003 020c 	and.w	r2, r3, #12
 800472a:	687b      	ldr	r3, [r7, #4]
 800472c:	685b      	ldr	r3, [r3, #4]
 800472e:	009b      	lsls	r3, r3, #2
 8004730:	429a      	cmp	r2, r3
 8004732:	d1eb      	bne.n	800470c <HAL_RCC_ClockConfig+0x140>
      }
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8004734:	687b      	ldr	r3, [r7, #4]
 8004736:	681b      	ldr	r3, [r3, #0]
 8004738:	f003 0302 	and.w	r3, r3, #2
 800473c:	2b00      	cmp	r3, #0
 800473e:	d009      	beq.n	8004754 <HAL_RCC_ClockConfig+0x188>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8004740:	4b33      	ldr	r3, [pc, #204]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 8004742:	689b      	ldr	r3, [r3, #8]
 8004744:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8004748:	687b      	ldr	r3, [r7, #4]
 800474a:	689b      	ldr	r3, [r3, #8]
 800474c:	4930      	ldr	r1, [pc, #192]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 800474e:	4313      	orrs	r3, r2
 8004750:	608b      	str	r3, [r1, #8]
 8004752:	e008      	b.n	8004766 <HAL_RCC_ClockConfig+0x19a>
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  else
  {
    /* Is intermediate HCLK prescaler 2 applied internally, complete with HCLK prescaler 1 */
    if(hpre == RCC_SYSCLK_DIV2)
 8004754:	697b      	ldr	r3, [r7, #20]
 8004756:	2b80      	cmp	r3, #128	; 0x80
 8004758:	d105      	bne.n	8004766 <HAL_RCC_ClockConfig+0x19a>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 800475a:	4b2d      	ldr	r3, [pc, #180]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 800475c:	689b      	ldr	r3, [r3, #8]
 800475e:	4a2c      	ldr	r2, [pc, #176]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 8004760:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8004764:	6093      	str	r3, [r2, #8]
    }
  }
#endif

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8004766:	4b29      	ldr	r3, [pc, #164]	; (800480c <HAL_RCC_ClockConfig+0x240>)
 8004768:	681b      	ldr	r3, [r3, #0]
 800476a:	f003 030f 	and.w	r3, r3, #15
 800476e:	683a      	ldr	r2, [r7, #0]
 8004770:	429a      	cmp	r2, r3
 8004772:	d210      	bcs.n	8004796 <HAL_RCC_ClockConfig+0x1ca>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004774:	4b25      	ldr	r3, [pc, #148]	; (800480c <HAL_RCC_ClockConfig+0x240>)
 8004776:	681b      	ldr	r3, [r3, #0]
 8004778:	f023 020f 	bic.w	r2, r3, #15
 800477c:	4923      	ldr	r1, [pc, #140]	; (800480c <HAL_RCC_ClockConfig+0x240>)
 800477e:	683b      	ldr	r3, [r7, #0]
 8004780:	4313      	orrs	r3, r2
 8004782:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8004784:	4b21      	ldr	r3, [pc, #132]	; (800480c <HAL_RCC_ClockConfig+0x240>)
 8004786:	681b      	ldr	r3, [r3, #0]
 8004788:	f003 030f 	and.w	r3, r3, #15
 800478c:	683a      	ldr	r2, [r7, #0]
 800478e:	429a      	cmp	r2, r3
 8004790:	d001      	beq.n	8004796 <HAL_RCC_ClockConfig+0x1ca>
    {
      return HAL_ERROR;
 8004792:	2301      	movs	r3, #1
 8004794:	e036      	b.n	8004804 <HAL_RCC_ClockConfig+0x238>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8004796:	687b      	ldr	r3, [r7, #4]
 8004798:	681b      	ldr	r3, [r3, #0]
 800479a:	f003 0304 	and.w	r3, r3, #4
 800479e:	2b00      	cmp	r3, #0
 80047a0:	d008      	beq.n	80047b4 <HAL_RCC_ClockConfig+0x1e8>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80047a2:	4b1b      	ldr	r3, [pc, #108]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 80047a4:	689b      	ldr	r3, [r3, #8]
 80047a6:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 80047aa:	687b      	ldr	r3, [r7, #4]
 80047ac:	68db      	ldr	r3, [r3, #12]
 80047ae:	4918      	ldr	r1, [pc, #96]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 80047b0:	4313      	orrs	r3, r2
 80047b2:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80047b4:	687b      	ldr	r3, [r7, #4]
 80047b6:	681b      	ldr	r3, [r3, #0]
 80047b8:	f003 0308 	and.w	r3, r3, #8
 80047bc:	2b00      	cmp	r3, #0
 80047be:	d009      	beq.n	80047d4 <HAL_RCC_ClockConfig+0x208>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 80047c0:	4b13      	ldr	r3, [pc, #76]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 80047c2:	689b      	ldr	r3, [r3, #8]
 80047c4:	f423 5260 	bic.w	r2, r3, #14336	; 0x3800
 80047c8:	687b      	ldr	r3, [r7, #4]
 80047ca:	691b      	ldr	r3, [r3, #16]
 80047cc:	00db      	lsls	r3, r3, #3
 80047ce:	4910      	ldr	r1, [pc, #64]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 80047d0:	4313      	orrs	r3, r2
 80047d2:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 80047d4:	f000 f826 	bl	8004824 <HAL_RCC_GetSysClockFreq>
 80047d8:	4601      	mov	r1, r0
 80047da:	4b0d      	ldr	r3, [pc, #52]	; (8004810 <HAL_RCC_ClockConfig+0x244>)
 80047dc:	689b      	ldr	r3, [r3, #8]
 80047de:	091b      	lsrs	r3, r3, #4
 80047e0:	f003 030f 	and.w	r3, r3, #15
 80047e4:	4a0c      	ldr	r2, [pc, #48]	; (8004818 <HAL_RCC_ClockConfig+0x24c>)
 80047e6:	5cd3      	ldrb	r3, [r2, r3]
 80047e8:	f003 031f 	and.w	r3, r3, #31
 80047ec:	fa21 f303 	lsr.w	r3, r1, r3
 80047f0:	4a0a      	ldr	r2, [pc, #40]	; (800481c <HAL_RCC_ClockConfig+0x250>)
 80047f2:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);
 80047f4:	4b0a      	ldr	r3, [pc, #40]	; (8004820 <HAL_RCC_ClockConfig+0x254>)
 80047f6:	681b      	ldr	r3, [r3, #0]
 80047f8:	4618      	mov	r0, r3
 80047fa:	f7fd f8a5 	bl	8001948 <HAL_InitTick>
 80047fe:	4603      	mov	r3, r0
 8004800:	73fb      	strb	r3, [r7, #15]

  return status;
 8004802:	7bfb      	ldrb	r3, [r7, #15]
}
 8004804:	4618      	mov	r0, r3
 8004806:	3718      	adds	r7, #24
 8004808:	46bd      	mov	sp, r7
 800480a:	bd80      	pop	{r7, pc}
 800480c:	40022000 	.word	0x40022000
 8004810:	40021000 	.word	0x40021000
 8004814:	04c4b400 	.word	0x04c4b400
 8004818:	0801ab88 	.word	0x0801ab88
 800481c:	20000000 	.word	0x20000000
 8004820:	20000004 	.word	0x20000004

08004824 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8004824:	b480      	push	{r7}
 8004826:	b089      	sub	sp, #36	; 0x24
 8004828:	af00      	add	r7, sp, #0
  uint32_t msirange = 0U, sysclockfreq = 0U;
 800482a:	2300      	movs	r3, #0
 800482c:	61fb      	str	r3, [r7, #28]
 800482e:	2300      	movs	r3, #0
 8004830:	61bb      	str	r3, [r7, #24]
  uint32_t pllvco, pllsource, pllr, pllm;    /* no init needed */
  uint32_t sysclk_source, pll_oscsource;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8004832:	4b3d      	ldr	r3, [pc, #244]	; (8004928 <HAL_RCC_GetSysClockFreq+0x104>)
 8004834:	689b      	ldr	r3, [r3, #8]
 8004836:	f003 030c 	and.w	r3, r3, #12
 800483a:	613b      	str	r3, [r7, #16]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 800483c:	4b3a      	ldr	r3, [pc, #232]	; (8004928 <HAL_RCC_GetSysClockFreq+0x104>)
 800483e:	68db      	ldr	r3, [r3, #12]
 8004840:	f003 0303 	and.w	r3, r3, #3
 8004844:	60fb      	str	r3, [r7, #12]

  if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8004846:	693b      	ldr	r3, [r7, #16]
 8004848:	2b00      	cmp	r3, #0
 800484a:	d005      	beq.n	8004858 <HAL_RCC_GetSysClockFreq+0x34>
 800484c:	693b      	ldr	r3, [r7, #16]
 800484e:	2b0c      	cmp	r3, #12
 8004850:	d121      	bne.n	8004896 <HAL_RCC_GetSysClockFreq+0x72>
     ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 8004852:	68fb      	ldr	r3, [r7, #12]
 8004854:	2b01      	cmp	r3, #1
 8004856:	d11e      	bne.n	8004896 <HAL_RCC_GetSysClockFreq+0x72>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8004858:	4b33      	ldr	r3, [pc, #204]	; (8004928 <HAL_RCC_GetSysClockFreq+0x104>)
 800485a:	681b      	ldr	r3, [r3, #0]
 800485c:	f003 0308 	and.w	r3, r3, #8
 8004860:	2b00      	cmp	r3, #0
 8004862:	d107      	bne.n	8004874 <HAL_RCC_GetSysClockFreq+0x50>
    { /* MSISRANGE from RCC_CSR applies */
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8004864:	4b30      	ldr	r3, [pc, #192]	; (8004928 <HAL_RCC_GetSysClockFreq+0x104>)
 8004866:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800486a:	0a1b      	lsrs	r3, r3, #8
 800486c:	f003 030f 	and.w	r3, r3, #15
 8004870:	61fb      	str	r3, [r7, #28]
 8004872:	e005      	b.n	8004880 <HAL_RCC_GetSysClockFreq+0x5c>
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8004874:	4b2c      	ldr	r3, [pc, #176]	; (8004928 <HAL_RCC_GetSysClockFreq+0x104>)
 8004876:	681b      	ldr	r3, [r3, #0]
 8004878:	091b      	lsrs	r3, r3, #4
 800487a:	f003 030f 	and.w	r3, r3, #15
 800487e:	61fb      	str	r3, [r7, #28]
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8004880:	4a2a      	ldr	r2, [pc, #168]	; (800492c <HAL_RCC_GetSysClockFreq+0x108>)
 8004882:	69fb      	ldr	r3, [r7, #28]
 8004884:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004888:	61fb      	str	r3, [r7, #28]

    if(sysclk_source == RCC_CFGR_SWS_MSI)
 800488a:	693b      	ldr	r3, [r7, #16]
 800488c:	2b00      	cmp	r3, #0
 800488e:	d10d      	bne.n	80048ac <HAL_RCC_GetSysClockFreq+0x88>
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
 8004890:	69fb      	ldr	r3, [r7, #28]
 8004892:	61bb      	str	r3, [r7, #24]
    if(sysclk_source == RCC_CFGR_SWS_MSI)
 8004894:	e00a      	b.n	80048ac <HAL_RCC_GetSysClockFreq+0x88>
    }
  }
  else if(sysclk_source == RCC_CFGR_SWS_HSI)
 8004896:	693b      	ldr	r3, [r7, #16]
 8004898:	2b04      	cmp	r3, #4
 800489a:	d102      	bne.n	80048a2 <HAL_RCC_GetSysClockFreq+0x7e>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 800489c:	4b24      	ldr	r3, [pc, #144]	; (8004930 <HAL_RCC_GetSysClockFreq+0x10c>)
 800489e:	61bb      	str	r3, [r7, #24]
 80048a0:	e004      	b.n	80048ac <HAL_RCC_GetSysClockFreq+0x88>
  }
  else if(sysclk_source == RCC_CFGR_SWS_HSE)
 80048a2:	693b      	ldr	r3, [r7, #16]
 80048a4:	2b08      	cmp	r3, #8
 80048a6:	d101      	bne.n	80048ac <HAL_RCC_GetSysClockFreq+0x88>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
 80048a8:	4b22      	ldr	r3, [pc, #136]	; (8004934 <HAL_RCC_GetSysClockFreq+0x110>)
 80048aa:	61bb      	str	r3, [r7, #24]
  else
  {
    /* unexpected case: sysclockfreq at 0 */
  }

  if(sysclk_source == RCC_CFGR_SWS_PLL)
 80048ac:	693b      	ldr	r3, [r7, #16]
 80048ae:	2b0c      	cmp	r3, #12
 80048b0:	d133      	bne.n	800491a <HAL_RCC_GetSysClockFreq+0xf6>
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE) * PLLN / PLLM
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 80048b2:	4b1d      	ldr	r3, [pc, #116]	; (8004928 <HAL_RCC_GetSysClockFreq+0x104>)
 80048b4:	68db      	ldr	r3, [r3, #12]
 80048b6:	f003 0303 	and.w	r3, r3, #3
 80048ba:	60bb      	str	r3, [r7, #8]

    switch (pllsource)
 80048bc:	68bb      	ldr	r3, [r7, #8]
 80048be:	2b02      	cmp	r3, #2
 80048c0:	d002      	beq.n	80048c8 <HAL_RCC_GetSysClockFreq+0xa4>
 80048c2:	2b03      	cmp	r3, #3
 80048c4:	d003      	beq.n	80048ce <HAL_RCC_GetSysClockFreq+0xaa>
 80048c6:	e005      	b.n	80048d4 <HAL_RCC_GetSysClockFreq+0xb0>
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = HSI_VALUE;
 80048c8:	4b19      	ldr	r3, [pc, #100]	; (8004930 <HAL_RCC_GetSysClockFreq+0x10c>)
 80048ca:	617b      	str	r3, [r7, #20]
      break;
 80048cc:	e005      	b.n	80048da <HAL_RCC_GetSysClockFreq+0xb6>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = HSE_VALUE;
 80048ce:	4b19      	ldr	r3, [pc, #100]	; (8004934 <HAL_RCC_GetSysClockFreq+0x110>)
 80048d0:	617b      	str	r3, [r7, #20]
      break;
 80048d2:	e002      	b.n	80048da <HAL_RCC_GetSysClockFreq+0xb6>

    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
    default:
      pllvco = msirange;
 80048d4:	69fb      	ldr	r3, [r7, #28]
 80048d6:	617b      	str	r3, [r7, #20]
      break;
 80048d8:	bf00      	nop
    }
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80048da:	4b13      	ldr	r3, [pc, #76]	; (8004928 <HAL_RCC_GetSysClockFreq+0x104>)
 80048dc:	68db      	ldr	r3, [r3, #12]
 80048de:	091b      	lsrs	r3, r3, #4
 80048e0:	f003 030f 	and.w	r3, r3, #15
 80048e4:	3301      	adds	r3, #1
 80048e6:	607b      	str	r3, [r7, #4]
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 80048e8:	4b0f      	ldr	r3, [pc, #60]	; (8004928 <HAL_RCC_GetSysClockFreq+0x104>)
 80048ea:	68db      	ldr	r3, [r3, #12]
 80048ec:	0a1b      	lsrs	r3, r3, #8
 80048ee:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80048f2:	697a      	ldr	r2, [r7, #20]
 80048f4:	fb02 f203 	mul.w	r2, r2, r3
 80048f8:	687b      	ldr	r3, [r7, #4]
 80048fa:	fbb2 f3f3 	udiv	r3, r2, r3
 80048fe:	617b      	str	r3, [r7, #20]
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8004900:	4b09      	ldr	r3, [pc, #36]	; (8004928 <HAL_RCC_GetSysClockFreq+0x104>)
 8004902:	68db      	ldr	r3, [r3, #12]
 8004904:	0e5b      	lsrs	r3, r3, #25
 8004906:	f003 0303 	and.w	r3, r3, #3
 800490a:	3301      	adds	r3, #1
 800490c:	005b      	lsls	r3, r3, #1
 800490e:	603b      	str	r3, [r7, #0]
    sysclockfreq = pllvco / pllr;
 8004910:	697a      	ldr	r2, [r7, #20]
 8004912:	683b      	ldr	r3, [r7, #0]
 8004914:	fbb2 f3f3 	udiv	r3, r2, r3
 8004918:	61bb      	str	r3, [r7, #24]
  }

  return sysclockfreq;
 800491a:	69bb      	ldr	r3, [r7, #24]
}
 800491c:	4618      	mov	r0, r3
 800491e:	3724      	adds	r7, #36	; 0x24
 8004920:	46bd      	mov	sp, r7
 8004922:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004926:	4770      	bx	lr
 8004928:	40021000 	.word	0x40021000
 800492c:	0801aba0 	.word	0x0801aba0
 8004930:	00f42400 	.word	0x00f42400
 8004934:	007a1200 	.word	0x007a1200

08004938 <HAL_RCC_GetHCLKFreq>:
  *
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8004938:	b480      	push	{r7}
 800493a:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 800493c:	4b03      	ldr	r3, [pc, #12]	; (800494c <HAL_RCC_GetHCLKFreq+0x14>)
 800493e:	681b      	ldr	r3, [r3, #0]
}
 8004940:	4618      	mov	r0, r3
 8004942:	46bd      	mov	sp, r7
 8004944:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004948:	4770      	bx	lr
 800494a:	bf00      	nop
 800494c:	20000000 	.word	0x20000000

08004950 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8004950:	b580      	push	{r7, lr}
 8004952:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8004954:	f7ff fff0 	bl	8004938 <HAL_RCC_GetHCLKFreq>
 8004958:	4601      	mov	r1, r0
 800495a:	4b06      	ldr	r3, [pc, #24]	; (8004974 <HAL_RCC_GetPCLK1Freq+0x24>)
 800495c:	689b      	ldr	r3, [r3, #8]
 800495e:	0a1b      	lsrs	r3, r3, #8
 8004960:	f003 0307 	and.w	r3, r3, #7
 8004964:	4a04      	ldr	r2, [pc, #16]	; (8004978 <HAL_RCC_GetPCLK1Freq+0x28>)
 8004966:	5cd3      	ldrb	r3, [r2, r3]
 8004968:	f003 031f 	and.w	r3, r3, #31
 800496c:	fa21 f303 	lsr.w	r3, r1, r3
}
 8004970:	4618      	mov	r0, r3
 8004972:	bd80      	pop	{r7, pc}
 8004974:	40021000 	.word	0x40021000
 8004978:	0801ab98 	.word	0x0801ab98

0800497c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800497c:	b580      	push	{r7, lr}
 800497e:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8004980:	f7ff ffda 	bl	8004938 <HAL_RCC_GetHCLKFreq>
 8004984:	4601      	mov	r1, r0
 8004986:	4b06      	ldr	r3, [pc, #24]	; (80049a0 <HAL_RCC_GetPCLK2Freq+0x24>)
 8004988:	689b      	ldr	r3, [r3, #8]
 800498a:	0adb      	lsrs	r3, r3, #11
 800498c:	f003 0307 	and.w	r3, r3, #7
 8004990:	4a04      	ldr	r2, [pc, #16]	; (80049a4 <HAL_RCC_GetPCLK2Freq+0x28>)
 8004992:	5cd3      	ldrb	r3, [r2, r3]
 8004994:	f003 031f 	and.w	r3, r3, #31
 8004998:	fa21 f303 	lsr.w	r3, r1, r3
}
 800499c:	4618      	mov	r0, r3
 800499e:	bd80      	pop	{r7, pc}
 80049a0:	40021000 	.word	0x40021000
 80049a4:	0801ab98 	.word	0x0801ab98

080049a8 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 80049a8:	b580      	push	{r7, lr}
 80049aa:	b086      	sub	sp, #24
 80049ac:	af00      	add	r7, sp, #0
 80049ae:	6078      	str	r0, [r7, #4]
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 80049b0:	2300      	movs	r3, #0
 80049b2:	613b      	str	r3, [r7, #16]

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 80049b4:	4b27      	ldr	r3, [pc, #156]	; (8004a54 <RCC_SetFlashLatencyFromMSIRange+0xac>)
 80049b6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80049b8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80049bc:	2b00      	cmp	r3, #0
 80049be:	d003      	beq.n	80049c8 <RCC_SetFlashLatencyFromMSIRange+0x20>
  {
    vos = HAL_PWREx_GetVoltageRange();
 80049c0:	f7ff f91a 	bl	8003bf8 <HAL_PWREx_GetVoltageRange>
 80049c4:	6178      	str	r0, [r7, #20]
 80049c6:	e014      	b.n	80049f2 <RCC_SetFlashLatencyFromMSIRange+0x4a>
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 80049c8:	4b22      	ldr	r3, [pc, #136]	; (8004a54 <RCC_SetFlashLatencyFromMSIRange+0xac>)
 80049ca:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80049cc:	4a21      	ldr	r2, [pc, #132]	; (8004a54 <RCC_SetFlashLatencyFromMSIRange+0xac>)
 80049ce:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80049d2:	6593      	str	r3, [r2, #88]	; 0x58
 80049d4:	4b1f      	ldr	r3, [pc, #124]	; (8004a54 <RCC_SetFlashLatencyFromMSIRange+0xac>)
 80049d6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80049d8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80049dc:	60fb      	str	r3, [r7, #12]
 80049de:	68fb      	ldr	r3, [r7, #12]
    vos = HAL_PWREx_GetVoltageRange();
 80049e0:	f7ff f90a 	bl	8003bf8 <HAL_PWREx_GetVoltageRange>
 80049e4:	6178      	str	r0, [r7, #20]
    __HAL_RCC_PWR_CLK_DISABLE();
 80049e6:	4b1b      	ldr	r3, [pc, #108]	; (8004a54 <RCC_SetFlashLatencyFromMSIRange+0xac>)
 80049e8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80049ea:	4a1a      	ldr	r2, [pc, #104]	; (8004a54 <RCC_SetFlashLatencyFromMSIRange+0xac>)
 80049ec:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80049f0:	6593      	str	r3, [r2, #88]	; 0x58
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 80049f2:	697b      	ldr	r3, [r7, #20]
 80049f4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80049f8:	d10b      	bne.n	8004a12 <RCC_SetFlashLatencyFromMSIRange+0x6a>
  {
    if(msirange > RCC_MSIRANGE_8)
 80049fa:	687b      	ldr	r3, [r7, #4]
 80049fc:	2b80      	cmp	r3, #128	; 0x80
 80049fe:	d913      	bls.n	8004a28 <RCC_SetFlashLatencyFromMSIRange+0x80>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
 8004a00:	687b      	ldr	r3, [r7, #4]
 8004a02:	2ba0      	cmp	r3, #160	; 0xa0
 8004a04:	d902      	bls.n	8004a0c <RCC_SetFlashLatencyFromMSIRange+0x64>
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 8004a06:	2302      	movs	r3, #2
 8004a08:	613b      	str	r3, [r7, #16]
 8004a0a:	e00d      	b.n	8004a28 <RCC_SetFlashLatencyFromMSIRange+0x80>
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 8004a0c:	2301      	movs	r3, #1
 8004a0e:	613b      	str	r3, [r7, #16]
 8004a10:	e00a      	b.n	8004a28 <RCC_SetFlashLatencyFromMSIRange+0x80>
  }
  else
  {
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    if(msirange >= RCC_MSIRANGE_8)
 8004a12:	687b      	ldr	r3, [r7, #4]
 8004a14:	2b7f      	cmp	r3, #127	; 0x7f
 8004a16:	d902      	bls.n	8004a1e <RCC_SetFlashLatencyFromMSIRange+0x76>
    {
      /* MSI >= 16Mhz */
      latency = FLASH_LATENCY_2; /* 2WS */
 8004a18:	2302      	movs	r3, #2
 8004a1a:	613b      	str	r3, [r7, #16]
 8004a1c:	e004      	b.n	8004a28 <RCC_SetFlashLatencyFromMSIRange+0x80>
    }
    else
    {
      if(msirange == RCC_MSIRANGE_7)
 8004a1e:	687b      	ldr	r3, [r7, #4]
 8004a20:	2b70      	cmp	r3, #112	; 0x70
 8004a22:	d101      	bne.n	8004a28 <RCC_SetFlashLatencyFromMSIRange+0x80>
      {
        /* MSI 8Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 8004a24:	2301      	movs	r3, #1
 8004a26:	613b      	str	r3, [r7, #16]
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#endif
  }

  __HAL_FLASH_SET_LATENCY(latency);
 8004a28:	4b0b      	ldr	r3, [pc, #44]	; (8004a58 <RCC_SetFlashLatencyFromMSIRange+0xb0>)
 8004a2a:	681b      	ldr	r3, [r3, #0]
 8004a2c:	f023 020f 	bic.w	r2, r3, #15
 8004a30:	4909      	ldr	r1, [pc, #36]	; (8004a58 <RCC_SetFlashLatencyFromMSIRange+0xb0>)
 8004a32:	693b      	ldr	r3, [r7, #16]
 8004a34:	4313      	orrs	r3, r2
 8004a36:	600b      	str	r3, [r1, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if(__HAL_FLASH_GET_LATENCY() != latency)
 8004a38:	4b07      	ldr	r3, [pc, #28]	; (8004a58 <RCC_SetFlashLatencyFromMSIRange+0xb0>)
 8004a3a:	681b      	ldr	r3, [r3, #0]
 8004a3c:	f003 030f 	and.w	r3, r3, #15
 8004a40:	693a      	ldr	r2, [r7, #16]
 8004a42:	429a      	cmp	r2, r3
 8004a44:	d001      	beq.n	8004a4a <RCC_SetFlashLatencyFromMSIRange+0xa2>
  {
    return HAL_ERROR;
 8004a46:	2301      	movs	r3, #1
 8004a48:	e000      	b.n	8004a4c <RCC_SetFlashLatencyFromMSIRange+0xa4>
  }

  return HAL_OK;
 8004a4a:	2300      	movs	r3, #0
}
 8004a4c:	4618      	mov	r0, r3
 8004a4e:	3718      	adds	r7, #24
 8004a50:	46bd      	mov	sp, r7
 8004a52:	bd80      	pop	{r7, pc}
 8004a54:	40021000 	.word	0x40021000
 8004a58:	40022000 	.word	0x40022000

08004a5c <RCC_GetSysClockFreqFromPLLSource>:
/**
  * @brief  Compute SYSCLK frequency based on PLL SYSCLK source.
  * @retval SYSCLK frequency
  */
static uint32_t RCC_GetSysClockFreqFromPLLSource(void)
{
 8004a5c:	b480      	push	{r7}
 8004a5e:	b087      	sub	sp, #28
 8004a60:	af00      	add	r7, sp, #0
  uint32_t msirange = 0U;
 8004a62:	2300      	movs	r3, #0
 8004a64:	617b      	str	r3, [r7, #20]
  uint32_t pllvco, pllsource, pllr, pllm, sysclockfreq;  /* no init needed */

  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)
 8004a66:	4b2d      	ldr	r3, [pc, #180]	; (8004b1c <RCC_GetSysClockFreqFromPLLSource+0xc0>)
 8004a68:	68db      	ldr	r3, [r3, #12]
 8004a6a:	f003 0303 	and.w	r3, r3, #3
 8004a6e:	2b01      	cmp	r3, #1
 8004a70:	d118      	bne.n	8004aa4 <RCC_GetSysClockFreqFromPLLSource+0x48>
  {
    /* Get MSI range source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8004a72:	4b2a      	ldr	r3, [pc, #168]	; (8004b1c <RCC_GetSysClockFreqFromPLLSource+0xc0>)
 8004a74:	681b      	ldr	r3, [r3, #0]
 8004a76:	f003 0308 	and.w	r3, r3, #8
 8004a7a:	2b00      	cmp	r3, #0
 8004a7c:	d107      	bne.n	8004a8e <RCC_GetSysClockFreqFromPLLSource+0x32>
    { /* MSISRANGE from RCC_CSR applies */
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8004a7e:	4b27      	ldr	r3, [pc, #156]	; (8004b1c <RCC_GetSysClockFreqFromPLLSource+0xc0>)
 8004a80:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8004a84:	0a1b      	lsrs	r3, r3, #8
 8004a86:	f003 030f 	and.w	r3, r3, #15
 8004a8a:	617b      	str	r3, [r7, #20]
 8004a8c:	e005      	b.n	8004a9a <RCC_GetSysClockFreqFromPLLSource+0x3e>
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8004a8e:	4b23      	ldr	r3, [pc, #140]	; (8004b1c <RCC_GetSysClockFreqFromPLLSource+0xc0>)
 8004a90:	681b      	ldr	r3, [r3, #0]
 8004a92:	091b      	lsrs	r3, r3, #4
 8004a94:	f003 030f 	and.w	r3, r3, #15
 8004a98:	617b      	str	r3, [r7, #20]
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8004a9a:	4a21      	ldr	r2, [pc, #132]	; (8004b20 <RCC_GetSysClockFreqFromPLLSource+0xc4>)
 8004a9c:	697b      	ldr	r3, [r7, #20]
 8004a9e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004aa2:	617b      	str	r3, [r7, #20]
  }

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE) * PLLN / PLLM
     SYSCLK = PLL_VCO / PLLR
   */
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8004aa4:	4b1d      	ldr	r3, [pc, #116]	; (8004b1c <RCC_GetSysClockFreqFromPLLSource+0xc0>)
 8004aa6:	68db      	ldr	r3, [r3, #12]
 8004aa8:	f003 0303 	and.w	r3, r3, #3
 8004aac:	60fb      	str	r3, [r7, #12]

  switch (pllsource)
 8004aae:	68fb      	ldr	r3, [r7, #12]
 8004ab0:	2b02      	cmp	r3, #2
 8004ab2:	d002      	beq.n	8004aba <RCC_GetSysClockFreqFromPLLSource+0x5e>
 8004ab4:	2b03      	cmp	r3, #3
 8004ab6:	d003      	beq.n	8004ac0 <RCC_GetSysClockFreqFromPLLSource+0x64>
 8004ab8:	e005      	b.n	8004ac6 <RCC_GetSysClockFreqFromPLLSource+0x6a>
  {
  case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
    pllvco = HSI_VALUE;
 8004aba:	4b1a      	ldr	r3, [pc, #104]	; (8004b24 <RCC_GetSysClockFreqFromPLLSource+0xc8>)
 8004abc:	613b      	str	r3, [r7, #16]
    break;
 8004abe:	e005      	b.n	8004acc <RCC_GetSysClockFreqFromPLLSource+0x70>

  case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
    pllvco = HSE_VALUE;
 8004ac0:	4b19      	ldr	r3, [pc, #100]	; (8004b28 <RCC_GetSysClockFreqFromPLLSource+0xcc>)
 8004ac2:	613b      	str	r3, [r7, #16]
    break;
 8004ac4:	e002      	b.n	8004acc <RCC_GetSysClockFreqFromPLLSource+0x70>

  case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
  default:
    pllvco = msirange;
 8004ac6:	697b      	ldr	r3, [r7, #20]
 8004ac8:	613b      	str	r3, [r7, #16]
    break;
 8004aca:	bf00      	nop
  }
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8004acc:	4b13      	ldr	r3, [pc, #76]	; (8004b1c <RCC_GetSysClockFreqFromPLLSource+0xc0>)
 8004ace:	68db      	ldr	r3, [r3, #12]
 8004ad0:	091b      	lsrs	r3, r3, #4
 8004ad2:	f003 030f 	and.w	r3, r3, #15
 8004ad6:	3301      	adds	r3, #1
 8004ad8:	60bb      	str	r3, [r7, #8]
  pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8004ada:	4b10      	ldr	r3, [pc, #64]	; (8004b1c <RCC_GetSysClockFreqFromPLLSource+0xc0>)
 8004adc:	68db      	ldr	r3, [r3, #12]
 8004ade:	0a1b      	lsrs	r3, r3, #8
 8004ae0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8004ae4:	693a      	ldr	r2, [r7, #16]
 8004ae6:	fb02 f203 	mul.w	r2, r2, r3
 8004aea:	68bb      	ldr	r3, [r7, #8]
 8004aec:	fbb2 f3f3 	udiv	r3, r2, r3
 8004af0:	613b      	str	r3, [r7, #16]
  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8004af2:	4b0a      	ldr	r3, [pc, #40]	; (8004b1c <RCC_GetSysClockFreqFromPLLSource+0xc0>)
 8004af4:	68db      	ldr	r3, [r3, #12]
 8004af6:	0e5b      	lsrs	r3, r3, #25
 8004af8:	f003 0303 	and.w	r3, r3, #3
 8004afc:	3301      	adds	r3, #1
 8004afe:	005b      	lsls	r3, r3, #1
 8004b00:	607b      	str	r3, [r7, #4]
  sysclockfreq = pllvco / pllr;
 8004b02:	693a      	ldr	r2, [r7, #16]
 8004b04:	687b      	ldr	r3, [r7, #4]
 8004b06:	fbb2 f3f3 	udiv	r3, r2, r3
 8004b0a:	603b      	str	r3, [r7, #0]

  return sysclockfreq;
 8004b0c:	683b      	ldr	r3, [r7, #0]
}
 8004b0e:	4618      	mov	r0, r3
 8004b10:	371c      	adds	r7, #28
 8004b12:	46bd      	mov	sp, r7
 8004b14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004b18:	4770      	bx	lr
 8004b1a:	bf00      	nop
 8004b1c:	40021000 	.word	0x40021000
 8004b20:	0801aba0 	.word	0x0801aba0
 8004b24:	00f42400 	.word	0x00f42400
 8004b28:	007a1200 	.word	0x007a1200

08004b2c <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8004b2c:	b580      	push	{r7, lr}
 8004b2e:	b086      	sub	sp, #24
 8004b30:	af00      	add	r7, sp, #0
 8004b32:	6078      	str	r0, [r7, #4]
  uint32_t tmpregister, tickstart;     /* no init needed */
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 8004b34:	2300      	movs	r3, #0
 8004b36:	74fb      	strb	r3, [r7, #19]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8004b38:	2300      	movs	r3, #0
 8004b3a:	74bb      	strb	r3, [r7, #18]
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

#if defined(SAI1)

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8004b3c:	687b      	ldr	r3, [r7, #4]
 8004b3e:	681b      	ldr	r3, [r3, #0]
 8004b40:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8004b44:	2b00      	cmp	r3, #0
 8004b46:	d03d      	beq.n	8004bc4 <HAL_RCCEx_PeriphCLKConfig+0x98>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));

    switch(PeriphClkInit->Sai1ClockSelection)
 8004b48:	687b      	ldr	r3, [r7, #4]
 8004b4a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8004b4c:	2b40      	cmp	r3, #64	; 0x40
 8004b4e:	d00b      	beq.n	8004b68 <HAL_RCCEx_PeriphCLKConfig+0x3c>
 8004b50:	2b40      	cmp	r3, #64	; 0x40
 8004b52:	d804      	bhi.n	8004b5e <HAL_RCCEx_PeriphCLKConfig+0x32>
 8004b54:	2b00      	cmp	r3, #0
 8004b56:	d00e      	beq.n	8004b76 <HAL_RCCEx_PeriphCLKConfig+0x4a>
 8004b58:	2b20      	cmp	r3, #32
 8004b5a:	d015      	beq.n	8004b88 <HAL_RCCEx_PeriphCLKConfig+0x5c>
 8004b5c:	e01d      	b.n	8004b9a <HAL_RCCEx_PeriphCLKConfig+0x6e>
 8004b5e:	2b60      	cmp	r3, #96	; 0x60
 8004b60:	d01e      	beq.n	8004ba0 <HAL_RCCEx_PeriphCLKConfig+0x74>
 8004b62:	2b80      	cmp	r3, #128	; 0x80
 8004b64:	d01c      	beq.n	8004ba0 <HAL_RCCEx_PeriphCLKConfig+0x74>
 8004b66:	e018      	b.n	8004b9a <HAL_RCCEx_PeriphCLKConfig+0x6e>
    {
    case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
      /* Enable SAI Clock output generated from System PLL . */
#if defined(RCC_PLLSAI2_SUPPORT)
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8004b68:	4b86      	ldr	r3, [pc, #536]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004b6a:	68db      	ldr	r3, [r3, #12]
 8004b6c:	4a85      	ldr	r2, [pc, #532]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004b6e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004b72:	60d3      	str	r3, [r2, #12]
#else
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI2CLK);
#endif /* RCC_PLLSAI2_SUPPORT */
      /* SAI1 clock source config set later after clock selection check */
      break;
 8004b74:	e015      	b.n	8004ba2 <HAL_RCCEx_PeriphCLKConfig+0x76>

    case RCC_SAI1CLKSOURCE_PLLSAI1:  /* PLLSAI1 is used as clock source for SAI1*/
      /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8004b76:	687b      	ldr	r3, [r7, #4]
 8004b78:	3304      	adds	r3, #4
 8004b7a:	2100      	movs	r1, #0
 8004b7c:	4618      	mov	r0, r3
 8004b7e:	f000 fb0d 	bl	800519c <RCCEx_PLLSAI1_Config>
 8004b82:	4603      	mov	r3, r0
 8004b84:	74fb      	strb	r3, [r7, #19]
      /* SAI1 clock source config set later after clock selection check */
      break;
 8004b86:	e00c      	b.n	8004ba2 <HAL_RCCEx_PeriphCLKConfig+0x76>

#if defined(RCC_PLLSAI2_SUPPORT)

    case RCC_SAI1CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI1*/
      /* PLLSAI2 input clock, parameters M, N & P configuration clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8004b88:	687b      	ldr	r3, [r7, #4]
 8004b8a:	3320      	adds	r3, #32
 8004b8c:	2100      	movs	r1, #0
 8004b8e:	4618      	mov	r0, r3
 8004b90:	f000 fbf4 	bl	800537c <RCCEx_PLLSAI2_Config>
 8004b94:	4603      	mov	r3, r0
 8004b96:	74fb      	strb	r3, [r7, #19]
      /* SAI1 clock source config set later after clock selection check */
      break;
 8004b98:	e003      	b.n	8004ba2 <HAL_RCCEx_PeriphCLKConfig+0x76>
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
      /* SAI1 clock source config set later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8004b9a:	2301      	movs	r3, #1
 8004b9c:	74fb      	strb	r3, [r7, #19]
      break;
 8004b9e:	e000      	b.n	8004ba2 <HAL_RCCEx_PeriphCLKConfig+0x76>
      break;
 8004ba0:	bf00      	nop
    }

    if(ret == HAL_OK)
 8004ba2:	7cfb      	ldrb	r3, [r7, #19]
 8004ba4:	2b00      	cmp	r3, #0
 8004ba6:	d10b      	bne.n	8004bc0 <HAL_RCCEx_PeriphCLKConfig+0x94>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8004ba8:	4b76      	ldr	r3, [pc, #472]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004baa:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8004bae:	f023 02e0 	bic.w	r2, r3, #224	; 0xe0
 8004bb2:	687b      	ldr	r3, [r7, #4]
 8004bb4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8004bb6:	4973      	ldr	r1, [pc, #460]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004bb8:	4313      	orrs	r3, r2
 8004bba:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
 8004bbe:	e001      	b.n	8004bc4 <HAL_RCCEx_PeriphCLKConfig+0x98>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8004bc0:	7cfb      	ldrb	r3, [r7, #19]
 8004bc2:	74bb      	strb	r3, [r7, #18]
#endif /* SAI1 */

#if defined(SAI2)

  /*-------------------------- SAI2 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 8004bc4:	687b      	ldr	r3, [r7, #4]
 8004bc6:	681b      	ldr	r3, [r3, #0]
 8004bc8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8004bcc:	2b00      	cmp	r3, #0
 8004bce:	d042      	beq.n	8004c56 <HAL_RCCEx_PeriphCLKConfig+0x12a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLK(PeriphClkInit->Sai2ClockSelection));

    switch(PeriphClkInit->Sai2ClockSelection)
 8004bd0:	687b      	ldr	r3, [r7, #4]
 8004bd2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004bd4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8004bd8:	d00f      	beq.n	8004bfa <HAL_RCCEx_PeriphCLKConfig+0xce>
 8004bda:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8004bde:	d805      	bhi.n	8004bec <HAL_RCCEx_PeriphCLKConfig+0xc0>
 8004be0:	2b00      	cmp	r3, #0
 8004be2:	d011      	beq.n	8004c08 <HAL_RCCEx_PeriphCLKConfig+0xdc>
 8004be4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8004be8:	d017      	beq.n	8004c1a <HAL_RCCEx_PeriphCLKConfig+0xee>
 8004bea:	e01f      	b.n	8004c2c <HAL_RCCEx_PeriphCLKConfig+0x100>
 8004bec:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8004bf0:	d01f      	beq.n	8004c32 <HAL_RCCEx_PeriphCLKConfig+0x106>
 8004bf2:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8004bf6:	d01c      	beq.n	8004c32 <HAL_RCCEx_PeriphCLKConfig+0x106>
 8004bf8:	e018      	b.n	8004c2c <HAL_RCCEx_PeriphCLKConfig+0x100>
    {
    case RCC_SAI2CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated from System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8004bfa:	4b62      	ldr	r3, [pc, #392]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004bfc:	68db      	ldr	r3, [r3, #12]
 8004bfe:	4a61      	ldr	r2, [pc, #388]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004c00:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004c04:	60d3      	str	r3, [r2, #12]
      /* SAI2 clock source config set later after clock selection check */
      break;
 8004c06:	e015      	b.n	8004c34 <HAL_RCCEx_PeriphCLKConfig+0x108>

    case RCC_SAI2CLKSOURCE_PLLSAI1: /* PLLSAI1 is used as clock source for SAI2*/
      /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8004c08:	687b      	ldr	r3, [r7, #4]
 8004c0a:	3304      	adds	r3, #4
 8004c0c:	2100      	movs	r1, #0
 8004c0e:	4618      	mov	r0, r3
 8004c10:	f000 fac4 	bl	800519c <RCCEx_PLLSAI1_Config>
 8004c14:	4603      	mov	r3, r0
 8004c16:	74fb      	strb	r3, [r7, #19]
      /* SAI2 clock source config set later after clock selection check */
      break;
 8004c18:	e00c      	b.n	8004c34 <HAL_RCCEx_PeriphCLKConfig+0x108>

    case RCC_SAI2CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI2*/
      /* PLLSAI2 input clock, parameters M, N & P configuration and clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8004c1a:	687b      	ldr	r3, [r7, #4]
 8004c1c:	3320      	adds	r3, #32
 8004c1e:	2100      	movs	r1, #0
 8004c20:	4618      	mov	r0, r3
 8004c22:	f000 fbab 	bl	800537c <RCCEx_PLLSAI2_Config>
 8004c26:	4603      	mov	r3, r0
 8004c28:	74fb      	strb	r3, [r7, #19]
      /* SAI2 clock source config set later after clock selection check */
      break;
 8004c2a:	e003      	b.n	8004c34 <HAL_RCCEx_PeriphCLKConfig+0x108>
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
      /* SAI2 clock source config set later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8004c2c:	2301      	movs	r3, #1
 8004c2e:	74fb      	strb	r3, [r7, #19]
      break;
 8004c30:	e000      	b.n	8004c34 <HAL_RCCEx_PeriphCLKConfig+0x108>
      break;
 8004c32:	bf00      	nop
    }

    if(ret == HAL_OK)
 8004c34:	7cfb      	ldrb	r3, [r7, #19]
 8004c36:	2b00      	cmp	r3, #0
 8004c38:	d10b      	bne.n	8004c52 <HAL_RCCEx_PeriphCLKConfig+0x126>
    {
      /* Set the source of SAI2 clock*/
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8004c3a:	4b52      	ldr	r3, [pc, #328]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004c3c:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8004c40:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8004c44:	687b      	ldr	r3, [r7, #4]
 8004c46:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004c48:	494e      	ldr	r1, [pc, #312]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004c4a:	4313      	orrs	r3, r2
 8004c4c:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
 8004c50:	e001      	b.n	8004c56 <HAL_RCCEx_PeriphCLKConfig+0x12a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8004c52:	7cfb      	ldrb	r3, [r7, #19]
 8004c54:	74bb      	strb	r3, [r7, #18]
    }
  }
#endif /* SAI2 */

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8004c56:	687b      	ldr	r3, [r7, #4]
 8004c58:	681b      	ldr	r3, [r3, #0]
 8004c5a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004c5e:	2b00      	cmp	r3, #0
 8004c60:	f000 809f 	beq.w	8004da2 <HAL_RCCEx_PeriphCLKConfig+0x276>
  {
    FlagStatus       pwrclkchanged = RESET;
 8004c64:	2300      	movs	r3, #0
 8004c66:	747b      	strb	r3, [r7, #17]

    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 8004c68:	4b46      	ldr	r3, [pc, #280]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004c6a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8004c6c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8004c70:	2b00      	cmp	r3, #0
 8004c72:	d101      	bne.n	8004c78 <HAL_RCCEx_PeriphCLKConfig+0x14c>
 8004c74:	2301      	movs	r3, #1
 8004c76:	e000      	b.n	8004c7a <HAL_RCCEx_PeriphCLKConfig+0x14e>
 8004c78:	2300      	movs	r3, #0
 8004c7a:	2b00      	cmp	r3, #0
 8004c7c:	d00d      	beq.n	8004c9a <HAL_RCCEx_PeriphCLKConfig+0x16e>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8004c7e:	4b41      	ldr	r3, [pc, #260]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004c80:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8004c82:	4a40      	ldr	r2, [pc, #256]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004c84:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8004c88:	6593      	str	r3, [r2, #88]	; 0x58
 8004c8a:	4b3e      	ldr	r3, [pc, #248]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004c8c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8004c8e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8004c92:	60bb      	str	r3, [r7, #8]
 8004c94:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 8004c96:	2301      	movs	r3, #1
 8004c98:	747b      	strb	r3, [r7, #17]
    }

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8004c9a:	4b3b      	ldr	r3, [pc, #236]	; (8004d88 <HAL_RCCEx_PeriphCLKConfig+0x25c>)
 8004c9c:	681b      	ldr	r3, [r3, #0]
 8004c9e:	4a3a      	ldr	r2, [pc, #232]	; (8004d88 <HAL_RCCEx_PeriphCLKConfig+0x25c>)
 8004ca0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004ca4:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8004ca6:	f7fc fe9f 	bl	80019e8 <HAL_GetTick>
 8004caa:	60f8      	str	r0, [r7, #12]

    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
 8004cac:	e009      	b.n	8004cc2 <HAL_RCCEx_PeriphCLKConfig+0x196>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8004cae:	f7fc fe9b 	bl	80019e8 <HAL_GetTick>
 8004cb2:	4602      	mov	r2, r0
 8004cb4:	68fb      	ldr	r3, [r7, #12]
 8004cb6:	1ad3      	subs	r3, r2, r3
 8004cb8:	2b02      	cmp	r3, #2
 8004cba:	d902      	bls.n	8004cc2 <HAL_RCCEx_PeriphCLKConfig+0x196>
      {
        ret = HAL_TIMEOUT;
 8004cbc:	2303      	movs	r3, #3
 8004cbe:	74fb      	strb	r3, [r7, #19]
        break;
 8004cc0:	e005      	b.n	8004cce <HAL_RCCEx_PeriphCLKConfig+0x1a2>
    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
 8004cc2:	4b31      	ldr	r3, [pc, #196]	; (8004d88 <HAL_RCCEx_PeriphCLKConfig+0x25c>)
 8004cc4:	681b      	ldr	r3, [r3, #0]
 8004cc6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004cca:	2b00      	cmp	r3, #0
 8004ccc:	d0ef      	beq.n	8004cae <HAL_RCCEx_PeriphCLKConfig+0x182>
      }
    }

    if(ret == HAL_OK)
 8004cce:	7cfb      	ldrb	r3, [r7, #19]
 8004cd0:	2b00      	cmp	r3, #0
 8004cd2:	d15b      	bne.n	8004d8c <HAL_RCCEx_PeriphCLKConfig+0x260>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8004cd4:	4b2b      	ldr	r3, [pc, #172]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004cd6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004cda:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8004cde:	617b      	str	r3, [r7, #20]

      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 8004ce0:	697b      	ldr	r3, [r7, #20]
 8004ce2:	2b00      	cmp	r3, #0
 8004ce4:	d01f      	beq.n	8004d26 <HAL_RCCEx_PeriphCLKConfig+0x1fa>
 8004ce6:	687b      	ldr	r3, [r7, #4]
 8004ce8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004cec:	697a      	ldr	r2, [r7, #20]
 8004cee:	429a      	cmp	r2, r3
 8004cf0:	d019      	beq.n	8004d26 <HAL_RCCEx_PeriphCLKConfig+0x1fa>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8004cf2:	4b24      	ldr	r3, [pc, #144]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004cf4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004cf8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8004cfc:	617b      	str	r3, [r7, #20]
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8004cfe:	4b21      	ldr	r3, [pc, #132]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004d00:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004d04:	4a1f      	ldr	r2, [pc, #124]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004d06:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004d0a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 8004d0e:	4b1d      	ldr	r3, [pc, #116]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004d10:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004d14:	4a1b      	ldr	r2, [pc, #108]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004d16:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8004d1a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 8004d1e:	4a19      	ldr	r2, [pc, #100]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004d20:	697b      	ldr	r3, [r7, #20]
 8004d22:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8004d26:	697b      	ldr	r3, [r7, #20]
 8004d28:	f003 0301 	and.w	r3, r3, #1
 8004d2c:	2b00      	cmp	r3, #0
 8004d2e:	d016      	beq.n	8004d5e <HAL_RCCEx_PeriphCLKConfig+0x232>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004d30:	f7fc fe5a 	bl	80019e8 <HAL_GetTick>
 8004d34:	60f8      	str	r0, [r7, #12]

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8004d36:	e00b      	b.n	8004d50 <HAL_RCCEx_PeriphCLKConfig+0x224>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004d38:	f7fc fe56 	bl	80019e8 <HAL_GetTick>
 8004d3c:	4602      	mov	r2, r0
 8004d3e:	68fb      	ldr	r3, [r7, #12]
 8004d40:	1ad3      	subs	r3, r2, r3
 8004d42:	f241 3288 	movw	r2, #5000	; 0x1388
 8004d46:	4293      	cmp	r3, r2
 8004d48:	d902      	bls.n	8004d50 <HAL_RCCEx_PeriphCLKConfig+0x224>
          {
            ret = HAL_TIMEOUT;
 8004d4a:	2303      	movs	r3, #3
 8004d4c:	74fb      	strb	r3, [r7, #19]
            break;
 8004d4e:	e006      	b.n	8004d5e <HAL_RCCEx_PeriphCLKConfig+0x232>
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8004d50:	4b0c      	ldr	r3, [pc, #48]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004d52:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004d56:	f003 0302 	and.w	r3, r3, #2
 8004d5a:	2b00      	cmp	r3, #0
 8004d5c:	d0ec      	beq.n	8004d38 <HAL_RCCEx_PeriphCLKConfig+0x20c>
          }
        }
      }

      if(ret == HAL_OK)
 8004d5e:	7cfb      	ldrb	r3, [r7, #19]
 8004d60:	2b00      	cmp	r3, #0
 8004d62:	d10c      	bne.n	8004d7e <HAL_RCCEx_PeriphCLKConfig+0x252>
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8004d64:	4b07      	ldr	r3, [pc, #28]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004d66:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004d6a:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8004d6e:	687b      	ldr	r3, [r7, #4]
 8004d70:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004d74:	4903      	ldr	r1, [pc, #12]	; (8004d84 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8004d76:	4313      	orrs	r3, r2
 8004d78:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
 8004d7c:	e008      	b.n	8004d90 <HAL_RCCEx_PeriphCLKConfig+0x264>
      }
      else
      {
        /* set overall return value */
        status = ret;
 8004d7e:	7cfb      	ldrb	r3, [r7, #19]
 8004d80:	74bb      	strb	r3, [r7, #18]
 8004d82:	e005      	b.n	8004d90 <HAL_RCCEx_PeriphCLKConfig+0x264>
 8004d84:	40021000 	.word	0x40021000
 8004d88:	40007000 	.word	0x40007000
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 8004d8c:	7cfb      	ldrb	r3, [r7, #19]
 8004d8e:	74bb      	strb	r3, [r7, #18]
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8004d90:	7c7b      	ldrb	r3, [r7, #17]
 8004d92:	2b01      	cmp	r3, #1
 8004d94:	d105      	bne.n	8004da2 <HAL_RCCEx_PeriphCLKConfig+0x276>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8004d96:	4ba0      	ldr	r3, [pc, #640]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004d98:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8004d9a:	4a9f      	ldr	r2, [pc, #636]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004d9c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8004da0:	6593      	str	r3, [r2, #88]	; 0x58
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8004da2:	687b      	ldr	r3, [r7, #4]
 8004da4:	681b      	ldr	r3, [r3, #0]
 8004da6:	f003 0301 	and.w	r3, r3, #1
 8004daa:	2b00      	cmp	r3, #0
 8004dac:	d00a      	beq.n	8004dc4 <HAL_RCCEx_PeriphCLKConfig+0x298>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8004dae:	4b9a      	ldr	r3, [pc, #616]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004db0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004db4:	f023 0203 	bic.w	r2, r3, #3
 8004db8:	687b      	ldr	r3, [r7, #4]
 8004dba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004dbc:	4996      	ldr	r1, [pc, #600]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004dbe:	4313      	orrs	r3, r2
 8004dc0:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8004dc4:	687b      	ldr	r3, [r7, #4]
 8004dc6:	681b      	ldr	r3, [r3, #0]
 8004dc8:	f003 0302 	and.w	r3, r3, #2
 8004dcc:	2b00      	cmp	r3, #0
 8004dce:	d00a      	beq.n	8004de6 <HAL_RCCEx_PeriphCLKConfig+0x2ba>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8004dd0:	4b91      	ldr	r3, [pc, #580]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004dd2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004dd6:	f023 020c 	bic.w	r2, r3, #12
 8004dda:	687b      	ldr	r3, [r7, #4]
 8004ddc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004dde:	498e      	ldr	r1, [pc, #568]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004de0:	4313      	orrs	r3, r2
 8004de2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

#if defined(USART3)

  /*-------------------------- USART3 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8004de6:	687b      	ldr	r3, [r7, #4]
 8004de8:	681b      	ldr	r3, [r3, #0]
 8004dea:	f003 0304 	and.w	r3, r3, #4
 8004dee:	2b00      	cmp	r3, #0
 8004df0:	d00a      	beq.n	8004e08 <HAL_RCCEx_PeriphCLKConfig+0x2dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8004df2:	4b89      	ldr	r3, [pc, #548]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004df4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004df8:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 8004dfc:	687b      	ldr	r3, [r7, #4]
 8004dfe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8004e00:	4985      	ldr	r1, [pc, #532]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004e02:	4313      	orrs	r3, r2
 8004e04:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
#endif /* USART3 */

#if defined(UART4)

  /*-------------------------- UART4 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8004e08:	687b      	ldr	r3, [r7, #4]
 8004e0a:	681b      	ldr	r3, [r3, #0]
 8004e0c:	f003 0308 	and.w	r3, r3, #8
 8004e10:	2b00      	cmp	r3, #0
 8004e12:	d00a      	beq.n	8004e2a <HAL_RCCEx_PeriphCLKConfig+0x2fe>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8004e14:	4b80      	ldr	r3, [pc, #512]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004e16:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004e1a:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
 8004e1e:	687b      	ldr	r3, [r7, #4]
 8004e20:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8004e22:	497d      	ldr	r1, [pc, #500]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004e24:	4313      	orrs	r3, r2
 8004e26:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
#endif /* UART4 */

#if defined(UART5)

  /*-------------------------- UART5 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8004e2a:	687b      	ldr	r3, [r7, #4]
 8004e2c:	681b      	ldr	r3, [r3, #0]
 8004e2e:	f003 0310 	and.w	r3, r3, #16
 8004e32:	2b00      	cmp	r3, #0
 8004e34:	d00a      	beq.n	8004e4c <HAL_RCCEx_PeriphCLKConfig+0x320>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8004e36:	4b78      	ldr	r3, [pc, #480]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004e38:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004e3c:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8004e40:	687b      	ldr	r3, [r7, #4]
 8004e42:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004e44:	4974      	ldr	r1, [pc, #464]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004e46:	4313      	orrs	r3, r2
 8004e48:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

#endif /* UART5 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8004e4c:	687b      	ldr	r3, [r7, #4]
 8004e4e:	681b      	ldr	r3, [r3, #0]
 8004e50:	f003 0320 	and.w	r3, r3, #32
 8004e54:	2b00      	cmp	r3, #0
 8004e56:	d00a      	beq.n	8004e6e <HAL_RCCEx_PeriphCLKConfig+0x342>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUART1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8004e58:	4b6f      	ldr	r3, [pc, #444]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004e5a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004e5e:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
 8004e62:	687b      	ldr	r3, [r7, #4]
 8004e64:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004e66:	496c      	ldr	r1, [pc, #432]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004e68:	4313      	orrs	r3, r2
 8004e6a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8004e6e:	687b      	ldr	r3, [r7, #4]
 8004e70:	681b      	ldr	r3, [r3, #0]
 8004e72:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8004e76:	2b00      	cmp	r3, #0
 8004e78:	d00a      	beq.n	8004e90 <HAL_RCCEx_PeriphCLKConfig+0x364>
  {
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8004e7a:	4b67      	ldr	r3, [pc, #412]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004e7c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004e80:	f423 2240 	bic.w	r2, r3, #786432	; 0xc0000
 8004e84:	687b      	ldr	r3, [r7, #4]
 8004e86:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004e88:	4963      	ldr	r1, [pc, #396]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004e8a:	4313      	orrs	r3, r2
 8004e8c:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8004e90:	687b      	ldr	r3, [r7, #4]
 8004e92:	681b      	ldr	r3, [r3, #0]
 8004e94:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8004e98:	2b00      	cmp	r3, #0
 8004e9a:	d00a      	beq.n	8004eb2 <HAL_RCCEx_PeriphCLKConfig+0x386>
  {
    assert_param(IS_RCC_LPTIM2CLK(PeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8004e9c:	4b5e      	ldr	r3, [pc, #376]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004e9e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004ea2:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8004ea6:	687b      	ldr	r3, [r7, #4]
 8004ea8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8004eaa:	495b      	ldr	r1, [pc, #364]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004eac:	4313      	orrs	r3, r2
 8004eae:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8004eb2:	687b      	ldr	r3, [r7, #4]
 8004eb4:	681b      	ldr	r3, [r3, #0]
 8004eb6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8004eba:	2b00      	cmp	r3, #0
 8004ebc:	d00a      	beq.n	8004ed4 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8004ebe:	4b56      	ldr	r3, [pc, #344]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004ec0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004ec4:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
 8004ec8:	687b      	ldr	r3, [r7, #4]
 8004eca:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004ecc:	4952      	ldr	r1, [pc, #328]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004ece:	4313      	orrs	r3, r2
 8004ed0:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

#if defined(I2C2)

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8004ed4:	687b      	ldr	r3, [r7, #4]
 8004ed6:	681b      	ldr	r3, [r3, #0]
 8004ed8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8004edc:	2b00      	cmp	r3, #0
 8004ede:	d00a      	beq.n	8004ef6 <HAL_RCCEx_PeriphCLKConfig+0x3ca>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8004ee0:	4b4d      	ldr	r3, [pc, #308]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004ee2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004ee6:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
 8004eea:	687b      	ldr	r3, [r7, #4]
 8004eec:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8004eee:	494a      	ldr	r1, [pc, #296]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004ef0:	4313      	orrs	r3, r2
 8004ef2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

#endif /* I2C2 */

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8004ef6:	687b      	ldr	r3, [r7, #4]
 8004ef8:	681b      	ldr	r3, [r3, #0]
 8004efa:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004efe:	2b00      	cmp	r3, #0
 8004f00:	d00a      	beq.n	8004f18 <HAL_RCCEx_PeriphCLKConfig+0x3ec>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8004f02:	4b45      	ldr	r3, [pc, #276]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004f04:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004f08:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 8004f0c:	687b      	ldr	r3, [r7, #4]
 8004f0e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004f10:	4941      	ldr	r1, [pc, #260]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004f12:	4313      	orrs	r3, r2
 8004f14:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

#if defined(I2C4)

  /*-------------------------- I2C4 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8004f18:	687b      	ldr	r3, [r7, #4]
 8004f1a:	681b      	ldr	r3, [r3, #0]
 8004f1c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8004f20:	2b00      	cmp	r3, #0
 8004f22:	d00a      	beq.n	8004f3a <HAL_RCCEx_PeriphCLKConfig+0x40e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8004f24:	4b3c      	ldr	r3, [pc, #240]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004f26:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8004f2a:	f023 0203 	bic.w	r2, r3, #3
 8004f2e:	687b      	ldr	r3, [r7, #4]
 8004f30:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004f32:	4939      	ldr	r1, [pc, #228]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004f34:	4313      	orrs	r3, r2
 8004f36:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
#endif /* I2C4 */

#if defined(USB_OTG_FS) || defined(USB)

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8004f3a:	687b      	ldr	r3, [r7, #4]
 8004f3c:	681b      	ldr	r3, [r3, #0]
 8004f3e:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8004f42:	2b00      	cmp	r3, #0
 8004f44:	d028      	beq.n	8004f98 <HAL_RCCEx_PeriphCLKConfig+0x46c>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8004f46:	4b34      	ldr	r3, [pc, #208]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004f48:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004f4c:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
 8004f50:	687b      	ldr	r3, [r7, #4]
 8004f52:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8004f54:	4930      	ldr	r1, [pc, #192]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004f56:	4313      	orrs	r3, r2
 8004f58:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8004f5c:	687b      	ldr	r3, [r7, #4]
 8004f5e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8004f60:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8004f64:	d106      	bne.n	8004f74 <HAL_RCCEx_PeriphCLKConfig+0x448>
    {
      /* Enable PLL48M1CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8004f66:	4b2c      	ldr	r3, [pc, #176]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004f68:	68db      	ldr	r3, [r3, #12]
 8004f6a:	4a2b      	ldr	r2, [pc, #172]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004f6c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8004f70:	60d3      	str	r3, [r2, #12]
 8004f72:	e011      	b.n	8004f98 <HAL_RCCEx_PeriphCLKConfig+0x46c>
    }
    else
    {
#if defined(RCC_PLLSAI1_SUPPORT)
      if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 8004f74:	687b      	ldr	r3, [r7, #4]
 8004f76:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8004f78:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8004f7c:	d10c      	bne.n	8004f98 <HAL_RCCEx_PeriphCLKConfig+0x46c>
      {
        /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8004f7e:	687b      	ldr	r3, [r7, #4]
 8004f80:	3304      	adds	r3, #4
 8004f82:	2101      	movs	r1, #1
 8004f84:	4618      	mov	r0, r3
 8004f86:	f000 f909 	bl	800519c <RCCEx_PLLSAI1_Config>
 8004f8a:	4603      	mov	r3, r0
 8004f8c:	74fb      	strb	r3, [r7, #19]

        if(ret != HAL_OK)
 8004f8e:	7cfb      	ldrb	r3, [r7, #19]
 8004f90:	2b00      	cmp	r3, #0
 8004f92:	d001      	beq.n	8004f98 <HAL_RCCEx_PeriphCLKConfig+0x46c>
        {
          /* set overall return value */
          status = ret;
 8004f94:	7cfb      	ldrb	r3, [r7, #19]
 8004f96:	74bb      	strb	r3, [r7, #18]
#endif /* USB_OTG_FS || USB */

#if defined(SDMMC1)

  /*-------------------------- SDMMC1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 8004f98:	687b      	ldr	r3, [r7, #4]
 8004f9a:	681b      	ldr	r3, [r3, #0]
 8004f9c:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8004fa0:	2b00      	cmp	r3, #0
 8004fa2:	d04d      	beq.n	8005040 <HAL_RCCEx_PeriphCLKConfig+0x514>
  {
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8004fa4:	687b      	ldr	r3, [r7, #4]
 8004fa6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8004fa8:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8004fac:	d108      	bne.n	8004fc0 <HAL_RCCEx_PeriphCLKConfig+0x494>
 8004fae:	4b1a      	ldr	r3, [pc, #104]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004fb0:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8004fb4:	4a18      	ldr	r2, [pc, #96]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004fb6:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8004fba:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
 8004fbe:	e012      	b.n	8004fe6 <HAL_RCCEx_PeriphCLKConfig+0x4ba>
 8004fc0:	4b15      	ldr	r3, [pc, #84]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004fc2:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8004fc6:	4a14      	ldr	r2, [pc, #80]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004fc8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8004fcc:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
 8004fd0:	4b11      	ldr	r3, [pc, #68]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004fd2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004fd6:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
 8004fda:	687b      	ldr	r3, [r7, #4]
 8004fdc:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8004fde:	490e      	ldr	r1, [pc, #56]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004fe0:	4313      	orrs	r3, r2
 8004fe2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 8004fe6:	687b      	ldr	r3, [r7, #4]
 8004fe8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8004fea:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8004fee:	d106      	bne.n	8004ffe <HAL_RCCEx_PeriphCLKConfig+0x4d2>
    {
      /* Enable PLL48M1CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8004ff0:	4b09      	ldr	r3, [pc, #36]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004ff2:	68db      	ldr	r3, [r3, #12]
 8004ff4:	4a08      	ldr	r2, [pc, #32]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 8004ff6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8004ffa:	60d3      	str	r3, [r2, #12]
 8004ffc:	e020      	b.n	8005040 <HAL_RCCEx_PeriphCLKConfig+0x514>
    }
#if defined(RCC_CCIPR2_SDMMCSEL)
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLP) /* PLL "P" ? */
 8004ffe:	687b      	ldr	r3, [r7, #4]
 8005000:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8005002:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8005006:	d109      	bne.n	800501c <HAL_RCCEx_PeriphCLKConfig+0x4f0>
    {
      /* Enable PLLSAI3CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8005008:	4b03      	ldr	r3, [pc, #12]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 800500a:	68db      	ldr	r3, [r3, #12]
 800500c:	4a02      	ldr	r2, [pc, #8]	; (8005018 <HAL_RCCEx_PeriphCLKConfig+0x4ec>)
 800500e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8005012:	60d3      	str	r3, [r2, #12]
 8005014:	e014      	b.n	8005040 <HAL_RCCEx_PeriphCLKConfig+0x514>
 8005016:	bf00      	nop
 8005018:	40021000 	.word	0x40021000
    }
#endif
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 800501c:	687b      	ldr	r3, [r7, #4]
 800501e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8005020:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8005024:	d10c      	bne.n	8005040 <HAL_RCCEx_PeriphCLKConfig+0x514>
    {
      /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8005026:	687b      	ldr	r3, [r7, #4]
 8005028:	3304      	adds	r3, #4
 800502a:	2101      	movs	r1, #1
 800502c:	4618      	mov	r0, r3
 800502e:	f000 f8b5 	bl	800519c <RCCEx_PLLSAI1_Config>
 8005032:	4603      	mov	r3, r0
 8005034:	74fb      	strb	r3, [r7, #19]

      if(ret != HAL_OK)
 8005036:	7cfb      	ldrb	r3, [r7, #19]
 8005038:	2b00      	cmp	r3, #0
 800503a:	d001      	beq.n	8005040 <HAL_RCCEx_PeriphCLKConfig+0x514>
      {
        /* set overall return value */
        status = ret;
 800503c:	7cfb      	ldrb	r3, [r7, #19]
 800503e:	74bb      	strb	r3, [r7, #18]
  }

#endif /* SDMMC1 */

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8005040:	687b      	ldr	r3, [r7, #4]
 8005042:	681b      	ldr	r3, [r3, #0]
 8005044:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8005048:	2b00      	cmp	r3, #0
 800504a:	d028      	beq.n	800509e <HAL_RCCEx_PeriphCLKConfig+0x572>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 800504c:	4b4a      	ldr	r3, [pc, #296]	; (8005178 <HAL_RCCEx_PeriphCLKConfig+0x64c>)
 800504e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005052:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
 8005056:	687b      	ldr	r3, [r7, #4]
 8005058:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800505a:	4947      	ldr	r1, [pc, #284]	; (8005178 <HAL_RCCEx_PeriphCLKConfig+0x64c>)
 800505c:	4313      	orrs	r3, r2
 800505e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8005062:	687b      	ldr	r3, [r7, #4]
 8005064:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8005066:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800506a:	d106      	bne.n	800507a <HAL_RCCEx_PeriphCLKConfig+0x54e>
    {
      /* Enable PLL48M1CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800506c:	4b42      	ldr	r3, [pc, #264]	; (8005178 <HAL_RCCEx_PeriphCLKConfig+0x64c>)
 800506e:	68db      	ldr	r3, [r3, #12]
 8005070:	4a41      	ldr	r2, [pc, #260]	; (8005178 <HAL_RCCEx_PeriphCLKConfig+0x64c>)
 8005072:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8005076:	60d3      	str	r3, [r2, #12]
 8005078:	e011      	b.n	800509e <HAL_RCCEx_PeriphCLKConfig+0x572>
    }
#if defined(RCC_PLLSAI1_SUPPORT)
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 800507a:	687b      	ldr	r3, [r7, #4]
 800507c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800507e:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8005082:	d10c      	bne.n	800509e <HAL_RCCEx_PeriphCLKConfig+0x572>
    {
      /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8005084:	687b      	ldr	r3, [r7, #4]
 8005086:	3304      	adds	r3, #4
 8005088:	2101      	movs	r1, #1
 800508a:	4618      	mov	r0, r3
 800508c:	f000 f886 	bl	800519c <RCCEx_PLLSAI1_Config>
 8005090:	4603      	mov	r3, r0
 8005092:	74fb      	strb	r3, [r7, #19]

      if(ret != HAL_OK)
 8005094:	7cfb      	ldrb	r3, [r7, #19]
 8005096:	2b00      	cmp	r3, #0
 8005098:	d001      	beq.n	800509e <HAL_RCCEx_PeriphCLKConfig+0x572>
      {
        /* set overall return value */
        status = ret;
 800509a:	7cfb      	ldrb	r3, [r7, #19]
 800509c:	74bb      	strb	r3, [r7, #18]
    }
  }

  /*-------------------------- ADC clock source configuration ----------------------*/
#if !defined(STM32L412xx) && !defined(STM32L422xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 800509e:	687b      	ldr	r3, [r7, #4]
 80050a0:	681b      	ldr	r3, [r3, #0]
 80050a2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80050a6:	2b00      	cmp	r3, #0
 80050a8:	d01e      	beq.n	80050e8 <HAL_RCCEx_PeriphCLKConfig+0x5bc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 80050aa:	4b33      	ldr	r3, [pc, #204]	; (8005178 <HAL_RCCEx_PeriphCLKConfig+0x64c>)
 80050ac:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80050b0:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
 80050b4:	687b      	ldr	r3, [r7, #4]
 80050b6:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80050ba:	492f      	ldr	r1, [pc, #188]	; (8005178 <HAL_RCCEx_PeriphCLKConfig+0x64c>)
 80050bc:	4313      	orrs	r3, r2
 80050be:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

#if defined(RCC_PLLSAI1_SUPPORT)
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 80050c2:	687b      	ldr	r3, [r7, #4]
 80050c4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80050c8:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 80050cc:	d10c      	bne.n	80050e8 <HAL_RCCEx_PeriphCLKConfig+0x5bc>
    {
      /* PLLSAI1 input clock, parameters M, N & R configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 80050ce:	687b      	ldr	r3, [r7, #4]
 80050d0:	3304      	adds	r3, #4
 80050d2:	2102      	movs	r1, #2
 80050d4:	4618      	mov	r0, r3
 80050d6:	f000 f861 	bl	800519c <RCCEx_PLLSAI1_Config>
 80050da:	4603      	mov	r3, r0
 80050dc:	74fb      	strb	r3, [r7, #19]

      if(ret != HAL_OK)
 80050de:	7cfb      	ldrb	r3, [r7, #19]
 80050e0:	2b00      	cmp	r3, #0
 80050e2:	d001      	beq.n	80050e8 <HAL_RCCEx_PeriphCLKConfig+0x5bc>
      {
        /* set overall return value */
        status = ret;
 80050e4:	7cfb      	ldrb	r3, [r7, #19]
 80050e6:	74bb      	strb	r3, [r7, #18]
#endif /* SWPMI1 */

#if defined(DFSDM1_Filter0)

  /*-------------------------- DFSDM1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 80050e8:	687b      	ldr	r3, [r7, #4]
 80050ea:	681b      	ldr	r3, [r3, #0]
 80050ec:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80050f0:	2b00      	cmp	r3, #0
 80050f2:	d00b      	beq.n	800510c <HAL_RCCEx_PeriphCLKConfig+0x5e0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 80050f4:	4b20      	ldr	r3, [pc, #128]	; (8005178 <HAL_RCCEx_PeriphCLKConfig+0x64c>)
 80050f6:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80050fa:	f023 0204 	bic.w	r2, r3, #4
 80050fe:	687b      	ldr	r3, [r7, #4]
 8005100:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8005104:	491c      	ldr	r1, [pc, #112]	; (8005178 <HAL_RCCEx_PeriphCLKConfig+0x64c>)
 8005106:	4313      	orrs	r3, r2
 8005108:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
  }

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  /*-------------------------- DFSDM1 audio clock source configuration -------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1AUDIO) == RCC_PERIPHCLK_DFSDM1AUDIO)
 800510c:	687b      	ldr	r3, [r7, #4]
 800510e:	681b      	ldr	r3, [r3, #0]
 8005110:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8005114:	2b00      	cmp	r3, #0
 8005116:	d00b      	beq.n	8005130 <HAL_RCCEx_PeriphCLKConfig+0x604>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1AUDIOCLKSOURCE(PeriphClkInit->Dfsdm1AudioClockSelection));

    /* Configure the DFSDM1 interface audio clock source */
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 8005118:	4b17      	ldr	r3, [pc, #92]	; (8005178 <HAL_RCCEx_PeriphCLKConfig+0x64c>)
 800511a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800511e:	f023 0218 	bic.w	r2, r3, #24
 8005122:	687b      	ldr	r3, [r7, #4]
 8005124:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005128:	4913      	ldr	r1, [pc, #76]	; (8005178 <HAL_RCCEx_PeriphCLKConfig+0x64c>)
 800512a:	4313      	orrs	r3, r2
 800512c:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
#endif /* DSI */

#if defined(OCTOSPI1) || defined(OCTOSPI2)

  /*-------------------------- OctoSPIx clock source configuration ----------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
 8005130:	687b      	ldr	r3, [r7, #4]
 8005132:	681b      	ldr	r3, [r3, #0]
 8005134:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8005138:	2b00      	cmp	r3, #0
 800513a:	d017      	beq.n	800516c <HAL_RCCEx_PeriphCLKConfig+0x640>
  {
    /* Check the parameters */
    assert_param(IS_RCC_OSPICLKSOURCE(PeriphClkInit->OspiClockSelection));

    /* Configure the OctoSPI clock source */
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 800513c:	4b0e      	ldr	r3, [pc, #56]	; (8005178 <HAL_RCCEx_PeriphCLKConfig+0x64c>)
 800513e:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8005142:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8005146:	687b      	ldr	r3, [r7, #4]
 8005148:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800514c:	490a      	ldr	r1, [pc, #40]	; (8005178 <HAL_RCCEx_PeriphCLKConfig+0x64c>)
 800514e:	4313      	orrs	r3, r2
 8005150:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c

    if(PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
 8005154:	687b      	ldr	r3, [r7, #4]
 8005156:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800515a:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 800515e:	d105      	bne.n	800516c <HAL_RCCEx_PeriphCLKConfig+0x640>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8005160:	4b05      	ldr	r3, [pc, #20]	; (8005178 <HAL_RCCEx_PeriphCLKConfig+0x64c>)
 8005162:	68db      	ldr	r3, [r3, #12]
 8005164:	4a04      	ldr	r2, [pc, #16]	; (8005178 <HAL_RCCEx_PeriphCLKConfig+0x64c>)
 8005166:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800516a:	60d3      	str	r3, [r2, #12]
    }
  }

#endif /* OCTOSPI1 || OCTOSPI2 */

  return status;
 800516c:	7cbb      	ldrb	r3, [r7, #18]
}
 800516e:	4618      	mov	r0, r3
 8005170:	3718      	adds	r7, #24
 8005172:	46bd      	mov	sp, r7
 8005174:	bd80      	pop	{r7, pc}
 8005176:	bf00      	nop
 8005178:	40021000 	.word	0x40021000

0800517c <HAL_RCCEx_EnableMSIPLLMode>:
  * @note   Prior to enable the PLL-mode of the MSI for automatic hardware
  *         calibration LSE oscillator is to be enabled with HAL_RCC_OscConfig().
  * @retval None
  */
void HAL_RCCEx_EnableMSIPLLMode(void)
{
 800517c:	b480      	push	{r7}
 800517e:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_MSIPLLEN) ;
 8005180:	4b05      	ldr	r3, [pc, #20]	; (8005198 <HAL_RCCEx_EnableMSIPLLMode+0x1c>)
 8005182:	681b      	ldr	r3, [r3, #0]
 8005184:	4a04      	ldr	r2, [pc, #16]	; (8005198 <HAL_RCCEx_EnableMSIPLLMode+0x1c>)
 8005186:	f043 0304 	orr.w	r3, r3, #4
 800518a:	6013      	str	r3, [r2, #0]
}
 800518c:	bf00      	nop
 800518e:	46bd      	mov	sp, r7
 8005190:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005194:	4770      	bx	lr
 8005196:	bf00      	nop
 8005198:	40021000 	.word	0x40021000

0800519c <RCCEx_PLLSAI1_Config>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
{
 800519c:	b580      	push	{r7, lr}
 800519e:	b084      	sub	sp, #16
 80051a0:	af00      	add	r7, sp, #0
 80051a2:	6078      	str	r0, [r7, #4]
 80051a4:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 80051a6:	2300      	movs	r3, #0
 80051a8:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 80051aa:	4b70      	ldr	r3, [pc, #448]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 80051ac:	68db      	ldr	r3, [r3, #12]
 80051ae:	f003 0303 	and.w	r3, r3, #3
 80051b2:	2b00      	cmp	r3, #0
 80051b4:	d00e      	beq.n	80051d4 <RCCEx_PLLSAI1_Config+0x38>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
 80051b6:	4b6d      	ldr	r3, [pc, #436]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 80051b8:	68db      	ldr	r3, [r3, #12]
 80051ba:	f003 0203 	and.w	r2, r3, #3
 80051be:	687b      	ldr	r3, [r7, #4]
 80051c0:	681b      	ldr	r3, [r3, #0]
 80051c2:	429a      	cmp	r2, r3
 80051c4:	d103      	bne.n	80051ce <RCCEx_PLLSAI1_Config+0x32>
       ||
       (PllSai1->PLLSAI1Source == RCC_PLLSOURCE_NONE)
 80051c6:	687b      	ldr	r3, [r7, #4]
 80051c8:	681b      	ldr	r3, [r3, #0]
       ||
 80051ca:	2b00      	cmp	r3, #0
 80051cc:	d13f      	bne.n	800524e <RCCEx_PLLSAI1_Config+0xb2>
       ||
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
#endif
      )
    {
      status = HAL_ERROR;
 80051ce:	2301      	movs	r3, #1
 80051d0:	73fb      	strb	r3, [r7, #15]
 80051d2:	e03c      	b.n	800524e <RCCEx_PLLSAI1_Config+0xb2>
    }
  }
  else
  {
    /* Check PLLSAI1 clock source availability */
    switch(PllSai1->PLLSAI1Source)
 80051d4:	687b      	ldr	r3, [r7, #4]
 80051d6:	681b      	ldr	r3, [r3, #0]
 80051d8:	2b02      	cmp	r3, #2
 80051da:	d00c      	beq.n	80051f6 <RCCEx_PLLSAI1_Config+0x5a>
 80051dc:	2b03      	cmp	r3, #3
 80051de:	d013      	beq.n	8005208 <RCCEx_PLLSAI1_Config+0x6c>
 80051e0:	2b01      	cmp	r3, #1
 80051e2:	d120      	bne.n	8005226 <RCCEx_PLLSAI1_Config+0x8a>
    {
    case RCC_PLLSOURCE_MSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 80051e4:	4b61      	ldr	r3, [pc, #388]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 80051e6:	681b      	ldr	r3, [r3, #0]
 80051e8:	f003 0302 	and.w	r3, r3, #2
 80051ec:	2b00      	cmp	r3, #0
 80051ee:	d11d      	bne.n	800522c <RCCEx_PLLSAI1_Config+0x90>
      {
        status = HAL_ERROR;
 80051f0:	2301      	movs	r3, #1
 80051f2:	73fb      	strb	r3, [r7, #15]
      }
      break;
 80051f4:	e01a      	b.n	800522c <RCCEx_PLLSAI1_Config+0x90>
    case RCC_PLLSOURCE_HSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 80051f6:	4b5d      	ldr	r3, [pc, #372]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 80051f8:	681b      	ldr	r3, [r3, #0]
 80051fa:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80051fe:	2b00      	cmp	r3, #0
 8005200:	d116      	bne.n	8005230 <RCCEx_PLLSAI1_Config+0x94>
      {
        status = HAL_ERROR;
 8005202:	2301      	movs	r3, #1
 8005204:	73fb      	strb	r3, [r7, #15]
      }
      break;
 8005206:	e013      	b.n	8005230 <RCCEx_PLLSAI1_Config+0x94>
    case RCC_PLLSOURCE_HSE:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 8005208:	4b58      	ldr	r3, [pc, #352]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 800520a:	681b      	ldr	r3, [r3, #0]
 800520c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8005210:	2b00      	cmp	r3, #0
 8005212:	d10f      	bne.n	8005234 <RCCEx_PLLSAI1_Config+0x98>
      {
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8005214:	4b55      	ldr	r3, [pc, #340]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 8005216:	681b      	ldr	r3, [r3, #0]
 8005218:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800521c:	2b00      	cmp	r3, #0
 800521e:	d109      	bne.n	8005234 <RCCEx_PLLSAI1_Config+0x98>
        {
          status = HAL_ERROR;
 8005220:	2301      	movs	r3, #1
 8005222:	73fb      	strb	r3, [r7, #15]
        }
      }
      break;
 8005224:	e006      	b.n	8005234 <RCCEx_PLLSAI1_Config+0x98>
    default:
      status = HAL_ERROR;
 8005226:	2301      	movs	r3, #1
 8005228:	73fb      	strb	r3, [r7, #15]
      break;
 800522a:	e004      	b.n	8005236 <RCCEx_PLLSAI1_Config+0x9a>
      break;
 800522c:	bf00      	nop
 800522e:	e002      	b.n	8005236 <RCCEx_PLLSAI1_Config+0x9a>
      break;
 8005230:	bf00      	nop
 8005232:	e000      	b.n	8005236 <RCCEx_PLLSAI1_Config+0x9a>
      break;
 8005234:	bf00      	nop
    }

    if(status == HAL_OK)
 8005236:	7bfb      	ldrb	r3, [r7, #15]
 8005238:	2b00      	cmp	r3, #0
 800523a:	d108      	bne.n	800524e <RCCEx_PLLSAI1_Config+0xb2>
    {
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
      /* Set PLLSAI1 clock source */
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai1->PLLSAI1Source);
 800523c:	4b4b      	ldr	r3, [pc, #300]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 800523e:	68db      	ldr	r3, [r3, #12]
 8005240:	f023 0203 	bic.w	r2, r3, #3
 8005244:	687b      	ldr	r3, [r7, #4]
 8005246:	681b      	ldr	r3, [r3, #0]
 8005248:	4948      	ldr	r1, [pc, #288]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 800524a:	4313      	orrs	r3, r2
 800524c:	60cb      	str	r3, [r1, #12]
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai1->PLLSAI1Source | (PllSai1->PLLSAI1M - 1U) << RCC_PLLCFGR_PLLM_Pos);
#endif
    }
  }

  if(status == HAL_OK)
 800524e:	7bfb      	ldrb	r3, [r7, #15]
 8005250:	2b00      	cmp	r3, #0
 8005252:	f040 8086 	bne.w	8005362 <RCCEx_PLLSAI1_Config+0x1c6>
  {
    /* Disable the PLLSAI1 */
    __HAL_RCC_PLLSAI1_DISABLE();
 8005256:	4b45      	ldr	r3, [pc, #276]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 8005258:	681b      	ldr	r3, [r3, #0]
 800525a:	4a44      	ldr	r2, [pc, #272]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 800525c:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8005260:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8005262:	f7fc fbc1 	bl	80019e8 <HAL_GetTick>
 8005266:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI1 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 8005268:	e009      	b.n	800527e <RCCEx_PLLSAI1_Config+0xe2>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800526a:	f7fc fbbd 	bl	80019e8 <HAL_GetTick>
 800526e:	4602      	mov	r2, r0
 8005270:	68bb      	ldr	r3, [r7, #8]
 8005272:	1ad3      	subs	r3, r2, r3
 8005274:	2b02      	cmp	r3, #2
 8005276:	d902      	bls.n	800527e <RCCEx_PLLSAI1_Config+0xe2>
      {
        status = HAL_TIMEOUT;
 8005278:	2303      	movs	r3, #3
 800527a:	73fb      	strb	r3, [r7, #15]
        break;
 800527c:	e005      	b.n	800528a <RCCEx_PLLSAI1_Config+0xee>
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 800527e:	4b3b      	ldr	r3, [pc, #236]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 8005280:	681b      	ldr	r3, [r3, #0]
 8005282:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8005286:	2b00      	cmp	r3, #0
 8005288:	d1ef      	bne.n	800526a <RCCEx_PLLSAI1_Config+0xce>
      }
    }

    if(status == HAL_OK)
 800528a:	7bfb      	ldrb	r3, [r7, #15]
 800528c:	2b00      	cmp	r3, #0
 800528e:	d168      	bne.n	8005362 <RCCEx_PLLSAI1_Config+0x1c6>
    {
      if(Divider == DIVIDER_P_UPDATE)
 8005290:	683b      	ldr	r3, [r7, #0]
 8005292:	2b00      	cmp	r3, #0
 8005294:	d113      	bne.n	80052be <RCCEx_PLLSAI1_Config+0x122>
        assert_param(IS_RCC_PLLSAI1P_VALUE(PllSai1->PLLSAI1P));
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)

        /* Configure the PLLSAI1 Division factor M, P and Multiplication factor N*/
#if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8005296:	4b35      	ldr	r3, [pc, #212]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 8005298:	691a      	ldr	r2, [r3, #16]
 800529a:	4b35      	ldr	r3, [pc, #212]	; (8005370 <RCCEx_PLLSAI1_Config+0x1d4>)
 800529c:	4013      	ands	r3, r2
 800529e:	687a      	ldr	r2, [r7, #4]
 80052a0:	6892      	ldr	r2, [r2, #8]
 80052a2:	0211      	lsls	r1, r2, #8
 80052a4:	687a      	ldr	r2, [r7, #4]
 80052a6:	68d2      	ldr	r2, [r2, #12]
 80052a8:	06d2      	lsls	r2, r2, #27
 80052aa:	4311      	orrs	r1, r2
 80052ac:	687a      	ldr	r2, [r7, #4]
 80052ae:	6852      	ldr	r2, [r2, #4]
 80052b0:	3a01      	subs	r2, #1
 80052b2:	0112      	lsls	r2, r2, #4
 80052b4:	430a      	orrs	r2, r1
 80052b6:	492d      	ldr	r1, [pc, #180]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 80052b8:	4313      	orrs	r3, r2
 80052ba:	610b      	str	r3, [r1, #16]
 80052bc:	e02d      	b.n	800531a <RCCEx_PLLSAI1_Config+0x17e>
                   ((PllSai1->PLLSAI1P >> 4U) << RCC_PLLSAI1CFGR_PLLSAI1P_Pos));
#endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */

#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }
      else if(Divider == DIVIDER_Q_UPDATE)
 80052be:	683b      	ldr	r3, [r7, #0]
 80052c0:	2b01      	cmp	r3, #1
 80052c2:	d115      	bne.n	80052f0 <RCCEx_PLLSAI1_Config+0x154>
      {
        assert_param(IS_RCC_PLLSAI1Q_VALUE(PllSai1->PLLSAI1Q));
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI1 Division factor M, Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80052c4:	4b29      	ldr	r3, [pc, #164]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 80052c6:	691a      	ldr	r2, [r3, #16]
 80052c8:	4b2a      	ldr	r3, [pc, #168]	; (8005374 <RCCEx_PLLSAI1_Config+0x1d8>)
 80052ca:	4013      	ands	r3, r2
 80052cc:	687a      	ldr	r2, [r7, #4]
 80052ce:	6892      	ldr	r2, [r2, #8]
 80052d0:	0211      	lsls	r1, r2, #8
 80052d2:	687a      	ldr	r2, [r7, #4]
 80052d4:	6912      	ldr	r2, [r2, #16]
 80052d6:	0852      	lsrs	r2, r2, #1
 80052d8:	3a01      	subs	r2, #1
 80052da:	0552      	lsls	r2, r2, #21
 80052dc:	4311      	orrs	r1, r2
 80052de:	687a      	ldr	r2, [r7, #4]
 80052e0:	6852      	ldr	r2, [r2, #4]
 80052e2:	3a01      	subs	r2, #1
 80052e4:	0112      	lsls	r2, r2, #4
 80052e6:	430a      	orrs	r2, r1
 80052e8:	4920      	ldr	r1, [pc, #128]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 80052ea:	4313      	orrs	r3, r2
 80052ec:	610b      	str	r3, [r1, #16]
 80052ee:	e014      	b.n	800531a <RCCEx_PLLSAI1_Config+0x17e>
      else
      {
        assert_param(IS_RCC_PLLSAI1R_VALUE(PllSai1->PLLSAI1R));
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI1 Division factor M, R and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80052f0:	4b1e      	ldr	r3, [pc, #120]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 80052f2:	691a      	ldr	r2, [r3, #16]
 80052f4:	4b20      	ldr	r3, [pc, #128]	; (8005378 <RCCEx_PLLSAI1_Config+0x1dc>)
 80052f6:	4013      	ands	r3, r2
 80052f8:	687a      	ldr	r2, [r7, #4]
 80052fa:	6892      	ldr	r2, [r2, #8]
 80052fc:	0211      	lsls	r1, r2, #8
 80052fe:	687a      	ldr	r2, [r7, #4]
 8005300:	6952      	ldr	r2, [r2, #20]
 8005302:	0852      	lsrs	r2, r2, #1
 8005304:	3a01      	subs	r2, #1
 8005306:	0652      	lsls	r2, r2, #25
 8005308:	4311      	orrs	r1, r2
 800530a:	687a      	ldr	r2, [r7, #4]
 800530c:	6852      	ldr	r2, [r2, #4]
 800530e:	3a01      	subs	r2, #1
 8005310:	0112      	lsls	r2, r2, #4
 8005312:	430a      	orrs	r2, r1
 8005314:	4915      	ldr	r1, [pc, #84]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 8005316:	4313      	orrs	r3, r2
 8005318:	610b      	str	r3, [r1, #16]
                   (((PllSai1->PLLSAI1R >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1R_Pos));
#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }

      /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
      __HAL_RCC_PLLSAI1_ENABLE();
 800531a:	4b14      	ldr	r3, [pc, #80]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 800531c:	681b      	ldr	r3, [r3, #0]
 800531e:	4a13      	ldr	r2, [pc, #76]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 8005320:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8005324:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8005326:	f7fc fb5f 	bl	80019e8 <HAL_GetTick>
 800532a:	60b8      	str	r0, [r7, #8]

      /* Wait till PLLSAI1 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 800532c:	e009      	b.n	8005342 <RCCEx_PLLSAI1_Config+0x1a6>
      {
        if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800532e:	f7fc fb5b 	bl	80019e8 <HAL_GetTick>
 8005332:	4602      	mov	r2, r0
 8005334:	68bb      	ldr	r3, [r7, #8]
 8005336:	1ad3      	subs	r3, r2, r3
 8005338:	2b02      	cmp	r3, #2
 800533a:	d902      	bls.n	8005342 <RCCEx_PLLSAI1_Config+0x1a6>
        {
          status = HAL_TIMEOUT;
 800533c:	2303      	movs	r3, #3
 800533e:	73fb      	strb	r3, [r7, #15]
          break;
 8005340:	e005      	b.n	800534e <RCCEx_PLLSAI1_Config+0x1b2>
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 8005342:	4b0a      	ldr	r3, [pc, #40]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 8005344:	681b      	ldr	r3, [r3, #0]
 8005346:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800534a:	2b00      	cmp	r3, #0
 800534c:	d0ef      	beq.n	800532e <RCCEx_PLLSAI1_Config+0x192>
        }
      }

      if(status == HAL_OK)
 800534e:	7bfb      	ldrb	r3, [r7, #15]
 8005350:	2b00      	cmp	r3, #0
 8005352:	d106      	bne.n	8005362 <RCCEx_PLLSAI1_Config+0x1c6>
      {
        /* Configure the PLLSAI1 Clock output(s) */
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 8005354:	4b05      	ldr	r3, [pc, #20]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 8005356:	691a      	ldr	r2, [r3, #16]
 8005358:	687b      	ldr	r3, [r7, #4]
 800535a:	699b      	ldr	r3, [r3, #24]
 800535c:	4903      	ldr	r1, [pc, #12]	; (800536c <RCCEx_PLLSAI1_Config+0x1d0>)
 800535e:	4313      	orrs	r3, r2
 8005360:	610b      	str	r3, [r1, #16]
      }
    }
  }

  return status;
 8005362:	7bfb      	ldrb	r3, [r7, #15]
}
 8005364:	4618      	mov	r0, r3
 8005366:	3710      	adds	r7, #16
 8005368:	46bd      	mov	sp, r7
 800536a:	bd80      	pop	{r7, pc}
 800536c:	40021000 	.word	0x40021000
 8005370:	07ff800f 	.word	0x07ff800f
 8005374:	ff9f800f 	.word	0xff9f800f
 8005378:	f9ff800f 	.word	0xf9ff800f

0800537c <RCCEx_PLLSAI2_Config>:
  * @note   PLLSAI2 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI2_Config(RCC_PLLSAI2InitTypeDef *PllSai2, uint32_t Divider)
{
 800537c:	b580      	push	{r7, lr}
 800537e:	b084      	sub	sp, #16
 8005380:	af00      	add	r7, sp, #0
 8005382:	6078      	str	r0, [r7, #4]
 8005384:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 8005386:	2300      	movs	r3, #0
 8005388:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLSAI2M_VALUE(PllSai2->PLLSAI2M));
  assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));

  /* Check that PLLSAI2 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 800538a:	4b70      	ldr	r3, [pc, #448]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 800538c:	68db      	ldr	r3, [r3, #12]
 800538e:	f003 0303 	and.w	r3, r3, #3
 8005392:	2b00      	cmp	r3, #0
 8005394:	d00e      	beq.n	80053b4 <RCCEx_PLLSAI2_Config+0x38>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai2->PLLSAI2Source)
 8005396:	4b6d      	ldr	r3, [pc, #436]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 8005398:	68db      	ldr	r3, [r3, #12]
 800539a:	f003 0203 	and.w	r2, r3, #3
 800539e:	687b      	ldr	r3, [r7, #4]
 80053a0:	681b      	ldr	r3, [r3, #0]
 80053a2:	429a      	cmp	r2, r3
 80053a4:	d103      	bne.n	80053ae <RCCEx_PLLSAI2_Config+0x32>
       ||
       (PllSai2->PLLSAI2Source == RCC_PLLSOURCE_NONE)
 80053a6:	687b      	ldr	r3, [r7, #4]
 80053a8:	681b      	ldr	r3, [r3, #0]
       ||
 80053aa:	2b00      	cmp	r3, #0
 80053ac:	d13f      	bne.n	800542e <RCCEx_PLLSAI2_Config+0xb2>
       ||
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai2->PLLSAI2M)
#endif
      )
    {
      status = HAL_ERROR;
 80053ae:	2301      	movs	r3, #1
 80053b0:	73fb      	strb	r3, [r7, #15]
 80053b2:	e03c      	b.n	800542e <RCCEx_PLLSAI2_Config+0xb2>
    }
  }
  else
  {
    /* Check PLLSAI2 clock source availability */
    switch(PllSai2->PLLSAI2Source)
 80053b4:	687b      	ldr	r3, [r7, #4]
 80053b6:	681b      	ldr	r3, [r3, #0]
 80053b8:	2b02      	cmp	r3, #2
 80053ba:	d00c      	beq.n	80053d6 <RCCEx_PLLSAI2_Config+0x5a>
 80053bc:	2b03      	cmp	r3, #3
 80053be:	d013      	beq.n	80053e8 <RCCEx_PLLSAI2_Config+0x6c>
 80053c0:	2b01      	cmp	r3, #1
 80053c2:	d120      	bne.n	8005406 <RCCEx_PLLSAI2_Config+0x8a>
    {
    case RCC_PLLSOURCE_MSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 80053c4:	4b61      	ldr	r3, [pc, #388]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 80053c6:	681b      	ldr	r3, [r3, #0]
 80053c8:	f003 0302 	and.w	r3, r3, #2
 80053cc:	2b00      	cmp	r3, #0
 80053ce:	d11d      	bne.n	800540c <RCCEx_PLLSAI2_Config+0x90>
      {
        status = HAL_ERROR;
 80053d0:	2301      	movs	r3, #1
 80053d2:	73fb      	strb	r3, [r7, #15]
      }
      break;
 80053d4:	e01a      	b.n	800540c <RCCEx_PLLSAI2_Config+0x90>
    case RCC_PLLSOURCE_HSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 80053d6:	4b5d      	ldr	r3, [pc, #372]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 80053d8:	681b      	ldr	r3, [r3, #0]
 80053da:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80053de:	2b00      	cmp	r3, #0
 80053e0:	d116      	bne.n	8005410 <RCCEx_PLLSAI2_Config+0x94>
      {
        status = HAL_ERROR;
 80053e2:	2301      	movs	r3, #1
 80053e4:	73fb      	strb	r3, [r7, #15]
      }
      break;
 80053e6:	e013      	b.n	8005410 <RCCEx_PLLSAI2_Config+0x94>
    case RCC_PLLSOURCE_HSE:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 80053e8:	4b58      	ldr	r3, [pc, #352]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 80053ea:	681b      	ldr	r3, [r3, #0]
 80053ec:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80053f0:	2b00      	cmp	r3, #0
 80053f2:	d10f      	bne.n	8005414 <RCCEx_PLLSAI2_Config+0x98>
      {
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 80053f4:	4b55      	ldr	r3, [pc, #340]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 80053f6:	681b      	ldr	r3, [r3, #0]
 80053f8:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80053fc:	2b00      	cmp	r3, #0
 80053fe:	d109      	bne.n	8005414 <RCCEx_PLLSAI2_Config+0x98>
        {
          status = HAL_ERROR;
 8005400:	2301      	movs	r3, #1
 8005402:	73fb      	strb	r3, [r7, #15]
        }
      }
      break;
 8005404:	e006      	b.n	8005414 <RCCEx_PLLSAI2_Config+0x98>
    default:
      status = HAL_ERROR;
 8005406:	2301      	movs	r3, #1
 8005408:	73fb      	strb	r3, [r7, #15]
      break;
 800540a:	e004      	b.n	8005416 <RCCEx_PLLSAI2_Config+0x9a>
      break;
 800540c:	bf00      	nop
 800540e:	e002      	b.n	8005416 <RCCEx_PLLSAI2_Config+0x9a>
      break;
 8005410:	bf00      	nop
 8005412:	e000      	b.n	8005416 <RCCEx_PLLSAI2_Config+0x9a>
      break;
 8005414:	bf00      	nop
    }

    if(status == HAL_OK)
 8005416:	7bfb      	ldrb	r3, [r7, #15]
 8005418:	2b00      	cmp	r3, #0
 800541a:	d108      	bne.n	800542e <RCCEx_PLLSAI2_Config+0xb2>
    {
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
      /* Set PLLSAI2 clock source */
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai2->PLLSAI2Source);
 800541c:	4b4b      	ldr	r3, [pc, #300]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 800541e:	68db      	ldr	r3, [r3, #12]
 8005420:	f023 0203 	bic.w	r2, r3, #3
 8005424:	687b      	ldr	r3, [r7, #4]
 8005426:	681b      	ldr	r3, [r3, #0]
 8005428:	4948      	ldr	r1, [pc, #288]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 800542a:	4313      	orrs	r3, r2
 800542c:	60cb      	str	r3, [r1, #12]
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai2->PLLSAI2Source | (PllSai2->PLLSAI2M - 1U) << RCC_PLLCFGR_PLLM_Pos);
#endif
    }
  }

  if(status == HAL_OK)
 800542e:	7bfb      	ldrb	r3, [r7, #15]
 8005430:	2b00      	cmp	r3, #0
 8005432:	f040 8086 	bne.w	8005542 <RCCEx_PLLSAI2_Config+0x1c6>
  {
    /* Disable the PLLSAI2 */
    __HAL_RCC_PLLSAI2_DISABLE();
 8005436:	4b45      	ldr	r3, [pc, #276]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 8005438:	681b      	ldr	r3, [r3, #0]
 800543a:	4a44      	ldr	r2, [pc, #272]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 800543c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8005440:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8005442:	f7fc fad1 	bl	80019e8 <HAL_GetTick>
 8005446:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI2 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 8005448:	e009      	b.n	800545e <RCCEx_PLLSAI2_Config+0xe2>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 800544a:	f7fc facd 	bl	80019e8 <HAL_GetTick>
 800544e:	4602      	mov	r2, r0
 8005450:	68bb      	ldr	r3, [r7, #8]
 8005452:	1ad3      	subs	r3, r2, r3
 8005454:	2b02      	cmp	r3, #2
 8005456:	d902      	bls.n	800545e <RCCEx_PLLSAI2_Config+0xe2>
      {
        status = HAL_TIMEOUT;
 8005458:	2303      	movs	r3, #3
 800545a:	73fb      	strb	r3, [r7, #15]
        break;
 800545c:	e005      	b.n	800546a <RCCEx_PLLSAI2_Config+0xee>
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 800545e:	4b3b      	ldr	r3, [pc, #236]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 8005460:	681b      	ldr	r3, [r3, #0]
 8005462:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8005466:	2b00      	cmp	r3, #0
 8005468:	d1ef      	bne.n	800544a <RCCEx_PLLSAI2_Config+0xce>
      }
    }

    if(status == HAL_OK)
 800546a:	7bfb      	ldrb	r3, [r7, #15]
 800546c:	2b00      	cmp	r3, #0
 800546e:	d168      	bne.n	8005542 <RCCEx_PLLSAI2_Config+0x1c6>
    {
      if(Divider == DIVIDER_P_UPDATE)
 8005470:	683b      	ldr	r3, [r7, #0]
 8005472:	2b00      	cmp	r3, #0
 8005474:	d113      	bne.n	800549e <RCCEx_PLLSAI2_Config+0x122>
        assert_param(IS_RCC_PLLSAI2P_VALUE(PllSai2->PLLSAI2P));
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)

        /* Configure the PLLSAI2 Division factor M, P and Multiplication factor N*/
#if defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
        MODIFY_REG(RCC->PLLSAI2CFGR,
 8005476:	4b35      	ldr	r3, [pc, #212]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 8005478:	695a      	ldr	r2, [r3, #20]
 800547a:	4b35      	ldr	r3, [pc, #212]	; (8005550 <RCCEx_PLLSAI2_Config+0x1d4>)
 800547c:	4013      	ands	r3, r2
 800547e:	687a      	ldr	r2, [r7, #4]
 8005480:	6892      	ldr	r2, [r2, #8]
 8005482:	0211      	lsls	r1, r2, #8
 8005484:	687a      	ldr	r2, [r7, #4]
 8005486:	68d2      	ldr	r2, [r2, #12]
 8005488:	06d2      	lsls	r2, r2, #27
 800548a:	4311      	orrs	r1, r2
 800548c:	687a      	ldr	r2, [r7, #4]
 800548e:	6852      	ldr	r2, [r2, #4]
 8005490:	3a01      	subs	r2, #1
 8005492:	0112      	lsls	r2, r2, #4
 8005494:	430a      	orrs	r2, r1
 8005496:	492d      	ldr	r1, [pc, #180]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 8005498:	4313      	orrs	r3, r2
 800549a:	614b      	str	r3, [r1, #20]
 800549c:	e02d      	b.n	80054fa <RCCEx_PLLSAI2_Config+0x17e>
#endif /* RCC_PLLSAI2P_DIV_2_31_SUPPORT */

#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
      }
#if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
      else if(Divider == DIVIDER_Q_UPDATE)
 800549e:	683b      	ldr	r3, [r7, #0]
 80054a0:	2b01      	cmp	r3, #1
 80054a2:	d115      	bne.n	80054d0 <RCCEx_PLLSAI2_Config+0x154>
      {
        assert_param(IS_RCC_PLLSAI2Q_VALUE(PllSai2->PLLSAI2Q));
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI2 Division factor M, Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI2CFGR,
 80054a4:	4b29      	ldr	r3, [pc, #164]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 80054a6:	695a      	ldr	r2, [r3, #20]
 80054a8:	4b2a      	ldr	r3, [pc, #168]	; (8005554 <RCCEx_PLLSAI2_Config+0x1d8>)
 80054aa:	4013      	ands	r3, r2
 80054ac:	687a      	ldr	r2, [r7, #4]
 80054ae:	6892      	ldr	r2, [r2, #8]
 80054b0:	0211      	lsls	r1, r2, #8
 80054b2:	687a      	ldr	r2, [r7, #4]
 80054b4:	6912      	ldr	r2, [r2, #16]
 80054b6:	0852      	lsrs	r2, r2, #1
 80054b8:	3a01      	subs	r2, #1
 80054ba:	0552      	lsls	r2, r2, #21
 80054bc:	4311      	orrs	r1, r2
 80054be:	687a      	ldr	r2, [r7, #4]
 80054c0:	6852      	ldr	r2, [r2, #4]
 80054c2:	3a01      	subs	r2, #1
 80054c4:	0112      	lsls	r2, r2, #4
 80054c6:	430a      	orrs	r2, r1
 80054c8:	4920      	ldr	r1, [pc, #128]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 80054ca:	4313      	orrs	r3, r2
 80054cc:	614b      	str	r3, [r1, #20]
 80054ce:	e014      	b.n	80054fa <RCCEx_PLLSAI2_Config+0x17e>
      else
      {
        assert_param(IS_RCC_PLLSAI2R_VALUE(PllSai2->PLLSAI2R));
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI2 Division factor M, R and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI2CFGR,
 80054d0:	4b1e      	ldr	r3, [pc, #120]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 80054d2:	695a      	ldr	r2, [r3, #20]
 80054d4:	4b20      	ldr	r3, [pc, #128]	; (8005558 <RCCEx_PLLSAI2_Config+0x1dc>)
 80054d6:	4013      	ands	r3, r2
 80054d8:	687a      	ldr	r2, [r7, #4]
 80054da:	6892      	ldr	r2, [r2, #8]
 80054dc:	0211      	lsls	r1, r2, #8
 80054de:	687a      	ldr	r2, [r7, #4]
 80054e0:	6952      	ldr	r2, [r2, #20]
 80054e2:	0852      	lsrs	r2, r2, #1
 80054e4:	3a01      	subs	r2, #1
 80054e6:	0652      	lsls	r2, r2, #25
 80054e8:	4311      	orrs	r1, r2
 80054ea:	687a      	ldr	r2, [r7, #4]
 80054ec:	6852      	ldr	r2, [r2, #4]
 80054ee:	3a01      	subs	r2, #1
 80054f0:	0112      	lsls	r2, r2, #4
 80054f2:	430a      	orrs	r2, r1
 80054f4:	4915      	ldr	r1, [pc, #84]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 80054f6:	4313      	orrs	r3, r2
 80054f8:	614b      	str	r3, [r1, #20]
                   (((PllSai2->PLLSAI2R >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2R_Pos));
#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
      }

      /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
      __HAL_RCC_PLLSAI2_ENABLE();
 80054fa:	4b14      	ldr	r3, [pc, #80]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 80054fc:	681b      	ldr	r3, [r3, #0]
 80054fe:	4a13      	ldr	r2, [pc, #76]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 8005500:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8005504:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8005506:	f7fc fa6f 	bl	80019e8 <HAL_GetTick>
 800550a:	60b8      	str	r0, [r7, #8]

      /* Wait till PLLSAI2 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 800550c:	e009      	b.n	8005522 <RCCEx_PLLSAI2_Config+0x1a6>
      {
        if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 800550e:	f7fc fa6b 	bl	80019e8 <HAL_GetTick>
 8005512:	4602      	mov	r2, r0
 8005514:	68bb      	ldr	r3, [r7, #8]
 8005516:	1ad3      	subs	r3, r2, r3
 8005518:	2b02      	cmp	r3, #2
 800551a:	d902      	bls.n	8005522 <RCCEx_PLLSAI2_Config+0x1a6>
        {
          status = HAL_TIMEOUT;
 800551c:	2303      	movs	r3, #3
 800551e:	73fb      	strb	r3, [r7, #15]
          break;
 8005520:	e005      	b.n	800552e <RCCEx_PLLSAI2_Config+0x1b2>
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 8005522:	4b0a      	ldr	r3, [pc, #40]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 8005524:	681b      	ldr	r3, [r3, #0]
 8005526:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800552a:	2b00      	cmp	r3, #0
 800552c:	d0ef      	beq.n	800550e <RCCEx_PLLSAI2_Config+0x192>
        }
      }

      if(status == HAL_OK)
 800552e:	7bfb      	ldrb	r3, [r7, #15]
 8005530:	2b00      	cmp	r3, #0
 8005532:	d106      	bne.n	8005542 <RCCEx_PLLSAI2_Config+0x1c6>
      {
        /* Configure the PLLSAI2 Clock output(s) */
        __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
 8005534:	4b05      	ldr	r3, [pc, #20]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 8005536:	695a      	ldr	r2, [r3, #20]
 8005538:	687b      	ldr	r3, [r7, #4]
 800553a:	699b      	ldr	r3, [r3, #24]
 800553c:	4903      	ldr	r1, [pc, #12]	; (800554c <RCCEx_PLLSAI2_Config+0x1d0>)
 800553e:	4313      	orrs	r3, r2
 8005540:	614b      	str	r3, [r1, #20]
      }
    }
  }

  return status;
 8005542:	7bfb      	ldrb	r3, [r7, #15]
}
 8005544:	4618      	mov	r0, r3
 8005546:	3710      	adds	r7, #16
 8005548:	46bd      	mov	sp, r7
 800554a:	bd80      	pop	{r7, pc}
 800554c:	40021000 	.word	0x40021000
 8005550:	07ff800f 	.word	0x07ff800f
 8005554:	ff9f800f 	.word	0xff9f800f
 8005558:	f9ff800f 	.word	0xf9ff800f

0800555c <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 800555c:	b580      	push	{r7, lr}
 800555e:	b084      	sub	sp, #16
 8005560:	af00      	add	r7, sp, #0
 8005562:	6078      	str	r0, [r7, #4]
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 8005564:	687b      	ldr	r3, [r7, #4]
 8005566:	2b00      	cmp	r3, #0
 8005568:	d101      	bne.n	800556e <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 800556a:	2301      	movs	r3, #1
 800556c:	e095      	b.n	800569a <HAL_SPI_Init+0x13e>
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
  assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 800556e:	687b      	ldr	r3, [r7, #4]
 8005570:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005572:	2b00      	cmp	r3, #0
 8005574:	d108      	bne.n	8005588 <HAL_SPI_Init+0x2c>
  {
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));

    if (hspi->Init.Mode == SPI_MODE_MASTER)
 8005576:	687b      	ldr	r3, [r7, #4]
 8005578:	685b      	ldr	r3, [r3, #4]
 800557a:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 800557e:	d009      	beq.n	8005594 <HAL_SPI_Init+0x38>
      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    }
    else
    {
      /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8005580:	687b      	ldr	r3, [r7, #4]
 8005582:	2200      	movs	r2, #0
 8005584:	61da      	str	r2, [r3, #28]
 8005586:	e005      	b.n	8005594 <HAL_SPI_Init+0x38>
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 8005588:	687b      	ldr	r3, [r7, #4]
 800558a:	2200      	movs	r2, #0
 800558c:	611a      	str	r2, [r3, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 800558e:	687b      	ldr	r3, [r7, #4]
 8005590:	2200      	movs	r2, #0
 8005592:	615a      	str	r2, [r3, #20]
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8005594:	687b      	ldr	r3, [r7, #4]
 8005596:	2200      	movs	r2, #0
 8005598:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 800559a:	687b      	ldr	r3, [r7, #4]
 800559c:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 80055a0:	b2db      	uxtb	r3, r3
 80055a2:	2b00      	cmp	r3, #0
 80055a4:	d106      	bne.n	80055b4 <HAL_SPI_Init+0x58>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 80055a6:	687b      	ldr	r3, [r7, #4]
 80055a8:	2200      	movs	r2, #0
 80055aa:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 80055ae:	6878      	ldr	r0, [r7, #4]
 80055b0:	f7fb ff26 	bl	8001400 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 80055b4:	687b      	ldr	r3, [r7, #4]
 80055b6:	2202      	movs	r2, #2
 80055b8:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80055bc:	687b      	ldr	r3, [r7, #4]
 80055be:	681b      	ldr	r3, [r3, #0]
 80055c0:	681a      	ldr	r2, [r3, #0]
 80055c2:	687b      	ldr	r3, [r7, #4]
 80055c4:	681b      	ldr	r3, [r3, #0]
 80055c6:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80055ca:	601a      	str	r2, [r3, #0]

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80055cc:	687b      	ldr	r3, [r7, #4]
 80055ce:	68db      	ldr	r3, [r3, #12]
 80055d0:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 80055d4:	d902      	bls.n	80055dc <HAL_SPI_Init+0x80>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 80055d6:	2300      	movs	r3, #0
 80055d8:	60fb      	str	r3, [r7, #12]
 80055da:	e002      	b.n	80055e2 <HAL_SPI_Init+0x86>
  }
  else
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 80055dc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80055e0:	60fb      	str	r3, [r7, #12]
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 80055e2:	687b      	ldr	r3, [r7, #4]
 80055e4:	68db      	ldr	r3, [r3, #12]
 80055e6:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 80055ea:	d007      	beq.n	80055fc <HAL_SPI_Init+0xa0>
 80055ec:	687b      	ldr	r3, [r7, #4]
 80055ee:	68db      	ldr	r3, [r3, #12]
 80055f0:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 80055f4:	d002      	beq.n	80055fc <HAL_SPI_Init+0xa0>
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80055f6:	687b      	ldr	r3, [r7, #4]
 80055f8:	2200      	movs	r2, #0
 80055fa:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80055fc:	687b      	ldr	r3, [r7, #4]
 80055fe:	685b      	ldr	r3, [r3, #4]
 8005600:	f403 7282 	and.w	r2, r3, #260	; 0x104
 8005604:	687b      	ldr	r3, [r7, #4]
 8005606:	689b      	ldr	r3, [r3, #8]
 8005608:	f403 4304 	and.w	r3, r3, #33792	; 0x8400
 800560c:	431a      	orrs	r2, r3
 800560e:	687b      	ldr	r3, [r7, #4]
 8005610:	691b      	ldr	r3, [r3, #16]
 8005612:	f003 0302 	and.w	r3, r3, #2
 8005616:	431a      	orrs	r2, r3
 8005618:	687b      	ldr	r3, [r7, #4]
 800561a:	695b      	ldr	r3, [r3, #20]
 800561c:	f003 0301 	and.w	r3, r3, #1
 8005620:	431a      	orrs	r2, r3
 8005622:	687b      	ldr	r3, [r7, #4]
 8005624:	699b      	ldr	r3, [r3, #24]
 8005626:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800562a:	431a      	orrs	r2, r3
 800562c:	687b      	ldr	r3, [r7, #4]
 800562e:	69db      	ldr	r3, [r3, #28]
 8005630:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8005634:	431a      	orrs	r2, r3
 8005636:	687b      	ldr	r3, [r7, #4]
 8005638:	6a1b      	ldr	r3, [r3, #32]
 800563a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800563e:	ea42 0103 	orr.w	r1, r2, r3
 8005642:	687b      	ldr	r3, [r7, #4]
 8005644:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005646:	f403 5200 	and.w	r2, r3, #8192	; 0x2000
 800564a:	687b      	ldr	r3, [r7, #4]
 800564c:	681b      	ldr	r3, [r3, #0]
 800564e:	430a      	orrs	r2, r1
 8005650:	601a      	str	r2, [r3, #0]
    }
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 8005652:	687b      	ldr	r3, [r7, #4]
 8005654:	699b      	ldr	r3, [r3, #24]
 8005656:	0c1b      	lsrs	r3, r3, #16
 8005658:	f003 0204 	and.w	r2, r3, #4
 800565c:	687b      	ldr	r3, [r7, #4]
 800565e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005660:	f003 0310 	and.w	r3, r3, #16
 8005664:	431a      	orrs	r2, r3
 8005666:	687b      	ldr	r3, [r7, #4]
 8005668:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800566a:	f003 0308 	and.w	r3, r3, #8
 800566e:	431a      	orrs	r2, r3
 8005670:	687b      	ldr	r3, [r7, #4]
 8005672:	68db      	ldr	r3, [r3, #12]
 8005674:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8005678:	ea42 0103 	orr.w	r1, r2, r3
 800567c:	68fb      	ldr	r3, [r7, #12]
 800567e:	f403 5280 	and.w	r2, r3, #4096	; 0x1000
 8005682:	687b      	ldr	r3, [r7, #4]
 8005684:	681b      	ldr	r3, [r3, #0]
 8005686:	430a      	orrs	r2, r1
 8005688:	605a      	str	r2, [r3, #4]
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800568a:	687b      	ldr	r3, [r7, #4]
 800568c:	2200      	movs	r2, #0
 800568e:	661a      	str	r2, [r3, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8005690:	687b      	ldr	r3, [r7, #4]
 8005692:	2201      	movs	r2, #1
 8005694:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

  return HAL_OK;
 8005698:	2300      	movs	r3, #0
}
 800569a:	4618      	mov	r0, r3
 800569c:	3710      	adds	r7, #16
 800569e:	46bd      	mov	sp, r7
 80056a0:	bd80      	pop	{r7, pc}

080056a2 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 80056a2:	b580      	push	{r7, lr}
 80056a4:	b082      	sub	sp, #8
 80056a6:	af00      	add	r7, sp, #0
 80056a8:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 80056aa:	687b      	ldr	r3, [r7, #4]
 80056ac:	2b00      	cmp	r3, #0
 80056ae:	d101      	bne.n	80056b4 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 80056b0:	2301      	movs	r3, #1
 80056b2:	e042      	b.n	800573a <HAL_UART_Init+0x98>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 80056b4:	687b      	ldr	r3, [r7, #4]
 80056b6:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80056ba:	2b00      	cmp	r3, #0
 80056bc:	d106      	bne.n	80056cc <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 80056be:	687b      	ldr	r3, [r7, #4]
 80056c0:	2200      	movs	r2, #0
 80056c2:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 80056c6:	6878      	ldr	r0, [r7, #4]
 80056c8:	f7fb ff10 	bl	80014ec <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 80056cc:	687b      	ldr	r3, [r7, #4]
 80056ce:	2224      	movs	r2, #36	; 0x24
 80056d0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  __HAL_UART_DISABLE(huart);
 80056d4:	687b      	ldr	r3, [r7, #4]
 80056d6:	681b      	ldr	r3, [r3, #0]
 80056d8:	681a      	ldr	r2, [r3, #0]
 80056da:	687b      	ldr	r3, [r7, #4]
 80056dc:	681b      	ldr	r3, [r3, #0]
 80056de:	f022 0201 	bic.w	r2, r2, #1
 80056e2:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 80056e4:	6878      	ldr	r0, [r7, #4]
 80056e6:	f000 f8c3 	bl	8005870 <UART_SetConfig>
 80056ea:	4603      	mov	r3, r0
 80056ec:	2b01      	cmp	r3, #1
 80056ee:	d101      	bne.n	80056f4 <HAL_UART_Init+0x52>
  {
    return HAL_ERROR;
 80056f0:	2301      	movs	r3, #1
 80056f2:	e022      	b.n	800573a <HAL_UART_Init+0x98>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80056f4:	687b      	ldr	r3, [r7, #4]
 80056f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80056f8:	2b00      	cmp	r3, #0
 80056fa:	d002      	beq.n	8005702 <HAL_UART_Init+0x60>
  {
    UART_AdvFeatureConfig(huart);
 80056fc:	6878      	ldr	r0, [r7, #4]
 80056fe:	f000 fb89 	bl	8005e14 <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8005702:	687b      	ldr	r3, [r7, #4]
 8005704:	681b      	ldr	r3, [r3, #0]
 8005706:	685a      	ldr	r2, [r3, #4]
 8005708:	687b      	ldr	r3, [r7, #4]
 800570a:	681b      	ldr	r3, [r3, #0]
 800570c:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8005710:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8005712:	687b      	ldr	r3, [r7, #4]
 8005714:	681b      	ldr	r3, [r3, #0]
 8005716:	689a      	ldr	r2, [r3, #8]
 8005718:	687b      	ldr	r3, [r7, #4]
 800571a:	681b      	ldr	r3, [r3, #0]
 800571c:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8005720:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 8005722:	687b      	ldr	r3, [r7, #4]
 8005724:	681b      	ldr	r3, [r3, #0]
 8005726:	681a      	ldr	r2, [r3, #0]
 8005728:	687b      	ldr	r3, [r7, #4]
 800572a:	681b      	ldr	r3, [r3, #0]
 800572c:	f042 0201 	orr.w	r2, r2, #1
 8005730:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 8005732:	6878      	ldr	r0, [r7, #4]
 8005734:	f000 fc10 	bl	8005f58 <UART_CheckIdleState>
 8005738:	4603      	mov	r3, r0
}
 800573a:	4618      	mov	r0, r3
 800573c:	3708      	adds	r7, #8
 800573e:	46bd      	mov	sp, r7
 8005740:	bd80      	pop	{r7, pc}

08005742 <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8005742:	b580      	push	{r7, lr}
 8005744:	b08a      	sub	sp, #40	; 0x28
 8005746:	af02      	add	r7, sp, #8
 8005748:	60f8      	str	r0, [r7, #12]
 800574a:	60b9      	str	r1, [r7, #8]
 800574c:	603b      	str	r3, [r7, #0]
 800574e:	4613      	mov	r3, r2
 8005750:	80fb      	strh	r3, [r7, #6]
  uint8_t  *pdata8bits;
  uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 8005752:	68fb      	ldr	r3, [r7, #12]
 8005754:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8005758:	2b20      	cmp	r3, #32
 800575a:	f040 8084 	bne.w	8005866 <HAL_UART_Transmit+0x124>
  {
    if ((pData == NULL) || (Size == 0U))
 800575e:	68bb      	ldr	r3, [r7, #8]
 8005760:	2b00      	cmp	r3, #0
 8005762:	d002      	beq.n	800576a <HAL_UART_Transmit+0x28>
 8005764:	88fb      	ldrh	r3, [r7, #6]
 8005766:	2b00      	cmp	r3, #0
 8005768:	d101      	bne.n	800576e <HAL_UART_Transmit+0x2c>
    {
      return  HAL_ERROR;
 800576a:	2301      	movs	r3, #1
 800576c:	e07c      	b.n	8005868 <HAL_UART_Transmit+0x126>
    }

    __HAL_LOCK(huart);
 800576e:	68fb      	ldr	r3, [r7, #12]
 8005770:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 8005774:	2b01      	cmp	r3, #1
 8005776:	d101      	bne.n	800577c <HAL_UART_Transmit+0x3a>
 8005778:	2302      	movs	r3, #2
 800577a:	e075      	b.n	8005868 <HAL_UART_Transmit+0x126>
 800577c:	68fb      	ldr	r3, [r7, #12]
 800577e:	2201      	movs	r2, #1
 8005780:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005784:	68fb      	ldr	r3, [r7, #12]
 8005786:	2200      	movs	r2, #0
 8005788:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800578c:	68fb      	ldr	r3, [r7, #12]
 800578e:	2221      	movs	r2, #33	; 0x21
 8005790:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

    /* Init tickstart for timeout managment*/
    tickstart = HAL_GetTick();
 8005794:	f7fc f928 	bl	80019e8 <HAL_GetTick>
 8005798:	6178      	str	r0, [r7, #20]

    huart->TxXferSize  = Size;
 800579a:	68fb      	ldr	r3, [r7, #12]
 800579c:	88fa      	ldrh	r2, [r7, #6]
 800579e:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
    huart->TxXferCount = Size;
 80057a2:	68fb      	ldr	r3, [r7, #12]
 80057a4:	88fa      	ldrh	r2, [r7, #6]
 80057a6:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80057aa:	68fb      	ldr	r3, [r7, #12]
 80057ac:	689b      	ldr	r3, [r3, #8]
 80057ae:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80057b2:	d108      	bne.n	80057c6 <HAL_UART_Transmit+0x84>
 80057b4:	68fb      	ldr	r3, [r7, #12]
 80057b6:	691b      	ldr	r3, [r3, #16]
 80057b8:	2b00      	cmp	r3, #0
 80057ba:	d104      	bne.n	80057c6 <HAL_UART_Transmit+0x84>
    {
      pdata8bits  = NULL;
 80057bc:	2300      	movs	r3, #0
 80057be:	61fb      	str	r3, [r7, #28]
      pdata16bits = (uint16_t *) pData;
 80057c0:	68bb      	ldr	r3, [r7, #8]
 80057c2:	61bb      	str	r3, [r7, #24]
 80057c4:	e003      	b.n	80057ce <HAL_UART_Transmit+0x8c>
    }
    else
    {
      pdata8bits  = pData;
 80057c6:	68bb      	ldr	r3, [r7, #8]
 80057c8:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 80057ca:	2300      	movs	r3, #0
 80057cc:	61bb      	str	r3, [r7, #24]
    }

    __HAL_UNLOCK(huart);
 80057ce:	68fb      	ldr	r3, [r7, #12]
 80057d0:	2200      	movs	r2, #0
 80057d2:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

    while (huart->TxXferCount > 0U)
 80057d6:	e02d      	b.n	8005834 <HAL_UART_Transmit+0xf2>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80057d8:	683b      	ldr	r3, [r7, #0]
 80057da:	9300      	str	r3, [sp, #0]
 80057dc:	697b      	ldr	r3, [r7, #20]
 80057de:	2200      	movs	r2, #0
 80057e0:	2180      	movs	r1, #128	; 0x80
 80057e2:	68f8      	ldr	r0, [r7, #12]
 80057e4:	f000 fc00 	bl	8005fe8 <UART_WaitOnFlagUntilTimeout>
 80057e8:	4603      	mov	r3, r0
 80057ea:	2b00      	cmp	r3, #0
 80057ec:	d001      	beq.n	80057f2 <HAL_UART_Transmit+0xb0>
      {
        return HAL_TIMEOUT;
 80057ee:	2303      	movs	r3, #3
 80057f0:	e03a      	b.n	8005868 <HAL_UART_Transmit+0x126>
      }
      if (pdata8bits == NULL)
 80057f2:	69fb      	ldr	r3, [r7, #28]
 80057f4:	2b00      	cmp	r3, #0
 80057f6:	d10b      	bne.n	8005810 <HAL_UART_Transmit+0xce>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 80057f8:	69bb      	ldr	r3, [r7, #24]
 80057fa:	881a      	ldrh	r2, [r3, #0]
 80057fc:	68fb      	ldr	r3, [r7, #12]
 80057fe:	681b      	ldr	r3, [r3, #0]
 8005800:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8005804:	b292      	uxth	r2, r2
 8005806:	851a      	strh	r2, [r3, #40]	; 0x28
        pdata16bits++;
 8005808:	69bb      	ldr	r3, [r7, #24]
 800580a:	3302      	adds	r3, #2
 800580c:	61bb      	str	r3, [r7, #24]
 800580e:	e008      	b.n	8005822 <HAL_UART_Transmit+0xe0>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8005810:	69fb      	ldr	r3, [r7, #28]
 8005812:	781a      	ldrb	r2, [r3, #0]
 8005814:	68fb      	ldr	r3, [r7, #12]
 8005816:	681b      	ldr	r3, [r3, #0]
 8005818:	b292      	uxth	r2, r2
 800581a:	851a      	strh	r2, [r3, #40]	; 0x28
        pdata8bits++;
 800581c:	69fb      	ldr	r3, [r7, #28]
 800581e:	3301      	adds	r3, #1
 8005820:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 8005822:	68fb      	ldr	r3, [r7, #12]
 8005824:	f8b3 3056 	ldrh.w	r3, [r3, #86]	; 0x56
 8005828:	b29b      	uxth	r3, r3
 800582a:	3b01      	subs	r3, #1
 800582c:	b29a      	uxth	r2, r3
 800582e:	68fb      	ldr	r3, [r7, #12]
 8005830:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56
    while (huart->TxXferCount > 0U)
 8005834:	68fb      	ldr	r3, [r7, #12]
 8005836:	f8b3 3056 	ldrh.w	r3, [r3, #86]	; 0x56
 800583a:	b29b      	uxth	r3, r3
 800583c:	2b00      	cmp	r3, #0
 800583e:	d1cb      	bne.n	80057d8 <HAL_UART_Transmit+0x96>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8005840:	683b      	ldr	r3, [r7, #0]
 8005842:	9300      	str	r3, [sp, #0]
 8005844:	697b      	ldr	r3, [r7, #20]
 8005846:	2200      	movs	r2, #0
 8005848:	2140      	movs	r1, #64	; 0x40
 800584a:	68f8      	ldr	r0, [r7, #12]
 800584c:	f000 fbcc 	bl	8005fe8 <UART_WaitOnFlagUntilTimeout>
 8005850:	4603      	mov	r3, r0
 8005852:	2b00      	cmp	r3, #0
 8005854:	d001      	beq.n	800585a <HAL_UART_Transmit+0x118>
    {
      return HAL_TIMEOUT;
 8005856:	2303      	movs	r3, #3
 8005858:	e006      	b.n	8005868 <HAL_UART_Transmit+0x126>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 800585a:	68fb      	ldr	r3, [r7, #12]
 800585c:	2220      	movs	r2, #32
 800585e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

    return HAL_OK;
 8005862:	2300      	movs	r3, #0
 8005864:	e000      	b.n	8005868 <HAL_UART_Transmit+0x126>
  }
  else
  {
    return HAL_BUSY;
 8005866:	2302      	movs	r3, #2
  }
}
 8005868:	4618      	mov	r0, r3
 800586a:	3720      	adds	r7, #32
 800586c:	46bd      	mov	sp, r7
 800586e:	bd80      	pop	{r7, pc}

08005870 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8005870:	e92d 4890 	stmdb	sp!, {r4, r7, fp, lr}
 8005874:	b088      	sub	sp, #32
 8005876:	af00      	add	r7, sp, #0
 8005878:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 800587a:	2300      	movs	r3, #0
 800587c:	76bb      	strb	r3, [r7, #26]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800587e:	687b      	ldr	r3, [r7, #4]
 8005880:	689a      	ldr	r2, [r3, #8]
 8005882:	687b      	ldr	r3, [r7, #4]
 8005884:	691b      	ldr	r3, [r3, #16]
 8005886:	431a      	orrs	r2, r3
 8005888:	687b      	ldr	r3, [r7, #4]
 800588a:	695b      	ldr	r3, [r3, #20]
 800588c:	431a      	orrs	r2, r3
 800588e:	687b      	ldr	r3, [r7, #4]
 8005890:	69db      	ldr	r3, [r3, #28]
 8005892:	4313      	orrs	r3, r2
 8005894:	61fb      	str	r3, [r7, #28]
#if defined(USART_CR1_FIFOEN)
  tmpreg |= (uint32_t)huart->FifoMode;
 8005896:	687b      	ldr	r3, [r7, #4]
 8005898:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800589a:	69fa      	ldr	r2, [r7, #28]
 800589c:	4313      	orrs	r3, r2
 800589e:	61fb      	str	r3, [r7, #28]
#endif /* USART_CR1_FIFOEN */
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80058a0:	687b      	ldr	r3, [r7, #4]
 80058a2:	681b      	ldr	r3, [r3, #0]
 80058a4:	681a      	ldr	r2, [r3, #0]
 80058a6:	4bb1      	ldr	r3, [pc, #708]	; (8005b6c <UART_SetConfig+0x2fc>)
 80058a8:	4013      	ands	r3, r2
 80058aa:	687a      	ldr	r2, [r7, #4]
 80058ac:	6812      	ldr	r2, [r2, #0]
 80058ae:	69f9      	ldr	r1, [r7, #28]
 80058b0:	430b      	orrs	r3, r1
 80058b2:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80058b4:	687b      	ldr	r3, [r7, #4]
 80058b6:	681b      	ldr	r3, [r3, #0]
 80058b8:	685b      	ldr	r3, [r3, #4]
 80058ba:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 80058be:	687b      	ldr	r3, [r7, #4]
 80058c0:	68da      	ldr	r2, [r3, #12]
 80058c2:	687b      	ldr	r3, [r7, #4]
 80058c4:	681b      	ldr	r3, [r3, #0]
 80058c6:	430a      	orrs	r2, r1
 80058c8:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 80058ca:	687b      	ldr	r3, [r7, #4]
 80058cc:	699b      	ldr	r3, [r3, #24]
 80058ce:	61fb      	str	r3, [r7, #28]

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80058d0:	687b      	ldr	r3, [r7, #4]
 80058d2:	681b      	ldr	r3, [r3, #0]
 80058d4:	4aa6      	ldr	r2, [pc, #664]	; (8005b70 <UART_SetConfig+0x300>)
 80058d6:	4293      	cmp	r3, r2
 80058d8:	d004      	beq.n	80058e4 <UART_SetConfig+0x74>
  {
    tmpreg |= huart->Init.OneBitSampling;
 80058da:	687b      	ldr	r3, [r7, #4]
 80058dc:	6a1b      	ldr	r3, [r3, #32]
 80058de:	69fa      	ldr	r2, [r7, #28]
 80058e0:	4313      	orrs	r3, r2
 80058e2:	61fb      	str	r3, [r7, #28]
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80058e4:	687b      	ldr	r3, [r7, #4]
 80058e6:	681b      	ldr	r3, [r3, #0]
 80058e8:	689b      	ldr	r3, [r3, #8]
 80058ea:	f023 436e 	bic.w	r3, r3, #3992977408	; 0xee000000
 80058ee:	f423 6330 	bic.w	r3, r3, #2816	; 0xb00
 80058f2:	687a      	ldr	r2, [r7, #4]
 80058f4:	6812      	ldr	r2, [r2, #0]
 80058f6:	69f9      	ldr	r1, [r7, #28]
 80058f8:	430b      	orrs	r3, r1
 80058fa:	6093      	str	r3, [r2, #8]

#if defined(USART_PRESC_PRESCALER)
  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 80058fc:	687b      	ldr	r3, [r7, #4]
 80058fe:	681b      	ldr	r3, [r3, #0]
 8005900:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005902:	f023 010f 	bic.w	r1, r3, #15
 8005906:	687b      	ldr	r3, [r7, #4]
 8005908:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800590a:	687b      	ldr	r3, [r7, #4]
 800590c:	681b      	ldr	r3, [r3, #0]
 800590e:	430a      	orrs	r2, r1
 8005910:	62da      	str	r2, [r3, #44]	; 0x2c
#endif /* USART_PRESC_PRESCALER */

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8005912:	687b      	ldr	r3, [r7, #4]
 8005914:	681b      	ldr	r3, [r3, #0]
 8005916:	4a97      	ldr	r2, [pc, #604]	; (8005b74 <UART_SetConfig+0x304>)
 8005918:	4293      	cmp	r3, r2
 800591a:	d121      	bne.n	8005960 <UART_SetConfig+0xf0>
 800591c:	4b96      	ldr	r3, [pc, #600]	; (8005b78 <UART_SetConfig+0x308>)
 800591e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005922:	f003 0303 	and.w	r3, r3, #3
 8005926:	2b03      	cmp	r3, #3
 8005928:	d816      	bhi.n	8005958 <UART_SetConfig+0xe8>
 800592a:	a201      	add	r2, pc, #4	; (adr r2, 8005930 <UART_SetConfig+0xc0>)
 800592c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005930:	08005941 	.word	0x08005941
 8005934:	0800594d 	.word	0x0800594d
 8005938:	08005947 	.word	0x08005947
 800593c:	08005953 	.word	0x08005953
 8005940:	2301      	movs	r3, #1
 8005942:	76fb      	strb	r3, [r7, #27]
 8005944:	e0e8      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005946:	2302      	movs	r3, #2
 8005948:	76fb      	strb	r3, [r7, #27]
 800594a:	e0e5      	b.n	8005b18 <UART_SetConfig+0x2a8>
 800594c:	2304      	movs	r3, #4
 800594e:	76fb      	strb	r3, [r7, #27]
 8005950:	e0e2      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005952:	2308      	movs	r3, #8
 8005954:	76fb      	strb	r3, [r7, #27]
 8005956:	e0df      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005958:	2310      	movs	r3, #16
 800595a:	76fb      	strb	r3, [r7, #27]
 800595c:	bf00      	nop
 800595e:	e0db      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005960:	687b      	ldr	r3, [r7, #4]
 8005962:	681b      	ldr	r3, [r3, #0]
 8005964:	4a85      	ldr	r2, [pc, #532]	; (8005b7c <UART_SetConfig+0x30c>)
 8005966:	4293      	cmp	r3, r2
 8005968:	d134      	bne.n	80059d4 <UART_SetConfig+0x164>
 800596a:	4b83      	ldr	r3, [pc, #524]	; (8005b78 <UART_SetConfig+0x308>)
 800596c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005970:	f003 030c 	and.w	r3, r3, #12
 8005974:	2b0c      	cmp	r3, #12
 8005976:	d829      	bhi.n	80059cc <UART_SetConfig+0x15c>
 8005978:	a201      	add	r2, pc, #4	; (adr r2, 8005980 <UART_SetConfig+0x110>)
 800597a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800597e:	bf00      	nop
 8005980:	080059b5 	.word	0x080059b5
 8005984:	080059cd 	.word	0x080059cd
 8005988:	080059cd 	.word	0x080059cd
 800598c:	080059cd 	.word	0x080059cd
 8005990:	080059c1 	.word	0x080059c1
 8005994:	080059cd 	.word	0x080059cd
 8005998:	080059cd 	.word	0x080059cd
 800599c:	080059cd 	.word	0x080059cd
 80059a0:	080059bb 	.word	0x080059bb
 80059a4:	080059cd 	.word	0x080059cd
 80059a8:	080059cd 	.word	0x080059cd
 80059ac:	080059cd 	.word	0x080059cd
 80059b0:	080059c7 	.word	0x080059c7
 80059b4:	2300      	movs	r3, #0
 80059b6:	76fb      	strb	r3, [r7, #27]
 80059b8:	e0ae      	b.n	8005b18 <UART_SetConfig+0x2a8>
 80059ba:	2302      	movs	r3, #2
 80059bc:	76fb      	strb	r3, [r7, #27]
 80059be:	e0ab      	b.n	8005b18 <UART_SetConfig+0x2a8>
 80059c0:	2304      	movs	r3, #4
 80059c2:	76fb      	strb	r3, [r7, #27]
 80059c4:	e0a8      	b.n	8005b18 <UART_SetConfig+0x2a8>
 80059c6:	2308      	movs	r3, #8
 80059c8:	76fb      	strb	r3, [r7, #27]
 80059ca:	e0a5      	b.n	8005b18 <UART_SetConfig+0x2a8>
 80059cc:	2310      	movs	r3, #16
 80059ce:	76fb      	strb	r3, [r7, #27]
 80059d0:	bf00      	nop
 80059d2:	e0a1      	b.n	8005b18 <UART_SetConfig+0x2a8>
 80059d4:	687b      	ldr	r3, [r7, #4]
 80059d6:	681b      	ldr	r3, [r3, #0]
 80059d8:	4a69      	ldr	r2, [pc, #420]	; (8005b80 <UART_SetConfig+0x310>)
 80059da:	4293      	cmp	r3, r2
 80059dc:	d120      	bne.n	8005a20 <UART_SetConfig+0x1b0>
 80059de:	4b66      	ldr	r3, [pc, #408]	; (8005b78 <UART_SetConfig+0x308>)
 80059e0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80059e4:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80059e8:	2b10      	cmp	r3, #16
 80059ea:	d00f      	beq.n	8005a0c <UART_SetConfig+0x19c>
 80059ec:	2b10      	cmp	r3, #16
 80059ee:	d802      	bhi.n	80059f6 <UART_SetConfig+0x186>
 80059f0:	2b00      	cmp	r3, #0
 80059f2:	d005      	beq.n	8005a00 <UART_SetConfig+0x190>
 80059f4:	e010      	b.n	8005a18 <UART_SetConfig+0x1a8>
 80059f6:	2b20      	cmp	r3, #32
 80059f8:	d005      	beq.n	8005a06 <UART_SetConfig+0x196>
 80059fa:	2b30      	cmp	r3, #48	; 0x30
 80059fc:	d009      	beq.n	8005a12 <UART_SetConfig+0x1a2>
 80059fe:	e00b      	b.n	8005a18 <UART_SetConfig+0x1a8>
 8005a00:	2300      	movs	r3, #0
 8005a02:	76fb      	strb	r3, [r7, #27]
 8005a04:	e088      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005a06:	2302      	movs	r3, #2
 8005a08:	76fb      	strb	r3, [r7, #27]
 8005a0a:	e085      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005a0c:	2304      	movs	r3, #4
 8005a0e:	76fb      	strb	r3, [r7, #27]
 8005a10:	e082      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005a12:	2308      	movs	r3, #8
 8005a14:	76fb      	strb	r3, [r7, #27]
 8005a16:	e07f      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005a18:	2310      	movs	r3, #16
 8005a1a:	76fb      	strb	r3, [r7, #27]
 8005a1c:	bf00      	nop
 8005a1e:	e07b      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005a20:	687b      	ldr	r3, [r7, #4]
 8005a22:	681b      	ldr	r3, [r3, #0]
 8005a24:	4a57      	ldr	r2, [pc, #348]	; (8005b84 <UART_SetConfig+0x314>)
 8005a26:	4293      	cmp	r3, r2
 8005a28:	d120      	bne.n	8005a6c <UART_SetConfig+0x1fc>
 8005a2a:	4b53      	ldr	r3, [pc, #332]	; (8005b78 <UART_SetConfig+0x308>)
 8005a2c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005a30:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8005a34:	2b40      	cmp	r3, #64	; 0x40
 8005a36:	d00f      	beq.n	8005a58 <UART_SetConfig+0x1e8>
 8005a38:	2b40      	cmp	r3, #64	; 0x40
 8005a3a:	d802      	bhi.n	8005a42 <UART_SetConfig+0x1d2>
 8005a3c:	2b00      	cmp	r3, #0
 8005a3e:	d005      	beq.n	8005a4c <UART_SetConfig+0x1dc>
 8005a40:	e010      	b.n	8005a64 <UART_SetConfig+0x1f4>
 8005a42:	2b80      	cmp	r3, #128	; 0x80
 8005a44:	d005      	beq.n	8005a52 <UART_SetConfig+0x1e2>
 8005a46:	2bc0      	cmp	r3, #192	; 0xc0
 8005a48:	d009      	beq.n	8005a5e <UART_SetConfig+0x1ee>
 8005a4a:	e00b      	b.n	8005a64 <UART_SetConfig+0x1f4>
 8005a4c:	2300      	movs	r3, #0
 8005a4e:	76fb      	strb	r3, [r7, #27]
 8005a50:	e062      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005a52:	2302      	movs	r3, #2
 8005a54:	76fb      	strb	r3, [r7, #27]
 8005a56:	e05f      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005a58:	2304      	movs	r3, #4
 8005a5a:	76fb      	strb	r3, [r7, #27]
 8005a5c:	e05c      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005a5e:	2308      	movs	r3, #8
 8005a60:	76fb      	strb	r3, [r7, #27]
 8005a62:	e059      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005a64:	2310      	movs	r3, #16
 8005a66:	76fb      	strb	r3, [r7, #27]
 8005a68:	bf00      	nop
 8005a6a:	e055      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005a6c:	687b      	ldr	r3, [r7, #4]
 8005a6e:	681b      	ldr	r3, [r3, #0]
 8005a70:	4a45      	ldr	r2, [pc, #276]	; (8005b88 <UART_SetConfig+0x318>)
 8005a72:	4293      	cmp	r3, r2
 8005a74:	d124      	bne.n	8005ac0 <UART_SetConfig+0x250>
 8005a76:	4b40      	ldr	r3, [pc, #256]	; (8005b78 <UART_SetConfig+0x308>)
 8005a78:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005a7c:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8005a80:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8005a84:	d012      	beq.n	8005aac <UART_SetConfig+0x23c>
 8005a86:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8005a8a:	d802      	bhi.n	8005a92 <UART_SetConfig+0x222>
 8005a8c:	2b00      	cmp	r3, #0
 8005a8e:	d007      	beq.n	8005aa0 <UART_SetConfig+0x230>
 8005a90:	e012      	b.n	8005ab8 <UART_SetConfig+0x248>
 8005a92:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005a96:	d006      	beq.n	8005aa6 <UART_SetConfig+0x236>
 8005a98:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8005a9c:	d009      	beq.n	8005ab2 <UART_SetConfig+0x242>
 8005a9e:	e00b      	b.n	8005ab8 <UART_SetConfig+0x248>
 8005aa0:	2300      	movs	r3, #0
 8005aa2:	76fb      	strb	r3, [r7, #27]
 8005aa4:	e038      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005aa6:	2302      	movs	r3, #2
 8005aa8:	76fb      	strb	r3, [r7, #27]
 8005aaa:	e035      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005aac:	2304      	movs	r3, #4
 8005aae:	76fb      	strb	r3, [r7, #27]
 8005ab0:	e032      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005ab2:	2308      	movs	r3, #8
 8005ab4:	76fb      	strb	r3, [r7, #27]
 8005ab6:	e02f      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005ab8:	2310      	movs	r3, #16
 8005aba:	76fb      	strb	r3, [r7, #27]
 8005abc:	bf00      	nop
 8005abe:	e02b      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005ac0:	687b      	ldr	r3, [r7, #4]
 8005ac2:	681b      	ldr	r3, [r3, #0]
 8005ac4:	4a2a      	ldr	r2, [pc, #168]	; (8005b70 <UART_SetConfig+0x300>)
 8005ac6:	4293      	cmp	r3, r2
 8005ac8:	d124      	bne.n	8005b14 <UART_SetConfig+0x2a4>
 8005aca:	4b2b      	ldr	r3, [pc, #172]	; (8005b78 <UART_SetConfig+0x308>)
 8005acc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005ad0:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 8005ad4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8005ad8:	d012      	beq.n	8005b00 <UART_SetConfig+0x290>
 8005ada:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8005ade:	d802      	bhi.n	8005ae6 <UART_SetConfig+0x276>
 8005ae0:	2b00      	cmp	r3, #0
 8005ae2:	d007      	beq.n	8005af4 <UART_SetConfig+0x284>
 8005ae4:	e012      	b.n	8005b0c <UART_SetConfig+0x29c>
 8005ae6:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8005aea:	d006      	beq.n	8005afa <UART_SetConfig+0x28a>
 8005aec:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8005af0:	d009      	beq.n	8005b06 <UART_SetConfig+0x296>
 8005af2:	e00b      	b.n	8005b0c <UART_SetConfig+0x29c>
 8005af4:	2300      	movs	r3, #0
 8005af6:	76fb      	strb	r3, [r7, #27]
 8005af8:	e00e      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005afa:	2302      	movs	r3, #2
 8005afc:	76fb      	strb	r3, [r7, #27]
 8005afe:	e00b      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005b00:	2304      	movs	r3, #4
 8005b02:	76fb      	strb	r3, [r7, #27]
 8005b04:	e008      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005b06:	2308      	movs	r3, #8
 8005b08:	76fb      	strb	r3, [r7, #27]
 8005b0a:	e005      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005b0c:	2310      	movs	r3, #16
 8005b0e:	76fb      	strb	r3, [r7, #27]
 8005b10:	bf00      	nop
 8005b12:	e001      	b.n	8005b18 <UART_SetConfig+0x2a8>
 8005b14:	2310      	movs	r3, #16
 8005b16:	76fb      	strb	r3, [r7, #27]

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 8005b18:	687b      	ldr	r3, [r7, #4]
 8005b1a:	681b      	ldr	r3, [r3, #0]
 8005b1c:	4a14      	ldr	r2, [pc, #80]	; (8005b70 <UART_SetConfig+0x300>)
 8005b1e:	4293      	cmp	r3, r2
 8005b20:	f040 80a1 	bne.w	8005c66 <UART_SetConfig+0x3f6>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
 8005b24:	7efb      	ldrb	r3, [r7, #27]
 8005b26:	2b08      	cmp	r3, #8
 8005b28:	d836      	bhi.n	8005b98 <UART_SetConfig+0x328>
 8005b2a:	a201      	add	r2, pc, #4	; (adr r2, 8005b30 <UART_SetConfig+0x2c0>)
 8005b2c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005b30:	08005b55 	.word	0x08005b55
 8005b34:	08005b99 	.word	0x08005b99
 8005b38:	08005b5d 	.word	0x08005b5d
 8005b3c:	08005b99 	.word	0x08005b99
 8005b40:	08005b63 	.word	0x08005b63
 8005b44:	08005b99 	.word	0x08005b99
 8005b48:	08005b99 	.word	0x08005b99
 8005b4c:	08005b99 	.word	0x08005b99
 8005b50:	08005b91 	.word	0x08005b91
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 8005b54:	f7fe fefc 	bl	8004950 <HAL_RCC_GetPCLK1Freq>
 8005b58:	6178      	str	r0, [r7, #20]
        break;
 8005b5a:	e022      	b.n	8005ba2 <UART_SetConfig+0x332>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
 8005b5c:	4b0b      	ldr	r3, [pc, #44]	; (8005b8c <UART_SetConfig+0x31c>)
 8005b5e:	617b      	str	r3, [r7, #20]
        break;
 8005b60:	e01f      	b.n	8005ba2 <UART_SetConfig+0x332>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 8005b62:	f7fe fe5f 	bl	8004824 <HAL_RCC_GetSysClockFreq>
 8005b66:	6178      	str	r0, [r7, #20]
        break;
 8005b68:	e01b      	b.n	8005ba2 <UART_SetConfig+0x332>
 8005b6a:	bf00      	nop
 8005b6c:	cfff69f3 	.word	0xcfff69f3
 8005b70:	40008000 	.word	0x40008000
 8005b74:	40013800 	.word	0x40013800
 8005b78:	40021000 	.word	0x40021000
 8005b7c:	40004400 	.word	0x40004400
 8005b80:	40004800 	.word	0x40004800
 8005b84:	40004c00 	.word	0x40004c00
 8005b88:	40005000 	.word	0x40005000
 8005b8c:	00f42400 	.word	0x00f42400
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8005b90:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8005b94:	617b      	str	r3, [r7, #20]
        break;
 8005b96:	e004      	b.n	8005ba2 <UART_SetConfig+0x332>
      default:
        pclk = 0U;
 8005b98:	2300      	movs	r3, #0
 8005b9a:	617b      	str	r3, [r7, #20]
        ret = HAL_ERROR;
 8005b9c:	2301      	movs	r3, #1
 8005b9e:	76bb      	strb	r3, [r7, #26]
        break;
 8005ba0:	bf00      	nop
    }

    /* If proper clock source reported */
    if (pclk != 0U)
 8005ba2:	697b      	ldr	r3, [r7, #20]
 8005ba4:	2b00      	cmp	r3, #0
 8005ba6:	f000 811d 	beq.w	8005de4 <UART_SetConfig+0x574>
    {
#if defined(USART_PRESC_PRESCALER)
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8005baa:	687b      	ldr	r3, [r7, #4]
 8005bac:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005bae:	4a97      	ldr	r2, [pc, #604]	; (8005e0c <UART_SetConfig+0x59c>)
 8005bb0:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8005bb4:	461a      	mov	r2, r3
 8005bb6:	697b      	ldr	r3, [r7, #20]
 8005bb8:	fbb3 f3f2 	udiv	r3, r3, r2
 8005bbc:	60bb      	str	r3, [r7, #8]

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8005bbe:	687b      	ldr	r3, [r7, #4]
 8005bc0:	685a      	ldr	r2, [r3, #4]
 8005bc2:	4613      	mov	r3, r2
 8005bc4:	005b      	lsls	r3, r3, #1
 8005bc6:	4413      	add	r3, r2
 8005bc8:	68ba      	ldr	r2, [r7, #8]
 8005bca:	429a      	cmp	r2, r3
 8005bcc:	d305      	bcc.n	8005bda <UART_SetConfig+0x36a>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
 8005bce:	687b      	ldr	r3, [r7, #4]
 8005bd0:	685b      	ldr	r3, [r3, #4]
 8005bd2:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8005bd4:	68ba      	ldr	r2, [r7, #8]
 8005bd6:	429a      	cmp	r2, r3
 8005bd8:	d902      	bls.n	8005be0 <UART_SetConfig+0x370>
      {
        ret = HAL_ERROR;
 8005bda:	2301      	movs	r3, #1
 8005bdc:	76bb      	strb	r3, [r7, #26]
 8005bde:	e101      	b.n	8005de4 <UART_SetConfig+0x574>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, (uint64_t)huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8005be0:	697b      	ldr	r3, [r7, #20]
 8005be2:	4618      	mov	r0, r3
 8005be4:	f04f 0100 	mov.w	r1, #0
 8005be8:	687b      	ldr	r3, [r7, #4]
 8005bea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005bec:	4a87      	ldr	r2, [pc, #540]	; (8005e0c <UART_SetConfig+0x59c>)
 8005bee:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8005bf2:	b29b      	uxth	r3, r3
 8005bf4:	f04f 0400 	mov.w	r4, #0
 8005bf8:	461a      	mov	r2, r3
 8005bfa:	4623      	mov	r3, r4
 8005bfc:	f7fa fb58 	bl	80002b0 <__aeabi_uldivmod>
 8005c00:	4603      	mov	r3, r0
 8005c02:	460c      	mov	r4, r1
 8005c04:	4619      	mov	r1, r3
 8005c06:	4622      	mov	r2, r4
 8005c08:	f04f 0300 	mov.w	r3, #0
 8005c0c:	f04f 0400 	mov.w	r4, #0
 8005c10:	0214      	lsls	r4, r2, #8
 8005c12:	ea44 6411 	orr.w	r4, r4, r1, lsr #24
 8005c16:	020b      	lsls	r3, r1, #8
 8005c18:	687a      	ldr	r2, [r7, #4]
 8005c1a:	6852      	ldr	r2, [r2, #4]
 8005c1c:	0852      	lsrs	r2, r2, #1
 8005c1e:	4611      	mov	r1, r2
 8005c20:	f04f 0200 	mov.w	r2, #0
 8005c24:	eb13 0b01 	adds.w	fp, r3, r1
 8005c28:	eb44 0c02 	adc.w	ip, r4, r2
 8005c2c:	4658      	mov	r0, fp
 8005c2e:	4661      	mov	r1, ip
 8005c30:	687b      	ldr	r3, [r7, #4]
 8005c32:	685b      	ldr	r3, [r3, #4]
 8005c34:	f04f 0400 	mov.w	r4, #0
 8005c38:	461a      	mov	r2, r3
 8005c3a:	4623      	mov	r3, r4
 8005c3c:	f7fa fb38 	bl	80002b0 <__aeabi_uldivmod>
 8005c40:	4603      	mov	r3, r0
 8005c42:	460c      	mov	r4, r1
 8005c44:	613b      	str	r3, [r7, #16]
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8005c46:	693b      	ldr	r3, [r7, #16]
 8005c48:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8005c4c:	d308      	bcc.n	8005c60 <UART_SetConfig+0x3f0>
 8005c4e:	693b      	ldr	r3, [r7, #16]
 8005c50:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8005c54:	d204      	bcs.n	8005c60 <UART_SetConfig+0x3f0>
        {
          huart->Instance->BRR = usartdiv;
 8005c56:	687b      	ldr	r3, [r7, #4]
 8005c58:	681b      	ldr	r3, [r3, #0]
 8005c5a:	693a      	ldr	r2, [r7, #16]
 8005c5c:	60da      	str	r2, [r3, #12]
 8005c5e:	e0c1      	b.n	8005de4 <UART_SetConfig+0x574>
        }
        else
        {
          ret = HAL_ERROR;
 8005c60:	2301      	movs	r3, #1
 8005c62:	76bb      	strb	r3, [r7, #26]
 8005c64:	e0be      	b.n	8005de4 <UART_SetConfig+0x574>
      } /* if ( (pclk < (3 * huart->Init.BaudRate) ) || (pclk > (4096 * huart->Init.BaudRate) )) */
#endif /* USART_PRESC_PRESCALER */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8005c66:	687b      	ldr	r3, [r7, #4]
 8005c68:	69db      	ldr	r3, [r3, #28]
 8005c6a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8005c6e:	d164      	bne.n	8005d3a <UART_SetConfig+0x4ca>
  {
    switch (clocksource)
 8005c70:	7efb      	ldrb	r3, [r7, #27]
 8005c72:	2b08      	cmp	r3, #8
 8005c74:	d827      	bhi.n	8005cc6 <UART_SetConfig+0x456>
 8005c76:	a201      	add	r2, pc, #4	; (adr r2, 8005c7c <UART_SetConfig+0x40c>)
 8005c78:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005c7c:	08005ca1 	.word	0x08005ca1
 8005c80:	08005ca9 	.word	0x08005ca9
 8005c84:	08005cb1 	.word	0x08005cb1
 8005c88:	08005cc7 	.word	0x08005cc7
 8005c8c:	08005cb7 	.word	0x08005cb7
 8005c90:	08005cc7 	.word	0x08005cc7
 8005c94:	08005cc7 	.word	0x08005cc7
 8005c98:	08005cc7 	.word	0x08005cc7
 8005c9c:	08005cbf 	.word	0x08005cbf
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 8005ca0:	f7fe fe56 	bl	8004950 <HAL_RCC_GetPCLK1Freq>
 8005ca4:	6178      	str	r0, [r7, #20]
        break;
 8005ca6:	e013      	b.n	8005cd0 <UART_SetConfig+0x460>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 8005ca8:	f7fe fe68 	bl	800497c <HAL_RCC_GetPCLK2Freq>
 8005cac:	6178      	str	r0, [r7, #20]
        break;
 8005cae:	e00f      	b.n	8005cd0 <UART_SetConfig+0x460>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
 8005cb0:	4b57      	ldr	r3, [pc, #348]	; (8005e10 <UART_SetConfig+0x5a0>)
 8005cb2:	617b      	str	r3, [r7, #20]
        break;
 8005cb4:	e00c      	b.n	8005cd0 <UART_SetConfig+0x460>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 8005cb6:	f7fe fdb5 	bl	8004824 <HAL_RCC_GetSysClockFreq>
 8005cba:	6178      	str	r0, [r7, #20]
        break;
 8005cbc:	e008      	b.n	8005cd0 <UART_SetConfig+0x460>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8005cbe:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8005cc2:	617b      	str	r3, [r7, #20]
        break;
 8005cc4:	e004      	b.n	8005cd0 <UART_SetConfig+0x460>
      default:
        pclk = 0U;
 8005cc6:	2300      	movs	r3, #0
 8005cc8:	617b      	str	r3, [r7, #20]
        ret = HAL_ERROR;
 8005cca:	2301      	movs	r3, #1
 8005ccc:	76bb      	strb	r3, [r7, #26]
        break;
 8005cce:	bf00      	nop
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 8005cd0:	697b      	ldr	r3, [r7, #20]
 8005cd2:	2b00      	cmp	r3, #0
 8005cd4:	f000 8086 	beq.w	8005de4 <UART_SetConfig+0x574>
    {
#if defined(USART_PRESC_PRESCALER)
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8005cd8:	687b      	ldr	r3, [r7, #4]
 8005cda:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005cdc:	4a4b      	ldr	r2, [pc, #300]	; (8005e0c <UART_SetConfig+0x59c>)
 8005cde:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8005ce2:	461a      	mov	r2, r3
 8005ce4:	697b      	ldr	r3, [r7, #20]
 8005ce6:	fbb3 f3f2 	udiv	r3, r3, r2
 8005cea:	005a      	lsls	r2, r3, #1
 8005cec:	687b      	ldr	r3, [r7, #4]
 8005cee:	685b      	ldr	r3, [r3, #4]
 8005cf0:	085b      	lsrs	r3, r3, #1
 8005cf2:	441a      	add	r2, r3
 8005cf4:	687b      	ldr	r3, [r7, #4]
 8005cf6:	685b      	ldr	r3, [r3, #4]
 8005cf8:	fbb2 f3f3 	udiv	r3, r2, r3
 8005cfc:	b29b      	uxth	r3, r3
 8005cfe:	613b      	str	r3, [r7, #16]
#else
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
#endif /* USART_PRESC_PRESCALER */
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8005d00:	693b      	ldr	r3, [r7, #16]
 8005d02:	2b0f      	cmp	r3, #15
 8005d04:	d916      	bls.n	8005d34 <UART_SetConfig+0x4c4>
 8005d06:	693b      	ldr	r3, [r7, #16]
 8005d08:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8005d0c:	d212      	bcs.n	8005d34 <UART_SetConfig+0x4c4>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8005d0e:	693b      	ldr	r3, [r7, #16]
 8005d10:	b29b      	uxth	r3, r3
 8005d12:	f023 030f 	bic.w	r3, r3, #15
 8005d16:	81fb      	strh	r3, [r7, #14]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8005d18:	693b      	ldr	r3, [r7, #16]
 8005d1a:	085b      	lsrs	r3, r3, #1
 8005d1c:	b29b      	uxth	r3, r3
 8005d1e:	f003 0307 	and.w	r3, r3, #7
 8005d22:	b29a      	uxth	r2, r3
 8005d24:	89fb      	ldrh	r3, [r7, #14]
 8005d26:	4313      	orrs	r3, r2
 8005d28:	81fb      	strh	r3, [r7, #14]
        huart->Instance->BRR = brrtemp;
 8005d2a:	687b      	ldr	r3, [r7, #4]
 8005d2c:	681b      	ldr	r3, [r3, #0]
 8005d2e:	89fa      	ldrh	r2, [r7, #14]
 8005d30:	60da      	str	r2, [r3, #12]
 8005d32:	e057      	b.n	8005de4 <UART_SetConfig+0x574>
      }
      else
      {
        ret = HAL_ERROR;
 8005d34:	2301      	movs	r3, #1
 8005d36:	76bb      	strb	r3, [r7, #26]
 8005d38:	e054      	b.n	8005de4 <UART_SetConfig+0x574>
      }
    }
  }
  else
  {
    switch (clocksource)
 8005d3a:	7efb      	ldrb	r3, [r7, #27]
 8005d3c:	2b08      	cmp	r3, #8
 8005d3e:	d828      	bhi.n	8005d92 <UART_SetConfig+0x522>
 8005d40:	a201      	add	r2, pc, #4	; (adr r2, 8005d48 <UART_SetConfig+0x4d8>)
 8005d42:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005d46:	bf00      	nop
 8005d48:	08005d6d 	.word	0x08005d6d
 8005d4c:	08005d75 	.word	0x08005d75
 8005d50:	08005d7d 	.word	0x08005d7d
 8005d54:	08005d93 	.word	0x08005d93
 8005d58:	08005d83 	.word	0x08005d83
 8005d5c:	08005d93 	.word	0x08005d93
 8005d60:	08005d93 	.word	0x08005d93
 8005d64:	08005d93 	.word	0x08005d93
 8005d68:	08005d8b 	.word	0x08005d8b
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 8005d6c:	f7fe fdf0 	bl	8004950 <HAL_RCC_GetPCLK1Freq>
 8005d70:	6178      	str	r0, [r7, #20]
        break;
 8005d72:	e013      	b.n	8005d9c <UART_SetConfig+0x52c>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 8005d74:	f7fe fe02 	bl	800497c <HAL_RCC_GetPCLK2Freq>
 8005d78:	6178      	str	r0, [r7, #20]
        break;
 8005d7a:	e00f      	b.n	8005d9c <UART_SetConfig+0x52c>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
 8005d7c:	4b24      	ldr	r3, [pc, #144]	; (8005e10 <UART_SetConfig+0x5a0>)
 8005d7e:	617b      	str	r3, [r7, #20]
        break;
 8005d80:	e00c      	b.n	8005d9c <UART_SetConfig+0x52c>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 8005d82:	f7fe fd4f 	bl	8004824 <HAL_RCC_GetSysClockFreq>
 8005d86:	6178      	str	r0, [r7, #20]
        break;
 8005d88:	e008      	b.n	8005d9c <UART_SetConfig+0x52c>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8005d8a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8005d8e:	617b      	str	r3, [r7, #20]
        break;
 8005d90:	e004      	b.n	8005d9c <UART_SetConfig+0x52c>
      default:
        pclk = 0U;
 8005d92:	2300      	movs	r3, #0
 8005d94:	617b      	str	r3, [r7, #20]
        ret = HAL_ERROR;
 8005d96:	2301      	movs	r3, #1
 8005d98:	76bb      	strb	r3, [r7, #26]
        break;
 8005d9a:	bf00      	nop
    }

    if (pclk != 0U)
 8005d9c:	697b      	ldr	r3, [r7, #20]
 8005d9e:	2b00      	cmp	r3, #0
 8005da0:	d020      	beq.n	8005de4 <UART_SetConfig+0x574>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
#if defined(USART_PRESC_PRESCALER)
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8005da2:	687b      	ldr	r3, [r7, #4]
 8005da4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005da6:	4a19      	ldr	r2, [pc, #100]	; (8005e0c <UART_SetConfig+0x59c>)
 8005da8:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8005dac:	461a      	mov	r2, r3
 8005dae:	697b      	ldr	r3, [r7, #20]
 8005db0:	fbb3 f2f2 	udiv	r2, r3, r2
 8005db4:	687b      	ldr	r3, [r7, #4]
 8005db6:	685b      	ldr	r3, [r3, #4]
 8005db8:	085b      	lsrs	r3, r3, #1
 8005dba:	441a      	add	r2, r3
 8005dbc:	687b      	ldr	r3, [r7, #4]
 8005dbe:	685b      	ldr	r3, [r3, #4]
 8005dc0:	fbb2 f3f3 	udiv	r3, r2, r3
 8005dc4:	b29b      	uxth	r3, r3
 8005dc6:	613b      	str	r3, [r7, #16]
#else
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
#endif /* USART_PRESC_PRESCALER */
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8005dc8:	693b      	ldr	r3, [r7, #16]
 8005dca:	2b0f      	cmp	r3, #15
 8005dcc:	d908      	bls.n	8005de0 <UART_SetConfig+0x570>
 8005dce:	693b      	ldr	r3, [r7, #16]
 8005dd0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8005dd4:	d204      	bcs.n	8005de0 <UART_SetConfig+0x570>
      {
        huart->Instance->BRR = usartdiv;
 8005dd6:	687b      	ldr	r3, [r7, #4]
 8005dd8:	681b      	ldr	r3, [r3, #0]
 8005dda:	693a      	ldr	r2, [r7, #16]
 8005ddc:	60da      	str	r2, [r3, #12]
 8005dde:	e001      	b.n	8005de4 <UART_SetConfig+0x574>
      }
      else
      {
        ret = HAL_ERROR;
 8005de0:	2301      	movs	r3, #1
 8005de2:	76bb      	strb	r3, [r7, #26]
    }
  }

#if defined(USART_CR1_FIFOEN)
  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
 8005de4:	687b      	ldr	r3, [r7, #4]
 8005de6:	2201      	movs	r2, #1
 8005de8:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
  huart->NbRxDataToProcess = 1;
 8005dec:	687b      	ldr	r3, [r7, #4]
 8005dee:	2201      	movs	r2, #1
 8005df0:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
#endif /* USART_CR1_FIFOEN */

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 8005df4:	687b      	ldr	r3, [r7, #4]
 8005df6:	2200      	movs	r2, #0
 8005df8:	66da      	str	r2, [r3, #108]	; 0x6c
  huart->TxISR = NULL;
 8005dfa:	687b      	ldr	r3, [r7, #4]
 8005dfc:	2200      	movs	r2, #0
 8005dfe:	671a      	str	r2, [r3, #112]	; 0x70

  return ret;
 8005e00:	7ebb      	ldrb	r3, [r7, #26]
}
 8005e02:	4618      	mov	r0, r3
 8005e04:	3720      	adds	r7, #32
 8005e06:	46bd      	mov	sp, r7
 8005e08:	e8bd 8890 	ldmia.w	sp!, {r4, r7, fp, pc}
 8005e0c:	0801abd0 	.word	0x0801abd0
 8005e10:	00f42400 	.word	0x00f42400

08005e14 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 8005e14:	b480      	push	{r7}
 8005e16:	b083      	sub	sp, #12
 8005e18:	af00      	add	r7, sp, #0
 8005e1a:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8005e1c:	687b      	ldr	r3, [r7, #4]
 8005e1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005e20:	f003 0301 	and.w	r3, r3, #1
 8005e24:	2b00      	cmp	r3, #0
 8005e26:	d00a      	beq.n	8005e3e <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8005e28:	687b      	ldr	r3, [r7, #4]
 8005e2a:	681b      	ldr	r3, [r3, #0]
 8005e2c:	685b      	ldr	r3, [r3, #4]
 8005e2e:	f423 3100 	bic.w	r1, r3, #131072	; 0x20000
 8005e32:	687b      	ldr	r3, [r7, #4]
 8005e34:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005e36:	687b      	ldr	r3, [r7, #4]
 8005e38:	681b      	ldr	r3, [r3, #0]
 8005e3a:	430a      	orrs	r2, r1
 8005e3c:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8005e3e:	687b      	ldr	r3, [r7, #4]
 8005e40:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005e42:	f003 0302 	and.w	r3, r3, #2
 8005e46:	2b00      	cmp	r3, #0
 8005e48:	d00a      	beq.n	8005e60 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8005e4a:	687b      	ldr	r3, [r7, #4]
 8005e4c:	681b      	ldr	r3, [r3, #0]
 8005e4e:	685b      	ldr	r3, [r3, #4]
 8005e50:	f423 3180 	bic.w	r1, r3, #65536	; 0x10000
 8005e54:	687b      	ldr	r3, [r7, #4]
 8005e56:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005e58:	687b      	ldr	r3, [r7, #4]
 8005e5a:	681b      	ldr	r3, [r3, #0]
 8005e5c:	430a      	orrs	r2, r1
 8005e5e:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8005e60:	687b      	ldr	r3, [r7, #4]
 8005e62:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005e64:	f003 0304 	and.w	r3, r3, #4
 8005e68:	2b00      	cmp	r3, #0
 8005e6a:	d00a      	beq.n	8005e82 <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8005e6c:	687b      	ldr	r3, [r7, #4]
 8005e6e:	681b      	ldr	r3, [r3, #0]
 8005e70:	685b      	ldr	r3, [r3, #4]
 8005e72:	f423 2180 	bic.w	r1, r3, #262144	; 0x40000
 8005e76:	687b      	ldr	r3, [r7, #4]
 8005e78:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8005e7a:	687b      	ldr	r3, [r7, #4]
 8005e7c:	681b      	ldr	r3, [r3, #0]
 8005e7e:	430a      	orrs	r2, r1
 8005e80:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8005e82:	687b      	ldr	r3, [r7, #4]
 8005e84:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005e86:	f003 0308 	and.w	r3, r3, #8
 8005e8a:	2b00      	cmp	r3, #0
 8005e8c:	d00a      	beq.n	8005ea4 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8005e8e:	687b      	ldr	r3, [r7, #4]
 8005e90:	681b      	ldr	r3, [r3, #0]
 8005e92:	685b      	ldr	r3, [r3, #4]
 8005e94:	f423 4100 	bic.w	r1, r3, #32768	; 0x8000
 8005e98:	687b      	ldr	r3, [r7, #4]
 8005e9a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005e9c:	687b      	ldr	r3, [r7, #4]
 8005e9e:	681b      	ldr	r3, [r3, #0]
 8005ea0:	430a      	orrs	r2, r1
 8005ea2:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8005ea4:	687b      	ldr	r3, [r7, #4]
 8005ea6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005ea8:	f003 0310 	and.w	r3, r3, #16
 8005eac:	2b00      	cmp	r3, #0
 8005eae:	d00a      	beq.n	8005ec6 <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8005eb0:	687b      	ldr	r3, [r7, #4]
 8005eb2:	681b      	ldr	r3, [r3, #0]
 8005eb4:	689b      	ldr	r3, [r3, #8]
 8005eb6:	f423 5180 	bic.w	r1, r3, #4096	; 0x1000
 8005eba:	687b      	ldr	r3, [r7, #4]
 8005ebc:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8005ebe:	687b      	ldr	r3, [r7, #4]
 8005ec0:	681b      	ldr	r3, [r3, #0]
 8005ec2:	430a      	orrs	r2, r1
 8005ec4:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8005ec6:	687b      	ldr	r3, [r7, #4]
 8005ec8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005eca:	f003 0320 	and.w	r3, r3, #32
 8005ece:	2b00      	cmp	r3, #0
 8005ed0:	d00a      	beq.n	8005ee8 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8005ed2:	687b      	ldr	r3, [r7, #4]
 8005ed4:	681b      	ldr	r3, [r3, #0]
 8005ed6:	689b      	ldr	r3, [r3, #8]
 8005ed8:	f423 5100 	bic.w	r1, r3, #8192	; 0x2000
 8005edc:	687b      	ldr	r3, [r7, #4]
 8005ede:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005ee0:	687b      	ldr	r3, [r7, #4]
 8005ee2:	681b      	ldr	r3, [r3, #0]
 8005ee4:	430a      	orrs	r2, r1
 8005ee6:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8005ee8:	687b      	ldr	r3, [r7, #4]
 8005eea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005eec:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005ef0:	2b00      	cmp	r3, #0
 8005ef2:	d01a      	beq.n	8005f2a <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8005ef4:	687b      	ldr	r3, [r7, #4]
 8005ef6:	681b      	ldr	r3, [r3, #0]
 8005ef8:	685b      	ldr	r3, [r3, #4]
 8005efa:	f423 1180 	bic.w	r1, r3, #1048576	; 0x100000
 8005efe:	687b      	ldr	r3, [r7, #4]
 8005f00:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8005f02:	687b      	ldr	r3, [r7, #4]
 8005f04:	681b      	ldr	r3, [r3, #0]
 8005f06:	430a      	orrs	r2, r1
 8005f08:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8005f0a:	687b      	ldr	r3, [r7, #4]
 8005f0c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8005f0e:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8005f12:	d10a      	bne.n	8005f2a <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8005f14:	687b      	ldr	r3, [r7, #4]
 8005f16:	681b      	ldr	r3, [r3, #0]
 8005f18:	685b      	ldr	r3, [r3, #4]
 8005f1a:	f423 01c0 	bic.w	r1, r3, #6291456	; 0x600000
 8005f1e:	687b      	ldr	r3, [r7, #4]
 8005f20:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8005f22:	687b      	ldr	r3, [r7, #4]
 8005f24:	681b      	ldr	r3, [r3, #0]
 8005f26:	430a      	orrs	r2, r1
 8005f28:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8005f2a:	687b      	ldr	r3, [r7, #4]
 8005f2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005f2e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8005f32:	2b00      	cmp	r3, #0
 8005f34:	d00a      	beq.n	8005f4c <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8005f36:	687b      	ldr	r3, [r7, #4]
 8005f38:	681b      	ldr	r3, [r3, #0]
 8005f3a:	685b      	ldr	r3, [r3, #4]
 8005f3c:	f423 2100 	bic.w	r1, r3, #524288	; 0x80000
 8005f40:	687b      	ldr	r3, [r7, #4]
 8005f42:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8005f44:	687b      	ldr	r3, [r7, #4]
 8005f46:	681b      	ldr	r3, [r3, #0]
 8005f48:	430a      	orrs	r2, r1
 8005f4a:	605a      	str	r2, [r3, #4]
  }
}
 8005f4c:	bf00      	nop
 8005f4e:	370c      	adds	r7, #12
 8005f50:	46bd      	mov	sp, r7
 8005f52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005f56:	4770      	bx	lr

08005f58 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 8005f58:	b580      	push	{r7, lr}
 8005f5a:	b086      	sub	sp, #24
 8005f5c:	af02      	add	r7, sp, #8
 8005f5e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005f60:	687b      	ldr	r3, [r7, #4]
 8005f62:	2200      	movs	r2, #0
 8005f64:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 8005f68:	f7fb fd3e 	bl	80019e8 <HAL_GetTick>
 8005f6c:	60f8      	str	r0, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8005f6e:	687b      	ldr	r3, [r7, #4]
 8005f70:	681b      	ldr	r3, [r3, #0]
 8005f72:	681b      	ldr	r3, [r3, #0]
 8005f74:	f003 0308 	and.w	r3, r3, #8
 8005f78:	2b08      	cmp	r3, #8
 8005f7a:	d10e      	bne.n	8005f9a <UART_CheckIdleState+0x42>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8005f7c:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8005f80:	9300      	str	r3, [sp, #0]
 8005f82:	68fb      	ldr	r3, [r7, #12]
 8005f84:	2200      	movs	r2, #0
 8005f86:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8005f8a:	6878      	ldr	r0, [r7, #4]
 8005f8c:	f000 f82c 	bl	8005fe8 <UART_WaitOnFlagUntilTimeout>
 8005f90:	4603      	mov	r3, r0
 8005f92:	2b00      	cmp	r3, #0
 8005f94:	d001      	beq.n	8005f9a <UART_CheckIdleState+0x42>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 8005f96:	2303      	movs	r3, #3
 8005f98:	e022      	b.n	8005fe0 <UART_CheckIdleState+0x88>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8005f9a:	687b      	ldr	r3, [r7, #4]
 8005f9c:	681b      	ldr	r3, [r3, #0]
 8005f9e:	681b      	ldr	r3, [r3, #0]
 8005fa0:	f003 0304 	and.w	r3, r3, #4
 8005fa4:	2b04      	cmp	r3, #4
 8005fa6:	d10e      	bne.n	8005fc6 <UART_CheckIdleState+0x6e>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8005fa8:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8005fac:	9300      	str	r3, [sp, #0]
 8005fae:	68fb      	ldr	r3, [r7, #12]
 8005fb0:	2200      	movs	r2, #0
 8005fb2:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8005fb6:	6878      	ldr	r0, [r7, #4]
 8005fb8:	f000 f816 	bl	8005fe8 <UART_WaitOnFlagUntilTimeout>
 8005fbc:	4603      	mov	r3, r0
 8005fbe:	2b00      	cmp	r3, #0
 8005fc0:	d001      	beq.n	8005fc6 <UART_CheckIdleState+0x6e>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 8005fc2:	2303      	movs	r3, #3
 8005fc4:	e00c      	b.n	8005fe0 <UART_CheckIdleState+0x88>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 8005fc6:	687b      	ldr	r3, [r7, #4]
 8005fc8:	2220      	movs	r2, #32
 8005fca:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_READY;
 8005fce:	687b      	ldr	r3, [r7, #4]
 8005fd0:	2220      	movs	r2, #32
 8005fd2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  __HAL_UNLOCK(huart);
 8005fd6:	687b      	ldr	r3, [r7, #4]
 8005fd8:	2200      	movs	r2, #0
 8005fda:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

  return HAL_OK;
 8005fde:	2300      	movs	r3, #0
}
 8005fe0:	4618      	mov	r0, r3
 8005fe2:	3710      	adds	r7, #16
 8005fe4:	46bd      	mov	sp, r7
 8005fe6:	bd80      	pop	{r7, pc}

08005fe8 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 8005fe8:	b580      	push	{r7, lr}
 8005fea:	b084      	sub	sp, #16
 8005fec:	af00      	add	r7, sp, #0
 8005fee:	60f8      	str	r0, [r7, #12]
 8005ff0:	60b9      	str	r1, [r7, #8]
 8005ff2:	603b      	str	r3, [r7, #0]
 8005ff4:	4613      	mov	r3, r2
 8005ff6:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8005ff8:	e062      	b.n	80060c0 <UART_WaitOnFlagUntilTimeout+0xd8>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8005ffa:	69bb      	ldr	r3, [r7, #24]
 8005ffc:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006000:	d05e      	beq.n	80060c0 <UART_WaitOnFlagUntilTimeout+0xd8>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006002:	f7fb fcf1 	bl	80019e8 <HAL_GetTick>
 8006006:	4602      	mov	r2, r0
 8006008:	683b      	ldr	r3, [r7, #0]
 800600a:	1ad3      	subs	r3, r2, r3
 800600c:	69ba      	ldr	r2, [r7, #24]
 800600e:	429a      	cmp	r2, r3
 8006010:	d302      	bcc.n	8006018 <UART_WaitOnFlagUntilTimeout+0x30>
 8006012:	69bb      	ldr	r3, [r7, #24]
 8006014:	2b00      	cmp	r3, #0
 8006016:	d11d      	bne.n	8006054 <UART_WaitOnFlagUntilTimeout+0x6c>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
#if defined(USART_CR1_FIFOEN)
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 8006018:	68fb      	ldr	r3, [r7, #12]
 800601a:	681b      	ldr	r3, [r3, #0]
 800601c:	681a      	ldr	r2, [r3, #0]
 800601e:	68fb      	ldr	r3, [r7, #12]
 8006020:	681b      	ldr	r3, [r3, #0]
 8006022:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 8006026:	601a      	str	r2, [r3, #0]
#else
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
#endif /* USART_CR1_FIFOEN */
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8006028:	68fb      	ldr	r3, [r7, #12]
 800602a:	681b      	ldr	r3, [r3, #0]
 800602c:	689a      	ldr	r2, [r3, #8]
 800602e:	68fb      	ldr	r3, [r7, #12]
 8006030:	681b      	ldr	r3, [r3, #0]
 8006032:	f022 0201 	bic.w	r2, r2, #1
 8006036:	609a      	str	r2, [r3, #8]

        huart->gState = HAL_UART_STATE_READY;
 8006038:	68fb      	ldr	r3, [r7, #12]
 800603a:	2220      	movs	r2, #32
 800603c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
        huart->RxState = HAL_UART_STATE_READY;
 8006040:	68fb      	ldr	r3, [r7, #12]
 8006042:	2220      	movs	r2, #32
 8006044:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        __HAL_UNLOCK(huart);
 8006048:	68fb      	ldr	r3, [r7, #12]
 800604a:	2200      	movs	r2, #0
 800604c:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

        return HAL_TIMEOUT;
 8006050:	2303      	movs	r3, #3
 8006052:	e045      	b.n	80060e0 <UART_WaitOnFlagUntilTimeout+0xf8>
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 8006054:	68fb      	ldr	r3, [r7, #12]
 8006056:	681b      	ldr	r3, [r3, #0]
 8006058:	681b      	ldr	r3, [r3, #0]
 800605a:	f003 0304 	and.w	r3, r3, #4
 800605e:	2b00      	cmp	r3, #0
 8006060:	d02e      	beq.n	80060c0 <UART_WaitOnFlagUntilTimeout+0xd8>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 8006062:	68fb      	ldr	r3, [r7, #12]
 8006064:	681b      	ldr	r3, [r3, #0]
 8006066:	69db      	ldr	r3, [r3, #28]
 8006068:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800606c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8006070:	d126      	bne.n	80060c0 <UART_WaitOnFlagUntilTimeout+0xd8>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8006072:	68fb      	ldr	r3, [r7, #12]
 8006074:	681b      	ldr	r3, [r3, #0]
 8006076:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800607a:	621a      	str	r2, [r3, #32]

          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
#if defined(USART_CR1_FIFOEN)
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 800607c:	68fb      	ldr	r3, [r7, #12]
 800607e:	681b      	ldr	r3, [r3, #0]
 8006080:	681a      	ldr	r2, [r3, #0]
 8006082:	68fb      	ldr	r3, [r7, #12]
 8006084:	681b      	ldr	r3, [r3, #0]
 8006086:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 800608a:	601a      	str	r2, [r3, #0]
#else
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
#endif
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800608c:	68fb      	ldr	r3, [r7, #12]
 800608e:	681b      	ldr	r3, [r3, #0]
 8006090:	689a      	ldr	r2, [r3, #8]
 8006092:	68fb      	ldr	r3, [r7, #12]
 8006094:	681b      	ldr	r3, [r3, #0]
 8006096:	f022 0201 	bic.w	r2, r2, #1
 800609a:	609a      	str	r2, [r3, #8]

          huart->gState = HAL_UART_STATE_READY;
 800609c:	68fb      	ldr	r3, [r7, #12]
 800609e:	2220      	movs	r2, #32
 80060a0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
          huart->RxState = HAL_UART_STATE_READY;
 80060a4:	68fb      	ldr	r3, [r7, #12]
 80060a6:	2220      	movs	r2, #32
 80060a8:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 80060ac:	68fb      	ldr	r3, [r7, #12]
 80060ae:	2220      	movs	r2, #32
 80060b0:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 80060b4:	68fb      	ldr	r3, [r7, #12]
 80060b6:	2200      	movs	r2, #0
 80060b8:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

          return HAL_TIMEOUT;
 80060bc:	2303      	movs	r3, #3
 80060be:	e00f      	b.n	80060e0 <UART_WaitOnFlagUntilTimeout+0xf8>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80060c0:	68fb      	ldr	r3, [r7, #12]
 80060c2:	681b      	ldr	r3, [r3, #0]
 80060c4:	69da      	ldr	r2, [r3, #28]
 80060c6:	68bb      	ldr	r3, [r7, #8]
 80060c8:	4013      	ands	r3, r2
 80060ca:	68ba      	ldr	r2, [r7, #8]
 80060cc:	429a      	cmp	r2, r3
 80060ce:	bf0c      	ite	eq
 80060d0:	2301      	moveq	r3, #1
 80060d2:	2300      	movne	r3, #0
 80060d4:	b2db      	uxtb	r3, r3
 80060d6:	461a      	mov	r2, r3
 80060d8:	79fb      	ldrb	r3, [r7, #7]
 80060da:	429a      	cmp	r2, r3
 80060dc:	d08d      	beq.n	8005ffa <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 80060de:	2300      	movs	r3, #0
}
 80060e0:	4618      	mov	r0, r3
 80060e2:	3710      	adds	r7, #16
 80060e4:	46bd      	mov	sp, r7
 80060e6:	bd80      	pop	{r7, pc}

080060e8 <HAL_UARTEx_DisableFifoMode>:
  * @brief  Disable the FIFO mode.
  * @param huart      UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_DisableFifoMode(UART_HandleTypeDef *huart)
{
 80060e8:	b480      	push	{r7}
 80060ea:	b085      	sub	sp, #20
 80060ec:	af00      	add	r7, sp, #0
 80060ee:	6078      	str	r0, [r7, #4]

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
 80060f0:	687b      	ldr	r3, [r7, #4]
 80060f2:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 80060f6:	2b01      	cmp	r3, #1
 80060f8:	d101      	bne.n	80060fe <HAL_UARTEx_DisableFifoMode+0x16>
 80060fa:	2302      	movs	r3, #2
 80060fc:	e027      	b.n	800614e <HAL_UARTEx_DisableFifoMode+0x66>
 80060fe:	687b      	ldr	r3, [r7, #4]
 8006100:	2201      	movs	r2, #1
 8006102:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

  huart->gState = HAL_UART_STATE_BUSY;
 8006106:	687b      	ldr	r3, [r7, #4]
 8006108:	2224      	movs	r2, #36	; 0x24
 800610a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800610e:	687b      	ldr	r3, [r7, #4]
 8006110:	681b      	ldr	r3, [r3, #0]
 8006112:	681b      	ldr	r3, [r3, #0]
 8006114:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 8006116:	687b      	ldr	r3, [r7, #4]
 8006118:	681b      	ldr	r3, [r3, #0]
 800611a:	681a      	ldr	r2, [r3, #0]
 800611c:	687b      	ldr	r3, [r7, #4]
 800611e:	681b      	ldr	r3, [r3, #0]
 8006120:	f022 0201 	bic.w	r2, r2, #1
 8006124:	601a      	str	r2, [r3, #0]

  /* Enable FIFO mode */
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
 8006126:	68fb      	ldr	r3, [r7, #12]
 8006128:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 800612c:	60fb      	str	r3, [r7, #12]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 800612e:	687b      	ldr	r3, [r7, #4]
 8006130:	2200      	movs	r2, #0
 8006132:	665a      	str	r2, [r3, #100]	; 0x64

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8006134:	687b      	ldr	r3, [r7, #4]
 8006136:	681b      	ldr	r3, [r3, #0]
 8006138:	68fa      	ldr	r2, [r7, #12]
 800613a:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 800613c:	687b      	ldr	r3, [r7, #4]
 800613e:	2220      	movs	r2, #32
 8006140:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8006144:	687b      	ldr	r3, [r7, #4]
 8006146:	2200      	movs	r2, #0
 8006148:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

  return HAL_OK;
 800614c:	2300      	movs	r3, #0
}
 800614e:	4618      	mov	r0, r3
 8006150:	3714      	adds	r7, #20
 8006152:	46bd      	mov	sp, r7
 8006154:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006158:	4770      	bx	lr

0800615a <HAL_UARTEx_SetTxFifoThreshold>:
  *            @arg @ref UART_TXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_TXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetTxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
 800615a:	b580      	push	{r7, lr}
 800615c:	b084      	sub	sp, #16
 800615e:	af00      	add	r7, sp, #0
 8006160:	6078      	str	r0, [r7, #4]
 8006162:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 8006164:	687b      	ldr	r3, [r7, #4]
 8006166:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 800616a:	2b01      	cmp	r3, #1
 800616c:	d101      	bne.n	8006172 <HAL_UARTEx_SetTxFifoThreshold+0x18>
 800616e:	2302      	movs	r3, #2
 8006170:	e02d      	b.n	80061ce <HAL_UARTEx_SetTxFifoThreshold+0x74>
 8006172:	687b      	ldr	r3, [r7, #4]
 8006174:	2201      	movs	r2, #1
 8006176:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

  huart->gState = HAL_UART_STATE_BUSY;
 800617a:	687b      	ldr	r3, [r7, #4]
 800617c:	2224      	movs	r2, #36	; 0x24
 800617e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8006182:	687b      	ldr	r3, [r7, #4]
 8006184:	681b      	ldr	r3, [r3, #0]
 8006186:	681b      	ldr	r3, [r3, #0]
 8006188:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 800618a:	687b      	ldr	r3, [r7, #4]
 800618c:	681b      	ldr	r3, [r3, #0]
 800618e:	681a      	ldr	r2, [r3, #0]
 8006190:	687b      	ldr	r3, [r7, #4]
 8006192:	681b      	ldr	r3, [r3, #0]
 8006194:	f022 0201 	bic.w	r2, r2, #1
 8006198:	601a      	str	r2, [r3, #0]

  /* Update TX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 800619a:	687b      	ldr	r3, [r7, #4]
 800619c:	681b      	ldr	r3, [r3, #0]
 800619e:	689b      	ldr	r3, [r3, #8]
 80061a0:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 80061a4:	687b      	ldr	r3, [r7, #4]
 80061a6:	681b      	ldr	r3, [r3, #0]
 80061a8:	683a      	ldr	r2, [r7, #0]
 80061aa:	430a      	orrs	r2, r1
 80061ac:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
 80061ae:	6878      	ldr	r0, [r7, #4]
 80061b0:	f000 f850 	bl	8006254 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 80061b4:	687b      	ldr	r3, [r7, #4]
 80061b6:	681b      	ldr	r3, [r3, #0]
 80061b8:	68fa      	ldr	r2, [r7, #12]
 80061ba:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 80061bc:	687b      	ldr	r3, [r7, #4]
 80061be:	2220      	movs	r2, #32
 80061c0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 80061c4:	687b      	ldr	r3, [r7, #4]
 80061c6:	2200      	movs	r2, #0
 80061c8:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

  return HAL_OK;
 80061cc:	2300      	movs	r3, #0
}
 80061ce:	4618      	mov	r0, r3
 80061d0:	3710      	adds	r7, #16
 80061d2:	46bd      	mov	sp, r7
 80061d4:	bd80      	pop	{r7, pc}

080061d6 <HAL_UARTEx_SetRxFifoThreshold>:
  *            @arg @ref UART_RXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_RXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetRxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
 80061d6:	b580      	push	{r7, lr}
 80061d8:	b084      	sub	sp, #16
 80061da:	af00      	add	r7, sp, #0
 80061dc:	6078      	str	r0, [r7, #4]
 80061de:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 80061e0:	687b      	ldr	r3, [r7, #4]
 80061e2:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 80061e6:	2b01      	cmp	r3, #1
 80061e8:	d101      	bne.n	80061ee <HAL_UARTEx_SetRxFifoThreshold+0x18>
 80061ea:	2302      	movs	r3, #2
 80061ec:	e02d      	b.n	800624a <HAL_UARTEx_SetRxFifoThreshold+0x74>
 80061ee:	687b      	ldr	r3, [r7, #4]
 80061f0:	2201      	movs	r2, #1
 80061f2:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

  huart->gState = HAL_UART_STATE_BUSY;
 80061f6:	687b      	ldr	r3, [r7, #4]
 80061f8:	2224      	movs	r2, #36	; 0x24
 80061fa:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 80061fe:	687b      	ldr	r3, [r7, #4]
 8006200:	681b      	ldr	r3, [r3, #0]
 8006202:	681b      	ldr	r3, [r3, #0]
 8006204:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 8006206:	687b      	ldr	r3, [r7, #4]
 8006208:	681b      	ldr	r3, [r3, #0]
 800620a:	681a      	ldr	r2, [r3, #0]
 800620c:	687b      	ldr	r3, [r7, #4]
 800620e:	681b      	ldr	r3, [r3, #0]
 8006210:	f022 0201 	bic.w	r2, r2, #1
 8006214:	601a      	str	r2, [r3, #0]

  /* Update RX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8006216:	687b      	ldr	r3, [r7, #4]
 8006218:	681b      	ldr	r3, [r3, #0]
 800621a:	689b      	ldr	r3, [r3, #8]
 800621c:	f023 6160 	bic.w	r1, r3, #234881024	; 0xe000000
 8006220:	687b      	ldr	r3, [r7, #4]
 8006222:	681b      	ldr	r3, [r3, #0]
 8006224:	683a      	ldr	r2, [r7, #0]
 8006226:	430a      	orrs	r2, r1
 8006228:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
 800622a:	6878      	ldr	r0, [r7, #4]
 800622c:	f000 f812 	bl	8006254 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8006230:	687b      	ldr	r3, [r7, #4]
 8006232:	681b      	ldr	r3, [r3, #0]
 8006234:	68fa      	ldr	r2, [r7, #12]
 8006236:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 8006238:	687b      	ldr	r3, [r7, #4]
 800623a:	2220      	movs	r2, #32
 800623c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8006240:	687b      	ldr	r3, [r7, #4]
 8006242:	2200      	movs	r2, #0
 8006244:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

  return HAL_OK;
 8006248:	2300      	movs	r3, #0
}
 800624a:	4618      	mov	r0, r3
 800624c:	3710      	adds	r7, #16
 800624e:	46bd      	mov	sp, r7
 8006250:	bd80      	pop	{r7, pc}
	...

08006254 <UARTEx_SetNbDataToProcess>:
  *       the UART configuration registers.
  * @param huart UART handle.
  * @retval None
  */
static void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart)
{
 8006254:	b480      	push	{r7}
 8006256:	b089      	sub	sp, #36	; 0x24
 8006258:	af00      	add	r7, sp, #0
 800625a:	6078      	str	r0, [r7, #4]
  uint8_t rx_fifo_depth;
  uint8_t tx_fifo_depth;
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
 800625c:	4a2f      	ldr	r2, [pc, #188]	; (800631c <UARTEx_SetNbDataToProcess+0xc8>)
 800625e:	f107 0314 	add.w	r3, r7, #20
 8006262:	e892 0003 	ldmia.w	r2, {r0, r1}
 8006266:	e883 0003 	stmia.w	r3, {r0, r1}
  uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};
 800626a:	4a2d      	ldr	r2, [pc, #180]	; (8006320 <UARTEx_SetNbDataToProcess+0xcc>)
 800626c:	f107 030c 	add.w	r3, r7, #12
 8006270:	e892 0003 	ldmia.w	r2, {r0, r1}
 8006274:	e883 0003 	stmia.w	r3, {r0, r1}

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8006278:	687b      	ldr	r3, [r7, #4]
 800627a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800627c:	2b00      	cmp	r3, #0
 800627e:	d108      	bne.n	8006292 <UARTEx_SetNbDataToProcess+0x3e>
  {
    huart->NbTxDataToProcess = 1U;
 8006280:	687b      	ldr	r3, [r7, #4]
 8006282:	2201      	movs	r2, #1
 8006284:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
    huart->NbRxDataToProcess = 1U;
 8006288:	687b      	ldr	r3, [r7, #4]
 800628a:	2201      	movs	r2, #1
 800628c:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) / (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
  }
}
 8006290:	e03d      	b.n	800630e <UARTEx_SetNbDataToProcess+0xba>
    rx_fifo_depth = RX_FIFO_DEPTH;
 8006292:	2308      	movs	r3, #8
 8006294:	77fb      	strb	r3, [r7, #31]
    tx_fifo_depth = TX_FIFO_DEPTH;
 8006296:	2308      	movs	r3, #8
 8006298:	77bb      	strb	r3, [r7, #30]
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 800629a:	687b      	ldr	r3, [r7, #4]
 800629c:	681b      	ldr	r3, [r3, #0]
 800629e:	689b      	ldr	r3, [r3, #8]
 80062a0:	0e5b      	lsrs	r3, r3, #25
 80062a2:	b2db      	uxtb	r3, r3
 80062a4:	f003 0307 	and.w	r3, r3, #7
 80062a8:	777b      	strb	r3, [r7, #29]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 80062aa:	687b      	ldr	r3, [r7, #4]
 80062ac:	681b      	ldr	r3, [r3, #0]
 80062ae:	689b      	ldr	r3, [r3, #8]
 80062b0:	0f5b      	lsrs	r3, r3, #29
 80062b2:	b2db      	uxtb	r3, r3
 80062b4:	f003 0307 	and.w	r3, r3, #7
 80062b8:	773b      	strb	r3, [r7, #28]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) / (uint16_t)denominator[tx_fifo_threshold];
 80062ba:	7fbb      	ldrb	r3, [r7, #30]
 80062bc:	7f3a      	ldrb	r2, [r7, #28]
 80062be:	f107 0120 	add.w	r1, r7, #32
 80062c2:	440a      	add	r2, r1
 80062c4:	f812 2c0c 	ldrb.w	r2, [r2, #-12]
 80062c8:	fb02 f303 	mul.w	r3, r2, r3
 80062cc:	7f3a      	ldrb	r2, [r7, #28]
 80062ce:	f107 0120 	add.w	r1, r7, #32
 80062d2:	440a      	add	r2, r1
 80062d4:	f812 2c14 	ldrb.w	r2, [r2, #-20]
 80062d8:	fb93 f3f2 	sdiv	r3, r3, r2
 80062dc:	b29a      	uxth	r2, r3
 80062de:	687b      	ldr	r3, [r7, #4]
 80062e0:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
 80062e4:	7ffb      	ldrb	r3, [r7, #31]
 80062e6:	7f7a      	ldrb	r2, [r7, #29]
 80062e8:	f107 0120 	add.w	r1, r7, #32
 80062ec:	440a      	add	r2, r1
 80062ee:	f812 2c0c 	ldrb.w	r2, [r2, #-12]
 80062f2:	fb02 f303 	mul.w	r3, r2, r3
 80062f6:	7f7a      	ldrb	r2, [r7, #29]
 80062f8:	f107 0120 	add.w	r1, r7, #32
 80062fc:	440a      	add	r2, r1
 80062fe:	f812 2c14 	ldrb.w	r2, [r2, #-20]
 8006302:	fb93 f3f2 	sdiv	r3, r3, r2
 8006306:	b29a      	uxth	r2, r3
 8006308:	687b      	ldr	r3, [r7, #4]
 800630a:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
}
 800630e:	bf00      	nop
 8006310:	3724      	adds	r7, #36	; 0x24
 8006312:	46bd      	mov	sp, r7
 8006314:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006318:	4770      	bx	lr
 800631a:	bf00      	nop
 800631c:	0801a3fc 	.word	0x0801a3fc
 8006320:	0801a404 	.word	0x0801a404

08006324 <IsAtLeastTLSv1_3>:

    return 0;
}

int IsAtLeastTLSv1_3(const ProtocolVersion pv)
{
 8006324:	b480      	push	{r7}
 8006326:	b083      	sub	sp, #12
 8006328:	af00      	add	r7, sp, #0
 800632a:	80b8      	strh	r0, [r7, #4]
    return (pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_3_MINOR);
 800632c:	793b      	ldrb	r3, [r7, #4]
 800632e:	2b03      	cmp	r3, #3
 8006330:	d104      	bne.n	800633c <IsAtLeastTLSv1_3+0x18>
 8006332:	797b      	ldrb	r3, [r7, #5]
 8006334:	2b03      	cmp	r3, #3
 8006336:	d901      	bls.n	800633c <IsAtLeastTLSv1_3+0x18>
 8006338:	2301      	movs	r3, #1
 800633a:	e000      	b.n	800633e <IsAtLeastTLSv1_3+0x1a>
 800633c:	2300      	movs	r3, #0
}
 800633e:	4618      	mov	r0, r3
 8006340:	370c      	adds	r7, #12
 8006342:	46bd      	mov	sp, r7
 8006344:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006348:	4770      	bx	lr

0800634a <InitSSL_Method>:
#endif /* WOLFSSL_DTLS */
#endif /* WOLFSSL_SESSION_EXPORT */


void InitSSL_Method(WOLFSSL_METHOD* method, ProtocolVersion pv)
{
 800634a:	b480      	push	{r7}
 800634c:	b083      	sub	sp, #12
 800634e:	af00      	add	r7, sp, #0
 8006350:	6078      	str	r0, [r7, #4]
 8006352:	8039      	strh	r1, [r7, #0]
    method->version    = pv;
 8006354:	687b      	ldr	r3, [r7, #4]
 8006356:	461a      	mov	r2, r3
 8006358:	463b      	mov	r3, r7
 800635a:	881b      	ldrh	r3, [r3, #0]
 800635c:	8013      	strh	r3, [r2, #0]
    method->side       = WOLFSSL_CLIENT_END;
 800635e:	687b      	ldr	r3, [r7, #4]
 8006360:	2201      	movs	r2, #1
 8006362:	709a      	strb	r2, [r3, #2]
    method->downgrade  = 0;
 8006364:	687b      	ldr	r3, [r7, #4]
 8006366:	2200      	movs	r2, #0
 8006368:	70da      	strb	r2, [r3, #3]
}
 800636a:	bf00      	nop
 800636c:	370c      	adds	r7, #12
 800636e:	46bd      	mov	sp, r7
 8006370:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006374:	4770      	bx	lr

08006376 <InitSSL_Ctx>:
}
#endif /* OPENSSL_EXTRA || WOLFSSL_EITHER_SIDE */

/* Initialize SSL context, return 0 on success */
int InitSSL_Ctx(WOLFSSL_CTX* ctx, WOLFSSL_METHOD* method, void* heap)
{
 8006376:	b580      	push	{r7, lr}
 8006378:	b086      	sub	sp, #24
 800637a:	af00      	add	r7, sp, #0
 800637c:	60f8      	str	r0, [r7, #12]
 800637e:	60b9      	str	r1, [r7, #8]
 8006380:	607a      	str	r2, [r7, #4]
    int ret = 0;
 8006382:	2300      	movs	r3, #0
 8006384:	617b      	str	r3, [r7, #20]

    XMEMSET(ctx, 0, sizeof(WOLFSSL_CTX));
 8006386:	22a0      	movs	r2, #160	; 0xa0
 8006388:	2100      	movs	r1, #0
 800638a:	68f8      	ldr	r0, [r7, #12]
 800638c:	f013 f857 	bl	801943e <memset>

    ctx->method   = method;
 8006390:	68fb      	ldr	r3, [r7, #12]
 8006392:	68ba      	ldr	r2, [r7, #8]
 8006394:	601a      	str	r2, [r3, #0]
    ctx->refCount = 1;          /* so either CTX_free or SSL_free can release */
 8006396:	68fb      	ldr	r3, [r7, #12]
 8006398:	2201      	movs	r2, #1
 800639a:	60da      	str	r2, [r3, #12]
    ctx->heap     = ctx;        /* defaults to self */
 800639c:	68fb      	ldr	r3, [r7, #12]
 800639e:	68fa      	ldr	r2, [r7, #12]
 80063a0:	649a      	str	r2, [r3, #72]	; 0x48
    ctx->timeout  = WOLFSSL_SESSION_TIMEOUT;
 80063a2:	68fb      	ldr	r3, [r7, #12]
 80063a4:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 80063a8:	66da      	str	r2, [r3, #108]	; 0x6c
    ctx->minDowngrade = WOLFSSL_MIN_DOWNGRADE; /* current default: TLSv1_MINOR */
 80063aa:	68fb      	ldr	r3, [r7, #12]
 80063ac:	2203      	movs	r2, #3
 80063ae:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    if (wc_InitMutex(&ctx->countMutex) < 0) {
 80063b2:	68fb      	ldr	r3, [r7, #12]
 80063b4:	3308      	adds	r3, #8
 80063b6:	4618      	mov	r0, r3
 80063b8:	f012 ff56 	bl	8019268 <wc_InitMutex>
 80063bc:	4603      	mov	r3, r0
 80063be:	2b00      	cmp	r3, #0
 80063c0:	da06      	bge.n	80063d0 <InitSSL_Ctx+0x5a>
        WOLFSSL_MSG("Mutex error on CTX init");
        ctx->err = CTX_INIT_MUTEX_E;
 80063c2:	68fb      	ldr	r3, [r7, #12]
 80063c4:	f46f 72ce 	mvn.w	r2, #412	; 0x19c
 80063c8:	611a      	str	r2, [r3, #16]
        return BAD_MUTEX_E;
 80063ca:	f06f 0369 	mvn.w	r3, #105	; 0x69
 80063ce:	e05e      	b.n	800648e <InitSSL_Ctx+0x118>
    }

#ifndef NO_CERTS
    ctx->privateKeyDevId = INVALID_DEVID;
 80063d0:	68fb      	ldr	r3, [r7, #12]
 80063d2:	f06f 0201 	mvn.w	r2, #1
 80063d6:	63da      	str	r2, [r3, #60]	; 0x3c
#endif

#ifndef NO_DH
    ctx->minDhKeySz  = MIN_DHKEY_SZ;
 80063d8:	68fb      	ldr	r3, [r7, #12]
 80063da:	2280      	movs	r2, #128	; 0x80
 80063dc:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    ctx->maxDhKeySz  = MAX_DHKEY_SZ;
 80063e0:	68fb      	ldr	r3, [r7, #12]
 80063e2:	f44f 7200 	mov.w	r2, #512	; 0x200
 80063e6:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
#endif
#ifndef NO_RSA
    ctx->minRsaKeySz = MIN_RSAKEY_SZ;
 80063ea:	68fb      	ldr	r3, [r7, #12]
 80063ec:	2280      	movs	r2, #128	; 0x80
 80063ee:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56
#endif
#ifdef HAVE_ECC
    ctx->minEccKeySz  = MIN_ECCKEY_SZ;
 80063f2:	68fb      	ldr	r3, [r7, #12]
 80063f4:	221c      	movs	r2, #28
 80063f6:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
    ctx->eccTempKeySz = ECDHE_SIZE;
 80063fa:	68fb      	ldr	r3, [r7, #12]
 80063fc:	2220      	movs	r2, #32
 80063fe:	f8a3 2074 	strh.w	r2, [r3, #116]	; 0x74
    if (method->side == WOLFSSL_CLIENT_END)
        ctx->haveNTRU = 1;           /* always on client side */
                                     /* server can turn on by loading key */
#endif
#ifdef HAVE_ECC
    if (method->side == WOLFSSL_CLIENT_END) {
 8006402:	68bb      	ldr	r3, [r7, #8]
 8006404:	789b      	ldrb	r3, [r3, #2]
 8006406:	2b01      	cmp	r3, #1
 8006408:	d114      	bne.n	8006434 <InitSSL_Ctx+0xbe>
        ctx->haveECDSAsig  = 1;        /* always on client side */
 800640a:	68fa      	ldr	r2, [r7, #12]
 800640c:	f892 304e 	ldrb.w	r3, [r2, #78]	; 0x4e
 8006410:	f043 0310 	orr.w	r3, r3, #16
 8006414:	f882 304e 	strb.w	r3, [r2, #78]	; 0x4e
        ctx->haveECC  = 1;             /* server turns on with ECC key cert */
 8006418:	68fa      	ldr	r2, [r7, #12]
 800641a:	f892 304e 	ldrb.w	r3, [r2, #78]	; 0x4e
 800641e:	f043 0302 	orr.w	r3, r3, #2
 8006422:	f882 304e 	strb.w	r3, [r2, #78]	; 0x4e
        ctx->haveStaticECC = 1;        /* server can turn on by loading key */
 8006426:	68fa      	ldr	r2, [r7, #12]
 8006428:	f892 304e 	ldrb.w	r3, [r2, #78]	; 0x4e
 800642c:	f043 0320 	orr.w	r3, r3, #32
 8006430:	f882 304e 	strb.w	r3, [r2, #78]	; 0x4e
        ctx->haveECDSAsig  = 1;        /* always on client side */
        ctx->haveECC  = 1;             /* server turns on with ECC key cert */
    }
#endif

    ctx->devId = INVALID_DEVID;
 8006434:	68fb      	ldr	r3, [r7, #12]
 8006436:	f06f 0201 	mvn.w	r2, #1
 800643a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
        ctx->dtlsMtuSz = MAX_MTU;
    #endif
#endif

#ifndef NO_CERTS
    ctx->cm = wolfSSL_CertManagerNew_ex(heap);
 800643e:	6878      	ldr	r0, [r7, #4]
 8006440:	f000 fd11 	bl	8006e66 <wolfSSL_CertManagerNew_ex>
 8006444:	4602      	mov	r2, r0
 8006446:	68fb      	ldr	r3, [r7, #12]
 8006448:	641a      	str	r2, [r3, #64]	; 0x40
    if (ctx->cm == NULL) {
 800644a:	68fb      	ldr	r3, [r7, #12]
 800644c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800644e:	2b00      	cmp	r3, #0
 8006450:	d102      	bne.n	8006458 <InitSSL_Ctx+0xe2>
        WOLFSSL_MSG("Bad Cert Manager New");
        return BAD_CERT_MANAGER_ERROR;
 8006452:	f46f 73b3 	mvn.w	r3, #358	; 0x166
 8006456:	e01a      	b.n	800648e <InitSSL_Ctx+0x118>
    ctx->x509_store.cm = ctx->cm;
    #endif
#endif

#if defined(HAVE_EXTENDED_MASTER) && !defined(NO_WOLFSSL_CLIENT)
    if (method->side == WOLFSSL_CLIENT_END) {
 8006458:	68bb      	ldr	r3, [r7, #8]
 800645a:	789b      	ldrb	r3, [r3, #2]
 800645c:	2b01      	cmp	r3, #1
 800645e:	d10e      	bne.n	800647e <InitSSL_Ctx+0x108>
        if ((method->version.major == SSLv3_MAJOR) &&
 8006460:	68bb      	ldr	r3, [r7, #8]
 8006462:	781b      	ldrb	r3, [r3, #0]
 8006464:	2b03      	cmp	r3, #3
 8006466:	d10a      	bne.n	800647e <InitSSL_Ctx+0x108>
             (method->version.minor >= TLSv1_MINOR)) {
 8006468:	68bb      	ldr	r3, [r7, #8]
 800646a:	785b      	ldrb	r3, [r3, #1]
        if ((method->version.major == SSLv3_MAJOR) &&
 800646c:	2b00      	cmp	r3, #0
 800646e:	d006      	beq.n	800647e <InitSSL_Ctx+0x108>

            ctx->haveEMS = 1;
 8006470:	68fa      	ldr	r2, [r7, #12]
 8006472:	f892 3051 	ldrb.w	r3, [r2, #81]	; 0x51
 8006476:	f043 0301 	orr.w	r3, r3, #1
 800647a:	f882 3051 	strb.w	r3, [r2, #81]	; 0x51

#if defined(WOLFSSL_TLS13) && !defined(HAVE_SUPPORTED_CURVES)
    ctx->noPskDheKe = 1;
#endif

    ctx->heap = heap; /* wolfSSL_CTX_load_static_memory sets */
 800647e:	68fb      	ldr	r3, [r7, #12]
 8006480:	687a      	ldr	r2, [r7, #4]
 8006482:	649a      	str	r2, [r3, #72]	; 0x48
    ctx->verifyDepth = MAX_CHAIN_DEPTH;
 8006484:	68fb      	ldr	r3, [r7, #12]
 8006486:	2209      	movs	r2, #9
 8006488:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

    return ret;
 800648c:	697b      	ldr	r3, [r7, #20]
}
 800648e:	4618      	mov	r0, r3
 8006490:	3718      	adds	r7, #24
 8006492:	46bd      	mov	sp, r7
 8006494:	bd80      	pop	{r7, pc}

08006496 <SSL_CtxResourceFree>:


/* In case contexts are held in array and don't want to free actual ctx */
void SSL_CtxResourceFree(WOLFSSL_CTX* ctx)
{
 8006496:	b580      	push	{r7, lr}
 8006498:	b088      	sub	sp, #32
 800649a:	af00      	add	r7, sp, #0
 800649c:	6078      	str	r0, [r7, #4]
    }
    else {
        XFREE(ctx->method, NULL, DYNAMIC_TYPE_METHOD);
    }
#else
    XFREE(ctx->method, ctx->heap, DYNAMIC_TYPE_METHOD);
 800649e:	687b      	ldr	r3, [r7, #4]
 80064a0:	681b      	ldr	r3, [r3, #0]
 80064a2:	61fb      	str	r3, [r7, #28]
 80064a4:	69fb      	ldr	r3, [r7, #28]
 80064a6:	2b00      	cmp	r3, #0
 80064a8:	d002      	beq.n	80064b0 <SSL_CtxResourceFree+0x1a>
 80064aa:	69f8      	ldr	r0, [r7, #28]
 80064ac:	f008 fd40 	bl	800ef30 <wolfSSL_Free>
#endif
    ctx->method = NULL;
 80064b0:	687b      	ldr	r3, [r7, #4]
 80064b2:	2200      	movs	r2, #0
 80064b4:	601a      	str	r2, [r3, #0]
    if (ctx->suites) {
 80064b6:	687b      	ldr	r3, [r7, #4]
 80064b8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80064ba:	2b00      	cmp	r3, #0
 80064bc:	d00b      	beq.n	80064d6 <SSL_CtxResourceFree+0x40>
        XFREE(ctx->suites, ctx->heap, DYNAMIC_TYPE_SUITES);
 80064be:	687b      	ldr	r3, [r7, #4]
 80064c0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80064c2:	61bb      	str	r3, [r7, #24]
 80064c4:	69bb      	ldr	r3, [r7, #24]
 80064c6:	2b00      	cmp	r3, #0
 80064c8:	d002      	beq.n	80064d0 <SSL_CtxResourceFree+0x3a>
 80064ca:	69b8      	ldr	r0, [r7, #24]
 80064cc:	f008 fd30 	bl	800ef30 <wolfSSL_Free>
        ctx->suites = NULL;
 80064d0:	687b      	ldr	r3, [r7, #4]
 80064d2:	2200      	movs	r2, #0
 80064d4:	645a      	str	r2, [r3, #68]	; 0x44
    }

#ifndef NO_DH
    XFREE(ctx->serverDH_G.buffer, ctx->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 80064d6:	687b      	ldr	r3, [r7, #4]
 80064d8:	69db      	ldr	r3, [r3, #28]
 80064da:	617b      	str	r3, [r7, #20]
 80064dc:	697b      	ldr	r3, [r7, #20]
 80064de:	2b00      	cmp	r3, #0
 80064e0:	d002      	beq.n	80064e8 <SSL_CtxResourceFree+0x52>
 80064e2:	6978      	ldr	r0, [r7, #20]
 80064e4:	f008 fd24 	bl	800ef30 <wolfSSL_Free>
    ctx->serverDH_G.buffer = NULL;
 80064e8:	687b      	ldr	r3, [r7, #4]
 80064ea:	2200      	movs	r2, #0
 80064ec:	61da      	str	r2, [r3, #28]
    XFREE(ctx->serverDH_P.buffer, ctx->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 80064ee:	687b      	ldr	r3, [r7, #4]
 80064f0:	695b      	ldr	r3, [r3, #20]
 80064f2:	613b      	str	r3, [r7, #16]
 80064f4:	693b      	ldr	r3, [r7, #16]
 80064f6:	2b00      	cmp	r3, #0
 80064f8:	d002      	beq.n	8006500 <SSL_CtxResourceFree+0x6a>
 80064fa:	6938      	ldr	r0, [r7, #16]
 80064fc:	f008 fd18 	bl	800ef30 <wolfSSL_Free>
    ctx->serverDH_P.buffer = NULL;
 8006500:	687b      	ldr	r3, [r7, #4]
 8006502:	2200      	movs	r2, #0
 8006504:	615a      	str	r2, [r3, #20]
#endif /* !NO_DH */

#ifdef SINGLE_THREADED
    if (ctx->rng) {
 8006506:	687b      	ldr	r3, [r7, #4]
 8006508:	685b      	ldr	r3, [r3, #4]
 800650a:	2b00      	cmp	r3, #0
 800650c:	d010      	beq.n	8006530 <SSL_CtxResourceFree+0x9a>
        wc_FreeRng(ctx->rng);
 800650e:	687b      	ldr	r3, [r7, #4]
 8006510:	685b      	ldr	r3, [r3, #4]
 8006512:	4618      	mov	r0, r3
 8006514:	f008 fd61 	bl	800efda <wc_FreeRng>
        XFREE(ctx->rng, ctx->heap, DYNAMIC_TYPE_RNG);
 8006518:	687b      	ldr	r3, [r7, #4]
 800651a:	685b      	ldr	r3, [r3, #4]
 800651c:	60fb      	str	r3, [r7, #12]
 800651e:	68fb      	ldr	r3, [r7, #12]
 8006520:	2b00      	cmp	r3, #0
 8006522:	d002      	beq.n	800652a <SSL_CtxResourceFree+0x94>
 8006524:	68f8      	ldr	r0, [r7, #12]
 8006526:	f008 fd03 	bl	800ef30 <wolfSSL_Free>
        ctx->rng = NULL;
 800652a:	687b      	ldr	r3, [r7, #4]
 800652c:	2200      	movs	r2, #0
 800652e:	605a      	str	r2, [r3, #4]
    }
#endif /* SINGLE_THREADED */

#ifndef NO_CERTS
    FreeDer(&ctx->privateKey);
 8006530:	687b      	ldr	r3, [r7, #4]
 8006532:	3330      	adds	r3, #48	; 0x30
 8006534:	4618      	mov	r0, r3
 8006536:	f006 fe27 	bl	800d188 <FreeDer>
    FreeDer(&ctx->certificate);
 800653a:	687b      	ldr	r3, [r7, #4]
 800653c:	3324      	adds	r3, #36	; 0x24
 800653e:	4618      	mov	r0, r3
 8006540:	f006 fe22 	bl	800d188 <FreeDer>
            FreeX509(ctx->ourCert);
            XFREE(ctx->ourCert, ctx->heap, DYNAMIC_TYPE_X509);
            ctx->ourCert = NULL;
        }
    #endif /* KEEP_OUR_CERT */
    FreeDer(&ctx->certChain);
 8006544:	687b      	ldr	r3, [r7, #4]
 8006546:	3328      	adds	r3, #40	; 0x28
 8006548:	4618      	mov	r0, r3
 800654a:	f006 fe1d 	bl	800d188 <FreeDer>
    wolfSSL_CertManagerFree(ctx->cm);
 800654e:	687b      	ldr	r3, [r7, #4]
 8006550:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006552:	4618      	mov	r0, r3
 8006554:	f000 fcc4 	bl	8006ee0 <wolfSSL_CertManagerFree>
    ctx->cm = NULL;
 8006558:	687b      	ldr	r3, [r7, #4]
 800655a:	2200      	movs	r2, #0
 800655c:	641a      	str	r2, [r3, #64]	; 0x40
        }
    #endif
#endif /* !NO_CERTS */

#ifdef HAVE_TLS_EXTENSIONS
    TLSX_FreeAll(ctx->extensions, ctx->heap);
 800655e:	687b      	ldr	r3, [r7, #4]
 8006560:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8006564:	687b      	ldr	r3, [r7, #4]
 8006566:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8006568:	4619      	mov	r1, r3
 800656a:	4610      	mov	r0, r2
 800656c:	f002 f835 	bl	80085da <TLSX_FreeAll>
            WOLFSSL_HEAP_HINT* hint = (WOLFSSL_HEAP_HINT*)(ctx->heap);
            wc_FreeMutex(&((WOLFSSL_HEAP*)(hint->memory))->memory_mutex);
        }
    }
#endif /* WOLFSSL_STATIC_MEMORY */
}
 8006570:	bf00      	nop
 8006572:	3720      	adds	r7, #32
 8006574:	46bd      	mov	sp, r7
 8006576:	bd80      	pop	{r7, pc}

08006578 <FreeSSL_Ctx>:


void FreeSSL_Ctx(WOLFSSL_CTX* ctx)
{
 8006578:	b580      	push	{r7, lr}
 800657a:	b086      	sub	sp, #24
 800657c:	af00      	add	r7, sp, #0
 800657e:	6078      	str	r0, [r7, #4]
    int refCount;

    /* decrement CTX reference count */
    if ((refCount = SSL_CTX_RefCount(ctx, -1)) < 0) {
 8006580:	f04f 31ff 	mov.w	r1, #4294967295
 8006584:	6878      	ldr	r0, [r7, #4]
 8006586:	f000 fa7f 	bl	8006a88 <SSL_CTX_RefCount>
 800658a:	6178      	str	r0, [r7, #20]
 800658c:	697b      	ldr	r3, [r7, #20]
 800658e:	2b00      	cmp	r3, #0
 8006590:	da11      	bge.n	80065b6 <FreeSSL_Ctx+0x3e>
        /* check error state, if mutex error code then mutex init failed but
         * CTX was still malloc'd */
        if (ctx->err == CTX_INIT_MUTEX_E) {
 8006592:	687b      	ldr	r3, [r7, #4]
 8006594:	691b      	ldr	r3, [r3, #16]
 8006596:	f46f 72ce 	mvn.w	r2, #412	; 0x19c
 800659a:	4293      	cmp	r3, r2
 800659c:	d122      	bne.n	80065e4 <FreeSSL_Ctx+0x6c>
            SSL_CtxResourceFree(ctx);
 800659e:	6878      	ldr	r0, [r7, #4]
 80065a0:	f7ff ff79 	bl	8006496 <SSL_CtxResourceFree>
            XFREE(ctx, ctx->heap, DYNAMIC_TYPE_CTX);
 80065a4:	687b      	ldr	r3, [r7, #4]
 80065a6:	60bb      	str	r3, [r7, #8]
 80065a8:	68bb      	ldr	r3, [r7, #8]
 80065aa:	2b00      	cmp	r3, #0
 80065ac:	d01a      	beq.n	80065e4 <FreeSSL_Ctx+0x6c>
 80065ae:	68b8      	ldr	r0, [r7, #8]
 80065b0:	f008 fcbe 	bl	800ef30 <wolfSSL_Free>
        }
        return;
 80065b4:	e016      	b.n	80065e4 <FreeSSL_Ctx+0x6c>
    }

    if (refCount == 0) {
 80065b6:	697b      	ldr	r3, [r7, #20]
 80065b8:	2b00      	cmp	r3, #0
 80065ba:	d114      	bne.n	80065e6 <FreeSSL_Ctx+0x6e>
        void* heap = ctx->heap;
 80065bc:	687b      	ldr	r3, [r7, #4]
 80065be:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80065c0:	613b      	str	r3, [r7, #16]
        WOLFSSL_MSG("CTX ref count down to 0, doing full free");
        SSL_CtxResourceFree(ctx);
 80065c2:	6878      	ldr	r0, [r7, #4]
 80065c4:	f7ff ff67 	bl	8006496 <SSL_CtxResourceFree>
        wc_FreeMutex(&ctx->countMutex);
 80065c8:	687b      	ldr	r3, [r7, #4]
 80065ca:	3308      	adds	r3, #8
 80065cc:	4618      	mov	r0, r3
 80065ce:	f012 fe56 	bl	801927e <wc_FreeMutex>
#ifdef WOLFSSL_STATIC_MEMORY
        if (ctx->onHeap == 0) {
            heap = NULL;
        }
#endif
        XFREE(ctx, heap, DYNAMIC_TYPE_CTX);
 80065d2:	687b      	ldr	r3, [r7, #4]
 80065d4:	60fb      	str	r3, [r7, #12]
 80065d6:	68fb      	ldr	r3, [r7, #12]
 80065d8:	2b00      	cmp	r3, #0
 80065da:	d004      	beq.n	80065e6 <FreeSSL_Ctx+0x6e>
 80065dc:	68f8      	ldr	r0, [r7, #12]
 80065de:	f008 fca7 	bl	800ef30 <wolfSSL_Free>
 80065e2:	e000      	b.n	80065e6 <FreeSSL_Ctx+0x6e>
        return;
 80065e4:	bf00      	nop
    }
    else {
        (void)ctx;
        WOLFSSL_MSG("CTX ref count not 0 yet, no free");
    }
}
 80065e6:	3718      	adds	r7, #24
 80065e8:	46bd      	mov	sp, r7
 80065ea:	bd80      	pop	{r7, pc}

080065ec <AddSuiteHashSigAlgo>:
}
#endif /* USE_ECDSA_KEYSZ_HASH_ALGO */

static WC_INLINE void AddSuiteHashSigAlgo(Suites* suites, byte macAlgo, byte sigAlgo,
    int keySz, word16* inOutIdx)
{
 80065ec:	b480      	push	{r7}
 80065ee:	b087      	sub	sp, #28
 80065f0:	af00      	add	r7, sp, #0
 80065f2:	60f8      	str	r0, [r7, #12]
 80065f4:	607b      	str	r3, [r7, #4]
 80065f6:	460b      	mov	r3, r1
 80065f8:	72fb      	strb	r3, [r7, #11]
 80065fa:	4613      	mov	r3, r2
 80065fc:	72bb      	strb	r3, [r7, #10]
    int addSigAlgo = 1;
 80065fe:	2301      	movs	r3, #1
 8006600:	617b      	str	r3, [r7, #20]
    }
#else
    (void)keySz;
#endif /* USE_ECDSA_KEYSZ_HASH_ALGO */

    if (addSigAlgo) {
 8006602:	697b      	ldr	r3, [r7, #20]
 8006604:	2b00      	cmp	r3, #0
 8006606:	d059      	beq.n	80066bc <AddSuiteHashSigAlgo+0xd0>
#ifdef WC_RSA_PSS
        if (sigAlgo == rsa_pss_sa_algo) {
 8006608:	7abb      	ldrb	r3, [r7, #10]
 800660a:	2b08      	cmp	r3, #8
 800660c:	d13a      	bne.n	8006684 <AddSuiteHashSigAlgo+0x98>
            /* RSA PSS is sig then mac */
            suites->hashSigAlgo[*inOutIdx] = sigAlgo;
 800660e:	6a3b      	ldr	r3, [r7, #32]
 8006610:	881b      	ldrh	r3, [r3, #0]
 8006612:	461a      	mov	r2, r3
 8006614:	68fb      	ldr	r3, [r7, #12]
 8006616:	4413      	add	r3, r2
 8006618:	7aba      	ldrb	r2, [r7, #10]
 800661a:	f883 2130 	strb.w	r2, [r3, #304]	; 0x130
            *inOutIdx += 1;
 800661e:	6a3b      	ldr	r3, [r7, #32]
 8006620:	881b      	ldrh	r3, [r3, #0]
 8006622:	3301      	adds	r3, #1
 8006624:	b29a      	uxth	r2, r3
 8006626:	6a3b      	ldr	r3, [r7, #32]
 8006628:	801a      	strh	r2, [r3, #0]
            suites->hashSigAlgo[*inOutIdx] = macAlgo;
 800662a:	6a3b      	ldr	r3, [r7, #32]
 800662c:	881b      	ldrh	r3, [r3, #0]
 800662e:	461a      	mov	r2, r3
 8006630:	68fb      	ldr	r3, [r7, #12]
 8006632:	4413      	add	r3, r2
 8006634:	7afa      	ldrb	r2, [r7, #11]
 8006636:	f883 2130 	strb.w	r2, [r3, #304]	; 0x130
            *inOutIdx += 1;
 800663a:	6a3b      	ldr	r3, [r7, #32]
 800663c:	881b      	ldrh	r3, [r3, #0]
 800663e:	3301      	adds	r3, #1
 8006640:	b29a      	uxth	r2, r3
 8006642:	6a3b      	ldr	r3, [r7, #32]
 8006644:	801a      	strh	r2, [r3, #0]
    #ifdef WOLFSSL_TLS13
            /* Add the certificate algorithm as well */
            suites->hashSigAlgo[*inOutIdx] = sigAlgo;
 8006646:	6a3b      	ldr	r3, [r7, #32]
 8006648:	881b      	ldrh	r3, [r3, #0]
 800664a:	461a      	mov	r2, r3
 800664c:	68fb      	ldr	r3, [r7, #12]
 800664e:	4413      	add	r3, r2
 8006650:	7aba      	ldrb	r2, [r7, #10]
 8006652:	f883 2130 	strb.w	r2, [r3, #304]	; 0x130
            *inOutIdx += 1;
 8006656:	6a3b      	ldr	r3, [r7, #32]
 8006658:	881b      	ldrh	r3, [r3, #0]
 800665a:	3301      	adds	r3, #1
 800665c:	b29a      	uxth	r2, r3
 800665e:	6a3b      	ldr	r3, [r7, #32]
 8006660:	801a      	strh	r2, [r3, #0]
            suites->hashSigAlgo[*inOutIdx] = PSS_RSAE_TO_PSS_PSS(macAlgo);
 8006662:	6a3b      	ldr	r3, [r7, #32]
 8006664:	881b      	ldrh	r3, [r3, #0]
 8006666:	4619      	mov	r1, r3
 8006668:	7afb      	ldrb	r3, [r7, #11]
 800666a:	3305      	adds	r3, #5
 800666c:	b2da      	uxtb	r2, r3
 800666e:	68fb      	ldr	r3, [r7, #12]
 8006670:	440b      	add	r3, r1
 8006672:	f883 2130 	strb.w	r2, [r3, #304]	; 0x130
            *inOutIdx += 1;
 8006676:	6a3b      	ldr	r3, [r7, #32]
 8006678:	881b      	ldrh	r3, [r3, #0]
 800667a:	3301      	adds	r3, #1
 800667c:	b29a      	uxth	r2, r3
 800667e:	6a3b      	ldr	r3, [r7, #32]
 8006680:	801a      	strh	r2, [r3, #0]
            *inOutIdx += 1;
            suites->hashSigAlgo[*inOutIdx] = sigAlgo;
            *inOutIdx += 1;
        }
    }
}
 8006682:	e01b      	b.n	80066bc <AddSuiteHashSigAlgo+0xd0>
            suites->hashSigAlgo[*inOutIdx] = macAlgo;
 8006684:	6a3b      	ldr	r3, [r7, #32]
 8006686:	881b      	ldrh	r3, [r3, #0]
 8006688:	461a      	mov	r2, r3
 800668a:	68fb      	ldr	r3, [r7, #12]
 800668c:	4413      	add	r3, r2
 800668e:	7afa      	ldrb	r2, [r7, #11]
 8006690:	f883 2130 	strb.w	r2, [r3, #304]	; 0x130
            *inOutIdx += 1;
 8006694:	6a3b      	ldr	r3, [r7, #32]
 8006696:	881b      	ldrh	r3, [r3, #0]
 8006698:	3301      	adds	r3, #1
 800669a:	b29a      	uxth	r2, r3
 800669c:	6a3b      	ldr	r3, [r7, #32]
 800669e:	801a      	strh	r2, [r3, #0]
            suites->hashSigAlgo[*inOutIdx] = sigAlgo;
 80066a0:	6a3b      	ldr	r3, [r7, #32]
 80066a2:	881b      	ldrh	r3, [r3, #0]
 80066a4:	461a      	mov	r2, r3
 80066a6:	68fb      	ldr	r3, [r7, #12]
 80066a8:	4413      	add	r3, r2
 80066aa:	7aba      	ldrb	r2, [r7, #10]
 80066ac:	f883 2130 	strb.w	r2, [r3, #304]	; 0x130
            *inOutIdx += 1;
 80066b0:	6a3b      	ldr	r3, [r7, #32]
 80066b2:	881b      	ldrh	r3, [r3, #0]
 80066b4:	3301      	adds	r3, #1
 80066b6:	b29a      	uxth	r2, r3
 80066b8:	6a3b      	ldr	r3, [r7, #32]
 80066ba:	801a      	strh	r2, [r3, #0]
}
 80066bc:	bf00      	nop
 80066be:	371c      	adds	r7, #28
 80066c0:	46bd      	mov	sp, r7
 80066c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80066c6:	4770      	bx	lr

080066c8 <InitSuitesHashSigAlgo>:

void InitSuitesHashSigAlgo(Suites* suites, int haveECDSAsig, int haveRSAsig,
                           int haveAnon, int tls1_2, int keySz)
{
 80066c8:	b580      	push	{r7, lr}
 80066ca:	b088      	sub	sp, #32
 80066cc:	af02      	add	r7, sp, #8
 80066ce:	60f8      	str	r0, [r7, #12]
 80066d0:	60b9      	str	r1, [r7, #8]
 80066d2:	607a      	str	r2, [r7, #4]
 80066d4:	603b      	str	r3, [r7, #0]
    word16 idx = 0;
 80066d6:	2300      	movs	r3, #0
 80066d8:	82fb      	strh	r3, [r7, #22]

    (void)tls1_2;
    (void)keySz;

#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)
    if (haveECDSAsig) {
 80066da:	68bb      	ldr	r3, [r7, #8]
 80066dc:	2b00      	cmp	r3, #0
 80066de:	d008      	beq.n	80066f2 <InitSuitesHashSigAlgo+0x2a>
    #endif
    #ifdef WOLFSSL_SHA384
        AddSuiteHashSigAlgo(suites, sha384_mac, ecc_dsa_sa_algo, keySz, &idx);
    #endif
    #ifndef NO_SHA256
        AddSuiteHashSigAlgo(suites, sha256_mac, ecc_dsa_sa_algo, keySz, &idx);
 80066e0:	f107 0316 	add.w	r3, r7, #22
 80066e4:	9300      	str	r3, [sp, #0]
 80066e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80066e8:	2203      	movs	r2, #3
 80066ea:	2104      	movs	r1, #4
 80066ec:	68f8      	ldr	r0, [r7, #12]
 80066ee:	f7ff ff7d 	bl	80065ec <AddSuiteHashSigAlgo>
                                                                          &idx);
    #endif
    }
#endif /* HAVE_ECC || HAVE_ED25519 || defined(HAVE_ED448 */

    if (haveRSAsig) {
 80066f2:	687b      	ldr	r3, [r7, #4]
 80066f4:	2b00      	cmp	r3, #0
 80066f6:	d014      	beq.n	8006722 <InitSuitesHashSigAlgo+0x5a>
    #ifdef WC_RSA_PSS
        if (tls1_2) {
 80066f8:	6a3b      	ldr	r3, [r7, #32]
 80066fa:	2b00      	cmp	r3, #0
 80066fc:	d008      	beq.n	8006710 <InitSuitesHashSigAlgo+0x48>
        #ifdef WOLFSSL_SHA384
            AddSuiteHashSigAlgo(suites, sha384_mac, rsa_pss_sa_algo, keySz,
                                                                          &idx);
        #endif
        #ifndef NO_SHA256
            AddSuiteHashSigAlgo(suites, sha256_mac, rsa_pss_sa_algo, keySz,
 80066fe:	f107 0316 	add.w	r3, r7, #22
 8006702:	9300      	str	r3, [sp, #0]
 8006704:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006706:	2208      	movs	r2, #8
 8006708:	2104      	movs	r1, #4
 800670a:	68f8      	ldr	r0, [r7, #12]
 800670c:	f7ff ff6e 	bl	80065ec <AddSuiteHashSigAlgo>
    #endif
    #ifdef WOLFSSL_SHA384
        AddSuiteHashSigAlgo(suites, sha384_mac, rsa_sa_algo, keySz, &idx);
    #endif
    #ifndef NO_SHA256
        AddSuiteHashSigAlgo(suites, sha256_mac, rsa_sa_algo, keySz, &idx);
 8006710:	f107 0316 	add.w	r3, r7, #22
 8006714:	9300      	str	r3, [sp, #0]
 8006716:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006718:	2201      	movs	r2, #1
 800671a:	2104      	movs	r1, #4
 800671c:	68f8      	ldr	r0, [r7, #12]
 800671e:	f7ff ff65 	bl	80065ec <AddSuiteHashSigAlgo>
    }
#endif

    (void)haveAnon;
    (void)haveECDSAsig;
    suites->hashSigAlgoSz = idx;
 8006722:	8afa      	ldrh	r2, [r7, #22]
 8006724:	68fb      	ldr	r3, [r7, #12]
 8006726:	805a      	strh	r2, [r3, #2]
}
 8006728:	bf00      	nop
 800672a:	3718      	adds	r7, #24
 800672c:	46bd      	mov	sp, r7
 800672e:	bd80      	pop	{r7, pc}

08006730 <InitSuites>:

void InitSuites(Suites* suites, ProtocolVersion pv, int keySz, word16 haveRSA,
                word16 havePSK, word16 haveDH, word16 haveNTRU,
                word16 haveECDSAsig, word16 haveECC,
                word16 haveStaticECC, int side)
{
 8006730:	b580      	push	{r7, lr}
 8006732:	b08c      	sub	sp, #48	; 0x30
 8006734:	af02      	add	r7, sp, #8
 8006736:	60f8      	str	r0, [r7, #12]
 8006738:	8139      	strh	r1, [r7, #8]
 800673a:	607a      	str	r2, [r7, #4]
 800673c:	807b      	strh	r3, [r7, #2]
    word16 idx = 0;
 800673e:	2300      	movs	r3, #0
 8006740:	84fb      	strh	r3, [r7, #38]	; 0x26
    int    tls    = pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_MINOR;
 8006742:	7a3b      	ldrb	r3, [r7, #8]
 8006744:	2b03      	cmp	r3, #3
 8006746:	d104      	bne.n	8006752 <InitSuites+0x22>
 8006748:	7a7b      	ldrb	r3, [r7, #9]
 800674a:	2b00      	cmp	r3, #0
 800674c:	d001      	beq.n	8006752 <InitSuites+0x22>
 800674e:	2301      	movs	r3, #1
 8006750:	e000      	b.n	8006754 <InitSuites+0x24>
 8006752:	2300      	movs	r3, #0
 8006754:	61fb      	str	r3, [r7, #28]
    int    tls1_2 = pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_2_MINOR;
 8006756:	7a3b      	ldrb	r3, [r7, #8]
 8006758:	2b03      	cmp	r3, #3
 800675a:	d104      	bne.n	8006766 <InitSuites+0x36>
 800675c:	7a7b      	ldrb	r3, [r7, #9]
 800675e:	2b02      	cmp	r3, #2
 8006760:	d901      	bls.n	8006766 <InitSuites+0x36>
 8006762:	2301      	movs	r3, #1
 8006764:	e000      	b.n	8006768 <InitSuites+0x38>
 8006766:	2300      	movs	r3, #0
 8006768:	61bb      	str	r3, [r7, #24]
#ifdef WOLFSSL_TLS13
    int    tls1_3 = IsAtLeastTLSv1_3(pv);
 800676a:	68b8      	ldr	r0, [r7, #8]
 800676c:	f7ff fdda 	bl	8006324 <IsAtLeastTLSv1_3>
 8006770:	6178      	str	r0, [r7, #20]
#endif
    int    dtls   = 0;
 8006772:	2300      	movs	r3, #0
 8006774:	613b      	str	r3, [r7, #16]
    int    haveRSAsig = 1;
 8006776:	2301      	movs	r3, #1
 8006778:	623b      	str	r3, [r7, #32]
    (void)haveECC;
    (void)side;
    (void)haveRSA;    /* some builds won't read */
    (void)haveRSAsig; /* non ecc builds won't read */

    if (suites == NULL) {
 800677a:	68fb      	ldr	r3, [r7, #12]
 800677c:	2b00      	cmp	r3, #0
 800677e:	f000 817d 	beq.w	8006a7c <InitSuites+0x34c>
        WOLFSSL_MSG("InitSuites pointer error");
        return;
    }

    if (suites->setSuites)
 8006782:	68fb      	ldr	r3, [r7, #12]
 8006784:	f893 3154 	ldrb.w	r3, [r3, #340]	; 0x154
 8006788:	2b00      	cmp	r3, #0
 800678a:	f040 8179 	bne.w	8006a80 <InitSuites+0x350>
        return;      /* trust user settings, don't override */

#ifdef WOLFSSL_TLS13
#ifdef BUILD_TLS_AES_128_GCM_SHA256
    if (tls1_3) {
 800678e:	697b      	ldr	r3, [r7, #20]
 8006790:	2b00      	cmp	r3, #0
 8006792:	d00f      	beq.n	80067b4 <InitSuites+0x84>
        suites->suites[idx++] = TLS13_BYTE;
 8006794:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8006796:	1c5a      	adds	r2, r3, #1
 8006798:	84fa      	strh	r2, [r7, #38]	; 0x26
 800679a:	461a      	mov	r2, r3
 800679c:	68fb      	ldr	r3, [r7, #12]
 800679e:	4413      	add	r3, r2
 80067a0:	2213      	movs	r2, #19
 80067a2:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_AES_128_GCM_SHA256;
 80067a4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80067a6:	1c5a      	adds	r2, r3, #1
 80067a8:	84fa      	strh	r2, [r7, #38]	; 0x26
 80067aa:	461a      	mov	r2, r3
 80067ac:	68fb      	ldr	r3, [r7, #12]
 80067ae:	4413      	add	r3, r2
 80067b0:	2201      	movs	r2, #1
 80067b2:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_AES_256_GCM_SHA384;
    }
#endif

#ifdef BUILD_TLS_CHACHA20_POLY1305_SHA256
    if (tls1_3) {
 80067b4:	697b      	ldr	r3, [r7, #20]
 80067b6:	2b00      	cmp	r3, #0
 80067b8:	d00f      	beq.n	80067da <InitSuites+0xaa>
        suites->suites[idx++] = TLS13_BYTE;
 80067ba:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80067bc:	1c5a      	adds	r2, r3, #1
 80067be:	84fa      	strh	r2, [r7, #38]	; 0x26
 80067c0:	461a      	mov	r2, r3
 80067c2:	68fb      	ldr	r3, [r7, #12]
 80067c4:	4413      	add	r3, r2
 80067c6:	2213      	movs	r2, #19
 80067c8:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_CHACHA20_POLY1305_SHA256;
 80067ca:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80067cc:	1c5a      	adds	r2, r3, #1
 80067ce:	84fa      	strh	r2, [r7, #38]	; 0x26
 80067d0:	461a      	mov	r2, r3
 80067d2:	68fb      	ldr	r3, [r7, #12]
 80067d4:	4413      	add	r3, r2
 80067d6:	2203      	movs	r2, #3
 80067d8:	711a      	strb	r2, [r3, #4]
#endif /* WOLFSSL_TLS13 */

#ifndef WOLFSSL_NO_TLS12

#if !defined(NO_WOLFSSL_SERVER) && !defined(NO_RSA)
    if (side == WOLFSSL_SERVER_END && haveStaticECC) {
 80067da:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80067dc:	2b00      	cmp	r3, #0
 80067de:	d105      	bne.n	80067ec <InitSuites+0xbc>
 80067e0:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 80067e4:	2b00      	cmp	r3, #0
 80067e6:	d001      	beq.n	80067ec <InitSuites+0xbc>
        haveRSA = 0;   /* can't do RSA with ECDSA key */
 80067e8:	2300      	movs	r3, #0
 80067ea:	807b      	strh	r3, [r7, #2]
    }

    if (side == WOLFSSL_SERVER_END && haveECDSAsig) {
 80067ec:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80067ee:	2b00      	cmp	r3, #0
 80067f0:	d104      	bne.n	80067fc <InitSuites+0xcc>
 80067f2:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 80067f4:	2b00      	cmp	r3, #0
 80067f6:	d001      	beq.n	80067fc <InitSuites+0xcc>
        haveRSAsig = 0;     /* can't have RSA sig if signed by ECDSA */
 80067f8:	2300      	movs	r3, #0
 80067fa:	623b      	str	r3, [r7, #32]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384;
    }
#endif

#ifdef BUILD_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
    if (tls1_2 && haveECC) {
 80067fc:	69bb      	ldr	r3, [r7, #24]
 80067fe:	2b00      	cmp	r3, #0
 8006800:	d013      	beq.n	800682a <InitSuites+0xfa>
 8006802:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 8006806:	2b00      	cmp	r3, #0
 8006808:	d00f      	beq.n	800682a <InitSuites+0xfa>
        suites->suites[idx++] = ECC_BYTE;
 800680a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800680c:	1c5a      	adds	r2, r3, #1
 800680e:	84fa      	strh	r2, [r7, #38]	; 0x26
 8006810:	461a      	mov	r2, r3
 8006812:	68fb      	ldr	r3, [r7, #12]
 8006814:	4413      	add	r3, r2
 8006816:	22c0      	movs	r2, #192	; 0xc0
 8006818:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256;
 800681a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800681c:	1c5a      	adds	r2, r3, #1
 800681e:	84fa      	strh	r2, [r7, #38]	; 0x26
 8006820:	461a      	mov	r2, r3
 8006822:	68fb      	ldr	r3, [r7, #12]
 8006824:	4413      	add	r3, r2
 8006826:	222b      	movs	r2, #43	; 0x2b
 8006828:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384;
    }
#endif

#ifdef BUILD_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
    if (tls1_2 && haveRSA) {
 800682a:	69bb      	ldr	r3, [r7, #24]
 800682c:	2b00      	cmp	r3, #0
 800682e:	d012      	beq.n	8006856 <InitSuites+0x126>
 8006830:	887b      	ldrh	r3, [r7, #2]
 8006832:	2b00      	cmp	r3, #0
 8006834:	d00f      	beq.n	8006856 <InitSuites+0x126>
        suites->suites[idx++] = ECC_BYTE;
 8006836:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8006838:	1c5a      	adds	r2, r3, #1
 800683a:	84fa      	strh	r2, [r7, #38]	; 0x26
 800683c:	461a      	mov	r2, r3
 800683e:	68fb      	ldr	r3, [r7, #12]
 8006840:	4413      	add	r3, r2
 8006842:	22c0      	movs	r2, #192	; 0xc0
 8006844:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256;
 8006846:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8006848:	1c5a      	adds	r2, r3, #1
 800684a:	84fa      	strh	r2, [r7, #38]	; 0x26
 800684c:	461a      	mov	r2, r3
 800684e:	68fb      	ldr	r3, [r7, #12]
 8006850:	4413      	add	r3, r2
 8006852:	222f      	movs	r2, #47	; 0x2f
 8006854:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_AES_256_GCM_SHA384;
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
    if (tls1_2 && haveDH && haveRSA) {
 8006856:	69bb      	ldr	r3, [r7, #24]
 8006858:	2b00      	cmp	r3, #0
 800685a:	d015      	beq.n	8006888 <InitSuites+0x158>
 800685c:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 800685e:	2b00      	cmp	r3, #0
 8006860:	d012      	beq.n	8006888 <InitSuites+0x158>
 8006862:	887b      	ldrh	r3, [r7, #2]
 8006864:	2b00      	cmp	r3, #0
 8006866:	d00f      	beq.n	8006888 <InitSuites+0x158>
        suites->suites[idx++] = CIPHER_BYTE;
 8006868:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800686a:	1c5a      	adds	r2, r3, #1
 800686c:	84fa      	strh	r2, [r7, #38]	; 0x26
 800686e:	461a      	mov	r2, r3
 8006870:	68fb      	ldr	r3, [r7, #12]
 8006872:	4413      	add	r3, r2
 8006874:	2200      	movs	r2, #0
 8006876:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_AES_128_GCM_SHA256;
 8006878:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800687a:	1c5a      	adds	r2, r3, #1
 800687c:	84fa      	strh	r2, [r7, #38]	; 0x26
 800687e:	461a      	mov	r2, r3
 8006880:	68fb      	ldr	r3, [r7, #12]
 8006882:	4413      	add	r3, r2
 8006884:	229e      	movs	r2, #158	; 0x9e
 8006886:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_PSK_WITH_AES_128_GCM_SHA256;
    }
#endif

#ifdef BUILD_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
    if (tls1_2 && haveECC) {
 8006888:	69bb      	ldr	r3, [r7, #24]
 800688a:	2b00      	cmp	r3, #0
 800688c:	d013      	beq.n	80068b6 <InitSuites+0x186>
 800688e:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 8006892:	2b00      	cmp	r3, #0
 8006894:	d00f      	beq.n	80068b6 <InitSuites+0x186>
        suites->suites[idx++] = CHACHA_BYTE;
 8006896:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8006898:	1c5a      	adds	r2, r3, #1
 800689a:	84fa      	strh	r2, [r7, #38]	; 0x26
 800689c:	461a      	mov	r2, r3
 800689e:	68fb      	ldr	r3, [r7, #12]
 80068a0:	4413      	add	r3, r2
 80068a2:	22cc      	movs	r2, #204	; 0xcc
 80068a4:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256;
 80068a6:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80068a8:	1c5a      	adds	r2, r3, #1
 80068aa:	84fa      	strh	r2, [r7, #38]	; 0x26
 80068ac:	461a      	mov	r2, r3
 80068ae:	68fb      	ldr	r3, [r7, #12]
 80068b0:	4413      	add	r3, r2
 80068b2:	22a9      	movs	r2, #169	; 0xa9
 80068b4:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    if (tls1_2 && haveRSA) {
 80068b6:	69bb      	ldr	r3, [r7, #24]
 80068b8:	2b00      	cmp	r3, #0
 80068ba:	d012      	beq.n	80068e2 <InitSuites+0x1b2>
 80068bc:	887b      	ldrh	r3, [r7, #2]
 80068be:	2b00      	cmp	r3, #0
 80068c0:	d00f      	beq.n	80068e2 <InitSuites+0x1b2>
        suites->suites[idx++] = CHACHA_BYTE;
 80068c2:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80068c4:	1c5a      	adds	r2, r3, #1
 80068c6:	84fa      	strh	r2, [r7, #38]	; 0x26
 80068c8:	461a      	mov	r2, r3
 80068ca:	68fb      	ldr	r3, [r7, #12]
 80068cc:	4413      	add	r3, r2
 80068ce:	22cc      	movs	r2, #204	; 0xcc
 80068d0:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
 80068d2:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80068d4:	1c5a      	adds	r2, r3, #1
 80068d6:	84fa      	strh	r2, [r7, #38]	; 0x26
 80068d8:	461a      	mov	r2, r3
 80068da:	68fb      	ldr	r3, [r7, #12]
 80068dc:	4413      	add	r3, r2
 80068de:	22a8      	movs	r2, #168	; 0xa8
 80068e0:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    if (tls1_2 && haveRSA) {
 80068e2:	69bb      	ldr	r3, [r7, #24]
 80068e4:	2b00      	cmp	r3, #0
 80068e6:	d012      	beq.n	800690e <InitSuites+0x1de>
 80068e8:	887b      	ldrh	r3, [r7, #2]
 80068ea:	2b00      	cmp	r3, #0
 80068ec:	d00f      	beq.n	800690e <InitSuites+0x1de>
        suites->suites[idx++] = CHACHA_BYTE;
 80068ee:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80068f0:	1c5a      	adds	r2, r3, #1
 80068f2:	84fa      	strh	r2, [r7, #38]	; 0x26
 80068f4:	461a      	mov	r2, r3
 80068f6:	68fb      	ldr	r3, [r7, #12]
 80068f8:	4413      	add	r3, r2
 80068fa:	22cc      	movs	r2, #204	; 0xcc
 80068fc:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
 80068fe:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8006900:	1c5a      	adds	r2, r3, #1
 8006902:	84fa      	strh	r2, [r7, #38]	; 0x26
 8006904:	461a      	mov	r2, r3
 8006906:	68fb      	ldr	r3, [r7, #12]
 8006908:	4413      	add	r3, r2
 800690a:	22aa      	movs	r2, #170	; 0xaa
 800690c:	711a      	strb	r2, [r3, #4]
    }
#endif
#endif

#ifdef BUILD_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
    if (tls1_2 && haveRSA) {
 800690e:	69bb      	ldr	r3, [r7, #24]
 8006910:	2b00      	cmp	r3, #0
 8006912:	d012      	beq.n	800693a <InitSuites+0x20a>
 8006914:	887b      	ldrh	r3, [r7, #2]
 8006916:	2b00      	cmp	r3, #0
 8006918:	d00f      	beq.n	800693a <InitSuites+0x20a>
        suites->suites[idx++] = ECC_BYTE;
 800691a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800691c:	1c5a      	adds	r2, r3, #1
 800691e:	84fa      	strh	r2, [r7, #38]	; 0x26
 8006920:	461a      	mov	r2, r3
 8006922:	68fb      	ldr	r3, [r7, #12]
 8006924:	4413      	add	r3, r2
 8006926:	22c0      	movs	r2, #192	; 0xc0
 8006928:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256;
 800692a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800692c:	1c5a      	adds	r2, r3, #1
 800692e:	84fa      	strh	r2, [r7, #38]	; 0x26
 8006930:	461a      	mov	r2, r3
 8006932:	68fb      	ldr	r3, [r7, #12]
 8006934:	4413      	add	r3, r2
 8006936:	2227      	movs	r2, #39	; 0x27
 8006938:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
    if (tls1_2 && haveECC) {
 800693a:	69bb      	ldr	r3, [r7, #24]
 800693c:	2b00      	cmp	r3, #0
 800693e:	d013      	beq.n	8006968 <InitSuites+0x238>
 8006940:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 8006944:	2b00      	cmp	r3, #0
 8006946:	d00f      	beq.n	8006968 <InitSuites+0x238>
        suites->suites[idx++] = ECC_BYTE;
 8006948:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800694a:	1c5a      	adds	r2, r3, #1
 800694c:	84fa      	strh	r2, [r7, #38]	; 0x26
 800694e:	461a      	mov	r2, r3
 8006950:	68fb      	ldr	r3, [r7, #12]
 8006952:	4413      	add	r3, r2
 8006954:	22c0      	movs	r2, #192	; 0xc0
 8006956:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256;
 8006958:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800695a:	1c5a      	adds	r2, r3, #1
 800695c:	84fa      	strh	r2, [r7, #38]	; 0x26
 800695e:	461a      	mov	r2, r3
 8006960:	68fb      	ldr	r3, [r7, #12]
 8006962:	4413      	add	r3, r2
 8006964:	2223      	movs	r2, #35	; 0x23
 8006966:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
#ifndef WOLFSSL_OLDTLS_SHA2_CIPHERSUITES
    if (tls1_2 && haveDH && haveRSA)
 8006968:	69bb      	ldr	r3, [r7, #24]
 800696a:	2b00      	cmp	r3, #0
 800696c:	d015      	beq.n	800699a <InitSuites+0x26a>
 800696e:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8006970:	2b00      	cmp	r3, #0
 8006972:	d012      	beq.n	800699a <InitSuites+0x26a>
 8006974:	887b      	ldrh	r3, [r7, #2]
 8006976:	2b00      	cmp	r3, #0
 8006978:	d00f      	beq.n	800699a <InitSuites+0x26a>
#else
    if (tls && haveDH && haveRSA)
#endif
    {
        suites->suites[idx++] = CIPHER_BYTE;
 800697a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800697c:	1c5a      	adds	r2, r3, #1
 800697e:	84fa      	strh	r2, [r7, #38]	; 0x26
 8006980:	461a      	mov	r2, r3
 8006982:	68fb      	ldr	r3, [r7, #12]
 8006984:	4413      	add	r3, r2
 8006986:	2200      	movs	r2, #0
 8006988:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_AES_256_CBC_SHA256;
 800698a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800698c:	1c5a      	adds	r2, r3, #1
 800698e:	84fa      	strh	r2, [r7, #38]	; 0x26
 8006990:	461a      	mov	r2, r3
 8006992:	68fb      	ldr	r3, [r7, #12]
 8006994:	4413      	add	r3, r2
 8006996:	226b      	movs	r2, #107	; 0x6b
 8006998:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
#ifndef WOLFSSL_OLDTLS_SHA2_CIPHERSUITES
    if (tls1_2 && haveDH && haveRSA)
 800699a:	69bb      	ldr	r3, [r7, #24]
 800699c:	2b00      	cmp	r3, #0
 800699e:	d015      	beq.n	80069cc <InitSuites+0x29c>
 80069a0:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 80069a2:	2b00      	cmp	r3, #0
 80069a4:	d012      	beq.n	80069cc <InitSuites+0x29c>
 80069a6:	887b      	ldrh	r3, [r7, #2]
 80069a8:	2b00      	cmp	r3, #0
 80069aa:	d00f      	beq.n	80069cc <InitSuites+0x29c>
#else
    if (tls && haveDH && haveRSA)
#endif
    {
        suites->suites[idx++] = CIPHER_BYTE;
 80069ac:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80069ae:	1c5a      	adds	r2, r3, #1
 80069b0:	84fa      	strh	r2, [r7, #38]	; 0x26
 80069b2:	461a      	mov	r2, r3
 80069b4:	68fb      	ldr	r3, [r7, #12]
 80069b6:	4413      	add	r3, r2
 80069b8:	2200      	movs	r2, #0
 80069ba:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_AES_128_CBC_SHA256;
 80069bc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80069be:	1c5a      	adds	r2, r3, #1
 80069c0:	84fa      	strh	r2, [r7, #38]	; 0x26
 80069c2:	461a      	mov	r2, r3
 80069c4:	68fb      	ldr	r3, [r7, #12]
 80069c6:	4413      	add	r3, r2
 80069c8:	2267      	movs	r2, #103	; 0x67
 80069ca:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_RSA_WITH_AES_128_CBC_SHA;
    }
#endif

#ifdef BUILD_TLS_ECDHE_ECDSA_WITH_CHACHA20_OLD_POLY1305_SHA256
    if (tls1_2 && haveECC) {
 80069cc:	69bb      	ldr	r3, [r7, #24]
 80069ce:	2b00      	cmp	r3, #0
 80069d0:	d013      	beq.n	80069fa <InitSuites+0x2ca>
 80069d2:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 80069d6:	2b00      	cmp	r3, #0
 80069d8:	d00f      	beq.n	80069fa <InitSuites+0x2ca>
        suites->suites[idx++] = CHACHA_BYTE;
 80069da:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80069dc:	1c5a      	adds	r2, r3, #1
 80069de:	84fa      	strh	r2, [r7, #38]	; 0x26
 80069e0:	461a      	mov	r2, r3
 80069e2:	68fb      	ldr	r3, [r7, #12]
 80069e4:	4413      	add	r3, r2
 80069e6:	22cc      	movs	r2, #204	; 0xcc
 80069e8:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] =
 80069ea:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80069ec:	1c5a      	adds	r2, r3, #1
 80069ee:	84fa      	strh	r2, [r7, #38]	; 0x26
 80069f0:	461a      	mov	r2, r3
 80069f2:	68fb      	ldr	r3, [r7, #12]
 80069f4:	4413      	add	r3, r2
 80069f6:	2214      	movs	r2, #20
 80069f8:	711a      	strb	r2, [r3, #4]
                              TLS_ECDHE_ECDSA_WITH_CHACHA20_OLD_POLY1305_SHA256;
    }
#endif

#ifdef BUILD_TLS_ECDHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256
    if (tls1_2 && haveRSA) {
 80069fa:	69bb      	ldr	r3, [r7, #24]
 80069fc:	2b00      	cmp	r3, #0
 80069fe:	d012      	beq.n	8006a26 <InitSuites+0x2f6>
 8006a00:	887b      	ldrh	r3, [r7, #2]
 8006a02:	2b00      	cmp	r3, #0
 8006a04:	d00f      	beq.n	8006a26 <InitSuites+0x2f6>
        suites->suites[idx++] = CHACHA_BYTE;
 8006a06:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8006a08:	1c5a      	adds	r2, r3, #1
 8006a0a:	84fa      	strh	r2, [r7, #38]	; 0x26
 8006a0c:	461a      	mov	r2, r3
 8006a0e:	68fb      	ldr	r3, [r7, #12]
 8006a10:	4413      	add	r3, r2
 8006a12:	22cc      	movs	r2, #204	; 0xcc
 8006a14:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256;
 8006a16:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8006a18:	1c5a      	adds	r2, r3, #1
 8006a1a:	84fa      	strh	r2, [r7, #38]	; 0x26
 8006a1c:	461a      	mov	r2, r3
 8006a1e:	68fb      	ldr	r3, [r7, #12]
 8006a20:	4413      	add	r3, r2
 8006a22:	2213      	movs	r2, #19
 8006a24:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256
    if (tls1_2 && haveRSA) {
 8006a26:	69bb      	ldr	r3, [r7, #24]
 8006a28:	2b00      	cmp	r3, #0
 8006a2a:	d012      	beq.n	8006a52 <InitSuites+0x322>
 8006a2c:	887b      	ldrh	r3, [r7, #2]
 8006a2e:	2b00      	cmp	r3, #0
 8006a30:	d00f      	beq.n	8006a52 <InitSuites+0x322>
        suites->suites[idx++] = CHACHA_BYTE;
 8006a32:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8006a34:	1c5a      	adds	r2, r3, #1
 8006a36:	84fa      	strh	r2, [r7, #38]	; 0x26
 8006a38:	461a      	mov	r2, r3
 8006a3a:	68fb      	ldr	r3, [r7, #12]
 8006a3c:	4413      	add	r3, r2
 8006a3e:	22cc      	movs	r2, #204	; 0xcc
 8006a40:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256;
 8006a42:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8006a44:	1c5a      	adds	r2, r3, #1
 8006a46:	84fa      	strh	r2, [r7, #38]	; 0x26
 8006a48:	461a      	mov	r2, r3
 8006a4a:	68fb      	ldr	r3, [r7, #12]
 8006a4c:	4413      	add	r3, r2
 8006a4e:	2215      	movs	r2, #21
 8006a50:	711a      	strb	r2, [r3, #4]
    }
#endif

#endif /* !WOLFSSL_NO_TLS12 */

    suites->suiteSz = idx;
 8006a52:	68fb      	ldr	r3, [r7, #12]
 8006a54:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8006a56:	801a      	strh	r2, [r3, #0]

    InitSuitesHashSigAlgo(suites, haveECDSAsig | haveECC, haveRSAsig | haveRSA,
 8006a58:	8fba      	ldrh	r2, [r7, #60]	; 0x3c
 8006a5a:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 8006a5e:	4313      	orrs	r3, r2
 8006a60:	b29b      	uxth	r3, r3
 8006a62:	4619      	mov	r1, r3
 8006a64:	887a      	ldrh	r2, [r7, #2]
 8006a66:	6a3b      	ldr	r3, [r7, #32]
 8006a68:	431a      	orrs	r2, r3
 8006a6a:	687b      	ldr	r3, [r7, #4]
 8006a6c:	9301      	str	r3, [sp, #4]
 8006a6e:	69bb      	ldr	r3, [r7, #24]
 8006a70:	9300      	str	r3, [sp, #0]
 8006a72:	2300      	movs	r3, #0
 8006a74:	68f8      	ldr	r0, [r7, #12]
 8006a76:	f7ff fe27 	bl	80066c8 <InitSuitesHashSigAlgo>
 8006a7a:	e002      	b.n	8006a82 <InitSuites+0x352>
        return;
 8006a7c:	bf00      	nop
 8006a7e:	e000      	b.n	8006a82 <InitSuites+0x352>
        return;      /* trust user settings, don't override */
 8006a80:	bf00      	nop
                                                              0, tls1_2, keySz);
}
 8006a82:	3728      	adds	r7, #40	; 0x28
 8006a84:	46bd      	mov	sp, r7
 8006a86:	bd80      	pop	{r7, pc}

08006a88 <SSL_CTX_RefCount>:
    return WOLFSSL_SUCCESS;
}

/* returns new reference count. Arg incr positive=up or negative=down */
int SSL_CTX_RefCount(WOLFSSL_CTX* ctx, int incr)
{
 8006a88:	b580      	push	{r7, lr}
 8006a8a:	b084      	sub	sp, #16
 8006a8c:	af00      	add	r7, sp, #0
 8006a8e:	6078      	str	r0, [r7, #4]
 8006a90:	6039      	str	r1, [r7, #0]
    int refCount;

    if (ctx == NULL) {
 8006a92:	687b      	ldr	r3, [r7, #4]
 8006a94:	2b00      	cmp	r3, #0
 8006a96:	d102      	bne.n	8006a9e <SSL_CTX_RefCount+0x16>
        return BAD_FUNC_ARG;
 8006a98:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8006a9c:	e020      	b.n	8006ae0 <SSL_CTX_RefCount+0x58>
    }

    if (wc_LockMutex(&ctx->countMutex) != 0) {
 8006a9e:	687b      	ldr	r3, [r7, #4]
 8006aa0:	3308      	adds	r3, #8
 8006aa2:	4618      	mov	r0, r3
 8006aa4:	f012 fbf6 	bl	8019294 <wc_LockMutex>
 8006aa8:	4603      	mov	r3, r0
 8006aaa:	2b00      	cmp	r3, #0
 8006aac:	d002      	beq.n	8006ab4 <SSL_CTX_RefCount+0x2c>
        WOLFSSL_MSG("Couldn't lock CTX count mutex");
        return BAD_MUTEX_E;
 8006aae:	f06f 0369 	mvn.w	r3, #105	; 0x69
 8006ab2:	e015      	b.n	8006ae0 <SSL_CTX_RefCount+0x58>
    }

    ctx->refCount += incr;
 8006ab4:	687b      	ldr	r3, [r7, #4]
 8006ab6:	68da      	ldr	r2, [r3, #12]
 8006ab8:	683b      	ldr	r3, [r7, #0]
 8006aba:	441a      	add	r2, r3
 8006abc:	687b      	ldr	r3, [r7, #4]
 8006abe:	60da      	str	r2, [r3, #12]
    /* make sure refCount is never negative */
    if (ctx->refCount < 0) {
 8006ac0:	687b      	ldr	r3, [r7, #4]
 8006ac2:	68db      	ldr	r3, [r3, #12]
 8006ac4:	2b00      	cmp	r3, #0
 8006ac6:	da02      	bge.n	8006ace <SSL_CTX_RefCount+0x46>
        ctx->refCount = 0;
 8006ac8:	687b      	ldr	r3, [r7, #4]
 8006aca:	2200      	movs	r2, #0
 8006acc:	60da      	str	r2, [r3, #12]
    }
    refCount = ctx->refCount;
 8006ace:	687b      	ldr	r3, [r7, #4]
 8006ad0:	68db      	ldr	r3, [r3, #12]
 8006ad2:	60fb      	str	r3, [r7, #12]

    wc_UnLockMutex(&ctx->countMutex);
 8006ad4:	687b      	ldr	r3, [r7, #4]
 8006ad6:	3308      	adds	r3, #8
 8006ad8:	4618      	mov	r0, r3
 8006ada:	f012 fbe6 	bl	80192aa <wc_UnLockMutex>

    return refCount;
 8006ade:	68fb      	ldr	r3, [r7, #12]
}
 8006ae0:	4618      	mov	r0, r3
 8006ae2:	3710      	adds	r7, #16
 8006ae4:	46bd      	mov	sp, r7
 8006ae6:	bd80      	pop	{r7, pc}

08006ae8 <DoVerifyCallback>:
 * store->error_depth member to determine index (0=peer, >1 intermediates)
 */

int DoVerifyCallback(WOLFSSL_CERT_MANAGER* cm, WOLFSSL* ssl, int ret,
                                                        ProcPeerCertArgs* args)
{
 8006ae8:	b580      	push	{r7, lr}
 8006aea:	b08e      	sub	sp, #56	; 0x38
 8006aec:	af00      	add	r7, sp, #0
 8006aee:	60f8      	str	r0, [r7, #12]
 8006af0:	60b9      	str	r1, [r7, #8]
 8006af2:	607a      	str	r2, [r7, #4]
 8006af4:	603b      	str	r3, [r7, #0]
    int verify_ok = 0, use_cb = 0;
 8006af6:	2300      	movs	r3, #0
 8006af8:	637b      	str	r3, [r7, #52]	; 0x34
 8006afa:	2300      	movs	r3, #0
 8006afc:	633b      	str	r3, [r7, #48]	; 0x30
    void *heap;

    if (cm == NULL) {
 8006afe:	68fb      	ldr	r3, [r7, #12]
 8006b00:	2b00      	cmp	r3, #0
 8006b02:	d102      	bne.n	8006b0a <DoVerifyCallback+0x22>
        return BAD_FUNC_ARG;
 8006b04:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8006b08:	e0f1      	b.n	8006cee <DoVerifyCallback+0x206>
    }

    heap = (ssl != NULL) ? ssl->heap : cm->heap;
 8006b0a:	68bb      	ldr	r3, [r7, #8]
 8006b0c:	2b00      	cmp	r3, #0
 8006b0e:	d003      	beq.n	8006b18 <DoVerifyCallback+0x30>
 8006b10:	68bb      	ldr	r3, [r7, #8]
 8006b12:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8006b16:	e001      	b.n	8006b1c <DoVerifyCallback+0x34>
 8006b18:	68fb      	ldr	r3, [r7, #12]
 8006b1a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006b1c:	627b      	str	r3, [r7, #36]	; 0x24

    /* Determine if verify was okay */
    if (ret == 0) {
 8006b1e:	687b      	ldr	r3, [r7, #4]
 8006b20:	2b00      	cmp	r3, #0
 8006b22:	d101      	bne.n	8006b28 <DoVerifyCallback+0x40>
        verify_ok = 1;
 8006b24:	2301      	movs	r3, #1
 8006b26:	637b      	str	r3, [r7, #52]	; 0x34
    }

    /* Determine if verify callback should be used */
    if (ret != 0) {
 8006b28:	687b      	ldr	r3, [r7, #4]
 8006b2a:	2b00      	cmp	r3, #0
 8006b2c:	d00c      	beq.n	8006b48 <DoVerifyCallback+0x60>
        if ((ssl != NULL) && (!ssl->options.verifyNone)) {
 8006b2e:	68bb      	ldr	r3, [r7, #8]
 8006b30:	2b00      	cmp	r3, #0
 8006b32:	d009      	beq.n	8006b48 <DoVerifyCallback+0x60>
 8006b34:	68bb      	ldr	r3, [r7, #8]
 8006b36:	f893 331c 	ldrb.w	r3, [r3, #796]	; 0x31c
 8006b3a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8006b3e:	b2db      	uxtb	r3, r3
 8006b40:	2b00      	cmp	r3, #0
 8006b42:	d101      	bne.n	8006b48 <DoVerifyCallback+0x60>
            use_cb = 1; /* always report errors */
 8006b44:	2301      	movs	r3, #1
 8006b46:	633b      	str	r3, [r7, #48]	; 0x30
            }
        }
    }
#endif
    /* if verify callback has been set */
    if ((use_cb && (ssl != NULL) && ((ssl->verifyCallback != NULL)
 8006b48:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8006b4a:	2b00      	cmp	r3, #0
 8006b4c:	d007      	beq.n	8006b5e <DoVerifyCallback+0x76>
 8006b4e:	68bb      	ldr	r3, [r7, #8]
 8006b50:	2b00      	cmp	r3, #0
 8006b52:	d004      	beq.n	8006b5e <DoVerifyCallback+0x76>
 8006b54:	68bb      	ldr	r3, [r7, #8]
 8006b56:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8006b5a:	2b00      	cmp	r3, #0
 8006b5c:	d104      	bne.n	8006b68 <DoVerifyCallback+0x80>
    #ifdef OPENSSL_ALL
        || (ssl->ctx->verifyCertCb != NULL)
    #endif
        ))
    #ifndef NO_WOLFSSL_CM_VERIFY
        || (cm->verifyCallback != NULL)
 8006b5e:	68fb      	ldr	r3, [r7, #12]
 8006b60:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006b62:	2b00      	cmp	r3, #0
 8006b64:	f000 80c2 	beq.w	8006cec <DoVerifyCallback+0x204>
    #endif
        ) {
        int verifyFail = 0;
 8006b68:	2300      	movs	r3, #0
 8006b6a:	62fb      	str	r3, [r7, #44]	; 0x2c
    #ifdef WOLFSSL_SMALL_STACK
        WOLFSSL_X509_STORE_CTX* store;
        #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        WOLFSSL_X509* x509;
        #endif
        char* domain = NULL;
 8006b6c:	2300      	movs	r3, #0
 8006b6e:	623b      	str	r3, [r7, #32]
    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        int x509Free = 0;
    #endif

    #ifdef WOLFSSL_SMALL_STACK
        store = (WOLFSSL_X509_STORE_CTX*)XMALLOC(
 8006b70:	2030      	movs	r0, #48	; 0x30
 8006b72:	f008 f9c1 	bl	800eef8 <wolfSSL_Malloc>
 8006b76:	61f8      	str	r0, [r7, #28]
            sizeof(WOLFSSL_X509_STORE_CTX), heap, DYNAMIC_TYPE_X509_STORE);
        if (store == NULL) {
 8006b78:	69fb      	ldr	r3, [r7, #28]
 8006b7a:	2b00      	cmp	r3, #0
 8006b7c:	d102      	bne.n	8006b84 <DoVerifyCallback+0x9c>
            return MEMORY_E;
 8006b7e:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 8006b82:	e0b4      	b.n	8006cee <DoVerifyCallback+0x206>
        if (x509 == NULL) {
            XFREE(store, heap, DYNAMIC_TYPE_X509);
            return MEMORY_E;
        }
        #endif
        domain = (char*)XMALLOC(ASN_NAME_MAX, heap, DYNAMIC_TYPE_STRING);
 8006b84:	f44f 7080 	mov.w	r0, #256	; 0x100
 8006b88:	f008 f9b6 	bl	800eef8 <wolfSSL_Malloc>
 8006b8c:	6238      	str	r0, [r7, #32]
        if (domain == NULL) {
 8006b8e:	6a3b      	ldr	r3, [r7, #32]
 8006b90:	2b00      	cmp	r3, #0
 8006b92:	d10a      	bne.n	8006baa <DoVerifyCallback+0xc2>
            XFREE(store, heap, DYNAMIC_TYPE_X509);
 8006b94:	69fb      	ldr	r3, [r7, #28]
 8006b96:	613b      	str	r3, [r7, #16]
 8006b98:	693b      	ldr	r3, [r7, #16]
 8006b9a:	2b00      	cmp	r3, #0
 8006b9c:	d002      	beq.n	8006ba4 <DoVerifyCallback+0xbc>
 8006b9e:	6938      	ldr	r0, [r7, #16]
 8006ba0:	f008 f9c6 	bl	800ef30 <wolfSSL_Free>
            #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
            XFREE(x509, heap, DYNAMIC_TYPE_X509);
            #endif
            return MEMORY_E;
 8006ba4:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 8006ba8:	e0a1      	b.n	8006cee <DoVerifyCallback+0x206>
        }
    #endif /* WOLFSSL_SMALL_STACK */

        XMEMSET(store, 0, sizeof(WOLFSSL_X509_STORE_CTX));
 8006baa:	2230      	movs	r2, #48	; 0x30
 8006bac:	2100      	movs	r1, #0
 8006bae:	69f8      	ldr	r0, [r7, #28]
 8006bb0:	f012 fc45 	bl	801943e <memset>
    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        XMEMSET(x509, 0, sizeof(WOLFSSL_X509));
    #endif
        domain[0] = '\0';
 8006bb4:	6a3b      	ldr	r3, [r7, #32]
 8006bb6:	2200      	movs	r2, #0
 8006bb8:	701a      	strb	r2, [r3, #0]

        /* build subject CN as string to return in store */
        if (args->dCertInit && args->dCert && args->dCert->subjectCN) {
 8006bba:	683b      	ldr	r3, [r7, #0]
 8006bbc:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8006bc0:	f003 0304 	and.w	r3, r3, #4
 8006bc4:	b2db      	uxtb	r3, r3
 8006bc6:	2b00      	cmp	r3, #0
 8006bc8:	d022      	beq.n	8006c10 <DoVerifyCallback+0x128>
 8006bca:	683b      	ldr	r3, [r7, #0]
 8006bcc:	689b      	ldr	r3, [r3, #8]
 8006bce:	2b00      	cmp	r3, #0
 8006bd0:	d01e      	beq.n	8006c10 <DoVerifyCallback+0x128>
 8006bd2:	683b      	ldr	r3, [r7, #0]
 8006bd4:	689b      	ldr	r3, [r3, #8]
 8006bd6:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8006bd8:	2b00      	cmp	r3, #0
 8006bda:	d019      	beq.n	8006c10 <DoVerifyCallback+0x128>
            int subjectCNLen = args->dCert->subjectCNLen;
 8006bdc:	683b      	ldr	r3, [r7, #0]
 8006bde:	689b      	ldr	r3, [r3, #8]
 8006be0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8006be4:	62bb      	str	r3, [r7, #40]	; 0x28
            if (subjectCNLen > ASN_NAME_MAX-1)
 8006be6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006be8:	2bff      	cmp	r3, #255	; 0xff
 8006bea:	dd01      	ble.n	8006bf0 <DoVerifyCallback+0x108>
                subjectCNLen = ASN_NAME_MAX-1;
 8006bec:	23ff      	movs	r3, #255	; 0xff
 8006bee:	62bb      	str	r3, [r7, #40]	; 0x28
            if (subjectCNLen > 0) {
 8006bf0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006bf2:	2b00      	cmp	r3, #0
 8006bf4:	dd0c      	ble.n	8006c10 <DoVerifyCallback+0x128>
                XMEMCPY(domain, args->dCert->subjectCN, subjectCNLen);
 8006bf6:	683b      	ldr	r3, [r7, #0]
 8006bf8:	689b      	ldr	r3, [r3, #8]
 8006bfa:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8006bfc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8006bfe:	4619      	mov	r1, r3
 8006c00:	6a38      	ldr	r0, [r7, #32]
 8006c02:	f012 fbf8 	bl	80193f6 <memcpy>
                domain[subjectCNLen] = '\0';
 8006c06:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006c08:	6a3a      	ldr	r2, [r7, #32]
 8006c0a:	4413      	add	r3, r2
 8006c0c:	2200      	movs	r2, #0
 8006c0e:	701a      	strb	r2, [r3, #0]
            }
        }

        store->error = ret;
 8006c10:	69fb      	ldr	r3, [r7, #28]
 8006c12:	687a      	ldr	r2, [r7, #4]
 8006c14:	619a      	str	r2, [r3, #24]
        store->error_depth = args->certIdx;
 8006c16:	683b      	ldr	r3, [r7, #0]
 8006c18:	69da      	ldr	r2, [r3, #28]
 8006c1a:	69fb      	ldr	r3, [r7, #28]
 8006c1c:	61da      	str	r2, [r3, #28]
        store->discardSessionCerts = 0;
 8006c1e:	69fb      	ldr	r3, [r7, #28]
 8006c20:	2200      	movs	r2, #0
 8006c22:	621a      	str	r2, [r3, #32]
        store->domain = domain;
 8006c24:	69fb      	ldr	r3, [r7, #28]
 8006c26:	6a3a      	ldr	r2, [r7, #32]
 8006c28:	611a      	str	r2, [r3, #16]
        store->userCtx = (ssl != NULL) ? ssl->verifyCbCtx : cm;
 8006c2a:	68bb      	ldr	r3, [r7, #8]
 8006c2c:	2b00      	cmp	r3, #0
 8006c2e:	d002      	beq.n	8006c36 <DoVerifyCallback+0x14e>
 8006c30:	68bb      	ldr	r3, [r7, #8]
 8006c32:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8006c34:	e000      	b.n	8006c38 <DoVerifyCallback+0x150>
 8006c36:	68fb      	ldr	r3, [r7, #12]
 8006c38:	69fa      	ldr	r2, [r7, #28]
 8006c3a:	6153      	str	r3, [r2, #20]
        store->certs = args->certs;
 8006c3c:	683b      	ldr	r3, [r7, #0]
 8006c3e:	681a      	ldr	r2, [r3, #0]
 8006c40:	69fb      	ldr	r3, [r7, #28]
 8006c42:	629a      	str	r2, [r3, #40]	; 0x28
        store->totalCerts = args->totalCerts;
 8006c44:	683b      	ldr	r3, [r7, #0]
 8006c46:	695a      	ldr	r2, [r3, #20]
 8006c48:	69fb      	ldr	r3, [r7, #28]
 8006c4a:	625a      	str	r2, [r3, #36]	; 0x24
            store->sesChain = &ssl->session.chain;
    #endif
        }
    #ifndef NO_WOLFSSL_CM_VERIFY
        /* non-zero return code indicates failure override */
        if (cm->verifyCallback != NULL) {
 8006c4c:	68fb      	ldr	r3, [r7, #12]
 8006c4e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006c50:	2b00      	cmp	r3, #0
 8006c52:	d012      	beq.n	8006c7a <DoVerifyCallback+0x192>
            store->userCtx = cm;
 8006c54:	69fb      	ldr	r3, [r7, #28]
 8006c56:	68fa      	ldr	r2, [r7, #12]
 8006c58:	615a      	str	r2, [r3, #20]
            if (cm->verifyCallback(verify_ok, store)) {
 8006c5a:	68fb      	ldr	r3, [r7, #12]
 8006c5c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006c5e:	69f9      	ldr	r1, [r7, #28]
 8006c60:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8006c62:	4798      	blx	r3
 8006c64:	4603      	mov	r3, r0
 8006c66:	2b00      	cmp	r3, #0
 8006c68:	d005      	beq.n	8006c76 <DoVerifyCallback+0x18e>
                if (ret != 0) {
 8006c6a:	687b      	ldr	r3, [r7, #4]
 8006c6c:	2b00      	cmp	r3, #0
 8006c6e:	d004      	beq.n	8006c7a <DoVerifyCallback+0x192>
                    WOLFSSL_MSG("Verify CM callback overriding error!");
                    ret = 0;
 8006c70:	2300      	movs	r3, #0
 8006c72:	607b      	str	r3, [r7, #4]
 8006c74:	e001      	b.n	8006c7a <DoVerifyCallback+0x192>
                }
            }
            else {
                verifyFail = 1;
 8006c76:	2301      	movs	r3, #1
 8006c78:	62fb      	str	r3, [r7, #44]	; 0x2c
            }
        }
    #endif

        if (ssl != NULL) {
 8006c7a:	68bb      	ldr	r3, [r7, #8]
 8006c7c:	2b00      	cmp	r3, #0
 8006c7e:	d015      	beq.n	8006cac <DoVerifyCallback+0x1c4>
                }
            }
    #endif

            /* non-zero return code indicates failure override */
            if (ssl->verifyCallback) {
 8006c80:	68bb      	ldr	r3, [r7, #8]
 8006c82:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8006c86:	2b00      	cmp	r3, #0
 8006c88:	d010      	beq.n	8006cac <DoVerifyCallback+0x1c4>
                if (ssl->verifyCallback(verify_ok, store)) {
 8006c8a:	68bb      	ldr	r3, [r7, #8]
 8006c8c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8006c90:	69f9      	ldr	r1, [r7, #28]
 8006c92:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8006c94:	4798      	blx	r3
 8006c96:	4603      	mov	r3, r0
 8006c98:	2b00      	cmp	r3, #0
 8006c9a:	d005      	beq.n	8006ca8 <DoVerifyCallback+0x1c0>
                    if (ret != 0) {
 8006c9c:	687b      	ldr	r3, [r7, #4]
 8006c9e:	2b00      	cmp	r3, #0
 8006ca0:	d004      	beq.n	8006cac <DoVerifyCallback+0x1c4>
                        WOLFSSL_MSG("Verify callback overriding error!");
                        ret = 0;
 8006ca2:	2300      	movs	r3, #0
 8006ca4:	607b      	str	r3, [r7, #4]
 8006ca6:	e001      	b.n	8006cac <DoVerifyCallback+0x1c4>
                    }
                }
                else {
                    verifyFail = 1;
 8006ca8:	2301      	movs	r3, #1
 8006caa:	62fb      	str	r3, [r7, #44]	; 0x2c
                }
            }
        }

        if (verifyFail) {
 8006cac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006cae:	2b00      	cmp	r3, #0
 8006cb0:	d00c      	beq.n	8006ccc <DoVerifyCallback+0x1e4>
            /* induce error if one not present */
            if (ret == 0) {
 8006cb2:	687b      	ldr	r3, [r7, #4]
 8006cb4:	2b00      	cmp	r3, #0
 8006cb6:	d102      	bne.n	8006cbe <DoVerifyCallback+0x1d6>
                ret = VERIFY_CERT_ERROR;
 8006cb8:	f46f 73a4 	mvn.w	r3, #328	; 0x148
 8006cbc:	607b      	str	r3, [r7, #4]
            }

            /* mark as verify error */
            args->verifyErr = 1;
 8006cbe:	683a      	ldr	r2, [r7, #0]
 8006cc0:	f892 3025 	ldrb.w	r3, [r2, #37]	; 0x25
 8006cc4:	f043 0302 	orr.w	r3, r3, #2
 8006cc8:	f882 3025 	strb.w	r3, [r2, #37]	; 0x25
        if ((ssl != NULL) && (store->param)) {
            XFREE(store->param, heap, DYNAMIC_TYPE_OPENSSL);
        }
#endif
    #ifdef WOLFSSL_SMALL_STACK
        XFREE(domain, heap, DYNAMIC_TYPE_STRING);
 8006ccc:	6a3b      	ldr	r3, [r7, #32]
 8006cce:	61bb      	str	r3, [r7, #24]
 8006cd0:	69bb      	ldr	r3, [r7, #24]
 8006cd2:	2b00      	cmp	r3, #0
 8006cd4:	d002      	beq.n	8006cdc <DoVerifyCallback+0x1f4>
 8006cd6:	69b8      	ldr	r0, [r7, #24]
 8006cd8:	f008 f92a 	bl	800ef30 <wolfSSL_Free>
        #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        XFREE(x509, heap, DYNAMIC_TYPE_X509);
        #endif
        XFREE(store, heap, DYNAMIC_TYPE_X509_STORE);
 8006cdc:	69fb      	ldr	r3, [r7, #28]
 8006cde:	617b      	str	r3, [r7, #20]
 8006ce0:	697b      	ldr	r3, [r7, #20]
 8006ce2:	2b00      	cmp	r3, #0
 8006ce4:	d002      	beq.n	8006cec <DoVerifyCallback+0x204>
 8006ce6:	6978      	ldr	r0, [r7, #20]
 8006ce8:	f008 f922 	bl	800ef30 <wolfSSL_Free>
    #endif
    }

    (void)heap;

    return ret;
 8006cec:	687b      	ldr	r3, [r7, #4]
}
 8006cee:	4618      	mov	r0, r3
 8006cf0:	3738      	adds	r7, #56	; 0x38
 8006cf2:	46bd      	mov	sp, r7
 8006cf4:	bd80      	pop	{r7, pc}

08006cf6 <c32to24>:
#endif /* !WOLFSSL_HAVE_MAX */

#ifndef WOLFSSL_NO_INT_ENCODE
/* converts a 32 bit integer to 24 bit */
WC_STATIC WC_INLINE void c32to24(word32 in, word24 out)
{
 8006cf6:	b480      	push	{r7}
 8006cf8:	b083      	sub	sp, #12
 8006cfa:	af00      	add	r7, sp, #0
 8006cfc:	6078      	str	r0, [r7, #4]
 8006cfe:	6039      	str	r1, [r7, #0]
    out[0] = (in >> 16) & 0xff;
 8006d00:	687b      	ldr	r3, [r7, #4]
 8006d02:	0c1b      	lsrs	r3, r3, #16
 8006d04:	b2da      	uxtb	r2, r3
 8006d06:	683b      	ldr	r3, [r7, #0]
 8006d08:	701a      	strb	r2, [r3, #0]
    out[1] = (in >>  8) & 0xff;
 8006d0a:	687b      	ldr	r3, [r7, #4]
 8006d0c:	0a1a      	lsrs	r2, r3, #8
 8006d0e:	683b      	ldr	r3, [r7, #0]
 8006d10:	3301      	adds	r3, #1
 8006d12:	b2d2      	uxtb	r2, r2
 8006d14:	701a      	strb	r2, [r3, #0]
    out[2] =  in & 0xff;
 8006d16:	683b      	ldr	r3, [r7, #0]
 8006d18:	3302      	adds	r3, #2
 8006d1a:	687a      	ldr	r2, [r7, #4]
 8006d1c:	b2d2      	uxtb	r2, r2
 8006d1e:	701a      	strb	r2, [r3, #0]
}
 8006d20:	bf00      	nop
 8006d22:	370c      	adds	r7, #12
 8006d24:	46bd      	mov	sp, r7
 8006d26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006d2a:	4770      	bx	lr

08006d2c <wolfSSL_CTX_new_ex>:
   WOLFSSL_METHOD pointer passed in is given to ctx to manage.
   This function frees the passed in WOLFSSL_METHOD struct on failure and on
   success is freed when ctx is freed.
 */
WOLFSSL_CTX* wolfSSL_CTX_new_ex(WOLFSSL_METHOD* method, void* heap)
{
 8006d2c:	b580      	push	{r7, lr}
 8006d2e:	b088      	sub	sp, #32
 8006d30:	af00      	add	r7, sp, #0
 8006d32:	6078      	str	r0, [r7, #4]
 8006d34:	6039      	str	r1, [r7, #0]
    WOLFSSL_CTX* ctx = NULL;
 8006d36:	2300      	movs	r3, #0
 8006d38:	61fb      	str	r3, [r7, #28]

    WOLFSSL_ENTER("wolfSSL_CTX_new_ex");

    if (initRefCount == 0) {
 8006d3a:	4b1f      	ldr	r3, [pc, #124]	; (8006db8 <wolfSSL_CTX_new_ex+0x8c>)
 8006d3c:	681b      	ldr	r3, [r3, #0]
 8006d3e:	2b00      	cmp	r3, #0
 8006d40:	d112      	bne.n	8006d68 <wolfSSL_CTX_new_ex+0x3c>
        /* user no longer forced to call Init themselves */
        int ret = wolfSSL_Init();
 8006d42:	f000 fb97 	bl	8007474 <wolfSSL_Init>
 8006d46:	61b8      	str	r0, [r7, #24]
        if (ret != WOLFSSL_SUCCESS) {
 8006d48:	69bb      	ldr	r3, [r7, #24]
 8006d4a:	2b01      	cmp	r3, #1
 8006d4c:	d00c      	beq.n	8006d68 <wolfSSL_CTX_new_ex+0x3c>
            WOLFSSL_MSG("wolfSSL_Init failed");
            WOLFSSL_LEAVE("WOLFSSL_CTX_new", 0);
            if (method != NULL) {
 8006d4e:	687b      	ldr	r3, [r7, #4]
 8006d50:	2b00      	cmp	r3, #0
 8006d52:	d007      	beq.n	8006d64 <wolfSSL_CTX_new_ex+0x38>
                XFREE(method, heap, DYNAMIC_TYPE_METHOD);
 8006d54:	687b      	ldr	r3, [r7, #4]
 8006d56:	617b      	str	r3, [r7, #20]
 8006d58:	697b      	ldr	r3, [r7, #20]
 8006d5a:	2b00      	cmp	r3, #0
 8006d5c:	d002      	beq.n	8006d64 <wolfSSL_CTX_new_ex+0x38>
 8006d5e:	6978      	ldr	r0, [r7, #20]
 8006d60:	f008 f8e6 	bl	800ef30 <wolfSSL_Free>
            }
            return NULL;
 8006d64:	2300      	movs	r3, #0
 8006d66:	e023      	b.n	8006db0 <wolfSSL_CTX_new_ex+0x84>
        }
    }

    if (method == NULL)
 8006d68:	687b      	ldr	r3, [r7, #4]
 8006d6a:	2b00      	cmp	r3, #0
 8006d6c:	d101      	bne.n	8006d72 <wolfSSL_CTX_new_ex+0x46>
        return ctx;
 8006d6e:	69fb      	ldr	r3, [r7, #28]
 8006d70:	e01e      	b.n	8006db0 <wolfSSL_CTX_new_ex+0x84>

    ctx = (WOLFSSL_CTX*) XMALLOC(sizeof(WOLFSSL_CTX), heap, DYNAMIC_TYPE_CTX);
 8006d72:	20a0      	movs	r0, #160	; 0xa0
 8006d74:	f008 f8c0 	bl	800eef8 <wolfSSL_Malloc>
 8006d78:	61f8      	str	r0, [r7, #28]
    if (ctx) {
 8006d7a:	69fb      	ldr	r3, [r7, #28]
 8006d7c:	2b00      	cmp	r3, #0
 8006d7e:	d00e      	beq.n	8006d9e <wolfSSL_CTX_new_ex+0x72>
        int ret;

        ret = InitSSL_Ctx(ctx, method, heap);
 8006d80:	683a      	ldr	r2, [r7, #0]
 8006d82:	6879      	ldr	r1, [r7, #4]
 8006d84:	69f8      	ldr	r0, [r7, #28]
 8006d86:	f7ff faf6 	bl	8006376 <InitSSL_Ctx>
 8006d8a:	60f8      	str	r0, [r7, #12]
    #ifdef WOLFSSL_STATIC_MEMORY
        if (heap != NULL) {
            ctx->onHeap = 1; /* free the memory back to heap when done */
        }
    #endif
        if (ret < 0) {
 8006d8c:	68fb      	ldr	r3, [r7, #12]
 8006d8e:	2b00      	cmp	r3, #0
 8006d90:	da0d      	bge.n	8006dae <wolfSSL_CTX_new_ex+0x82>
            WOLFSSL_MSG("Init CTX failed");
            wolfSSL_CTX_free(ctx);
 8006d92:	69f8      	ldr	r0, [r7, #28]
 8006d94:	f000 f81f 	bl	8006dd6 <wolfSSL_CTX_free>
            ctx = NULL;
 8006d98:	2300      	movs	r3, #0
 8006d9a:	61fb      	str	r3, [r7, #28]
 8006d9c:	e007      	b.n	8006dae <wolfSSL_CTX_new_ex+0x82>
        }
#endif
    }
    else {
        WOLFSSL_MSG("Alloc CTX failed, method freed");
        XFREE(method, heap, DYNAMIC_TYPE_METHOD);
 8006d9e:	687b      	ldr	r3, [r7, #4]
 8006da0:	613b      	str	r3, [r7, #16]
 8006da2:	693b      	ldr	r3, [r7, #16]
 8006da4:	2b00      	cmp	r3, #0
 8006da6:	d002      	beq.n	8006dae <wolfSSL_CTX_new_ex+0x82>
 8006da8:	6938      	ldr	r0, [r7, #16]
 8006daa:	f008 f8c1 	bl	800ef30 <wolfSSL_Free>
    }


    WOLFSSL_LEAVE("WOLFSSL_CTX_new", 0);
    return ctx;
 8006dae:	69fb      	ldr	r3, [r7, #28]
}
 8006db0:	4618      	mov	r0, r3
 8006db2:	3720      	adds	r7, #32
 8006db4:	46bd      	mov	sp, r7
 8006db6:	bd80      	pop	{r7, pc}
 8006db8:	20000224 	.word	0x20000224

08006dbc <wolfSSL_CTX_new>:


WOLFSSL_ABI
WOLFSSL_CTX* wolfSSL_CTX_new(WOLFSSL_METHOD* method)
{
 8006dbc:	b580      	push	{r7, lr}
 8006dbe:	b082      	sub	sp, #8
 8006dc0:	af00      	add	r7, sp, #0
 8006dc2:	6078      	str	r0, [r7, #4]
#ifdef WOLFSSL_HEAP_TEST
    /* if testing the heap hint then set top level CTX to have test value */
    return wolfSSL_CTX_new_ex(method, (void*)WOLFSSL_HEAP_TEST);
#else
    return wolfSSL_CTX_new_ex(method, NULL);
 8006dc4:	2100      	movs	r1, #0
 8006dc6:	6878      	ldr	r0, [r7, #4]
 8006dc8:	f7ff ffb0 	bl	8006d2c <wolfSSL_CTX_new_ex>
 8006dcc:	4603      	mov	r3, r0
#endif
}
 8006dce:	4618      	mov	r0, r3
 8006dd0:	3708      	adds	r7, #8
 8006dd2:	46bd      	mov	sp, r7
 8006dd4:	bd80      	pop	{r7, pc}

08006dd6 <wolfSSL_CTX_free>:
}
#endif

WOLFSSL_ABI
void wolfSSL_CTX_free(WOLFSSL_CTX* ctx)
{
 8006dd6:	b580      	push	{r7, lr}
 8006dd8:	b082      	sub	sp, #8
 8006dda:	af00      	add	r7, sp, #0
 8006ddc:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("SSL_CTX_free");
    if (ctx) {
 8006dde:	687b      	ldr	r3, [r7, #4]
 8006de0:	2b00      	cmp	r3, #0
 8006de2:	d002      	beq.n	8006dea <wolfSSL_CTX_free+0x14>
            wc_SrpTerm(ctx->srp);
            XFREE(ctx->srp, ctx->heap, DYNAMIC_TYPE_SRP);
            ctx->srp = NULL;
        }
#endif
        FreeSSL_Ctx(ctx);
 8006de4:	6878      	ldr	r0, [r7, #4]
 8006de6:	f7ff fbc7 	bl	8006578 <FreeSSL_Ctx>
    }

    WOLFSSL_LEAVE("SSL_CTX_free", 0);
}
 8006dea:	bf00      	nop
 8006dec:	3708      	adds	r7, #8
 8006dee:	46bd      	mov	sp, r7
 8006df0:	bd80      	pop	{r7, pc}

08006df2 <wolfSSL_CTX_GetDevId>:
}

/* helpers to get device id and heap */
WOLFSSL_ABI
int wolfSSL_CTX_GetDevId(WOLFSSL_CTX* ctx, WOLFSSL* ssl)
{
 8006df2:	b480      	push	{r7}
 8006df4:	b085      	sub	sp, #20
 8006df6:	af00      	add	r7, sp, #0
 8006df8:	6078      	str	r0, [r7, #4]
 8006dfa:	6039      	str	r1, [r7, #0]
    int devId = INVALID_DEVID;
 8006dfc:	f06f 0301 	mvn.w	r3, #1
 8006e00:	60fb      	str	r3, [r7, #12]
    if (ctx != NULL)
 8006e02:	687b      	ldr	r3, [r7, #4]
 8006e04:	2b00      	cmp	r3, #0
 8006e06:	d004      	beq.n	8006e12 <wolfSSL_CTX_GetDevId+0x20>
        devId = ctx->devId;
 8006e08:	687b      	ldr	r3, [r7, #4]
 8006e0a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8006e0e:	60fb      	str	r3, [r7, #12]
 8006e10:	e006      	b.n	8006e20 <wolfSSL_CTX_GetDevId+0x2e>
    else if (ssl != NULL)
 8006e12:	683b      	ldr	r3, [r7, #0]
 8006e14:	2b00      	cmp	r3, #0
 8006e16:	d003      	beq.n	8006e20 <wolfSSL_CTX_GetDevId+0x2e>
        devId = ssl->devId;
 8006e18:	683b      	ldr	r3, [r7, #0]
 8006e1a:	f8d3 33a8 	ldr.w	r3, [r3, #936]	; 0x3a8
 8006e1e:	60fb      	str	r3, [r7, #12]
    return devId;
 8006e20:	68fb      	ldr	r3, [r7, #12]
}
 8006e22:	4618      	mov	r0, r3
 8006e24:	3714      	adds	r7, #20
 8006e26:	46bd      	mov	sp, r7
 8006e28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e2c:	4770      	bx	lr

08006e2e <wolfSSL_CTX_GetHeap>:
void* wolfSSL_CTX_GetHeap(WOLFSSL_CTX* ctx, WOLFSSL* ssl)
{
 8006e2e:	b480      	push	{r7}
 8006e30:	b085      	sub	sp, #20
 8006e32:	af00      	add	r7, sp, #0
 8006e34:	6078      	str	r0, [r7, #4]
 8006e36:	6039      	str	r1, [r7, #0]
    void* heap = NULL;
 8006e38:	2300      	movs	r3, #0
 8006e3a:	60fb      	str	r3, [r7, #12]
    if (ctx != NULL)
 8006e3c:	687b      	ldr	r3, [r7, #4]
 8006e3e:	2b00      	cmp	r3, #0
 8006e40:	d003      	beq.n	8006e4a <wolfSSL_CTX_GetHeap+0x1c>
        heap = ctx->heap;
 8006e42:	687b      	ldr	r3, [r7, #4]
 8006e44:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8006e46:	60fb      	str	r3, [r7, #12]
 8006e48:	e006      	b.n	8006e58 <wolfSSL_CTX_GetHeap+0x2a>
    else if (ssl != NULL)
 8006e4a:	683b      	ldr	r3, [r7, #0]
 8006e4c:	2b00      	cmp	r3, #0
 8006e4e:	d003      	beq.n	8006e58 <wolfSSL_CTX_GetHeap+0x2a>
        heap = ssl->heap;
 8006e50:	683b      	ldr	r3, [r7, #0]
 8006e52:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8006e56:	60fb      	str	r3, [r7, #12]
    return heap;
 8006e58:	68fb      	ldr	r3, [r7, #12]
}
 8006e5a:	4618      	mov	r0, r3
 8006e5c:	3714      	adds	r7, #20
 8006e5e:	46bd      	mov	sp, r7
 8006e60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e64:	4770      	bx	lr

08006e66 <wolfSSL_CertManagerNew_ex>:
        cm = ctx->cm;
    return cm;
}

WOLFSSL_CERT_MANAGER* wolfSSL_CertManagerNew_ex(void* heap)
{
 8006e66:	b580      	push	{r7, lr}
 8006e68:	b084      	sub	sp, #16
 8006e6a:	af00      	add	r7, sp, #0
 8006e6c:	6078      	str	r0, [r7, #4]
    WOLFSSL_CERT_MANAGER* cm;

    WOLFSSL_ENTER("wolfSSL_CertManagerNew");

    cm = (WOLFSSL_CERT_MANAGER*) XMALLOC(sizeof(WOLFSSL_CERT_MANAGER), heap,
 8006e6e:	2068      	movs	r0, #104	; 0x68
 8006e70:	f008 f842 	bl	800eef8 <wolfSSL_Malloc>
 8006e74:	60f8      	str	r0, [r7, #12]
                                         DYNAMIC_TYPE_CERT_MANAGER);
    if (cm) {
 8006e76:	68fb      	ldr	r3, [r7, #12]
 8006e78:	2b00      	cmp	r3, #0
 8006e7a:	d02c      	beq.n	8006ed6 <wolfSSL_CertManagerNew_ex+0x70>
        XMEMSET(cm, 0, sizeof(WOLFSSL_CERT_MANAGER));
 8006e7c:	2268      	movs	r2, #104	; 0x68
 8006e7e:	2100      	movs	r1, #0
 8006e80:	68f8      	ldr	r0, [r7, #12]
 8006e82:	f012 fadc 	bl	801943e <memset>
        cm->refCount = 1;
 8006e86:	68fb      	ldr	r3, [r7, #12]
 8006e88:	2201      	movs	r2, #1
 8006e8a:	665a      	str	r2, [r3, #100]	; 0x64

        if (wc_InitMutex(&cm->caLock) != 0) {
 8006e8c:	68fb      	ldr	r3, [r7, #12]
 8006e8e:	3354      	adds	r3, #84	; 0x54
 8006e90:	4618      	mov	r0, r3
 8006e92:	f012 f9e9 	bl	8019268 <wc_InitMutex>
 8006e96:	4603      	mov	r3, r0
 8006e98:	2b00      	cmp	r3, #0
 8006e9a:	d004      	beq.n	8006ea6 <wolfSSL_CertManagerNew_ex+0x40>
            WOLFSSL_MSG("Bad mutex init");
            wolfSSL_CertManagerFree(cm);
 8006e9c:	68f8      	ldr	r0, [r7, #12]
 8006e9e:	f000 f81f 	bl	8006ee0 <wolfSSL_CertManagerFree>
            return NULL;
 8006ea2:	2300      	movs	r3, #0
 8006ea4:	e018      	b.n	8006ed8 <wolfSSL_CertManagerNew_ex+0x72>
        }
        if (wc_InitMutex(&cm->refMutex) != 0) {
 8006ea6:	68fb      	ldr	r3, [r7, #12]
 8006ea8:	3360      	adds	r3, #96	; 0x60
 8006eaa:	4618      	mov	r0, r3
 8006eac:	f012 f9dc 	bl	8019268 <wc_InitMutex>
 8006eb0:	4603      	mov	r3, r0
 8006eb2:	2b00      	cmp	r3, #0
 8006eb4:	d004      	beq.n	8006ec0 <wolfSSL_CertManagerNew_ex+0x5a>
            WOLFSSL_MSG("Bad mutex init");
            wolfSSL_CertManagerFree(cm);
 8006eb6:	68f8      	ldr	r0, [r7, #12]
 8006eb8:	f000 f812 	bl	8006ee0 <wolfSSL_CertManagerFree>
            return NULL;
 8006ebc:	2300      	movs	r3, #0
 8006ebe:	e00b      	b.n	8006ed8 <wolfSSL_CertManagerNew_ex+0x72>
        }
        #endif

        /* set default minimum key size allowed */
        #ifndef NO_RSA
            cm->minRsaKeySz = MIN_RSAKEY_SZ;
 8006ec0:	68fb      	ldr	r3, [r7, #12]
 8006ec2:	2280      	movs	r2, #128	; 0x80
 8006ec4:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
        #endif
        #ifdef HAVE_ECC
            cm->minEccKeySz = MIN_ECCKEY_SZ;
 8006ec8:	68fb      	ldr	r3, [r7, #12]
 8006eca:	221c      	movs	r2, #28
 8006ecc:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
        #endif
            cm->heap = heap;
 8006ed0:	68fb      	ldr	r3, [r7, #12]
 8006ed2:	687a      	ldr	r2, [r7, #4]
 8006ed4:	62da      	str	r2, [r3, #44]	; 0x2c
    }

    return cm;
 8006ed6:	68fb      	ldr	r3, [r7, #12]
}
 8006ed8:	4618      	mov	r0, r3
 8006eda:	3710      	adds	r7, #16
 8006edc:	46bd      	mov	sp, r7
 8006ede:	bd80      	pop	{r7, pc}

08006ee0 <wolfSSL_CertManagerFree>:
    return wolfSSL_CertManagerNew_ex(NULL);
}


void wolfSSL_CertManagerFree(WOLFSSL_CERT_MANAGER* cm)
{
 8006ee0:	b580      	push	{r7, lr}
 8006ee2:	b084      	sub	sp, #16
 8006ee4:	af00      	add	r7, sp, #0
 8006ee6:	6078      	str	r0, [r7, #4]
    int doFree = 0;
 8006ee8:	2300      	movs	r3, #0
 8006eea:	60fb      	str	r3, [r7, #12]
    WOLFSSL_ENTER("wolfSSL_CertManagerFree");

    if (cm) {
 8006eec:	687b      	ldr	r3, [r7, #4]
 8006eee:	2b00      	cmp	r3, #0
 8006ef0:	d02b      	beq.n	8006f4a <wolfSSL_CertManagerFree+0x6a>
        if (wc_LockMutex(&cm->refMutex) != 0) {
 8006ef2:	687b      	ldr	r3, [r7, #4]
 8006ef4:	3360      	adds	r3, #96	; 0x60
 8006ef6:	4618      	mov	r0, r3
 8006ef8:	f012 f9cc 	bl	8019294 <wc_LockMutex>
            WOLFSSL_MSG("Couldn't lock cm mutex");
        }
        cm->refCount--;
 8006efc:	687b      	ldr	r3, [r7, #4]
 8006efe:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8006f00:	1e5a      	subs	r2, r3, #1
 8006f02:	687b      	ldr	r3, [r7, #4]
 8006f04:	665a      	str	r2, [r3, #100]	; 0x64
        if (cm->refCount == 0)
 8006f06:	687b      	ldr	r3, [r7, #4]
 8006f08:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8006f0a:	2b00      	cmp	r3, #0
 8006f0c:	d101      	bne.n	8006f12 <wolfSSL_CertManagerFree+0x32>
            doFree = 1;
 8006f0e:	2301      	movs	r3, #1
 8006f10:	60fb      	str	r3, [r7, #12]
        wc_UnLockMutex(&cm->refMutex);
 8006f12:	687b      	ldr	r3, [r7, #4]
 8006f14:	3360      	adds	r3, #96	; 0x60
 8006f16:	4618      	mov	r0, r3
 8006f18:	f012 f9c7 	bl	80192aa <wc_UnLockMutex>
        if (doFree) {
 8006f1c:	68fb      	ldr	r3, [r7, #12]
 8006f1e:	2b00      	cmp	r3, #0
 8006f20:	d013      	beq.n	8006f4a <wolfSSL_CertManagerFree+0x6a>
                 defined(HAVE_CERTIFICATE_STATUS_REQUEST_V2))
                if (cm->ocsp_stapling)
                    FreeOCSP(cm->ocsp_stapling, 1);
            #endif
            #endif
            FreeSignerTable(cm->caTable, CA_TABLE_SIZE, cm->heap);
 8006f22:	6878      	ldr	r0, [r7, #4]
 8006f24:	687b      	ldr	r3, [r7, #4]
 8006f26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006f28:	461a      	mov	r2, r3
 8006f2a:	210b      	movs	r1, #11
 8006f2c:	f006 f841 	bl	800cfb2 <FreeSignerTable>
            wc_FreeMutex(&cm->caLock);
 8006f30:	687b      	ldr	r3, [r7, #4]
 8006f32:	3354      	adds	r3, #84	; 0x54
 8006f34:	4618      	mov	r0, r3
 8006f36:	f012 f9a2 	bl	801927e <wc_FreeMutex>
            #ifdef WOLFSSL_TRUST_PEER_CERT
            FreeTrustedPeerTable(cm->tpTable, TP_TABLE_SIZE, cm->heap);
            wc_FreeMutex(&cm->tpLock);
            #endif

            XFREE(cm, cm->heap, DYNAMIC_TYPE_CERT_MANAGER);
 8006f3a:	687b      	ldr	r3, [r7, #4]
 8006f3c:	60bb      	str	r3, [r7, #8]
 8006f3e:	68bb      	ldr	r3, [r7, #8]
 8006f40:	2b00      	cmp	r3, #0
 8006f42:	d002      	beq.n	8006f4a <wolfSSL_CertManagerFree+0x6a>
 8006f44:	68b8      	ldr	r0, [r7, #8]
 8006f46:	f007 fff3 	bl	800ef30 <wolfSSL_Free>
        }
    }

}
 8006f4a:	bf00      	nop
 8006f4c:	3710      	adds	r7, #16
 8006f4e:	46bd      	mov	sp, r7
 8006f50:	bd80      	pop	{r7, pc}

08006f52 <MakeWordFromHash>:

#if !defined(NO_CERTS) || !defined(NO_SESSION_CACHE)

/* Make a work from the front of random hash */
static WC_INLINE word32 MakeWordFromHash(const byte* hashID)
{
 8006f52:	b480      	push	{r7}
 8006f54:	b083      	sub	sp, #12
 8006f56:	af00      	add	r7, sp, #0
 8006f58:	6078      	str	r0, [r7, #4]
    return ((word32)hashID[0] << 24) | ((word32)hashID[1] << 16) |
 8006f5a:	687b      	ldr	r3, [r7, #4]
 8006f5c:	781b      	ldrb	r3, [r3, #0]
 8006f5e:	061a      	lsls	r2, r3, #24
 8006f60:	687b      	ldr	r3, [r7, #4]
 8006f62:	3301      	adds	r3, #1
 8006f64:	781b      	ldrb	r3, [r3, #0]
 8006f66:	041b      	lsls	r3, r3, #16
 8006f68:	431a      	orrs	r2, r3
           ((word32)hashID[2] <<  8) |  (word32)hashID[3];
 8006f6a:	687b      	ldr	r3, [r7, #4]
 8006f6c:	3302      	adds	r3, #2
 8006f6e:	781b      	ldrb	r3, [r3, #0]
 8006f70:	021b      	lsls	r3, r3, #8
    return ((word32)hashID[0] << 24) | ((word32)hashID[1] << 16) |
 8006f72:	4313      	orrs	r3, r2
           ((word32)hashID[2] <<  8) |  (word32)hashID[3];
 8006f74:	687a      	ldr	r2, [r7, #4]
 8006f76:	3203      	adds	r2, #3
 8006f78:	7812      	ldrb	r2, [r2, #0]
 8006f7a:	4313      	orrs	r3, r2
}
 8006f7c:	4618      	mov	r0, r3
 8006f7e:	370c      	adds	r7, #12
 8006f80:	46bd      	mov	sp, r7
 8006f82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006f86:	4770      	bx	lr

08006f88 <HashSigner>:

#ifndef NO_CERTS

/* hash is the SHA digest of name, just use first 32 bits as hash */
static WC_INLINE word32 HashSigner(const byte* hash)
{
 8006f88:	b580      	push	{r7, lr}
 8006f8a:	b082      	sub	sp, #8
 8006f8c:	af00      	add	r7, sp, #0
 8006f8e:	6078      	str	r0, [r7, #4]
    return MakeWordFromHash(hash) % CA_TABLE_SIZE;
 8006f90:	6878      	ldr	r0, [r7, #4]
 8006f92:	f7ff ffde 	bl	8006f52 <MakeWordFromHash>
 8006f96:	4601      	mov	r1, r0
 8006f98:	4b07      	ldr	r3, [pc, #28]	; (8006fb8 <HashSigner+0x30>)
 8006f9a:	fba3 2301 	umull	r2, r3, r3, r1
 8006f9e:	08da      	lsrs	r2, r3, #3
 8006fa0:	4613      	mov	r3, r2
 8006fa2:	009b      	lsls	r3, r3, #2
 8006fa4:	4413      	add	r3, r2
 8006fa6:	005b      	lsls	r3, r3, #1
 8006fa8:	4413      	add	r3, r2
 8006faa:	1aca      	subs	r2, r1, r3
 8006fac:	4613      	mov	r3, r2
}
 8006fae:	4618      	mov	r0, r3
 8006fb0:	3708      	adds	r7, #8
 8006fb2:	46bd      	mov	sp, r7
 8006fb4:	bd80      	pop	{r7, pc}
 8006fb6:	bf00      	nop
 8006fb8:	ba2e8ba3 	.word	0xba2e8ba3

08006fbc <AlreadySigner>:


/* does CA already exist on signer list */
int AlreadySigner(WOLFSSL_CERT_MANAGER* cm, byte* hash)
{
 8006fbc:	b580      	push	{r7, lr}
 8006fbe:	b086      	sub	sp, #24
 8006fc0:	af00      	add	r7, sp, #0
 8006fc2:	6078      	str	r0, [r7, #4]
 8006fc4:	6039      	str	r1, [r7, #0]
    Signer* signers;
    int     ret = 0;
 8006fc6:	2300      	movs	r3, #0
 8006fc8:	613b      	str	r3, [r7, #16]
    word32  row;

    if (cm == NULL || hash == NULL) {
 8006fca:	687b      	ldr	r3, [r7, #4]
 8006fcc:	2b00      	cmp	r3, #0
 8006fce:	d002      	beq.n	8006fd6 <AlreadySigner+0x1a>
 8006fd0:	683b      	ldr	r3, [r7, #0]
 8006fd2:	2b00      	cmp	r3, #0
 8006fd4:	d101      	bne.n	8006fda <AlreadySigner+0x1e>
        return ret;
 8006fd6:	693b      	ldr	r3, [r7, #16]
 8006fd8:	e02d      	b.n	8007036 <AlreadySigner+0x7a>
    }

    row = HashSigner(hash);
 8006fda:	6838      	ldr	r0, [r7, #0]
 8006fdc:	f7ff ffd4 	bl	8006f88 <HashSigner>
 8006fe0:	60f8      	str	r0, [r7, #12]

    if (wc_LockMutex(&cm->caLock) != 0) {
 8006fe2:	687b      	ldr	r3, [r7, #4]
 8006fe4:	3354      	adds	r3, #84	; 0x54
 8006fe6:	4618      	mov	r0, r3
 8006fe8:	f012 f954 	bl	8019294 <wc_LockMutex>
 8006fec:	4603      	mov	r3, r0
 8006fee:	2b00      	cmp	r3, #0
 8006ff0:	d001      	beq.n	8006ff6 <AlreadySigner+0x3a>
        return ret;
 8006ff2:	693b      	ldr	r3, [r7, #16]
 8006ff4:	e01f      	b.n	8007036 <AlreadySigner+0x7a>
    }
    signers = cm->caTable[row];
 8006ff6:	687b      	ldr	r3, [r7, #4]
 8006ff8:	68fa      	ldr	r2, [r7, #12]
 8006ffa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006ffe:	617b      	str	r3, [r7, #20]
    while (signers) {
 8007000:	e010      	b.n	8007024 <AlreadySigner+0x68>
        byte* subjectHash;

    #ifndef NO_SKID
        subjectHash = signers->subjectKeyIdHash;
 8007002:	697b      	ldr	r3, [r7, #20]
 8007004:	3344      	adds	r3, #68	; 0x44
 8007006:	60bb      	str	r3, [r7, #8]
    #else
        subjectHash = signers->subjectNameHash;
    #endif

        if (XMEMCMP(hash, subjectHash, SIGNER_DIGEST_SIZE) == 0) {
 8007008:	2220      	movs	r2, #32
 800700a:	68b9      	ldr	r1, [r7, #8]
 800700c:	6838      	ldr	r0, [r7, #0]
 800700e:	f012 f9e3 	bl	80193d8 <memcmp>
 8007012:	4603      	mov	r3, r0
 8007014:	2b00      	cmp	r3, #0
 8007016:	d102      	bne.n	800701e <AlreadySigner+0x62>
            ret = 1; /* success */
 8007018:	2301      	movs	r3, #1
 800701a:	613b      	str	r3, [r7, #16]
            break;
 800701c:	e005      	b.n	800702a <AlreadySigner+0x6e>
        }
        signers = signers->next;
 800701e:	697b      	ldr	r3, [r7, #20]
 8007020:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8007022:	617b      	str	r3, [r7, #20]
    while (signers) {
 8007024:	697b      	ldr	r3, [r7, #20]
 8007026:	2b00      	cmp	r3, #0
 8007028:	d1eb      	bne.n	8007002 <AlreadySigner+0x46>
    }
    wc_UnLockMutex(&cm->caLock);
 800702a:	687b      	ldr	r3, [r7, #4]
 800702c:	3354      	adds	r3, #84	; 0x54
 800702e:	4618      	mov	r0, r3
 8007030:	f012 f93b 	bl	80192aa <wc_UnLockMutex>

    return ret;
 8007034:	693b      	ldr	r3, [r7, #16]
}
 8007036:	4618      	mov	r0, r3
 8007038:	3718      	adds	r7, #24
 800703a:	46bd      	mov	sp, r7
 800703c:	bd80      	pop	{r7, pc}

0800703e <GetCA>:
#endif /* WOLFSSL_TRUST_PEER_CERT */


/* return CA if found, otherwise NULL */
Signer* GetCA(void* vp, byte* hash)
{
 800703e:	b580      	push	{r7, lr}
 8007040:	b088      	sub	sp, #32
 8007042:	af00      	add	r7, sp, #0
 8007044:	6078      	str	r0, [r7, #4]
 8007046:	6039      	str	r1, [r7, #0]
    WOLFSSL_CERT_MANAGER* cm = (WOLFSSL_CERT_MANAGER*)vp;
 8007048:	687b      	ldr	r3, [r7, #4]
 800704a:	617b      	str	r3, [r7, #20]
    Signer* ret = NULL;
 800704c:	2300      	movs	r3, #0
 800704e:	61fb      	str	r3, [r7, #28]
    Signer* signers;
    word32  row = 0;
 8007050:	2300      	movs	r3, #0
 8007052:	613b      	str	r3, [r7, #16]

    if (cm == NULL || hash == NULL)
 8007054:	697b      	ldr	r3, [r7, #20]
 8007056:	2b00      	cmp	r3, #0
 8007058:	d002      	beq.n	8007060 <GetCA+0x22>
 800705a:	683b      	ldr	r3, [r7, #0]
 800705c:	2b00      	cmp	r3, #0
 800705e:	d101      	bne.n	8007064 <GetCA+0x26>
        return NULL;
 8007060:	2300      	movs	r3, #0
 8007062:	e02d      	b.n	80070c0 <GetCA+0x82>

    row = HashSigner(hash);
 8007064:	6838      	ldr	r0, [r7, #0]
 8007066:	f7ff ff8f 	bl	8006f88 <HashSigner>
 800706a:	6138      	str	r0, [r7, #16]

    if (wc_LockMutex(&cm->caLock) != 0)
 800706c:	697b      	ldr	r3, [r7, #20]
 800706e:	3354      	adds	r3, #84	; 0x54
 8007070:	4618      	mov	r0, r3
 8007072:	f012 f90f 	bl	8019294 <wc_LockMutex>
 8007076:	4603      	mov	r3, r0
 8007078:	2b00      	cmp	r3, #0
 800707a:	d001      	beq.n	8007080 <GetCA+0x42>
        return ret;
 800707c:	69fb      	ldr	r3, [r7, #28]
 800707e:	e01f      	b.n	80070c0 <GetCA+0x82>

    signers = cm->caTable[row];
 8007080:	697b      	ldr	r3, [r7, #20]
 8007082:	693a      	ldr	r2, [r7, #16]
 8007084:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007088:	61bb      	str	r3, [r7, #24]
    while (signers) {
 800708a:	e010      	b.n	80070ae <GetCA+0x70>
        byte* subjectHash;
        #ifndef NO_SKID
            subjectHash = signers->subjectKeyIdHash;
 800708c:	69bb      	ldr	r3, [r7, #24]
 800708e:	3344      	adds	r3, #68	; 0x44
 8007090:	60fb      	str	r3, [r7, #12]
        #else
            subjectHash = signers->subjectNameHash;
        #endif
        if (XMEMCMP(hash, subjectHash, SIGNER_DIGEST_SIZE) == 0) {
 8007092:	2220      	movs	r2, #32
 8007094:	68f9      	ldr	r1, [r7, #12]
 8007096:	6838      	ldr	r0, [r7, #0]
 8007098:	f012 f99e 	bl	80193d8 <memcmp>
 800709c:	4603      	mov	r3, r0
 800709e:	2b00      	cmp	r3, #0
 80070a0:	d102      	bne.n	80070a8 <GetCA+0x6a>
            ret = signers;
 80070a2:	69bb      	ldr	r3, [r7, #24]
 80070a4:	61fb      	str	r3, [r7, #28]
            break;
 80070a6:	e005      	b.n	80070b4 <GetCA+0x76>
        }
        signers = signers->next;
 80070a8:	69bb      	ldr	r3, [r7, #24]
 80070aa:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80070ac:	61bb      	str	r3, [r7, #24]
    while (signers) {
 80070ae:	69bb      	ldr	r3, [r7, #24]
 80070b0:	2b00      	cmp	r3, #0
 80070b2:	d1eb      	bne.n	800708c <GetCA+0x4e>
    }
    wc_UnLockMutex(&cm->caLock);
 80070b4:	697b      	ldr	r3, [r7, #20]
 80070b6:	3354      	adds	r3, #84	; 0x54
 80070b8:	4618      	mov	r0, r3
 80070ba:	f012 f8f6 	bl	80192aa <wc_UnLockMutex>

    return ret;
 80070be:	69fb      	ldr	r3, [r7, #28]
}
 80070c0:	4618      	mov	r0, r3
 80070c2:	3720      	adds	r7, #32
 80070c4:	46bd      	mov	sp, r7
 80070c6:	bd80      	pop	{r7, pc}

080070c8 <GetCAByName>:


#ifndef NO_SKID
/* return CA if found, otherwise NULL. Walk through hash table. */
Signer* GetCAByName(void* vp, byte* hash)
{
 80070c8:	b580      	push	{r7, lr}
 80070ca:	b086      	sub	sp, #24
 80070cc:	af00      	add	r7, sp, #0
 80070ce:	6078      	str	r0, [r7, #4]
 80070d0:	6039      	str	r1, [r7, #0]
    WOLFSSL_CERT_MANAGER* cm = (WOLFSSL_CERT_MANAGER*)vp;
 80070d2:	687b      	ldr	r3, [r7, #4]
 80070d4:	60bb      	str	r3, [r7, #8]
    Signer* ret = NULL;
 80070d6:	2300      	movs	r3, #0
 80070d8:	617b      	str	r3, [r7, #20]
    Signer* signers;
    word32  row;

    if (cm == NULL)
 80070da:	68bb      	ldr	r3, [r7, #8]
 80070dc:	2b00      	cmp	r3, #0
 80070de:	d101      	bne.n	80070e4 <GetCAByName+0x1c>
        return NULL;
 80070e0:	2300      	movs	r3, #0
 80070e2:	e036      	b.n	8007152 <GetCAByName+0x8a>

    if (wc_LockMutex(&cm->caLock) != 0)
 80070e4:	68bb      	ldr	r3, [r7, #8]
 80070e6:	3354      	adds	r3, #84	; 0x54
 80070e8:	4618      	mov	r0, r3
 80070ea:	f012 f8d3 	bl	8019294 <wc_LockMutex>
 80070ee:	4603      	mov	r3, r0
 80070f0:	2b00      	cmp	r3, #0
 80070f2:	d001      	beq.n	80070f8 <GetCAByName+0x30>
        return ret;
 80070f4:	697b      	ldr	r3, [r7, #20]
 80070f6:	e02c      	b.n	8007152 <GetCAByName+0x8a>

    for (row = 0; row < CA_TABLE_SIZE && ret == NULL; row++) {
 80070f8:	2300      	movs	r3, #0
 80070fa:	60fb      	str	r3, [r7, #12]
 80070fc:	e01d      	b.n	800713a <GetCAByName+0x72>
        signers = cm->caTable[row];
 80070fe:	68bb      	ldr	r3, [r7, #8]
 8007100:	68fa      	ldr	r2, [r7, #12]
 8007102:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007106:	613b      	str	r3, [r7, #16]
        while (signers && ret == NULL) {
 8007108:	e00e      	b.n	8007128 <GetCAByName+0x60>
            if (XMEMCMP(hash, signers->subjectNameHash,
 800710a:	693b      	ldr	r3, [r7, #16]
 800710c:	3324      	adds	r3, #36	; 0x24
 800710e:	2220      	movs	r2, #32
 8007110:	4619      	mov	r1, r3
 8007112:	6838      	ldr	r0, [r7, #0]
 8007114:	f012 f960 	bl	80193d8 <memcmp>
 8007118:	4603      	mov	r3, r0
 800711a:	2b00      	cmp	r3, #0
 800711c:	d101      	bne.n	8007122 <GetCAByName+0x5a>
                        SIGNER_DIGEST_SIZE) == 0) {
                ret = signers;
 800711e:	693b      	ldr	r3, [r7, #16]
 8007120:	617b      	str	r3, [r7, #20]
            }
            signers = signers->next;
 8007122:	693b      	ldr	r3, [r7, #16]
 8007124:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8007126:	613b      	str	r3, [r7, #16]
        while (signers && ret == NULL) {
 8007128:	693b      	ldr	r3, [r7, #16]
 800712a:	2b00      	cmp	r3, #0
 800712c:	d002      	beq.n	8007134 <GetCAByName+0x6c>
 800712e:	697b      	ldr	r3, [r7, #20]
 8007130:	2b00      	cmp	r3, #0
 8007132:	d0ea      	beq.n	800710a <GetCAByName+0x42>
    for (row = 0; row < CA_TABLE_SIZE && ret == NULL; row++) {
 8007134:	68fb      	ldr	r3, [r7, #12]
 8007136:	3301      	adds	r3, #1
 8007138:	60fb      	str	r3, [r7, #12]
 800713a:	68fb      	ldr	r3, [r7, #12]
 800713c:	2b0a      	cmp	r3, #10
 800713e:	d802      	bhi.n	8007146 <GetCAByName+0x7e>
 8007140:	697b      	ldr	r3, [r7, #20]
 8007142:	2b00      	cmp	r3, #0
 8007144:	d0db      	beq.n	80070fe <GetCAByName+0x36>
        }
    }
    wc_UnLockMutex(&cm->caLock);
 8007146:	68bb      	ldr	r3, [r7, #8]
 8007148:	3354      	adds	r3, #84	; 0x54
 800714a:	4618      	mov	r0, r3
 800714c:	f012 f8ad 	bl	80192aa <wc_UnLockMutex>

    return ret;
 8007150:	697b      	ldr	r3, [r7, #20]
}
 8007152:	4618      	mov	r0, r3
 8007154:	3718      	adds	r7, #24
 8007156:	46bd      	mov	sp, r7
 8007158:	bd80      	pop	{r7, pc}
	...

0800715c <AddCA>:

/* owns der, internal now uses too */
/* type flag ids from user or from chain received during verify
   don't allow chain ones to be added w/o isCA extension */
int AddCA(WOLFSSL_CERT_MANAGER* cm, DerBuffer** pDer, int type, int verify)
{
 800715c:	b580      	push	{r7, lr}
 800715e:	b08c      	sub	sp, #48	; 0x30
 8007160:	af00      	add	r7, sp, #0
 8007162:	60f8      	str	r0, [r7, #12]
 8007164:	60b9      	str	r1, [r7, #8]
 8007166:	607a      	str	r2, [r7, #4]
 8007168:	603b      	str	r3, [r7, #0]
    int         ret;
    Signer*     signer = NULL;
 800716a:	2300      	movs	r3, #0
 800716c:	62bb      	str	r3, [r7, #40]	; 0x28
    word32      row;
    byte*       subjectHash;
#ifdef WOLFSSL_SMALL_STACK
    DecodedCert* cert = NULL;
 800716e:	2300      	movs	r3, #0
 8007170:	627b      	str	r3, [r7, #36]	; 0x24
#else
    DecodedCert  cert[1];
#endif
    DerBuffer*   der = *pDer;
 8007172:	68bb      	ldr	r3, [r7, #8]
 8007174:	681b      	ldr	r3, [r3, #0]
 8007176:	623b      	str	r3, [r7, #32]

    WOLFSSL_MSG("Adding a CA");

    if (cm == NULL) {
 8007178:	68fb      	ldr	r3, [r7, #12]
 800717a:	2b00      	cmp	r3, #0
 800717c:	d105      	bne.n	800718a <AddCA+0x2e>
        FreeDer(pDer);
 800717e:	68b8      	ldr	r0, [r7, #8]
 8007180:	f006 f802 	bl	800d188 <FreeDer>
        return BAD_FUNC_ARG;
 8007184:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8007188:	e16d      	b.n	8007466 <AddCA+0x30a>
    }

#ifdef WOLFSSL_SMALL_STACK
    cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), NULL,
 800718a:	f44f 705f 	mov.w	r0, #892	; 0x37c
 800718e:	f007 feb3 	bl	800eef8 <wolfSSL_Malloc>
 8007192:	6278      	str	r0, [r7, #36]	; 0x24
                                 DYNAMIC_TYPE_DCERT);
    if (cert == NULL) {
 8007194:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007196:	2b00      	cmp	r3, #0
 8007198:	d105      	bne.n	80071a6 <AddCA+0x4a>
        FreeDer(pDer);
 800719a:	68b8      	ldr	r0, [r7, #8]
 800719c:	f005 fff4 	bl	800d188 <FreeDer>
        return MEMORY_E;
 80071a0:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 80071a4:	e15f      	b.n	8007466 <AddCA+0x30a>
    }
#endif

    InitDecodedCert(cert, der->buffer, der->length, cm->heap);
 80071a6:	6a3b      	ldr	r3, [r7, #32]
 80071a8:	6819      	ldr	r1, [r3, #0]
 80071aa:	6a3b      	ldr	r3, [r7, #32]
 80071ac:	689a      	ldr	r2, [r3, #8]
 80071ae:	68fb      	ldr	r3, [r7, #12]
 80071b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80071b2:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80071b4:	f002 fda7 	bl	8009d06 <InitDecodedCert>
    ret = ParseCert(cert, CA_TYPE, verify, cm);
 80071b8:	68fb      	ldr	r3, [r7, #12]
 80071ba:	683a      	ldr	r2, [r7, #0]
 80071bc:	2105      	movs	r1, #5
 80071be:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80071c0:	f005 fbc8 	bl	800c954 <ParseCert>
 80071c4:	62f8      	str	r0, [r7, #44]	; 0x2c
    WOLFSSL_MSG("\tParsed new CA");

#ifndef NO_SKID
    subjectHash = cert->extSubjKeyId;
 80071c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80071c8:	f503 7337 	add.w	r3, r3, #732	; 0x2dc
 80071cc:	61fb      	str	r3, [r7, #28]
#else
    subjectHash = cert->subjectHash;
#endif

    /* check CA key size */
    if (verify) {
 80071ce:	683b      	ldr	r3, [r7, #0]
 80071d0:	2b00      	cmp	r3, #0
 80071d2:	d02b      	beq.n	800722c <AddCA+0xd0>
        switch (cert->keyOID) {
 80071d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80071d6:	69db      	ldr	r3, [r3, #28]
 80071d8:	f240 2206 	movw	r2, #518	; 0x206
 80071dc:	4293      	cmp	r3, r2
 80071de:	d015      	beq.n	800720c <AddCA+0xb0>
 80071e0:	f240 2285 	movw	r2, #645	; 0x285
 80071e4:	4293      	cmp	r3, r2
 80071e6:	d000      	beq.n	80071ea <AddCA+0x8e>
                break;
            #endif /* HAVE_ED448 */

            default:
                WOLFSSL_MSG("\tNo key size check done on CA");
                break; /* no size check if key type is not in switch */
 80071e8:	e025      	b.n	8007236 <AddCA+0xda>
                if (cm->minRsaKeySz < 0 ||
 80071ea:	68fb      	ldr	r3, [r7, #12]
 80071ec:	f9b3 305a 	ldrsh.w	r3, [r3, #90]	; 0x5a
 80071f0:	2b00      	cmp	r3, #0
 80071f2:	db07      	blt.n	8007204 <AddCA+0xa8>
                                   cert->pubKeySize < (word16)cm->minRsaKeySz) {
 80071f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80071f6:	685b      	ldr	r3, [r3, #4]
 80071f8:	68fa      	ldr	r2, [r7, #12]
 80071fa:	f9b2 205a 	ldrsh.w	r2, [r2, #90]	; 0x5a
 80071fe:	b292      	uxth	r2, r2
                if (cm->minRsaKeySz < 0 ||
 8007200:	4293      	cmp	r3, r2
 8007202:	d215      	bcs.n	8007230 <AddCA+0xd4>
                    ret = RSA_KEY_SIZE_E;
 8007204:	f46f 73cc 	mvn.w	r3, #408	; 0x198
 8007208:	62fb      	str	r3, [r7, #44]	; 0x2c
                break;
 800720a:	e011      	b.n	8007230 <AddCA+0xd4>
                if (cm->minEccKeySz < 0 ||
 800720c:	68fb      	ldr	r3, [r7, #12]
 800720e:	f9b3 305c 	ldrsh.w	r3, [r3, #92]	; 0x5c
 8007212:	2b00      	cmp	r3, #0
 8007214:	db07      	blt.n	8007226 <AddCA+0xca>
                                   cert->pubKeySize < (word16)cm->minEccKeySz) {
 8007216:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007218:	685b      	ldr	r3, [r3, #4]
 800721a:	68fa      	ldr	r2, [r7, #12]
 800721c:	f9b2 205c 	ldrsh.w	r2, [r2, #92]	; 0x5c
 8007220:	b292      	uxth	r2, r2
                if (cm->minEccKeySz < 0 ||
 8007222:	4293      	cmp	r3, r2
 8007224:	d206      	bcs.n	8007234 <AddCA+0xd8>
                    ret = ECC_KEY_SIZE_E;
 8007226:	4b92      	ldr	r3, [pc, #584]	; (8007470 <AddCA+0x314>)
 8007228:	62fb      	str	r3, [r7, #44]	; 0x2c
                break;
 800722a:	e003      	b.n	8007234 <AddCA+0xd8>
        }
    }
 800722c:	bf00      	nop
 800722e:	e002      	b.n	8007236 <AddCA+0xda>
                break;
 8007230:	bf00      	nop
 8007232:	e000      	b.n	8007236 <AddCA+0xda>
                break;
 8007234:	bf00      	nop

    if (ret == 0 && cert->isCA == 0 && type != WOLFSSL_USER_CA) {
 8007236:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007238:	2b00      	cmp	r3, #0
 800723a:	d10e      	bne.n	800725a <AddCA+0xfe>
 800723c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800723e:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 8007242:	f003 0310 	and.w	r3, r3, #16
 8007246:	b2db      	uxtb	r3, r3
 8007248:	2b00      	cmp	r3, #0
 800724a:	d106      	bne.n	800725a <AddCA+0xfe>
 800724c:	687b      	ldr	r3, [r7, #4]
 800724e:	2b01      	cmp	r3, #1
 8007250:	d003      	beq.n	800725a <AddCA+0xfe>
        WOLFSSL_MSG("\tCan't add as CA if not actually one");
        ret = NOT_CA_ERROR;
 8007252:	f46f 73b2 	mvn.w	r3, #356	; 0x164
 8007256:	62fb      	str	r3, [r7, #44]	; 0x2c
 8007258:	e039      	b.n	80072ce <AddCA+0x172>
    }
#ifndef ALLOW_INVALID_CERTSIGN
    else if (ret == 0 && cert->isCA == 1 && type != WOLFSSL_USER_CA &&
 800725a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800725c:	2b00      	cmp	r3, #0
 800725e:	d11d      	bne.n	800729c <AddCA+0x140>
 8007260:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007262:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 8007266:	f003 0310 	and.w	r3, r3, #16
 800726a:	b2db      	uxtb	r3, r3
 800726c:	2b00      	cmp	r3, #0
 800726e:	d015      	beq.n	800729c <AddCA+0x140>
 8007270:	687b      	ldr	r3, [r7, #4]
 8007272:	2b01      	cmp	r3, #1
 8007274:	d012      	beq.n	800729c <AddCA+0x140>
        !cert->selfSigned && (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) == 0) {
 8007276:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007278:	f893 3379 	ldrb.w	r3, [r3, #889]	; 0x379
 800727c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8007280:	b2db      	uxtb	r3, r3
    else if (ret == 0 && cert->isCA == 1 && type != WOLFSSL_USER_CA &&
 8007282:	2b00      	cmp	r3, #0
 8007284:	d10a      	bne.n	800729c <AddCA+0x140>
        !cert->selfSigned && (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) == 0) {
 8007286:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007288:	f8b3 331e 	ldrh.w	r3, [r3, #798]	; 0x31e
 800728c:	f003 0304 	and.w	r3, r3, #4
 8007290:	2b00      	cmp	r3, #0
 8007292:	d103      	bne.n	800729c <AddCA+0x140>
        /* Intermediate CA certs are required to have the keyCertSign
        * extension set. User loaded root certs are not. */
        WOLFSSL_MSG("\tDoesn't have key usage certificate signing");
        ret = NOT_CA_ERROR;
 8007294:	f46f 73b2 	mvn.w	r3, #356	; 0x164
 8007298:	62fb      	str	r3, [r7, #44]	; 0x2c
 800729a:	e018      	b.n	80072ce <AddCA+0x172>
    }
#endif
    else if (ret == 0 && AlreadySigner(cm, subjectHash)) {
 800729c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800729e:	2b00      	cmp	r3, #0
 80072a0:	d106      	bne.n	80072b0 <AddCA+0x154>
 80072a2:	69f9      	ldr	r1, [r7, #28]
 80072a4:	68f8      	ldr	r0, [r7, #12]
 80072a6:	f7ff fe89 	bl	8006fbc <AlreadySigner>
 80072aa:	4603      	mov	r3, r0
 80072ac:	2b00      	cmp	r3, #0
 80072ae:	d10e      	bne.n	80072ce <AddCA+0x172>
        WOLFSSL_MSG("\tAlready have this CA, not adding again");
        (void)ret;
    }
    else if (ret == 0) {
 80072b0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80072b2:	2b00      	cmp	r3, #0
 80072b4:	d10b      	bne.n	80072ce <AddCA+0x172>
        /* take over signer parts */
        signer = MakeSigner(cm->heap);
 80072b6:	68fb      	ldr	r3, [r7, #12]
 80072b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80072ba:	4618      	mov	r0, r3
 80072bc:	f005 fe2d 	bl	800cf1a <MakeSigner>
 80072c0:	62b8      	str	r0, [r7, #40]	; 0x28
        if (!signer)
 80072c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80072c4:	2b00      	cmp	r3, #0
 80072c6:	d102      	bne.n	80072ce <AddCA+0x172>
            ret = MEMORY_ERROR;
 80072c8:	f46f 7397 	mvn.w	r3, #302	; 0x12e
 80072cc:	62fb      	str	r3, [r7, #44]	; 0x2c
    }
    if (ret == 0 && signer != NULL) {
 80072ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80072d0:	2b00      	cmp	r3, #0
 80072d2:	f040 80b4 	bne.w	800743e <AddCA+0x2e2>
 80072d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80072d8:	2b00      	cmp	r3, #0
 80072da:	f000 80b0 	beq.w	800743e <AddCA+0x2e2>
        ret = AllocDer(&signer->derCert, der->length, der->type, NULL);
    }
    if (ret == 0 && signer != NULL) {
        XMEMCPY(signer->derCert->buffer, der->buffer, der->length);
    #endif
        signer->keyOID         = cert->keyOID;
 80072de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80072e0:	69da      	ldr	r2, [r3, #28]
 80072e2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80072e4:	605a      	str	r2, [r3, #4]
        if (cert->pubKeyStored) {
 80072e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80072e8:	689b      	ldr	r3, [r3, #8]
 80072ea:	2b00      	cmp	r3, #0
 80072ec:	d007      	beq.n	80072fe <AddCA+0x1a2>
            signer->publicKey      = cert->publicKey;
 80072ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80072f0:	681a      	ldr	r2, [r3, #0]
 80072f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80072f4:	611a      	str	r2, [r3, #16]
            signer->pubKeySize     = cert->pubKeySize;
 80072f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80072f8:	685a      	ldr	r2, [r3, #4]
 80072fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80072fc:	601a      	str	r2, [r3, #0]
        }
        if (cert->subjectCNStored) {
 80072fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007300:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 8007304:	f003 0301 	and.w	r3, r3, #1
 8007308:	b2db      	uxtb	r3, r3
 800730a:	2b00      	cmp	r3, #0
 800730c:	d008      	beq.n	8007320 <AddCA+0x1c4>
            signer->nameLen        = cert->subjectCNLen;
 800730e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007310:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8007314:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007316:	615a      	str	r2, [r3, #20]
            signer->name           = cert->subjectCN;
 8007318:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800731a:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 800731c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800731e:	619a      	str	r2, [r3, #24]
        }
        signer->pathLength     = cert->pathLength;
 8007320:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007322:	f893 231c 	ldrb.w	r2, [r3, #796]	; 0x31c
 8007326:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007328:	72da      	strb	r2, [r3, #11]
        signer->maxPathLen     = cert->maxPathLen;
 800732a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800732c:	f893 231d 	ldrb.w	r2, [r3, #797]	; 0x31d
 8007330:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007332:	729a      	strb	r2, [r3, #10]
        signer->pathLengthSet  = cert->pathLengthSet;
 8007334:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007336:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 800733a:	f3c3 1340 	ubfx	r3, r3, #5, #1
 800733e:	b2d9      	uxtb	r1, r3
 8007340:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007342:	7b13      	ldrb	r3, [r2, #12]
 8007344:	f361 0300 	bfi	r3, r1, #0, #1
 8007348:	7313      	strb	r3, [r2, #12]
        signer->selfSigned     = cert->selfSigned;
 800734a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800734c:	f893 3379 	ldrb.w	r3, [r3, #889]	; 0x379
 8007350:	f3c3 1380 	ubfx	r3, r3, #6, #1
 8007354:	b2d9      	uxtb	r1, r3
 8007356:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007358:	7b13      	ldrb	r3, [r2, #12]
 800735a:	f361 0341 	bfi	r3, r1, #1, #1
 800735e:	7313      	strb	r3, [r2, #12]
    #ifndef IGNORE_NAME_CONSTRAINTS
        signer->permittedNames = cert->permittedNames;
 8007360:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007362:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8007364:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007366:	61da      	str	r2, [r3, #28]
        signer->excludedNames  = cert->excludedNames;
 8007368:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800736a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800736c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800736e:	621a      	str	r2, [r3, #32]
    #endif
    #ifndef NO_SKID
        XMEMCPY(signer->subjectKeyIdHash, cert->extSubjKeyId,
 8007370:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007372:	f103 0044 	add.w	r0, r3, #68	; 0x44
 8007376:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007378:	f503 7337 	add.w	r3, r3, #732	; 0x2dc
 800737c:	2220      	movs	r2, #32
 800737e:	4619      	mov	r1, r3
 8007380:	f012 f839 	bl	80193f6 <memcpy>
                SIGNER_DIGEST_SIZE);
    #endif
        XMEMCPY(signer->subjectNameHash, cert->subjectHash,
 8007384:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007386:	f103 0024 	add.w	r0, r3, #36	; 0x24
 800738a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800738c:	3338      	adds	r3, #56	; 0x38
 800738e:	2220      	movs	r2, #32
 8007390:	4619      	mov	r1, r3
 8007392:	f012 f830 	bl	80193f6 <memcpy>
                SIGNER_DIGEST_SIZE);
    #ifdef HAVE_OCSP
        XMEMCPY(signer->subjectKeyHash, cert->subjectKeyHash,
                KEYID_SIZE);
    #endif
        signer->keyUsage = cert->extKeyUsageSet ? cert->extKeyUsage
 8007396:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007398:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 800739c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80073a0:	b2db      	uxtb	r3, r3
 80073a2:	2b00      	cmp	r3, #0
 80073a4:	d003      	beq.n	80073ae <AddCA+0x252>
 80073a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80073a8:	f8b3 231e 	ldrh.w	r2, [r3, #798]	; 0x31e
 80073ac:	e001      	b.n	80073b2 <AddCA+0x256>
 80073ae:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80073b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80073b4:	811a      	strh	r2, [r3, #8]
                                                : 0xFFFF;
        signer->next    = NULL; /* If Key Usage not set, all uses valid. */
 80073b6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80073b8:	2200      	movs	r2, #0
 80073ba:	665a      	str	r2, [r3, #100]	; 0x64
        cert->publicKey = 0;    /* in case lock fails don't free here.   */
 80073bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80073be:	2200      	movs	r2, #0
 80073c0:	601a      	str	r2, [r3, #0]
        cert->subjectCN = 0;
 80073c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80073c4:	2200      	movs	r2, #0
 80073c6:	67da      	str	r2, [r3, #124]	; 0x7c
    #ifndef IGNORE_NAME_CONSTRAINTS
        cert->permittedNames = NULL;
 80073c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80073ca:	2200      	movs	r2, #0
 80073cc:	631a      	str	r2, [r3, #48]	; 0x30
        cert->excludedNames = NULL;
 80073ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80073d0:	2200      	movs	r2, #0
 80073d2:	635a      	str	r2, [r3, #52]	; 0x34
    #endif

    #ifndef NO_SKID
        row = HashSigner(signer->subjectKeyIdHash);
 80073d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80073d6:	3344      	adds	r3, #68	; 0x44
 80073d8:	4618      	mov	r0, r3
 80073da:	f7ff fdd5 	bl	8006f88 <HashSigner>
 80073de:	61b8      	str	r0, [r7, #24]
    #else
        row = HashSigner(signer->subjectNameHash);
    #endif

        if (wc_LockMutex(&cm->caLock) == 0) {
 80073e0:	68fb      	ldr	r3, [r7, #12]
 80073e2:	3354      	adds	r3, #84	; 0x54
 80073e4:	4618      	mov	r0, r3
 80073e6:	f011 ff55 	bl	8019294 <wc_LockMutex>
 80073ea:	4603      	mov	r3, r0
 80073ec:	2b00      	cmp	r3, #0
 80073ee:	d11d      	bne.n	800742c <AddCA+0x2d0>
            signer->next = cm->caTable[row];
 80073f0:	68fb      	ldr	r3, [r7, #12]
 80073f2:	69ba      	ldr	r2, [r7, #24]
 80073f4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80073f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80073fa:	665a      	str	r2, [r3, #100]	; 0x64
            cm->caTable[row] = signer;   /* takes ownership */
 80073fc:	68fb      	ldr	r3, [r7, #12]
 80073fe:	69ba      	ldr	r2, [r7, #24]
 8007400:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8007402:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            wc_UnLockMutex(&cm->caLock);
 8007406:	68fb      	ldr	r3, [r7, #12]
 8007408:	3354      	adds	r3, #84	; 0x54
 800740a:	4618      	mov	r0, r3
 800740c:	f011 ff4d 	bl	80192aa <wc_UnLockMutex>
            if (cm->caCacheCallback)
 8007410:	68fb      	ldr	r3, [r7, #12]
 8007412:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007414:	2b00      	cmp	r3, #0
 8007416:	d012      	beq.n	800743e <AddCA+0x2e2>
                cm->caCacheCallback(der->buffer, (int)der->length, type);
 8007418:	68fb      	ldr	r3, [r7, #12]
 800741a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800741c:	6a3a      	ldr	r2, [r7, #32]
 800741e:	6810      	ldr	r0, [r2, #0]
 8007420:	6a3a      	ldr	r2, [r7, #32]
 8007422:	6892      	ldr	r2, [r2, #8]
 8007424:	4611      	mov	r1, r2
 8007426:	687a      	ldr	r2, [r7, #4]
 8007428:	4798      	blx	r3
 800742a:	e008      	b.n	800743e <AddCA+0x2e2>
        }
        else {
            WOLFSSL_MSG("\tCA Mutex Lock failed");
            ret = BAD_MUTEX_E;
 800742c:	f06f 0369 	mvn.w	r3, #105	; 0x69
 8007430:	62fb      	str	r3, [r7, #44]	; 0x2c
            FreeSigner(signer, cm->heap);
 8007432:	68fb      	ldr	r3, [r7, #12]
 8007434:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007436:	4619      	mov	r1, r3
 8007438:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800743a:	f005 fd83 	bl	800cf44 <FreeSigner>
                WOLFSSL_MSG("tsip_tls_RootCertVerify() succeed");
        }
    }
#endif
    WOLFSSL_MSG("\tFreeing Parsed CA");
    FreeDecodedCert(cert);
 800743e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8007440:	f002 fce0 	bl	8009e04 <FreeDecodedCert>
#ifdef WOLFSSL_SMALL_STACK
    XFREE(cert, NULL, DYNAMIC_TYPE_DCERT);
 8007444:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007446:	617b      	str	r3, [r7, #20]
 8007448:	697b      	ldr	r3, [r7, #20]
 800744a:	2b00      	cmp	r3, #0
 800744c:	d002      	beq.n	8007454 <AddCA+0x2f8>
 800744e:	6978      	ldr	r0, [r7, #20]
 8007450:	f007 fd6e 	bl	800ef30 <wolfSSL_Free>
#endif
    WOLFSSL_MSG("\tFreeing der CA");
    FreeDer(pDer);
 8007454:	68b8      	ldr	r0, [r7, #8]
 8007456:	f005 fe97 	bl	800d188 <FreeDer>
    WOLFSSL_MSG("\t\tOK Freeing der CA");

    WOLFSSL_LEAVE("AddCA", ret);

    return ret == 0 ? WOLFSSL_SUCCESS : ret;
 800745a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800745c:	2b00      	cmp	r3, #0
 800745e:	d001      	beq.n	8007464 <AddCA+0x308>
 8007460:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007462:	e000      	b.n	8007466 <AddCA+0x30a>
 8007464:	2301      	movs	r3, #1
}
 8007466:	4618      	mov	r0, r3
 8007468:	3730      	adds	r7, #48	; 0x30
 800746a:	46bd      	mov	sp, r7
 800746c:	bd80      	pop	{r7, pc}
 800746e:	bf00      	nop
 8007470:	fffffe66 	.word	0xfffffe66

08007474 <wolfSSL_Init>:
static wolfSSL_Mutex globalRNGMutex;
#endif

WOLFSSL_ABI
int wolfSSL_Init(void)
{
 8007474:	b580      	push	{r7, lr}
 8007476:	af00      	add	r7, sp, #0
    WOLFSSL_ENTER("wolfSSL_Init");

    if (initRefCount == 0) {
 8007478:	4b14      	ldr	r3, [pc, #80]	; (80074cc <wolfSSL_Init+0x58>)
 800747a:	681b      	ldr	r3, [r3, #0]
 800747c:	2b00      	cmp	r3, #0
 800747e:	d110      	bne.n	80074a2 <wolfSSL_Init+0x2e>
        /* Initialize crypto for use with TLS connection */
        if (wolfCrypt_Init() != 0) {
 8007480:	f011 feb8 	bl	80191f4 <wolfCrypt_Init>
 8007484:	4603      	mov	r3, r0
 8007486:	2b00      	cmp	r3, #0
 8007488:	d002      	beq.n	8007490 <wolfSSL_Init+0x1c>
            WOLFSSL_MSG("Bad wolfCrypt Init");
            return WC_INIT_E;
 800748a:	f06f 03e3 	mvn.w	r3, #227	; 0xe3
 800748e:	e01a      	b.n	80074c6 <wolfSSL_Init+0x52>
        if (wc_InitMutex(&session_mutex) != 0) {
            WOLFSSL_MSG("Bad Init Mutex session");
            return BAD_MUTEX_E;
        }
#endif
        if (wc_InitMutex(&count_mutex) != 0) {
 8007490:	480f      	ldr	r0, [pc, #60]	; (80074d0 <wolfSSL_Init+0x5c>)
 8007492:	f011 fee9 	bl	8019268 <wc_InitMutex>
 8007496:	4603      	mov	r3, r0
 8007498:	2b00      	cmp	r3, #0
 800749a:	d002      	beq.n	80074a2 <wolfSSL_Init+0x2e>
            WOLFSSL_MSG("Bad Init Mutex count");
            return BAD_MUTEX_E;
 800749c:	f06f 0369 	mvn.w	r3, #105	; 0x69
 80074a0:	e011      	b.n	80074c6 <wolfSSL_Init+0x52>
        }
    }

    if (wc_LockMutex(&count_mutex) != 0) {
 80074a2:	480b      	ldr	r0, [pc, #44]	; (80074d0 <wolfSSL_Init+0x5c>)
 80074a4:	f011 fef6 	bl	8019294 <wc_LockMutex>
 80074a8:	4603      	mov	r3, r0
 80074aa:	2b00      	cmp	r3, #0
 80074ac:	d002      	beq.n	80074b4 <wolfSSL_Init+0x40>
        WOLFSSL_MSG("Bad Lock Mutex count");
        return BAD_MUTEX_E;
 80074ae:	f06f 0369 	mvn.w	r3, #105	; 0x69
 80074b2:	e008      	b.n	80074c6 <wolfSSL_Init+0x52>
    }

    initRefCount++;
 80074b4:	4b05      	ldr	r3, [pc, #20]	; (80074cc <wolfSSL_Init+0x58>)
 80074b6:	681b      	ldr	r3, [r3, #0]
 80074b8:	3301      	adds	r3, #1
 80074ba:	4a04      	ldr	r2, [pc, #16]	; (80074cc <wolfSSL_Init+0x58>)
 80074bc:	6013      	str	r3, [r2, #0]
    wc_UnLockMutex(&count_mutex);
 80074be:	4804      	ldr	r0, [pc, #16]	; (80074d0 <wolfSSL_Init+0x5c>)
 80074c0:	f011 fef3 	bl	80192aa <wc_UnLockMutex>

    return WOLFSSL_SUCCESS;
 80074c4:	2301      	movs	r3, #1
}
 80074c6:	4618      	mov	r0, r3
 80074c8:	bd80      	pop	{r7, pc}
 80074ca:	bf00      	nop
 80074cc:	20000224 	.word	0x20000224
 80074d0:	20000228 	.word	0x20000228

080074d4 <ProcessUserChain>:

/* process user cert chain to pass during the handshake */
static int ProcessUserChain(WOLFSSL_CTX* ctx, const unsigned char* buff,
                         long sz, int format, int type, WOLFSSL* ssl,
                         long* used, EncryptedInfo* info, int verify)
{
 80074d4:	b580      	push	{r7, lr}
 80074d6:	b098      	sub	sp, #96	; 0x60
 80074d8:	af04      	add	r7, sp, #16
 80074da:	60f8      	str	r0, [r7, #12]
 80074dc:	60b9      	str	r1, [r7, #8]
 80074de:	607a      	str	r2, [r7, #4]
 80074e0:	603b      	str	r3, [r7, #0]
    int ret = 0;
 80074e2:	2300      	movs	r3, #0
 80074e4:	64fb      	str	r3, [r7, #76]	; 0x4c
    void* heap = wolfSSL_CTX_GetHeap(ctx, ssl);
 80074e6:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 80074e8:	68f8      	ldr	r0, [r7, #12]
 80074ea:	f7ff fca0 	bl	8006e2e <wolfSSL_CTX_GetHeap>
 80074ee:	6338      	str	r0, [r7, #48]	; 0x30
#ifdef WOLFSSL_TLS13
    int cnt = 0;
 80074f0:	2300      	movs	r3, #0
 80074f2:	64bb      	str	r3, [r7, #72]	; 0x48
#endif

    if ((type == CA_TYPE) && (ctx == NULL)) {
 80074f4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80074f6:	2b05      	cmp	r3, #5
 80074f8:	d105      	bne.n	8007506 <ProcessUserChain+0x32>
 80074fa:	68fb      	ldr	r3, [r7, #12]
 80074fc:	2b00      	cmp	r3, #0
 80074fe:	d102      	bne.n	8007506 <ProcessUserChain+0x32>
        WOLFSSL_MSG("Need context for CA load");
        return BAD_FUNC_ARG;
 8007500:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8007504:	e14d      	b.n	80077a2 <ProcessUserChain+0x2ce>
    }

    /* we may have a user cert chain, try to consume */
    if ((type == CERT_TYPE || type == CA_TYPE) && (info->consumed < sz)) {
 8007506:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007508:	2b00      	cmp	r3, #0
 800750a:	d003      	beq.n	8007514 <ProcessUserChain+0x40>
 800750c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800750e:	2b05      	cmp	r3, #5
 8007510:	f040 8146 	bne.w	80077a0 <ProcessUserChain+0x2cc>
 8007514:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007516:	689b      	ldr	r3, [r3, #8]
 8007518:	687a      	ldr	r2, [r7, #4]
 800751a:	429a      	cmp	r2, r3
 800751c:	f340 8140 	ble.w	80077a0 <ProcessUserChain+0x2cc>
    #ifdef WOLFSSL_SMALL_STACK
        byte   staticBuffer[1];                 /* force heap usage */
    #else
        byte   staticBuffer[FILE_BUFFER_SIZE];  /* tmp chain buffer */
    #endif
        byte*  chainBuffer = staticBuffer;
 8007520:	f107 031c 	add.w	r3, r7, #28
 8007524:	647b      	str	r3, [r7, #68]	; 0x44
        int    dynamicBuffer = 0;
 8007526:	2300      	movs	r3, #0
 8007528:	643b      	str	r3, [r7, #64]	; 0x40
        word32 bufferSz;
        long   consumed = info->consumed;
 800752a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800752c:	689b      	ldr	r3, [r3, #8]
 800752e:	63fb      	str	r3, [r7, #60]	; 0x3c
        word32 idx = 0;
 8007530:	2300      	movs	r3, #0
 8007532:	63bb      	str	r3, [r7, #56]	; 0x38
        int    gotOne = 0;
 8007534:	2300      	movs	r3, #0
 8007536:	637b      	str	r3, [r7, #52]	; 0x34

        /* Calculate max possible size, including max headers */
        bufferSz = (word32)(sz - consumed) + (CERT_HEADER_SZ * MAX_CHAIN_DEPTH);
 8007538:	687a      	ldr	r2, [r7, #4]
 800753a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800753c:	1ad3      	subs	r3, r2, r3
 800753e:	331b      	adds	r3, #27
 8007540:	62fb      	str	r3, [r7, #44]	; 0x2c
        if (bufferSz > sizeof(staticBuffer)) {
 8007542:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007544:	2b01      	cmp	r3, #1
 8007546:	f240 80c9 	bls.w	80076dc <ProcessUserChain+0x208>
            WOLFSSL_MSG("Growing Tmp Chain Buffer");
            /* will shrink to actual size */
            chainBuffer = (byte*)XMALLOC(bufferSz, heap, DYNAMIC_TYPE_FILE);
 800754a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800754c:	f007 fcd4 	bl	800eef8 <wolfSSL_Malloc>
 8007550:	6478      	str	r0, [r7, #68]	; 0x44
            if (chainBuffer == NULL) {
 8007552:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007554:	2b00      	cmp	r3, #0
 8007556:	d102      	bne.n	800755e <ProcessUserChain+0x8a>
                return MEMORY_E;
 8007558:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800755c:	e121      	b.n	80077a2 <ProcessUserChain+0x2ce>
            }
            dynamicBuffer = 1;
 800755e:	2301      	movs	r3, #1
 8007560:	643b      	str	r3, [r7, #64]	; 0x40
        }

        WOLFSSL_MSG("Processing Cert Chain");
        while (consumed < sz) {
 8007562:	e0bb      	b.n	80076dc <ProcessUserChain+0x208>
            DerBuffer* part = NULL;
 8007564:	2300      	movs	r3, #0
 8007566:	61bb      	str	r3, [r7, #24]
            word32 remain = (word32)(sz - consumed);
 8007568:	687a      	ldr	r2, [r7, #4]
 800756a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800756c:	1ad3      	subs	r3, r2, r3
 800756e:	62bb      	str	r3, [r7, #40]	; 0x28
            info->consumed = 0;
 8007570:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007572:	2200      	movs	r2, #0
 8007574:	609a      	str	r2, [r3, #8]

            if (format == WOLFSSL_FILETYPE_PEM) {
 8007576:	683b      	ldr	r3, [r7, #0]
 8007578:	2b01      	cmp	r3, #1
 800757a:	d111      	bne.n	80075a0 <ProcessUserChain+0xcc>
            #ifdef WOLFSSL_PEM_TO_DER
                ret = PemToDer(buff + consumed, remain, type, &part,
 800757c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800757e:	68ba      	ldr	r2, [r7, #8]
 8007580:	18d0      	adds	r0, r2, r3
 8007582:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8007584:	f107 0218 	add.w	r2, r7, #24
 8007588:	2300      	movs	r3, #0
 800758a:	9302      	str	r3, [sp, #8]
 800758c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800758e:	9301      	str	r3, [sp, #4]
 8007590:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007592:	9300      	str	r3, [sp, #0]
 8007594:	4613      	mov	r3, r2
 8007596:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8007598:	f005 ff22 	bl	800d3e0 <PemToDer>
 800759c:	64f8      	str	r0, [r7, #76]	; 0x4c
 800759e:	e036      	b.n	800760e <ProcessUserChain+0x13a>
            #else
                ret = NOT_COMPILED_IN;
            #endif
            }
            else {
                int length = remain;
 80075a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80075a2:	617b      	str	r3, [r7, #20]
                if (format == WOLFSSL_FILETYPE_ASN1) {
 80075a4:	683b      	ldr	r3, [r7, #0]
 80075a6:	2b02      	cmp	r3, #2
 80075a8:	d116      	bne.n	80075d8 <ProcessUserChain+0x104>
                    /* get length of der (read sequence) */
                    word32 inOutIdx = 0;
 80075aa:	2300      	movs	r3, #0
 80075ac:	613b      	str	r3, [r7, #16]
                    if (GetSequence(buff + consumed, &inOutIdx, &length,
 80075ae:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80075b0:	68ba      	ldr	r2, [r7, #8]
 80075b2:	18d0      	adds	r0, r2, r3
 80075b4:	f107 0214 	add.w	r2, r7, #20
 80075b8:	f107 0110 	add.w	r1, r7, #16
 80075bc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80075be:	f001 f9e7 	bl	8008990 <GetSequence>
 80075c2:	4603      	mov	r3, r0
 80075c4:	2b00      	cmp	r3, #0
 80075c6:	da02      	bge.n	80075ce <ProcessUserChain+0xfa>
                            remain) < 0) {
                        ret = ASN_NO_PEM_HEADER;
 80075c8:	f06f 03a1 	mvn.w	r3, #161	; 0xa1
 80075cc:	64fb      	str	r3, [r7, #76]	; 0x4c
                    }
                    length += inOutIdx; /* include leading sequence */
 80075ce:	697b      	ldr	r3, [r7, #20]
 80075d0:	461a      	mov	r2, r3
 80075d2:	693b      	ldr	r3, [r7, #16]
 80075d4:	4413      	add	r3, r2
 80075d6:	617b      	str	r3, [r7, #20]
                }
                info->consumed = length;
 80075d8:	697a      	ldr	r2, [r7, #20]
 80075da:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80075dc:	609a      	str	r2, [r3, #8]
                if (ret == 0) {
 80075de:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80075e0:	2b00      	cmp	r3, #0
 80075e2:	d114      	bne.n	800760e <ProcessUserChain+0x13a>
                    ret = AllocDer(&part, length, type, heap);
 80075e4:	697b      	ldr	r3, [r7, #20]
 80075e6:	4619      	mov	r1, r3
 80075e8:	f107 0018 	add.w	r0, r7, #24
 80075ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80075ee:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80075f0:	f005 fd54 	bl	800d09c <AllocDer>
 80075f4:	64f8      	str	r0, [r7, #76]	; 0x4c
                    if (ret == 0) {
 80075f6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80075f8:	2b00      	cmp	r3, #0
 80075fa:	d108      	bne.n	800760e <ProcessUserChain+0x13a>
                        XMEMCPY(part->buffer, buff + consumed, length);
 80075fc:	69bb      	ldr	r3, [r7, #24]
 80075fe:	6818      	ldr	r0, [r3, #0]
 8007600:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007602:	68ba      	ldr	r2, [r7, #8]
 8007604:	4413      	add	r3, r2
 8007606:	697a      	ldr	r2, [r7, #20]
 8007608:	4619      	mov	r1, r3
 800760a:	f011 fef4 	bl	80193f6 <memcpy>
                    }
                }
            }
            if (ret == 0) {
 800760e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007610:	2b00      	cmp	r3, #0
 8007612:	d147      	bne.n	80076a4 <ProcessUserChain+0x1d0>
                gotOne = 1;
 8007614:	2301      	movs	r3, #1
 8007616:	637b      	str	r3, [r7, #52]	; 0x34
#ifdef WOLFSSL_TLS13
                cnt++;
 8007618:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800761a:	3301      	adds	r3, #1
 800761c:	64bb      	str	r3, [r7, #72]	; 0x48
#endif
                if ((idx + part->length + CERT_HEADER_SZ) > bufferSz) {
 800761e:	69bb      	ldr	r3, [r7, #24]
 8007620:	689a      	ldr	r2, [r3, #8]
 8007622:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007624:	4413      	add	r3, r2
 8007626:	3303      	adds	r3, #3
 8007628:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800762a:	429a      	cmp	r2, r3
 800762c:	d203      	bcs.n	8007636 <ProcessUserChain+0x162>
                    WOLFSSL_MSG("   Cert Chain bigger than buffer");
                    ret = BUFFER_E;
 800762e:	f06f 0383 	mvn.w	r3, #131	; 0x83
 8007632:	64fb      	str	r3, [r7, #76]	; 0x4c
 8007634:	e028      	b.n	8007688 <ProcessUserChain+0x1b4>
                }
                else {
                    c32to24(part->length, &chainBuffer[idx]);
 8007636:	69bb      	ldr	r3, [r7, #24]
 8007638:	6898      	ldr	r0, [r3, #8]
 800763a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800763c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800763e:	4413      	add	r3, r2
 8007640:	4619      	mov	r1, r3
 8007642:	f7ff fb58 	bl	8006cf6 <c32to24>
                    idx += CERT_HEADER_SZ;
 8007646:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007648:	3303      	adds	r3, #3
 800764a:	63bb      	str	r3, [r7, #56]	; 0x38
                    XMEMCPY(&chainBuffer[idx], part->buffer, part->length);
 800764c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800764e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007650:	18d0      	adds	r0, r2, r3
 8007652:	69bb      	ldr	r3, [r7, #24]
 8007654:	6819      	ldr	r1, [r3, #0]
 8007656:	69bb      	ldr	r3, [r7, #24]
 8007658:	689b      	ldr	r3, [r3, #8]
 800765a:	461a      	mov	r2, r3
 800765c:	f011 fecb 	bl	80193f6 <memcpy>
                    idx += part->length;
 8007660:	69bb      	ldr	r3, [r7, #24]
 8007662:	689b      	ldr	r3, [r3, #8]
 8007664:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8007666:	4413      	add	r3, r2
 8007668:	63bb      	str	r3, [r7, #56]	; 0x38
                    consumed  += info->consumed;
 800766a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800766c:	689b      	ldr	r3, [r3, #8]
 800766e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8007670:	4413      	add	r3, r2
 8007672:	63fb      	str	r3, [r7, #60]	; 0x3c
                    if (used)
 8007674:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8007676:	2b00      	cmp	r3, #0
 8007678:	d006      	beq.n	8007688 <ProcessUserChain+0x1b4>
                        *used += info->consumed;
 800767a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800767c:	681a      	ldr	r2, [r3, #0]
 800767e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007680:	689b      	ldr	r3, [r3, #8]
 8007682:	441a      	add	r2, r3
 8007684:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8007686:	601a      	str	r2, [r3, #0]
                }

                /* add CA's to certificate manager */
                if (type == CA_TYPE) {
 8007688:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800768a:	2b05      	cmp	r3, #5
 800768c:	d10a      	bne.n	80076a4 <ProcessUserChain+0x1d0>
                    /* verify CA unless user set to no verify */
                    ret = AddCA(ctx->cm, &part, WOLFSSL_USER_CA, verify);
 800768e:	68fb      	ldr	r3, [r7, #12]
 8007690:	6c18      	ldr	r0, [r3, #64]	; 0x40
 8007692:	f107 0118 	add.w	r1, r7, #24
 8007696:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8007698:	2201      	movs	r2, #1
 800769a:	f7ff fd5f 	bl	800715c <AddCA>
 800769e:	64f8      	str	r0, [r7, #76]	; 0x4c
                    gotOne = 0; /* don't exit loop for CA type */
 80076a0:	2300      	movs	r3, #0
 80076a2:	637b      	str	r3, [r7, #52]	; 0x34
                }
            }

            FreeDer(&part);
 80076a4:	f107 0318 	add.w	r3, r7, #24
 80076a8:	4618      	mov	r0, r3
 80076aa:	f005 fd6d 	bl	800d188 <FreeDer>

            if (ret == ASN_NO_PEM_HEADER && gotOne) {
 80076ae:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80076b0:	f113 0fa2 	cmn.w	r3, #162	; 0xa2
 80076b4:	d102      	bne.n	80076bc <ProcessUserChain+0x1e8>
 80076b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80076b8:	2b00      	cmp	r3, #0
 80076ba:	d115      	bne.n	80076e8 <ProcessUserChain+0x214>
                WOLFSSL_MSG("We got one good cert, so stuff at end ok");
                break;
            }

            if (ret < 0) {
 80076bc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80076be:	2b00      	cmp	r3, #0
 80076c0:	da0c      	bge.n	80076dc <ProcessUserChain+0x208>
                WOLFSSL_MSG("   Error in Cert in Chain");
                if (dynamicBuffer)
 80076c2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80076c4:	2b00      	cmp	r3, #0
 80076c6:	d007      	beq.n	80076d8 <ProcessUserChain+0x204>
                    XFREE(chainBuffer, heap, DYNAMIC_TYPE_FILE);
 80076c8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80076ca:	627b      	str	r3, [r7, #36]	; 0x24
 80076cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80076ce:	2b00      	cmp	r3, #0
 80076d0:	d002      	beq.n	80076d8 <ProcessUserChain+0x204>
 80076d2:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80076d4:	f007 fc2c 	bl	800ef30 <wolfSSL_Free>
                return ret;
 80076d8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
                return MEMORY_E;
 80076da:	e062      	b.n	80077a2 <ProcessUserChain+0x2ce>
        while (consumed < sz) {
 80076dc:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80076de:	687b      	ldr	r3, [r7, #4]
 80076e0:	429a      	cmp	r2, r3
 80076e2:	f6ff af3f 	blt.w	8007564 <ProcessUserChain+0x90>
 80076e6:	e000      	b.n	80076ea <ProcessUserChain+0x216>
                break;
 80076e8:	bf00      	nop
            WOLFSSL_MSG("   Consumed another Cert in Chain");
        }
        WOLFSSL_MSG("Finished Processing Cert Chain");

        /* only retain actual size used */
        ret = 0;
 80076ea:	2300      	movs	r3, #0
 80076ec:	64fb      	str	r3, [r7, #76]	; 0x4c
        if (idx > 0) {
 80076ee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80076f0:	2b00      	cmp	r3, #0
 80076f2:	d04a      	beq.n	800778a <ProcessUserChain+0x2b6>
            if (ssl) {
 80076f4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80076f6:	2b00      	cmp	r3, #0
 80076f8:	d028      	beq.n	800774c <ProcessUserChain+0x278>
                if (ssl->buffers.weOwnCertChain) {
 80076fa:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80076fc:	f893 3135 	ldrb.w	r3, [r3, #309]	; 0x135
 8007700:	2b00      	cmp	r3, #0
 8007702:	d005      	beq.n	8007710 <ProcessUserChain+0x23c>
                    FreeDer(&ssl->buffers.certChain);
 8007704:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007706:	f503 73b8 	add.w	r3, r3, #368	; 0x170
 800770a:	4618      	mov	r0, r3
 800770c:	f005 fd3c 	bl	800d188 <FreeDer>
                }
                ret = AllocDer(&ssl->buffers.certChain, idx, type, heap);
 8007710:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007712:	f503 70b8 	add.w	r0, r3, #368	; 0x170
 8007716:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007718:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800771a:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800771c:	f005 fcbe 	bl	800d09c <AllocDer>
 8007720:	64f8      	str	r0, [r7, #76]	; 0x4c
                if (ret == 0) {
 8007722:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007724:	2b00      	cmp	r3, #0
 8007726:	d10c      	bne.n	8007742 <ProcessUserChain+0x26e>
                    XMEMCPY(ssl->buffers.certChain->buffer, chainBuffer,
 8007728:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800772a:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 800772e:	681b      	ldr	r3, [r3, #0]
 8007730:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8007732:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8007734:	4618      	mov	r0, r3
 8007736:	f011 fe5e 	bl	80193f6 <memcpy>
                            idx);
                    ssl->buffers.weOwnCertChain = 1;
 800773a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800773c:	2201      	movs	r2, #1
 800773e:	f883 2135 	strb.w	r2, [r3, #309]	; 0x135
                }
            #ifdef WOLFSSL_TLS13
                ssl->buffers.certChainCnt = cnt;
 8007742:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007744:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8007746:	f8c3 2174 	str.w	r2, [r3, #372]	; 0x174
 800774a:	e01e      	b.n	800778a <ProcessUserChain+0x2b6>
            #endif
            } else if (ctx) {
 800774c:	68fb      	ldr	r3, [r7, #12]
 800774e:	2b00      	cmp	r3, #0
 8007750:	d01b      	beq.n	800778a <ProcessUserChain+0x2b6>
                FreeDer(&ctx->certChain);
 8007752:	68fb      	ldr	r3, [r7, #12]
 8007754:	3328      	adds	r3, #40	; 0x28
 8007756:	4618      	mov	r0, r3
 8007758:	f005 fd16 	bl	800d188 <FreeDer>
                ret = AllocDer(&ctx->certChain, idx, type, heap);
 800775c:	68fb      	ldr	r3, [r7, #12]
 800775e:	f103 0028 	add.w	r0, r3, #40	; 0x28
 8007762:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007764:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8007766:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8007768:	f005 fc98 	bl	800d09c <AllocDer>
 800776c:	64f8      	str	r0, [r7, #76]	; 0x4c
                if (ret == 0) {
 800776e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007770:	2b00      	cmp	r3, #0
 8007772:	d107      	bne.n	8007784 <ProcessUserChain+0x2b0>
                    XMEMCPY(ctx->certChain->buffer, chainBuffer, idx);
 8007774:	68fb      	ldr	r3, [r7, #12]
 8007776:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007778:	681b      	ldr	r3, [r3, #0]
 800777a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800777c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800777e:	4618      	mov	r0, r3
 8007780:	f011 fe39 	bl	80193f6 <memcpy>
                }
            #ifdef WOLFSSL_TLS13
                ctx->certChainCnt = cnt;
 8007784:	68fb      	ldr	r3, [r7, #12]
 8007786:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8007788:	62da      	str	r2, [r3, #44]	; 0x2c
            #endif
            }
        }

        if (dynamicBuffer)
 800778a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800778c:	2b00      	cmp	r3, #0
 800778e:	d007      	beq.n	80077a0 <ProcessUserChain+0x2cc>
            XFREE(chainBuffer, heap, DYNAMIC_TYPE_FILE);
 8007790:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007792:	623b      	str	r3, [r7, #32]
 8007794:	6a3b      	ldr	r3, [r7, #32]
 8007796:	2b00      	cmp	r3, #0
 8007798:	d002      	beq.n	80077a0 <ProcessUserChain+0x2cc>
 800779a:	6a38      	ldr	r0, [r7, #32]
 800779c:	f007 fbc8 	bl	800ef30 <wolfSSL_Free>
    }

    return ret;
 80077a0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
}
 80077a2:	4618      	mov	r0, r3
 80077a4:	3750      	adds	r7, #80	; 0x50
 80077a6:	46bd      	mov	sp, r7
 80077a8:	bd80      	pop	{r7, pc}
	...

080077ac <ProcessBufferTryDecode>:

static int ProcessBufferTryDecode(WOLFSSL_CTX* ctx, WOLFSSL* ssl, DerBuffer* der,
    int* keySz, word32* idx, int* resetSuites, int* keyFormat, void* heap, int devId)
{
 80077ac:	b580      	push	{r7, lr}
 80077ae:	b08c      	sub	sp, #48	; 0x30
 80077b0:	af00      	add	r7, sp, #0
 80077b2:	60f8      	str	r0, [r7, #12]
 80077b4:	60b9      	str	r1, [r7, #8]
 80077b6:	607a      	str	r2, [r7, #4]
 80077b8:	603b      	str	r3, [r7, #0]
    int ret = 0;
 80077ba:	2300      	movs	r3, #0
 80077bc:	62fb      	str	r3, [r7, #44]	; 0x2c

    (void)heap;
    (void)devId;

    if (ctx == NULL && ssl == NULL)
 80077be:	68fb      	ldr	r3, [r7, #12]
 80077c0:	2b00      	cmp	r3, #0
 80077c2:	d105      	bne.n	80077d0 <ProcessBufferTryDecode+0x24>
 80077c4:	68bb      	ldr	r3, [r7, #8]
 80077c6:	2b00      	cmp	r3, #0
 80077c8:	d102      	bne.n	80077d0 <ProcessBufferTryDecode+0x24>
        ret = BAD_FUNC_ARG;
 80077ca:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 80077ce:	62fb      	str	r3, [r7, #44]	; 0x2c
    if (!der || !keySz || !idx || !resetSuites || !keyFormat)
 80077d0:	687b      	ldr	r3, [r7, #4]
 80077d2:	2b00      	cmp	r3, #0
 80077d4:	d00b      	beq.n	80077ee <ProcessBufferTryDecode+0x42>
 80077d6:	683b      	ldr	r3, [r7, #0]
 80077d8:	2b00      	cmp	r3, #0
 80077da:	d008      	beq.n	80077ee <ProcessBufferTryDecode+0x42>
 80077dc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80077de:	2b00      	cmp	r3, #0
 80077e0:	d005      	beq.n	80077ee <ProcessBufferTryDecode+0x42>
 80077e2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80077e4:	2b00      	cmp	r3, #0
 80077e6:	d002      	beq.n	80077ee <ProcessBufferTryDecode+0x42>
 80077e8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80077ea:	2b00      	cmp	r3, #0
 80077ec:	d102      	bne.n	80077f4 <ProcessBufferTryDecode+0x48>
        ret = BAD_FUNC_ARG;
 80077ee:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 80077f2:	62fb      	str	r3, [r7, #44]	; 0x2c

#ifndef NO_RSA
    if (ret == 0 && (*keyFormat == 0 || *keyFormat == RSAk)) {
 80077f4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80077f6:	2b00      	cmp	r3, #0
 80077f8:	f040 8086 	bne.w	8007908 <ProcessBufferTryDecode+0x15c>
 80077fc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80077fe:	681b      	ldr	r3, [r3, #0]
 8007800:	2b00      	cmp	r3, #0
 8007802:	d005      	beq.n	8007810 <ProcessBufferTryDecode+0x64>
 8007804:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8007806:	681b      	ldr	r3, [r3, #0]
 8007808:	f240 2285 	movw	r2, #645	; 0x285
 800780c:	4293      	cmp	r3, r2
 800780e:	d17b      	bne.n	8007908 <ProcessBufferTryDecode+0x15c>
    #else
        RsaKey  key[1];
    #endif

    #ifdef WOLFSSL_SMALL_STACK
        key = (RsaKey*)XMALLOC(sizeof(RsaKey), heap, DYNAMIC_TYPE_RSA);
 8007810:	f641 007c 	movw	r0, #6268	; 0x187c
 8007814:	f007 fb70 	bl	800eef8 <wolfSSL_Malloc>
 8007818:	62b8      	str	r0, [r7, #40]	; 0x28
        if (key == NULL)
 800781a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800781c:	2b00      	cmp	r3, #0
 800781e:	d102      	bne.n	8007826 <ProcessBufferTryDecode+0x7a>
            return MEMORY_E;
 8007820:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 8007824:	e101      	b.n	8007a2a <ProcessBufferTryDecode+0x27e>
    #endif

        ret = wc_InitRsaKey_ex(key, heap, devId);
 8007826:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8007828:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800782a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800782c:	f007 fd64 	bl	800f2f8 <wc_InitRsaKey_ex>
 8007830:	62f8      	str	r0, [r7, #44]	; 0x2c
        if (ret == 0) {
 8007832:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007834:	2b00      	cmp	r3, #0
 8007836:	d15f      	bne.n	80078f8 <ProcessBufferTryDecode+0x14c>
            *idx = 0;
 8007838:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800783a:	2200      	movs	r2, #0
 800783c:	601a      	str	r2, [r3, #0]
            if (wc_RsaPrivateKeyDecode(der->buffer, idx, key, der->length)
 800783e:	687b      	ldr	r3, [r7, #4]
 8007840:	6818      	ldr	r0, [r3, #0]
 8007842:	687b      	ldr	r3, [r7, #4]
 8007844:	689b      	ldr	r3, [r3, #8]
 8007846:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007848:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800784a:	f001 ffa4 	bl	8009796 <wc_RsaPrivateKeyDecode>
 800784e:	4603      	mov	r3, r0
 8007850:	2b00      	cmp	r3, #0
 8007852:	d14e      	bne.n	80078f2 <ProcessBufferTryDecode+0x146>
                ret = WOLFSSL_BAD_FILE;
            #endif
            }
            else {
                /* check that the size of the RSA key is enough */
                int minRsaSz = ssl ? ssl->options.minRsaKeySz :
 8007854:	68bb      	ldr	r3, [r7, #8]
 8007856:	2b00      	cmp	r3, #0
 8007858:	d003      	beq.n	8007862 <ProcessBufferTryDecode+0xb6>
 800785a:	68bb      	ldr	r3, [r7, #8]
 800785c:	f9b3 3336 	ldrsh.w	r3, [r3, #822]	; 0x336
 8007860:	e002      	b.n	8007868 <ProcessBufferTryDecode+0xbc>
                    ctx->minRsaKeySz;
 8007862:	68fb      	ldr	r3, [r7, #12]
 8007864:	f9b3 3056 	ldrsh.w	r3, [r3, #86]	; 0x56
                int minRsaSz = ssl ? ssl->options.minRsaKeySz :
 8007868:	627b      	str	r3, [r7, #36]	; 0x24
                *keySz = wc_RsaEncryptSize((RsaKey*)key);
 800786a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800786c:	f008 fd38 	bl	80102e0 <wc_RsaEncryptSize>
 8007870:	4602      	mov	r2, r0
 8007872:	683b      	ldr	r3, [r7, #0]
 8007874:	601a      	str	r2, [r3, #0]
                if (*keySz < minRsaSz) {
 8007876:	683b      	ldr	r3, [r7, #0]
 8007878:	681b      	ldr	r3, [r3, #0]
 800787a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800787c:	429a      	cmp	r2, r3
 800787e:	dd02      	ble.n	8007886 <ProcessBufferTryDecode+0xda>
                    ret = RSA_KEY_SIZE_E;
 8007880:	f46f 73cc 	mvn.w	r3, #408	; 0x198
 8007884:	62fb      	str	r3, [r7, #44]	; 0x2c
                    WOLFSSL_MSG("Private Key size too small");
                }

                if (ssl) {
 8007886:	68bb      	ldr	r3, [r7, #8]
 8007888:	2b00      	cmp	r3, #0
 800788a:	d00d      	beq.n	80078a8 <ProcessBufferTryDecode+0xfc>
                    ssl->buffers.keyType = rsa_sa_algo;
 800788c:	68ba      	ldr	r2, [r7, #8]
 800788e:	f892 3164 	ldrb.w	r3, [r2, #356]	; 0x164
 8007892:	2101      	movs	r1, #1
 8007894:	f361 0305 	bfi	r3, r1, #0, #6
 8007898:	f882 3164 	strb.w	r3, [r2, #356]	; 0x164
                    ssl->buffers.keySz = *keySz;
 800789c:	683b      	ldr	r3, [r7, #0]
 800789e:	681a      	ldr	r2, [r3, #0]
 80078a0:	68bb      	ldr	r3, [r7, #8]
 80078a2:	f8c3 2168 	str.w	r2, [r3, #360]	; 0x168
 80078a6:	e00b      	b.n	80078c0 <ProcessBufferTryDecode+0x114>
                }
                else {
                    ctx->privateKeyType = rsa_sa_algo;
 80078a8:	68fa      	ldr	r2, [r7, #12]
 80078aa:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 80078ae:	2101      	movs	r1, #1
 80078b0:	f361 0305 	bfi	r3, r1, #0, #6
 80078b4:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
                    ctx->privateKeySz = *keySz;
 80078b8:	683b      	ldr	r3, [r7, #0]
 80078ba:	681a      	ldr	r2, [r3, #0]
 80078bc:	68fb      	ldr	r3, [r7, #12]
 80078be:	639a      	str	r2, [r3, #56]	; 0x38
                }

                *keyFormat = RSAk;
 80078c0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80078c2:	f240 2285 	movw	r2, #645	; 0x285
 80078c6:	601a      	str	r2, [r3, #0]

                if (ssl && ssl->options.side == WOLFSSL_SERVER_END) {
 80078c8:	68bb      	ldr	r3, [r7, #8]
 80078ca:	2b00      	cmp	r3, #0
 80078cc:	d011      	beq.n	80078f2 <ProcessBufferTryDecode+0x146>
 80078ce:	68bb      	ldr	r3, [r7, #8]
 80078d0:	f893 331c 	ldrb.w	r3, [r3, #796]	; 0x31c
 80078d4:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80078d8:	b2db      	uxtb	r3, r3
 80078da:	2b00      	cmp	r3, #0
 80078dc:	d109      	bne.n	80078f2 <ProcessBufferTryDecode+0x146>
                    ssl->options.haveStaticECC = 0;
 80078de:	68ba      	ldr	r2, [r7, #8]
 80078e0:	f892 331f 	ldrb.w	r3, [r2, #799]	; 0x31f
 80078e4:	f36f 1304 	bfc	r3, #4, #1
 80078e8:	f882 331f 	strb.w	r3, [r2, #799]	; 0x31f
                    *resetSuites = 1;
 80078ec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80078ee:	2201      	movs	r2, #1
 80078f0:	601a      	str	r2, [r3, #0]
                }
            }

            wc_FreeRsaKey(key);
 80078f2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80078f4:	f007 fd7f 	bl	800f3f6 <wc_FreeRsaKey>
        }

    #ifdef WOLFSSL_SMALL_STACK
        XFREE(key, heap, DYNAMIC_TYPE_RSA);
 80078f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80078fa:	623b      	str	r3, [r7, #32]
 80078fc:	6a3b      	ldr	r3, [r7, #32]
 80078fe:	2b00      	cmp	r3, #0
 8007900:	d002      	beq.n	8007908 <ProcessBufferTryDecode+0x15c>
 8007902:	6a38      	ldr	r0, [r7, #32]
 8007904:	f007 fb14 	bl	800ef30 <wolfSSL_Free>
    #endif
    }
#endif
#ifdef HAVE_ECC
    if (ret == 0 && (*keyFormat == 0 || *keyFormat == ECDSAk)) {
 8007908:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800790a:	2b00      	cmp	r3, #0
 800790c:	f040 808c 	bne.w	8007a28 <ProcessBufferTryDecode+0x27c>
 8007910:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8007912:	681b      	ldr	r3, [r3, #0]
 8007914:	2b00      	cmp	r3, #0
 8007916:	d006      	beq.n	8007926 <ProcessBufferTryDecode+0x17a>
 8007918:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800791a:	681b      	ldr	r3, [r3, #0]
 800791c:	f240 2206 	movw	r2, #518	; 0x206
 8007920:	4293      	cmp	r3, r2
 8007922:	f040 8081 	bne.w	8007a28 <ProcessBufferTryDecode+0x27c>
    #else
        ecc_key  key[1];
    #endif

    #ifdef WOLFSSL_SMALL_STACK
        key = (ecc_key*)XMALLOC(sizeof(ecc_key), heap, DYNAMIC_TYPE_ECC);
 8007926:	f44f 6083 	mov.w	r0, #1048	; 0x418
 800792a:	f007 fae5 	bl	800eef8 <wolfSSL_Malloc>
 800792e:	61f8      	str	r0, [r7, #28]
        if (key == NULL)
 8007930:	69fb      	ldr	r3, [r7, #28]
 8007932:	2b00      	cmp	r3, #0
 8007934:	d102      	bne.n	800793c <ProcessBufferTryDecode+0x190>
            return MEMORY_E;
 8007936:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800793a:	e076      	b.n	8007a2a <ProcessBufferTryDecode+0x27e>
    #endif

        if (wc_ecc_init_ex(key, heap, devId) == 0) {
 800793c:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800793e:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8007940:	69f8      	ldr	r0, [r7, #28]
 8007942:	f006 fe69 	bl	800e618 <wc_ecc_init_ex>
 8007946:	4603      	mov	r3, r0
 8007948:	2b00      	cmp	r3, #0
 800794a:	d165      	bne.n	8007a18 <ProcessBufferTryDecode+0x26c>
            *idx = 0;
 800794c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800794e:	2200      	movs	r2, #0
 8007950:	601a      	str	r2, [r3, #0]
            if (wc_EccPrivateKeyDecode(der->buffer, idx, key,
 8007952:	687b      	ldr	r3, [r7, #4]
 8007954:	6818      	ldr	r0, [r3, #0]
 8007956:	687b      	ldr	r3, [r7, #4]
 8007958:	689b      	ldr	r3, [r3, #8]
 800795a:	69fa      	ldr	r2, [r7, #28]
 800795c:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800795e:	f005 fea1 	bl	800d6a4 <wc_EccPrivateKeyDecode>
 8007962:	4603      	mov	r3, r0
 8007964:	2b00      	cmp	r3, #0
 8007966:	d154      	bne.n	8007a12 <ProcessBufferTryDecode+0x266>
                                                        der->length) == 0) {
                /* check for minimum ECC key size and then free */
                int minKeySz = ssl ? ssl->options.minEccKeySz :
 8007968:	68bb      	ldr	r3, [r7, #8]
 800796a:	2b00      	cmp	r3, #0
 800796c:	d003      	beq.n	8007976 <ProcessBufferTryDecode+0x1ca>
 800796e:	68bb      	ldr	r3, [r7, #8]
 8007970:	f9b3 3338 	ldrsh.w	r3, [r3, #824]	; 0x338
 8007974:	e002      	b.n	800797c <ProcessBufferTryDecode+0x1d0>
                                                        ctx->minEccKeySz;
 8007976:	68fb      	ldr	r3, [r7, #12]
 8007978:	f9b3 3058 	ldrsh.w	r3, [r3, #88]	; 0x58
                int minKeySz = ssl ? ssl->options.minEccKeySz :
 800797c:	61bb      	str	r3, [r7, #24]
                *keySz = wc_ecc_size(key);
 800797e:	69f8      	ldr	r0, [r7, #28]
 8007980:	f007 f98f 	bl	800eca2 <wc_ecc_size>
 8007984:	4602      	mov	r2, r0
 8007986:	683b      	ldr	r3, [r7, #0]
 8007988:	601a      	str	r2, [r3, #0]
                if (*keySz < minKeySz) {
 800798a:	683b      	ldr	r3, [r7, #0]
 800798c:	681b      	ldr	r3, [r3, #0]
 800798e:	69ba      	ldr	r2, [r7, #24]
 8007990:	429a      	cmp	r2, r3
 8007992:	dd01      	ble.n	8007998 <ProcessBufferTryDecode+0x1ec>
                    WOLFSSL_MSG("ECC private key too small");
                    ret = ECC_KEY_SIZE_E;
 8007994:	4b27      	ldr	r3, [pc, #156]	; (8007a34 <ProcessBufferTryDecode+0x288>)
 8007996:	62fb      	str	r3, [r7, #44]	; 0x2c
                }

                *keyFormat = ECDSAk;
 8007998:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800799a:	f240 2206 	movw	r2, #518	; 0x206
 800799e:	601a      	str	r2, [r3, #0]
                if (ssl) {
 80079a0:	68bb      	ldr	r3, [r7, #8]
 80079a2:	2b00      	cmp	r3, #0
 80079a4:	d014      	beq.n	80079d0 <ProcessBufferTryDecode+0x224>
                    ssl->options.haveStaticECC = 1;
 80079a6:	68ba      	ldr	r2, [r7, #8]
 80079a8:	f892 331f 	ldrb.w	r3, [r2, #799]	; 0x31f
 80079ac:	f043 0310 	orr.w	r3, r3, #16
 80079b0:	f882 331f 	strb.w	r3, [r2, #799]	; 0x31f
                    ssl->buffers.keyType = ecc_dsa_sa_algo;
 80079b4:	68ba      	ldr	r2, [r7, #8]
 80079b6:	f892 3164 	ldrb.w	r3, [r2, #356]	; 0x164
 80079ba:	2103      	movs	r1, #3
 80079bc:	f361 0305 	bfi	r3, r1, #0, #6
 80079c0:	f882 3164 	strb.w	r3, [r2, #356]	; 0x164
                    ssl->buffers.keySz = *keySz;
 80079c4:	683b      	ldr	r3, [r7, #0]
 80079c6:	681a      	ldr	r2, [r3, #0]
 80079c8:	68bb      	ldr	r3, [r7, #8]
 80079ca:	f8c3 2168 	str.w	r2, [r3, #360]	; 0x168
 80079ce:	e012      	b.n	80079f6 <ProcessBufferTryDecode+0x24a>
                }
                else {
                    ctx->haveStaticECC = 1;
 80079d0:	68fa      	ldr	r2, [r7, #12]
 80079d2:	f892 304e 	ldrb.w	r3, [r2, #78]	; 0x4e
 80079d6:	f043 0320 	orr.w	r3, r3, #32
 80079da:	f882 304e 	strb.w	r3, [r2, #78]	; 0x4e
                    ctx->privateKeyType = ecc_dsa_sa_algo;
 80079de:	68fa      	ldr	r2, [r7, #12]
 80079e0:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 80079e4:	2103      	movs	r1, #3
 80079e6:	f361 0305 	bfi	r3, r1, #0, #6
 80079ea:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
                    ctx->privateKeySz = *keySz;
 80079ee:	683b      	ldr	r3, [r7, #0]
 80079f0:	681a      	ldr	r2, [r3, #0]
 80079f2:	68fb      	ldr	r3, [r7, #12]
 80079f4:	639a      	str	r2, [r3, #56]	; 0x38
                }

                if (ssl && ssl->options.side == WOLFSSL_SERVER_END) {
 80079f6:	68bb      	ldr	r3, [r7, #8]
 80079f8:	2b00      	cmp	r3, #0
 80079fa:	d00a      	beq.n	8007a12 <ProcessBufferTryDecode+0x266>
 80079fc:	68bb      	ldr	r3, [r7, #8]
 80079fe:	f893 331c 	ldrb.w	r3, [r3, #796]	; 0x31c
 8007a02:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8007a06:	b2db      	uxtb	r3, r3
 8007a08:	2b00      	cmp	r3, #0
 8007a0a:	d102      	bne.n	8007a12 <ProcessBufferTryDecode+0x266>
                    *resetSuites = 1;
 8007a0c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007a0e:	2201      	movs	r2, #1
 8007a10:	601a      	str	r2, [r3, #0]
                }
            }

            wc_ecc_free(key);
 8007a12:	69f8      	ldr	r0, [r7, #28]
 8007a14:	f006 fe4a 	bl	800e6ac <wc_ecc_free>
        }

    #ifdef WOLFSSL_SMALL_STACK
        XFREE(key, heap, DYNAMIC_TYPE_ECC);
 8007a18:	69fb      	ldr	r3, [r7, #28]
 8007a1a:	617b      	str	r3, [r7, #20]
 8007a1c:	697b      	ldr	r3, [r7, #20]
 8007a1e:	2b00      	cmp	r3, #0
 8007a20:	d002      	beq.n	8007a28 <ProcessBufferTryDecode+0x27c>
 8007a22:	6978      	ldr	r0, [r7, #20]
 8007a24:	f007 fa84 	bl	800ef30 <wolfSSL_Free>
    #ifdef WOLFSSL_SMALL_STACK
        XFREE(key, heap, DYNAMIC_TYPE_ED448);
    #endif
    }
#endif /* HAVE_ED448 */
    return ret;
 8007a28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 8007a2a:	4618      	mov	r0, r3
 8007a2c:	3730      	adds	r7, #48	; 0x30
 8007a2e:	46bd      	mov	sp, r7
 8007a30:	bd80      	pop	{r7, pc}
 8007a32:	bf00      	nop
 8007a34:	fffffe66 	.word	0xfffffe66

08007a38 <ProcessBuffer>:
   used tracks bytes consumed, userChain specifies a user cert chain
   to pass during the handshake */
int ProcessBuffer(WOLFSSL_CTX* ctx, const unsigned char* buff,
                         long sz, int format, int type, WOLFSSL* ssl,
                         long* used, int userChain, int verify)
{
 8007a38:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007a3a:	b0a3      	sub	sp, #140	; 0x8c
 8007a3c:	af08      	add	r7, sp, #32
 8007a3e:	6178      	str	r0, [r7, #20]
 8007a40:	6139      	str	r1, [r7, #16]
 8007a42:	60fa      	str	r2, [r7, #12]
 8007a44:	60bb      	str	r3, [r7, #8]
    DerBuffer*    der = NULL;        /* holds DER or RAW (for NTRU) */
 8007a46:	2300      	movs	r3, #0
 8007a48:	63bb      	str	r3, [r7, #56]	; 0x38
    int           ret = 0;
 8007a4a:	2300      	movs	r3, #0
 8007a4c:	667b      	str	r3, [r7, #100]	; 0x64
    int           done = 0;
 8007a4e:	2300      	movs	r3, #0
 8007a50:	663b      	str	r3, [r7, #96]	; 0x60
    int           keyFormat = 0;
 8007a52:	2300      	movs	r3, #0
 8007a54:	637b      	str	r3, [r7, #52]	; 0x34
    int           resetSuites = 0;
 8007a56:	2300      	movs	r3, #0
 8007a58:	633b      	str	r3, [r7, #48]	; 0x30
    void*         heap = wolfSSL_CTX_GetHeap(ctx, ssl);
 8007a5a:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
 8007a5e:	6978      	ldr	r0, [r7, #20]
 8007a60:	f7ff f9e5 	bl	8006e2e <wolfSSL_CTX_GetHeap>
 8007a64:	65f8      	str	r0, [r7, #92]	; 0x5c
    int           devId = wolfSSL_CTX_GetDevId(ctx, ssl);
 8007a66:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
 8007a6a:	6978      	ldr	r0, [r7, #20]
 8007a6c:	f7ff f9c1 	bl	8006df2 <wolfSSL_CTX_GetDevId>
 8007a70:	65b8      	str	r0, [r7, #88]	; 0x58
    word32        idx = 0;
 8007a72:	2300      	movs	r3, #0
 8007a74:	62fb      	str	r3, [r7, #44]	; 0x2c
    int           keySz = 0;
 8007a76:	2300      	movs	r3, #0
 8007a78:	62bb      	str	r3, [r7, #40]	; 0x28
#if (defined(WOLFSSL_ENCRYPTED_KEYS) && !defined(NO_PWDBASED)) || \
     defined(HAVE_PKCS8)
    word32        algId = 0;
 8007a7a:	2300      	movs	r3, #0
 8007a7c:	627b      	str	r3, [r7, #36]	; 0x24
#endif
#ifdef WOLFSSL_SMALL_STACK
    EncryptedInfo* info = NULL;
 8007a7e:	2300      	movs	r3, #0
 8007a80:	657b      	str	r3, [r7, #84]	; 0x54

    (void)devId;
    (void)idx;
    (void)keySz;

    if (used)
 8007a82:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8007a86:	2b00      	cmp	r3, #0
 8007a88:	d003      	beq.n	8007a92 <ProcessBuffer+0x5a>
        *used = sz;     /* used bytes default to sz, PEM chain may shorten*/
 8007a8a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8007a8e:	68fa      	ldr	r2, [r7, #12]
 8007a90:	601a      	str	r2, [r3, #0]

    /* check args */
    if (format != WOLFSSL_FILETYPE_ASN1 && format != WOLFSSL_FILETYPE_PEM
 8007a92:	68bb      	ldr	r3, [r7, #8]
 8007a94:	2b02      	cmp	r3, #2
 8007a96:	d008      	beq.n	8007aaa <ProcessBuffer+0x72>
 8007a98:	68bb      	ldr	r3, [r7, #8]
 8007a9a:	2b01      	cmp	r3, #1
 8007a9c:	d005      	beq.n	8007aaa <ProcessBuffer+0x72>
                                    && format != WOLFSSL_FILETYPE_RAW)
 8007a9e:	68bb      	ldr	r3, [r7, #8]
 8007aa0:	2b03      	cmp	r3, #3
 8007aa2:	d002      	beq.n	8007aaa <ProcessBuffer+0x72>
        return WOLFSSL_BAD_FILETYPE;
 8007aa4:	f06f 0304 	mvn.w	r3, #4
 8007aa8:	e3aa      	b.n	8008200 <ProcessBuffer+0x7c8>

    if (ctx == NULL && ssl == NULL)
 8007aaa:	697b      	ldr	r3, [r7, #20]
 8007aac:	2b00      	cmp	r3, #0
 8007aae:	d106      	bne.n	8007abe <ProcessBuffer+0x86>
 8007ab0:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007ab4:	2b00      	cmp	r3, #0
 8007ab6:	d102      	bne.n	8007abe <ProcessBuffer+0x86>
        return BAD_FUNC_ARG;
 8007ab8:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8007abc:	e3a0      	b.n	8008200 <ProcessBuffer+0x7c8>

#ifdef WOLFSSL_SMALL_STACK
    info = (EncryptedInfo*)XMALLOC(sizeof(EncryptedInfo), heap,
 8007abe:	208c      	movs	r0, #140	; 0x8c
 8007ac0:	f007 fa1a 	bl	800eef8 <wolfSSL_Malloc>
 8007ac4:	6578      	str	r0, [r7, #84]	; 0x54
                                   DYNAMIC_TYPE_ENCRYPTEDINFO);
    if (info == NULL)
 8007ac6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007ac8:	2b00      	cmp	r3, #0
 8007aca:	d102      	bne.n	8007ad2 <ProcessBuffer+0x9a>
        return MEMORY_E;
 8007acc:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 8007ad0:	e396      	b.n	8008200 <ProcessBuffer+0x7c8>
#endif

    XMEMSET(info, 0, sizeof(EncryptedInfo));
 8007ad2:	228c      	movs	r2, #140	; 0x8c
 8007ad4:	2100      	movs	r1, #0
 8007ad6:	6d78      	ldr	r0, [r7, #84]	; 0x54
 8007ad8:	f011 fcb1 	bl	801943e <memset>
        info->passwd_cb       = ctx->passwd_cb;
        info->passwd_userdata = ctx->passwd_userdata;
    }
#endif

    if (format == WOLFSSL_FILETYPE_PEM) {
 8007adc:	68bb      	ldr	r3, [r7, #8]
 8007ade:	2b01      	cmp	r3, #1
 8007ae0:	d111      	bne.n	8007b06 <ProcessBuffer+0xce>
    #ifdef WOLFSSL_PEM_TO_DER
        ret = PemToDer(buff, sz, type, &der, heap, info, &keyFormat);
 8007ae2:	f107 0238 	add.w	r2, r7, #56	; 0x38
 8007ae6:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8007aea:	9302      	str	r3, [sp, #8]
 8007aec:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007aee:	9301      	str	r3, [sp, #4]
 8007af0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007af2:	9300      	str	r3, [sp, #0]
 8007af4:	4613      	mov	r3, r2
 8007af6:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8007afa:	68f9      	ldr	r1, [r7, #12]
 8007afc:	6938      	ldr	r0, [r7, #16]
 8007afe:	f005 fc6f 	bl	800d3e0 <PemToDer>
 8007b02:	6678      	str	r0, [r7, #100]	; 0x64
 8007b04:	e05f      	b.n	8007bc6 <ProcessBuffer+0x18e>
        ret = NOT_COMPILED_IN;
    #endif
    }
    else {
        /* ASN1 (DER) or RAW (NTRU) */
        int length = (int)sz;
 8007b06:	68fb      	ldr	r3, [r7, #12]
 8007b08:	623b      	str	r3, [r7, #32]
        if (format == WOLFSSL_FILETYPE_ASN1) {
 8007b0a:	68bb      	ldr	r3, [r7, #8]
 8007b0c:	2b02      	cmp	r3, #2
 8007b0e:	d12a      	bne.n	8007b66 <ProcessBuffer+0x12e>
            /* get length of der (read sequence or octet string) */
            word32 inOutIdx = 0;
 8007b10:	2300      	movs	r3, #0
 8007b12:	61fb      	str	r3, [r7, #28]
            if (GetSequence(buff, &inOutIdx, &length, (word32)sz) >= 0) {
 8007b14:	68fb      	ldr	r3, [r7, #12]
 8007b16:	f107 0220 	add.w	r2, r7, #32
 8007b1a:	f107 011c 	add.w	r1, r7, #28
 8007b1e:	6938      	ldr	r0, [r7, #16]
 8007b20:	f000 ff36 	bl	8008990 <GetSequence>
 8007b24:	4603      	mov	r3, r0
 8007b26:	2b00      	cmp	r3, #0
 8007b28:	db05      	blt.n	8007b36 <ProcessBuffer+0xfe>
                length += inOutIdx; /* include leading sequence */
 8007b2a:	6a3b      	ldr	r3, [r7, #32]
 8007b2c:	461a      	mov	r2, r3
 8007b2e:	69fb      	ldr	r3, [r7, #28]
 8007b30:	4413      	add	r3, r2
 8007b32:	623b      	str	r3, [r7, #32]
 8007b34:	e017      	b.n	8007b66 <ProcessBuffer+0x12e>
            }
            /* get length using octect string (allowed for private key types) */
            else if (type == PRIVATEKEY_TYPE &&
 8007b36:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8007b3a:	2b01      	cmp	r3, #1
 8007b3c:	d110      	bne.n	8007b60 <ProcessBuffer+0x128>
                    GetOctetString(buff, &inOutIdx, &length, (word32)sz) >= 0) {
 8007b3e:	68fb      	ldr	r3, [r7, #12]
 8007b40:	f107 0220 	add.w	r2, r7, #32
 8007b44:	f107 011c 	add.w	r1, r7, #28
 8007b48:	6938      	ldr	r0, [r7, #16]
 8007b4a:	f000 ffcd 	bl	8008ae8 <GetOctetString>
 8007b4e:	4603      	mov	r3, r0
            else if (type == PRIVATEKEY_TYPE &&
 8007b50:	2b00      	cmp	r3, #0
 8007b52:	db05      	blt.n	8007b60 <ProcessBuffer+0x128>
                length += inOutIdx; /* include leading oct string */
 8007b54:	6a3b      	ldr	r3, [r7, #32]
 8007b56:	461a      	mov	r2, r3
 8007b58:	69fb      	ldr	r3, [r7, #28]
 8007b5a:	4413      	add	r3, r2
 8007b5c:	623b      	str	r3, [r7, #32]
 8007b5e:	e002      	b.n	8007b66 <ProcessBuffer+0x12e>
            }
            else {
                ret = ASN_PARSE_E;
 8007b60:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8007b64:	667b      	str	r3, [r7, #100]	; 0x64
            }
        }

        info->consumed = length;
 8007b66:	6a3a      	ldr	r2, [r7, #32]
 8007b68:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007b6a:	609a      	str	r2, [r3, #8]

        if (ret == 0) {
 8007b6c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007b6e:	2b00      	cmp	r3, #0
 8007b70:	d129      	bne.n	8007bc6 <ProcessBuffer+0x18e>
            ret = AllocDer(&der, (word32)length, type, heap);
 8007b72:	6a3b      	ldr	r3, [r7, #32]
 8007b74:	4619      	mov	r1, r3
 8007b76:	f107 0038 	add.w	r0, r7, #56	; 0x38
 8007b7a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007b7c:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8007b80:	f005 fa8c 	bl	800d09c <AllocDer>
 8007b84:	6678      	str	r0, [r7, #100]	; 0x64
            if (ret == 0) {
 8007b86:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007b88:	2b00      	cmp	r3, #0
 8007b8a:	d106      	bne.n	8007b9a <ProcessBuffer+0x162>
                XMEMCPY(der->buffer, buff, length);
 8007b8c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007b8e:	681b      	ldr	r3, [r3, #0]
 8007b90:	6a3a      	ldr	r2, [r7, #32]
 8007b92:	6939      	ldr	r1, [r7, #16]
 8007b94:	4618      	mov	r0, r3
 8007b96:	f011 fc2e 	bl	80193f6 <memcpy>
            }

        #ifdef HAVE_PKCS8
            /* if private key try and remove PKCS8 header */
            if (type == PRIVATEKEY_TYPE) {
 8007b9a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8007b9e:	2b01      	cmp	r3, #1
 8007ba0:	d111      	bne.n	8007bc6 <ProcessBuffer+0x18e>
                if ((ret = ToTraditional_ex(der->buffer, der->length, &algId)) > 0) {
 8007ba2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007ba4:	6818      	ldr	r0, [r3, #0]
 8007ba6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007ba8:	689b      	ldr	r3, [r3, #8]
 8007baa:	f107 0224 	add.w	r2, r7, #36	; 0x24
 8007bae:	4619      	mov	r1, r3
 8007bb0:	f001 ff01 	bl	80099b6 <ToTraditional_ex>
 8007bb4:	6678      	str	r0, [r7, #100]	; 0x64
 8007bb6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007bb8:	2b00      	cmp	r3, #0
 8007bba:	dd02      	ble.n	8007bc2 <ProcessBuffer+0x18a>
                    /* Found PKCS8 header */
                    /* ToTraditional_ex moves buff and returns adjusted length */
                    der->length = ret;
 8007bbc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007bbe:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8007bc0:	609a      	str	r2, [r3, #8]
                }
                ret = 0; /* failures should be ignored */
 8007bc2:	2300      	movs	r3, #0
 8007bc4:	667b      	str	r3, [r7, #100]	; 0x64
            }
        #endif
        }
    }

    if (used) {
 8007bc6:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8007bca:	2b00      	cmp	r3, #0
 8007bcc:	d004      	beq.n	8007bd8 <ProcessBuffer+0x1a0>
        *used = info->consumed;
 8007bce:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007bd0:	689a      	ldr	r2, [r3, #8]
 8007bd2:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8007bd6:	601a      	str	r2, [r3, #0]
    }

    /* process user chain */
    if (ret >= 0) {
 8007bd8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007bda:	2b00      	cmp	r3, #0
 8007bdc:	db18      	blt.n	8007c10 <ProcessBuffer+0x1d8>
        /* Chain should have server cert first, then intermediates, then root.
         * First certificate in chain is processed below after ProcessUserChain
         *   and is loaded into ssl->buffers.certificate.
         * Remainder are processed using ProcessUserChain and are loaded into
         *   ssl->buffers.certChain. */
        if (userChain) {
 8007bde:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8007be2:	2b00      	cmp	r3, #0
 8007be4:	d014      	beq.n	8007c10 <ProcessBuffer+0x1d8>
            ret = ProcessUserChain(ctx, buff, sz, format, type, ssl, used, info,
 8007be6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8007bea:	9304      	str	r3, [sp, #16]
 8007bec:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007bee:	9303      	str	r3, [sp, #12]
 8007bf0:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8007bf4:	9302      	str	r3, [sp, #8]
 8007bf6:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007bfa:	9301      	str	r3, [sp, #4]
 8007bfc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8007c00:	9300      	str	r3, [sp, #0]
 8007c02:	68bb      	ldr	r3, [r7, #8]
 8007c04:	68fa      	ldr	r2, [r7, #12]
 8007c06:	6939      	ldr	r1, [r7, #16]
 8007c08:	6978      	ldr	r0, [r7, #20]
 8007c0a:	f7ff fc63 	bl	80074d4 <ProcessUserChain>
 8007c0e:	6678      	str	r0, [r7, #100]	; 0x64
                                   verify);
        }
    }

    /* info is only used for private key with DER or PEM, so free now */
    if (ret < 0 || type != PRIVATEKEY_TYPE || format == WOLFSSL_FILETYPE_RAW) {
 8007c10:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007c12:	2b00      	cmp	r3, #0
 8007c14:	db06      	blt.n	8007c24 <ProcessBuffer+0x1ec>
 8007c16:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8007c1a:	2b01      	cmp	r3, #1
 8007c1c:	d102      	bne.n	8007c24 <ProcessBuffer+0x1ec>
 8007c1e:	68bb      	ldr	r3, [r7, #8]
 8007c20:	2b03      	cmp	r3, #3
 8007c22:	d107      	bne.n	8007c34 <ProcessBuffer+0x1fc>
    #ifdef WOLFSSL_SMALL_STACK
        XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 8007c24:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007c26:	653b      	str	r3, [r7, #80]	; 0x50
 8007c28:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8007c2a:	2b00      	cmp	r3, #0
 8007c2c:	d002      	beq.n	8007c34 <ProcessBuffer+0x1fc>
 8007c2e:	6d38      	ldr	r0, [r7, #80]	; 0x50
 8007c30:	f007 f97e 	bl	800ef30 <wolfSSL_Free>
    #endif
    }

    /* check for error */
    if (ret < 0) {
 8007c34:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007c36:	2b00      	cmp	r3, #0
 8007c38:	da06      	bge.n	8007c48 <ProcessBuffer+0x210>
        FreeDer(&der);
 8007c3a:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8007c3e:	4618      	mov	r0, r3
 8007c40:	f005 faa2 	bl	800d188 <FreeDer>
        done = 1;
 8007c44:	2301      	movs	r3, #1
 8007c46:	663b      	str	r3, [r7, #96]	; 0x60
    }

    if (done == 1) {
 8007c48:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8007c4a:	2b01      	cmp	r3, #1
 8007c4c:	d07b      	beq.n	8007d46 <ProcessBuffer+0x30e>
        /* No operation, just skip the next section */
    }
    /* Handle DER owner */
    else if (type == CA_TYPE) {
 8007c4e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8007c52:	2b05      	cmp	r3, #5
 8007c54:	d117      	bne.n	8007c86 <ProcessBuffer+0x24e>
        if (ctx == NULL) {
 8007c56:	697b      	ldr	r3, [r7, #20]
 8007c58:	2b00      	cmp	r3, #0
 8007c5a:	d107      	bne.n	8007c6c <ProcessBuffer+0x234>
            WOLFSSL_MSG("Need context for CA load");
            FreeDer(&der);
 8007c5c:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8007c60:	4618      	mov	r0, r3
 8007c62:	f005 fa91 	bl	800d188 <FreeDer>
            return BAD_FUNC_ARG;
 8007c66:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8007c6a:	e2c9      	b.n	8008200 <ProcessBuffer+0x7c8>
        }
        /* verify CA unless user set to no verify */
        ret = AddCA(ctx->cm, &der, WOLFSSL_USER_CA, verify);
 8007c6c:	697b      	ldr	r3, [r7, #20]
 8007c6e:	6c18      	ldr	r0, [r3, #64]	; 0x40
 8007c70:	f107 0138 	add.w	r1, r7, #56	; 0x38
 8007c74:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8007c78:	2201      	movs	r2, #1
 8007c7a:	f7ff fa6f 	bl	800715c <AddCA>
 8007c7e:	6678      	str	r0, [r7, #100]	; 0x64
        done = 1;
 8007c80:	2301      	movs	r3, #1
 8007c82:	663b      	str	r3, [r7, #96]	; 0x60
 8007c84:	e05f      	b.n	8007d46 <ProcessBuffer+0x30e>
        /* add trusted peer cert */
        ret = AddTrustedPeer(ctx->cm, &der, !ctx->verifyNone);
        done = 1;
    }
#endif /* WOLFSSL_TRUST_PEER_CERT */
    else if (type == CERT_TYPE) {
 8007c86:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8007c8a:	2b00      	cmp	r3, #0
 8007c8c:	d127      	bne.n	8007cde <ProcessBuffer+0x2a6>
        if (ssl) {
 8007c8e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007c92:	2b00      	cmp	r3, #0
 8007c94:	d017      	beq.n	8007cc6 <ProcessBuffer+0x28e>
             /* Make sure previous is free'd */
            if (ssl->buffers.weOwnCert) {
 8007c96:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007c9a:	f893 3134 	ldrb.w	r3, [r3, #308]	; 0x134
 8007c9e:	2b00      	cmp	r3, #0
 8007ca0:	d006      	beq.n	8007cb0 <ProcessBuffer+0x278>
                FreeDer(&ssl->buffers.certificate);
 8007ca2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007ca6:	f503 73ae 	add.w	r3, r3, #348	; 0x15c
 8007caa:	4618      	mov	r0, r3
 8007cac:	f005 fa6c 	bl	800d188 <FreeDer>
                    XFREE(ssl->ourCert, ssl->heap, DYNAMIC_TYPE_X509);
                    ssl->ourCert = NULL;
                }
            #endif
            }
            ssl->buffers.certificate = der;
 8007cb0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8007cb2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007cb6:	f8c3 215c 	str.w	r2, [r3, #348]	; 0x15c
        #ifdef KEEP_OUR_CERT
            ssl->keepCert = 1; /* hold cert for ssl lifetime */
        #endif
            ssl->buffers.weOwnCert = 1;
 8007cba:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007cbe:	2201      	movs	r2, #1
 8007cc0:	f883 2134 	strb.w	r2, [r3, #308]	; 0x134
 8007cc4:	e03f      	b.n	8007d46 <ProcessBuffer+0x30e>
        }
        else if (ctx) {
 8007cc6:	697b      	ldr	r3, [r7, #20]
 8007cc8:	2b00      	cmp	r3, #0
 8007cca:	d03c      	beq.n	8007d46 <ProcessBuffer+0x30e>
            FreeDer(&ctx->certificate); /* Make sure previous is free'd */
 8007ccc:	697b      	ldr	r3, [r7, #20]
 8007cce:	3324      	adds	r3, #36	; 0x24
 8007cd0:	4618      	mov	r0, r3
 8007cd2:	f005 fa59 	bl	800d188 <FreeDer>
                    XFREE(ctx->ourCert, ctx->heap, DYNAMIC_TYPE_X509);
                }
                ctx->ourCert = NULL;
            }
        #endif
            ctx->certificate = der;
 8007cd6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8007cd8:	697b      	ldr	r3, [r7, #20]
 8007cda:	625a      	str	r2, [r3, #36]	; 0x24
 8007cdc:	e033      	b.n	8007d46 <ProcessBuffer+0x30e>
        }
    }
    else if (type == PRIVATEKEY_TYPE) {
 8007cde:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8007ce2:	2b01      	cmp	r3, #1
 8007ce4:	d127      	bne.n	8007d36 <ProcessBuffer+0x2fe>
        if (ssl) {
 8007ce6:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007cea:	2b00      	cmp	r3, #0
 8007cec:	d017      	beq.n	8007d1e <ProcessBuffer+0x2e6>
             /* Make sure previous is free'd */
            if (ssl->buffers.weOwnKey) {
 8007cee:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007cf2:	f893 3136 	ldrb.w	r3, [r3, #310]	; 0x136
 8007cf6:	2b00      	cmp	r3, #0
 8007cf8:	d006      	beq.n	8007d08 <ProcessBuffer+0x2d0>
                FreeDer(&ssl->buffers.key);
 8007cfa:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007cfe:	f503 73b0 	add.w	r3, r3, #352	; 0x160
 8007d02:	4618      	mov	r0, r3
 8007d04:	f005 fa40 	bl	800d188 <FreeDer>
            }
            ssl->buffers.key = der;
 8007d08:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8007d0a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007d0e:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
            ssl->buffers.weOwnKey = 1;
 8007d12:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007d16:	2201      	movs	r2, #1
 8007d18:	f883 2136 	strb.w	r2, [r3, #310]	; 0x136
 8007d1c:	e013      	b.n	8007d46 <ProcessBuffer+0x30e>
        }
        else if (ctx) {
 8007d1e:	697b      	ldr	r3, [r7, #20]
 8007d20:	2b00      	cmp	r3, #0
 8007d22:	d010      	beq.n	8007d46 <ProcessBuffer+0x30e>
            FreeDer(&ctx->privateKey);
 8007d24:	697b      	ldr	r3, [r7, #20]
 8007d26:	3330      	adds	r3, #48	; 0x30
 8007d28:	4618      	mov	r0, r3
 8007d2a:	f005 fa2d 	bl	800d188 <FreeDer>
            ctx->privateKey = der;
 8007d2e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8007d30:	697b      	ldr	r3, [r7, #20]
 8007d32:	631a      	str	r2, [r3, #48]	; 0x30
 8007d34:	e007      	b.n	8007d46 <ProcessBuffer+0x30e>
        }
    }
    else {
        FreeDer(&der);
 8007d36:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8007d3a:	4618      	mov	r0, r3
 8007d3c:	f005 fa24 	bl	800d188 <FreeDer>
        return WOLFSSL_BAD_CERTTYPE;
 8007d40:	f06f 0307 	mvn.w	r3, #7
 8007d44:	e25c      	b.n	8008200 <ProcessBuffer+0x7c8>
    }

    if (done == 1) {
 8007d46:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8007d48:	2b01      	cmp	r3, #1
 8007d4a:	f000 81d5 	beq.w	80080f8 <ProcessBuffer+0x6c0>
        /* No operation, just skip the next section */
    }
    else if (type == PRIVATEKEY_TYPE && format != WOLFSSL_FILETYPE_RAW) {
 8007d4e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8007d52:	2b01      	cmp	r3, #1
 8007d54:	d12f      	bne.n	8007db6 <ProcessBuffer+0x37e>
 8007d56:	68bb      	ldr	r3, [r7, #8]
 8007d58:	2b03      	cmp	r3, #3
 8007d5a:	d02c      	beq.n	8007db6 <ProcessBuffer+0x37e>
    #if defined(WOLFSSL_ENCRYPTED_KEYS) || defined(HAVE_PKCS8)
        keyFormat = algId;
 8007d5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007d5e:	637b      	str	r3, [r7, #52]	; 0x34
    #endif

        ret = ProcessBufferTryDecode(ctx, ssl, der, &keySz, &idx, &resetSuites,
 8007d60:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8007d62:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8007d66:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007d68:	9304      	str	r3, [sp, #16]
 8007d6a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007d6c:	9303      	str	r3, [sp, #12]
 8007d6e:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8007d72:	9302      	str	r3, [sp, #8]
 8007d74:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8007d78:	9301      	str	r3, [sp, #4]
 8007d7a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8007d7e:	9300      	str	r3, [sp, #0]
 8007d80:	460b      	mov	r3, r1
 8007d82:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
 8007d86:	6978      	ldr	r0, [r7, #20]
 8007d88:	f7ff fd10 	bl	80077ac <ProcessBufferTryDecode>
 8007d8c:	6678      	str	r0, [r7, #100]	; 0x64
                &resetSuites, &keyFormat, heap, devId);
        }
    #endif /* WOLFSSL_ENCRYPTED_KEYS && !NO_PWDBASED */

    #ifdef WOLFSSL_SMALL_STACK
        XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 8007d8e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007d90:	64fb      	str	r3, [r7, #76]	; 0x4c
 8007d92:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007d94:	2b00      	cmp	r3, #0
 8007d96:	d002      	beq.n	8007d9e <ProcessBuffer+0x366>
 8007d98:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8007d9a:	f007 f8c9 	bl	800ef30 <wolfSSL_Free>
    #endif

        if (ret != 0)
 8007d9e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007da0:	2b00      	cmp	r3, #0
 8007da2:	d001      	beq.n	8007da8 <ProcessBuffer+0x370>
            return ret;
 8007da4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007da6:	e22b      	b.n	8008200 <ProcessBuffer+0x7c8>
        if (keyFormat == 0) {
 8007da8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007daa:	2b00      	cmp	r3, #0
 8007dac:	f040 81a3 	bne.w	80080f6 <ProcessBuffer+0x6be>
            /* Reaching this point probably means that the
             * decryption password is wrong */
            if (info->passwd_cb)
                EVPerr(0, EVP_R_BAD_DECRYPT);
#endif
            return WOLFSSL_BAD_FILE;
 8007db0:	f06f 0303 	mvn.w	r3, #3
 8007db4:	e224      	b.n	8008200 <ProcessBuffer+0x7c8>
        }

        (void)devId;
    }
    else if (type == CERT_TYPE) {
 8007db6:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8007dba:	2b00      	cmp	r3, #0
 8007dbc:	f040 819c 	bne.w	80080f8 <ProcessBuffer+0x6c0>
    #if defined(HAVE_PKCS11) || defined(HAVE_PK_CALLBACKS)
        int keyType = 0;
    #endif

    #ifdef WOLFSSL_SMALL_STACK
        cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), heap,
 8007dc0:	f44f 705f 	mov.w	r0, #892	; 0x37c
 8007dc4:	f007 f898 	bl	800eef8 <wolfSSL_Malloc>
 8007dc8:	64b8      	str	r0, [r7, #72]	; 0x48
                                     DYNAMIC_TYPE_DCERT);
        if (cert == NULL)
 8007dca:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007dcc:	2b00      	cmp	r3, #0
 8007dce:	d102      	bne.n	8007dd6 <ProcessBuffer+0x39e>
            return MEMORY_E;
 8007dd0:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 8007dd4:	e214      	b.n	8008200 <ProcessBuffer+0x7c8>
    #endif

        WOLFSSL_MSG("Checking cert signature type");
        InitDecodedCert(cert, der->buffer, der->length, heap);
 8007dd6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007dd8:	6819      	ldr	r1, [r3, #0]
 8007dda:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007ddc:	689a      	ldr	r2, [r3, #8]
 8007dde:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007de0:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8007de2:	f001 ff90 	bl	8009d06 <InitDecodedCert>

        if (DecodeToKey(cert, 0) < 0) {
 8007de6:	2100      	movs	r1, #0
 8007de8:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8007dea:	f002 fe5d 	bl	800aaa8 <DecodeToKey>
 8007dee:	4603      	mov	r3, r0
 8007df0:	2b00      	cmp	r3, #0
 8007df2:	da0d      	bge.n	8007e10 <ProcessBuffer+0x3d8>
            WOLFSSL_MSG("Decode to key failed");
            FreeDecodedCert(cert);
 8007df4:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8007df6:	f002 f805 	bl	8009e04 <FreeDecodedCert>
        #ifdef WOLFSSL_SMALL_STACK
            XFREE(cert, heap, DYNAMIC_TYPE_DCERT);
 8007dfa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007dfc:	643b      	str	r3, [r7, #64]	; 0x40
 8007dfe:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8007e00:	2b00      	cmp	r3, #0
 8007e02:	d002      	beq.n	8007e0a <ProcessBuffer+0x3d2>
 8007e04:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8007e06:	f007 f893 	bl	800ef30 <wolfSSL_Free>
        #endif
            return WOLFSSL_BAD_FILE;
 8007e0a:	f06f 0303 	mvn.w	r3, #3
 8007e0e:	e1f7      	b.n	8008200 <ProcessBuffer+0x7c8>
        }

        if (ssl && ssl->options.side == WOLFSSL_SERVER_END) {
 8007e10:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007e14:	2b00      	cmp	r3, #0
 8007e16:	d00a      	beq.n	8007e2e <ProcessBuffer+0x3f6>
 8007e18:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007e1c:	f893 331c 	ldrb.w	r3, [r3, #796]	; 0x31c
 8007e20:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8007e24:	b2db      	uxtb	r3, r3
 8007e26:	2b00      	cmp	r3, #0
 8007e28:	d101      	bne.n	8007e2e <ProcessBuffer+0x3f6>
            resetSuites = 1;
 8007e2a:	2301      	movs	r3, #1
 8007e2c:	633b      	str	r3, [r7, #48]	; 0x30
        }
        if (ssl && ssl->ctx->haveECDSAsig) {
 8007e2e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007e32:	2b00      	cmp	r3, #0
 8007e34:	d011      	beq.n	8007e5a <ProcessBuffer+0x422>
 8007e36:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007e3a:	681b      	ldr	r3, [r3, #0]
 8007e3c:	f893 304e 	ldrb.w	r3, [r3, #78]	; 0x4e
 8007e40:	f003 0310 	and.w	r3, r3, #16
 8007e44:	b2db      	uxtb	r3, r3
 8007e46:	2b00      	cmp	r3, #0
 8007e48:	d007      	beq.n	8007e5a <ProcessBuffer+0x422>
            WOLFSSL_MSG("SSL layer setting cert, CTX had ECDSA, turning off");
            ssl->options.haveECDSAsig = 0;   /* may turn back on next */
 8007e4a:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8007e4e:	f892 331f 	ldrb.w	r3, [r2, #799]	; 0x31f
 8007e52:	f36f 03c3 	bfc	r3, #3, #1
 8007e56:	f882 331f 	strb.w	r3, [r2, #799]	; 0x31f
        }

        switch (cert->signatureOID) {
 8007e5a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007e5c:	699b      	ldr	r3, [r3, #24]
 8007e5e:	f5b3 7f02 	cmp.w	r3, #520	; 0x208
 8007e62:	d00e      	beq.n	8007e82 <ProcessBuffer+0x44a>
 8007e64:	f5b3 7f02 	cmp.w	r3, #520	; 0x208
 8007e68:	d807      	bhi.n	8007e7a <ProcessBuffer+0x442>
 8007e6a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8007e6e:	d020      	beq.n	8007eb2 <ProcessBuffer+0x47a>
 8007e70:	f240 1201 	movw	r2, #257	; 0x101
 8007e74:	4293      	cmp	r3, r2
 8007e76:	d034      	beq.n	8007ee2 <ProcessBuffer+0x4aa>
                else if (ctx)
                    ctx->haveECDSAsig = 1;
                break;
            default:
                WOLFSSL_MSG("Not ECDSA cert signature");
                break;
 8007e78:	e04b      	b.n	8007f12 <ProcessBuffer+0x4da>
        switch (cert->signatureOID) {
 8007e7a:	f5a3 7303 	sub.w	r3, r3, #524	; 0x20c
 8007e7e:	2b02      	cmp	r3, #2
 8007e80:	d847      	bhi.n	8007f12 <ProcessBuffer+0x4da>
                if (ssl)
 8007e82:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007e86:	2b00      	cmp	r3, #0
 8007e88:	d008      	beq.n	8007e9c <ProcessBuffer+0x464>
                    ssl->options.haveECDSAsig = 1;
 8007e8a:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8007e8e:	f892 331f 	ldrb.w	r3, [r2, #799]	; 0x31f
 8007e92:	f043 0308 	orr.w	r3, r3, #8
 8007e96:	f882 331f 	strb.w	r3, [r2, #799]	; 0x31f
                break;
 8007e9a:	e03c      	b.n	8007f16 <ProcessBuffer+0x4de>
                else if (ctx)
 8007e9c:	697b      	ldr	r3, [r7, #20]
 8007e9e:	2b00      	cmp	r3, #0
 8007ea0:	d039      	beq.n	8007f16 <ProcessBuffer+0x4de>
                    ctx->haveECDSAsig = 1;
 8007ea2:	697a      	ldr	r2, [r7, #20]
 8007ea4:	f892 304e 	ldrb.w	r3, [r2, #78]	; 0x4e
 8007ea8:	f043 0310 	orr.w	r3, r3, #16
 8007eac:	f882 304e 	strb.w	r3, [r2, #78]	; 0x4e
                break;
 8007eb0:	e031      	b.n	8007f16 <ProcessBuffer+0x4de>
                if (ssl)
 8007eb2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007eb6:	2b00      	cmp	r3, #0
 8007eb8:	d008      	beq.n	8007ecc <ProcessBuffer+0x494>
                    ssl->options.haveECDSAsig = 1;
 8007eba:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8007ebe:	f892 331f 	ldrb.w	r3, [r2, #799]	; 0x31f
 8007ec2:	f043 0308 	orr.w	r3, r3, #8
 8007ec6:	f882 331f 	strb.w	r3, [r2, #799]	; 0x31f
                break;
 8007eca:	e026      	b.n	8007f1a <ProcessBuffer+0x4e2>
                else if (ctx)
 8007ecc:	697b      	ldr	r3, [r7, #20]
 8007ece:	2b00      	cmp	r3, #0
 8007ed0:	d023      	beq.n	8007f1a <ProcessBuffer+0x4e2>
                    ctx->haveECDSAsig = 1;
 8007ed2:	697a      	ldr	r2, [r7, #20]
 8007ed4:	f892 304e 	ldrb.w	r3, [r2, #78]	; 0x4e
 8007ed8:	f043 0310 	orr.w	r3, r3, #16
 8007edc:	f882 304e 	strb.w	r3, [r2, #78]	; 0x4e
                break;
 8007ee0:	e01b      	b.n	8007f1a <ProcessBuffer+0x4e2>
                if (ssl)
 8007ee2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007ee6:	2b00      	cmp	r3, #0
 8007ee8:	d008      	beq.n	8007efc <ProcessBuffer+0x4c4>
                    ssl->options.haveECDSAsig = 1;
 8007eea:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8007eee:	f892 331f 	ldrb.w	r3, [r2, #799]	; 0x31f
 8007ef2:	f043 0308 	orr.w	r3, r3, #8
 8007ef6:	f882 331f 	strb.w	r3, [r2, #799]	; 0x31f
                break;
 8007efa:	e010      	b.n	8007f1e <ProcessBuffer+0x4e6>
                else if (ctx)
 8007efc:	697b      	ldr	r3, [r7, #20]
 8007efe:	2b00      	cmp	r3, #0
 8007f00:	d00d      	beq.n	8007f1e <ProcessBuffer+0x4e6>
                    ctx->haveECDSAsig = 1;
 8007f02:	697a      	ldr	r2, [r7, #20]
 8007f04:	f892 304e 	ldrb.w	r3, [r2, #78]	; 0x4e
 8007f08:	f043 0310 	orr.w	r3, r3, #16
 8007f0c:	f882 304e 	strb.w	r3, [r2, #78]	; 0x4e
                break;
 8007f10:	e005      	b.n	8007f1e <ProcessBuffer+0x4e6>
                break;
 8007f12:	bf00      	nop
 8007f14:	e004      	b.n	8007f20 <ProcessBuffer+0x4e8>
                break;
 8007f16:	bf00      	nop
 8007f18:	e002      	b.n	8007f20 <ProcessBuffer+0x4e8>
                break;
 8007f1a:	bf00      	nop
 8007f1c:	e000      	b.n	8007f20 <ProcessBuffer+0x4e8>
                break;
 8007f1e:	bf00      	nop
        }

    #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)
        if (ssl) {
 8007f20:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007f24:	2b00      	cmp	r3, #0
 8007f26:	d015      	beq.n	8007f54 <ProcessBuffer+0x51c>
            ssl->pkCurveOID = cert->pkCurveOID;
 8007f28:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007f2a:	f8d3 2324 	ldr.w	r2, [r3, #804]	; 0x324
 8007f2e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007f32:	f8c3 23a0 	str.w	r2, [r3, #928]	; 0x3a0
        #ifndef WC_STRICT_SIG
            if (cert->keyOID == ECDSAk) {
 8007f36:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007f38:	69db      	ldr	r3, [r3, #28]
 8007f3a:	f240 2206 	movw	r2, #518	; 0x206
 8007f3e:	4293      	cmp	r3, r2
 8007f40:	d11d      	bne.n	8007f7e <ProcessBuffer+0x546>
                ssl->options.haveECC = 1;
 8007f42:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8007f46:	f892 331e 	ldrb.w	r3, [r2, #798]	; 0x31e
 8007f4a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8007f4e:	f882 331e 	strb.w	r3, [r2, #798]	; 0x31e
 8007f52:	e014      	b.n	8007f7e <ProcessBuffer+0x546>
            #endif
        #else
            ssl->options.haveECC = ssl->options.haveECDSAsig;
        #endif
        }
        else if (ctx) {
 8007f54:	697b      	ldr	r3, [r7, #20]
 8007f56:	2b00      	cmp	r3, #0
 8007f58:	d011      	beq.n	8007f7e <ProcessBuffer+0x546>
            ctx->pkCurveOID = cert->pkCurveOID;
 8007f5a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007f5c:	f8d3 2324 	ldr.w	r2, [r3, #804]	; 0x324
 8007f60:	697b      	ldr	r3, [r7, #20]
 8007f62:	679a      	str	r2, [r3, #120]	; 0x78
        #ifndef WC_STRICT_SIG
            if (cert->keyOID == ECDSAk) {
 8007f64:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007f66:	69db      	ldr	r3, [r3, #28]
 8007f68:	f240 2206 	movw	r2, #518	; 0x206
 8007f6c:	4293      	cmp	r3, r2
 8007f6e:	d106      	bne.n	8007f7e <ProcessBuffer+0x546>
                ctx->haveECC = 1;
 8007f70:	697a      	ldr	r2, [r7, #20]
 8007f72:	f892 304e 	ldrb.w	r3, [r2, #78]	; 0x4e
 8007f76:	f043 0302 	orr.w	r3, r3, #2
 8007f7a:	f882 304e 	strb.w	r3, [r2, #78]	; 0x4e
        #endif
        }
    #endif

        /* check key size of cert unless specified not to */
        switch (cert->keyOID) {
 8007f7e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007f80:	69db      	ldr	r3, [r3, #28]
 8007f82:	f240 2206 	movw	r2, #518	; 0x206
 8007f86:	4293      	cmp	r3, r2
 8007f88:	d057      	beq.n	800803a <ProcessBuffer+0x602>
 8007f8a:	f240 2285 	movw	r2, #645	; 0x285
 8007f8e:	4293      	cmp	r3, r2
 8007f90:	d000      	beq.n	8007f94 <ProcessBuffer+0x55c>
                break;
        #endif /* HAVE_ED448 */

            default:
                WOLFSSL_MSG("No key size check done on certificate");
                break; /* do no check if not a case for the key */
 8007f92:	e09f      	b.n	80080d4 <ProcessBuffer+0x69c>
                idx = 0;
 8007f94:	2300      	movs	r3, #0
 8007f96:	62fb      	str	r3, [r7, #44]	; 0x2c
                ret = wc_RsaPublicKeyDecode_ex(cert->publicKey, &idx,
 8007f98:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007f9a:	6818      	ldr	r0, [r3, #0]
 8007f9c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007f9e:	685a      	ldr	r2, [r3, #4]
 8007fa0:	f107 012c 	add.w	r1, r7, #44	; 0x2c
 8007fa4:	2300      	movs	r3, #0
 8007fa6:	9302      	str	r3, [sp, #8]
 8007fa8:	2300      	movs	r3, #0
 8007faa:	9301      	str	r3, [sp, #4]
 8007fac:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8007fb0:	9300      	str	r3, [sp, #0]
 8007fb2:	2300      	movs	r3, #0
 8007fb4:	f001 fd30 	bl	8009a18 <wc_RsaPublicKeyDecode_ex>
 8007fb8:	6678      	str	r0, [r7, #100]	; 0x64
                if (ret < 0)
 8007fba:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007fbc:	2b00      	cmp	r3, #0
 8007fbe:	f2c0 8084 	blt.w	80080ca <ProcessBuffer+0x692>
                if (ssl && !ssl->options.verifyNone) {
 8007fc2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007fc6:	2b00      	cmp	r3, #0
 8007fc8:	d01a      	beq.n	8008000 <ProcessBuffer+0x5c8>
 8007fca:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007fce:	f893 331c 	ldrb.w	r3, [r3, #796]	; 0x31c
 8007fd2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8007fd6:	b2db      	uxtb	r3, r3
 8007fd8:	2b00      	cmp	r3, #0
 8007fda:	d111      	bne.n	8008000 <ProcessBuffer+0x5c8>
                    if (ssl->options.minRsaKeySz < 0 ||
 8007fdc:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007fe0:	f9b3 3336 	ldrsh.w	r3, [r3, #822]	; 0x336
 8007fe4:	2b00      	cmp	r3, #0
 8007fe6:	db07      	blt.n	8007ff8 <ProcessBuffer+0x5c0>
                          keySz < (int)ssl->options.minRsaKeySz) {
 8007fe8:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007fec:	f9b3 3336 	ldrsh.w	r3, [r3, #822]	; 0x336
 8007ff0:	461a      	mov	r2, r3
 8007ff2:	6abb      	ldr	r3, [r7, #40]	; 0x28
                    if (ssl->options.minRsaKeySz < 0 ||
 8007ff4:	429a      	cmp	r2, r3
 8007ff6:	dd1e      	ble.n	8008036 <ProcessBuffer+0x5fe>
                        ret = RSA_KEY_SIZE_E;
 8007ff8:	f46f 73cc 	mvn.w	r3, #408	; 0x198
 8007ffc:	667b      	str	r3, [r7, #100]	; 0x64
                    if (ssl->options.minRsaKeySz < 0 ||
 8007ffe:	e01a      	b.n	8008036 <ProcessBuffer+0x5fe>
                else if (ctx && !ctx->verifyNone) {
 8008000:	697b      	ldr	r3, [r7, #20]
 8008002:	2b00      	cmp	r3, #0
 8008004:	d063      	beq.n	80080ce <ProcessBuffer+0x696>
 8008006:	697b      	ldr	r3, [r7, #20]
 8008008:	f893 304d 	ldrb.w	r3, [r3, #77]	; 0x4d
 800800c:	f003 0302 	and.w	r3, r3, #2
 8008010:	b2db      	uxtb	r3, r3
 8008012:	2b00      	cmp	r3, #0
 8008014:	d15b      	bne.n	80080ce <ProcessBuffer+0x696>
                    if (ctx->minRsaKeySz < 0 ||
 8008016:	697b      	ldr	r3, [r7, #20]
 8008018:	f9b3 3056 	ldrsh.w	r3, [r3, #86]	; 0x56
 800801c:	2b00      	cmp	r3, #0
 800801e:	db06      	blt.n	800802e <ProcessBuffer+0x5f6>
                                  keySz < (int)ctx->minRsaKeySz) {
 8008020:	697b      	ldr	r3, [r7, #20]
 8008022:	f9b3 3056 	ldrsh.w	r3, [r3, #86]	; 0x56
 8008026:	461a      	mov	r2, r3
 8008028:	6abb      	ldr	r3, [r7, #40]	; 0x28
                    if (ctx->minRsaKeySz < 0 ||
 800802a:	429a      	cmp	r2, r3
 800802c:	dd4f      	ble.n	80080ce <ProcessBuffer+0x696>
                        ret = RSA_KEY_SIZE_E;
 800802e:	f46f 73cc 	mvn.w	r3, #408	; 0x198
 8008032:	667b      	str	r3, [r7, #100]	; 0x64
                break;
 8008034:	e04b      	b.n	80080ce <ProcessBuffer+0x696>
                    if (ssl->options.minRsaKeySz < 0 ||
 8008036:	bf00      	nop
                break;
 8008038:	e049      	b.n	80080ce <ProcessBuffer+0x696>
                keySz = wc_ecc_get_curve_size_from_id(
 800803a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800803c:	f8d3 3324 	ldr.w	r3, [r3, #804]	; 0x324
 8008040:	2200      	movs	r2, #0
 8008042:	2100      	movs	r1, #0
 8008044:	4618      	mov	r0, r3
 8008046:	f006 fe3f 	bl	800ecc8 <wc_ecc_get_oid>
 800804a:	4603      	mov	r3, r0
 800804c:	4618      	mov	r0, r3
 800804e:	f006 f9f5 	bl	800e43c <wc_ecc_get_curve_size_from_id>
 8008052:	4603      	mov	r3, r0
 8008054:	62bb      	str	r3, [r7, #40]	; 0x28
                if (ssl && !ssl->options.verifyNone) {
 8008056:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800805a:	2b00      	cmp	r3, #0
 800805c:	d019      	beq.n	8008092 <ProcessBuffer+0x65a>
 800805e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8008062:	f893 331c 	ldrb.w	r3, [r3, #796]	; 0x31c
 8008066:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800806a:	b2db      	uxtb	r3, r3
 800806c:	2b00      	cmp	r3, #0
 800806e:	d110      	bne.n	8008092 <ProcessBuffer+0x65a>
                    if (ssl->options.minEccKeySz < 0 ||
 8008070:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8008074:	f9b3 3338 	ldrsh.w	r3, [r3, #824]	; 0x338
 8008078:	2b00      	cmp	r3, #0
 800807a:	db07      	blt.n	800808c <ProcessBuffer+0x654>
                          keySz < (int)ssl->options.minEccKeySz) {
 800807c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8008080:	f9b3 3338 	ldrsh.w	r3, [r3, #824]	; 0x338
 8008084:	461a      	mov	r2, r3
 8008086:	6abb      	ldr	r3, [r7, #40]	; 0x28
                    if (ssl->options.minEccKeySz < 0 ||
 8008088:	429a      	cmp	r2, r3
 800808a:	dd1c      	ble.n	80080c6 <ProcessBuffer+0x68e>
                        ret = ECC_KEY_SIZE_E;
 800808c:	4b5e      	ldr	r3, [pc, #376]	; (8008208 <ProcessBuffer+0x7d0>)
 800808e:	667b      	str	r3, [r7, #100]	; 0x64
                    if (ssl->options.minEccKeySz < 0 ||
 8008090:	e019      	b.n	80080c6 <ProcessBuffer+0x68e>
                else if (ctx && !ctx->verifyNone) {
 8008092:	697b      	ldr	r3, [r7, #20]
 8008094:	2b00      	cmp	r3, #0
 8008096:	d01c      	beq.n	80080d2 <ProcessBuffer+0x69a>
 8008098:	697b      	ldr	r3, [r7, #20]
 800809a:	f893 304d 	ldrb.w	r3, [r3, #77]	; 0x4d
 800809e:	f003 0302 	and.w	r3, r3, #2
 80080a2:	b2db      	uxtb	r3, r3
 80080a4:	2b00      	cmp	r3, #0
 80080a6:	d114      	bne.n	80080d2 <ProcessBuffer+0x69a>
                    if (ctx->minEccKeySz < 0 ||
 80080a8:	697b      	ldr	r3, [r7, #20]
 80080aa:	f9b3 3058 	ldrsh.w	r3, [r3, #88]	; 0x58
 80080ae:	2b00      	cmp	r3, #0
 80080b0:	db06      	blt.n	80080c0 <ProcessBuffer+0x688>
                                  keySz < (int)ctx->minEccKeySz) {
 80080b2:	697b      	ldr	r3, [r7, #20]
 80080b4:	f9b3 3058 	ldrsh.w	r3, [r3, #88]	; 0x58
 80080b8:	461a      	mov	r2, r3
 80080ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
                    if (ctx->minEccKeySz < 0 ||
 80080bc:	429a      	cmp	r2, r3
 80080be:	dd08      	ble.n	80080d2 <ProcessBuffer+0x69a>
                        ret = ECC_KEY_SIZE_E;
 80080c0:	4b51      	ldr	r3, [pc, #324]	; (8008208 <ProcessBuffer+0x7d0>)
 80080c2:	667b      	str	r3, [r7, #100]	; 0x64
                break;
 80080c4:	e005      	b.n	80080d2 <ProcessBuffer+0x69a>
                    if (ssl->options.minEccKeySz < 0 ||
 80080c6:	bf00      	nop
                break;
 80080c8:	e003      	b.n	80080d2 <ProcessBuffer+0x69a>
                    break;
 80080ca:	bf00      	nop
 80080cc:	e002      	b.n	80080d4 <ProcessBuffer+0x69c>
                break;
 80080ce:	bf00      	nop
 80080d0:	e000      	b.n	80080d4 <ProcessBuffer+0x69c>
                break;
 80080d2:	bf00      	nop
            ctx->privateKeyType = keyType;
            ctx->privateKeySz = keySz;
        }
    #endif

        FreeDecodedCert(cert);
 80080d4:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 80080d6:	f001 fe95 	bl	8009e04 <FreeDecodedCert>
    #ifdef WOLFSSL_SMALL_STACK
        XFREE(cert, heap, DYNAMIC_TYPE_DCERT);
 80080da:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80080dc:	647b      	str	r3, [r7, #68]	; 0x44
 80080de:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80080e0:	2b00      	cmp	r3, #0
 80080e2:	d002      	beq.n	80080ea <ProcessBuffer+0x6b2>
 80080e4:	6c78      	ldr	r0, [r7, #68]	; 0x44
 80080e6:	f006 ff23 	bl	800ef30 <wolfSSL_Free>
    #endif

        if (ret != 0) {
 80080ea:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80080ec:	2b00      	cmp	r3, #0
 80080ee:	d003      	beq.n	80080f8 <ProcessBuffer+0x6c0>
            done = 1;
 80080f0:	2301      	movs	r3, #1
 80080f2:	663b      	str	r3, [r7, #96]	; 0x60
 80080f4:	e000      	b.n	80080f8 <ProcessBuffer+0x6c0>
        (void)devId;
 80080f6:	bf00      	nop
        }
    }

    if (done == 1) {
 80080f8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80080fa:	2b01      	cmp	r3, #1
 80080fc:	d124      	bne.n	8008148 <ProcessBuffer+0x710>
    #if !defined(NO_WOLFSSL_CM_VERIFY) && (!defined(NO_WOLFSSL_CLIENT) || \
                                           !defined(WOLFSSL_NO_CLIENT_AUTH))
        if ((type == CA_TYPE) || (type == CERT_TYPE)) {
 80080fe:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8008102:	2b05      	cmp	r3, #5
 8008104:	d003      	beq.n	800810e <ProcessBuffer+0x6d6>
 8008106:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800810a:	2b00      	cmp	r3, #0
 800810c:	d11a      	bne.n	8008144 <ProcessBuffer+0x70c>
            /* Call to over-ride status */
            if ((ctx != NULL) && (ctx->cm != NULL) &&
 800810e:	697b      	ldr	r3, [r7, #20]
 8008110:	2b00      	cmp	r3, #0
 8008112:	d017      	beq.n	8008144 <ProcessBuffer+0x70c>
 8008114:	697b      	ldr	r3, [r7, #20]
 8008116:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008118:	2b00      	cmp	r3, #0
 800811a:	d013      	beq.n	8008144 <ProcessBuffer+0x70c>
                (ctx->cm->verifyCallback != NULL)) {
 800811c:	697b      	ldr	r3, [r7, #20]
 800811e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008120:	6c1b      	ldr	r3, [r3, #64]	; 0x40
            if ((ctx != NULL) && (ctx->cm != NULL) &&
 8008122:	2b00      	cmp	r3, #0
 8008124:	d00e      	beq.n	8008144 <ProcessBuffer+0x70c>
                ret = CM_VerifyBuffer_ex(ctx->cm, buff,
 8008126:	697b      	ldr	r3, [r7, #20]
 8008128:	6c18      	ldr	r0, [r3, #64]	; 0x40
 800812a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800812c:	2b01      	cmp	r3, #1
 800812e:	d001      	beq.n	8008134 <ProcessBuffer+0x6fc>
 8008130:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8008132:	e000      	b.n	8008136 <ProcessBuffer+0x6fe>
 8008134:	2300      	movs	r3, #0
 8008136:	9300      	str	r3, [sp, #0]
 8008138:	68bb      	ldr	r3, [r7, #8]
 800813a:	68fa      	ldr	r2, [r7, #12]
 800813c:	6939      	ldr	r1, [r7, #16]
 800813e:	f000 f8a6 	bl	800828e <CM_VerifyBuffer_ex>
 8008142:	6678      	str	r0, [r7, #100]	; 0x64
                        sz, format, (ret == WOLFSSL_SUCCESS ? 0 : ret));
            }
        }
    #endif /* NO_WOLFSSL_CM_VERIFY */

        return ret;
 8008144:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8008146:	e05b      	b.n	8008200 <ProcessBuffer+0x7c8>
    }


    if (ssl && resetSuites) {
 8008148:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800814c:	2b00      	cmp	r3, #0
 800814e:	d056      	beq.n	80081fe <ProcessBuffer+0x7c6>
 8008150:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008152:	2b00      	cmp	r3, #0
 8008154:	d053      	beq.n	80081fe <ProcessBuffer+0x7c6>
        word16 havePSK = 0;
 8008156:	2300      	movs	r3, #0
 8008158:	87fb      	strh	r3, [r7, #62]	; 0x3e
        word16 haveRSA = 0;
 800815a:	2300      	movs	r3, #0
 800815c:	87bb      	strh	r3, [r7, #60]	; 0x3c
        if (ssl->options.havePSK) {
            havePSK = 1;
        }
        #endif
        #ifndef NO_RSA
            haveRSA = 1;
 800815e:	2301      	movs	r3, #1
 8008160:	87bb      	strh	r3, [r7, #60]	; 0x3c
        #endif
        #ifndef NO_CERTS
            keySz = ssl->buffers.keySz;
 8008162:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8008166:	f8d3 3168 	ldr.w	r3, [r3, #360]	; 0x168
 800816a:	62bb      	str	r3, [r7, #40]	; 0x28
        #endif

        /* let's reset suites */
        InitSuites(ssl->suites, ssl->version, keySz, haveRSA,
 800816c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8008170:	685b      	ldr	r3, [r3, #4]
 8008172:	607b      	str	r3, [r7, #4]
 8008174:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008176:	603b      	str	r3, [r7, #0]
                   havePSK, ssl->options.haveDH, ssl->options.haveNTRU,
 8008178:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800817c:	f893 331f 	ldrb.w	r3, [r3, #799]	; 0x31f
 8008180:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8008184:	b2db      	uxtb	r3, r3
        InitSuites(ssl->suites, ssl->version, keySz, haveRSA,
 8008186:	b29b      	uxth	r3, r3
                   havePSK, ssl->options.haveDH, ssl->options.haveNTRU,
 8008188:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800818c:	f892 231f 	ldrb.w	r2, [r2, #799]	; 0x31f
 8008190:	f3c2 0240 	ubfx	r2, r2, #1, #1
 8008194:	b2d2      	uxtb	r2, r2
        InitSuites(ssl->suites, ssl->version, keySz, haveRSA,
 8008196:	b292      	uxth	r2, r2
                   ssl->options.haveECDSAsig, ssl->options.haveECC,
 8008198:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
 800819c:	f891 131f 	ldrb.w	r1, [r1, #799]	; 0x31f
 80081a0:	f3c1 01c0 	ubfx	r1, r1, #3, #1
 80081a4:	b2c9      	uxtb	r1, r1
        InitSuites(ssl->suites, ssl->version, keySz, haveRSA,
 80081a6:	b288      	uxth	r0, r1
                   ssl->options.haveECDSAsig, ssl->options.haveECC,
 80081a8:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
 80081ac:	f891 131e 	ldrb.w	r1, [r1, #798]	; 0x31e
 80081b0:	f3c1 11c0 	ubfx	r1, r1, #7, #1
 80081b4:	b2c9      	uxtb	r1, r1
        InitSuites(ssl->suites, ssl->version, keySz, haveRSA,
 80081b6:	b28c      	uxth	r4, r1
                   ssl->options.haveStaticECC, ssl->options.side);
 80081b8:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
 80081bc:	f891 131f 	ldrb.w	r1, [r1, #799]	; 0x31f
 80081c0:	f3c1 1100 	ubfx	r1, r1, #4, #1
 80081c4:	b2c9      	uxtb	r1, r1
        InitSuites(ssl->suites, ssl->version, keySz, haveRSA,
 80081c6:	b28d      	uxth	r5, r1
                   ssl->options.haveStaticECC, ssl->options.side);
 80081c8:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
 80081cc:	f891 131c 	ldrb.w	r1, [r1, #796]	; 0x31c
 80081d0:	f3c1 1101 	ubfx	r1, r1, #4, #2
 80081d4:	b2c9      	uxtb	r1, r1
        InitSuites(ssl->suites, ssl->version, keySz, haveRSA,
 80081d6:	f8b7 c03c 	ldrh.w	ip, [r7, #60]	; 0x3c
 80081da:	f8d7 6084 	ldr.w	r6, [r7, #132]	; 0x84
 80081de:	9106      	str	r1, [sp, #24]
 80081e0:	9505      	str	r5, [sp, #20]
 80081e2:	9404      	str	r4, [sp, #16]
 80081e4:	9003      	str	r0, [sp, #12]
 80081e6:	9202      	str	r2, [sp, #8]
 80081e8:	9301      	str	r3, [sp, #4]
 80081ea:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 80081ec:	9300      	str	r3, [sp, #0]
 80081ee:	4663      	mov	r3, ip
 80081f0:	683a      	ldr	r2, [r7, #0]
 80081f2:	4631      	mov	r1, r6
 80081f4:	f8d1 122c 	ldr.w	r1, [r1, #556]	; 0x22c
 80081f8:	6878      	ldr	r0, [r7, #4]
 80081fa:	f7fe fa99 	bl	8006730 <InitSuites>
    }

    return WOLFSSL_SUCCESS;
 80081fe:	2301      	movs	r3, #1
}
 8008200:	4618      	mov	r0, r3
 8008202:	376c      	adds	r7, #108	; 0x6c
 8008204:	46bd      	mov	sp, r7
 8008206:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008208:	fffffe66 	.word	0xfffffe66

0800820c <ProcessChainBuffer>:


/* CA PEM file for verification, may have multiple/chain certs to process */
static int ProcessChainBuffer(WOLFSSL_CTX* ctx, const unsigned char* buff,
                        long sz, int format, int type, WOLFSSL* ssl, int verify)
{
 800820c:	b580      	push	{r7, lr}
 800820e:	b08e      	sub	sp, #56	; 0x38
 8008210:	af06      	add	r7, sp, #24
 8008212:	60f8      	str	r0, [r7, #12]
 8008214:	60b9      	str	r1, [r7, #8]
 8008216:	607a      	str	r2, [r7, #4]
 8008218:	603b      	str	r3, [r7, #0]
    long used   = 0;
 800821a:	2300      	movs	r3, #0
 800821c:	61fb      	str	r3, [r7, #28]
    int  ret    = 0;
 800821e:	2300      	movs	r3, #0
 8008220:	61bb      	str	r3, [r7, #24]
    int  gotOne = 0;
 8008222:	2300      	movs	r3, #0
 8008224:	617b      	str	r3, [r7, #20]

    WOLFSSL_MSG("Processing CA PEM file");
    while (used < sz) {
 8008226:	e024      	b.n	8008272 <ProcessChainBuffer+0x66>
        long consumed = 0;
 8008228:	2300      	movs	r3, #0
 800822a:	613b      	str	r3, [r7, #16]

        ret = ProcessBuffer(ctx, buff + used, sz - used, format, type, ssl,
 800822c:	69fb      	ldr	r3, [r7, #28]
 800822e:	68ba      	ldr	r2, [r7, #8]
 8008230:	18d1      	adds	r1, r2, r3
 8008232:	687a      	ldr	r2, [r7, #4]
 8008234:	69fb      	ldr	r3, [r7, #28]
 8008236:	1ad2      	subs	r2, r2, r3
 8008238:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800823a:	9304      	str	r3, [sp, #16]
 800823c:	2300      	movs	r3, #0
 800823e:	9303      	str	r3, [sp, #12]
 8008240:	f107 0310 	add.w	r3, r7, #16
 8008244:	9302      	str	r3, [sp, #8]
 8008246:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008248:	9301      	str	r3, [sp, #4]
 800824a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800824c:	9300      	str	r3, [sp, #0]
 800824e:	683b      	ldr	r3, [r7, #0]
 8008250:	68f8      	ldr	r0, [r7, #12]
 8008252:	f7ff fbf1 	bl	8007a38 <ProcessBuffer>
 8008256:	61b8      	str	r0, [r7, #24]
                            &consumed, 0, verify);

        if (ret < 0) {
 8008258:	69bb      	ldr	r3, [r7, #24]
 800825a:	2b00      	cmp	r3, #0
 800825c:	da03      	bge.n	8008266 <ProcessChainBuffer+0x5a>
                used += info.consumed;
                continue;
            }
#endif

            if (consumed > 0) { /* Made progress in file */
 800825e:	693b      	ldr	r3, [r7, #16]
 8008260:	2b00      	cmp	r3, #0
 8008262:	dc02      	bgt.n	800826a <ProcessChainBuffer+0x5e>
                WOLFSSL_MSG("Search for other certs in file");
            }
            else {
                WOLFSSL_MSG("CA Parse failed, no progress in file.");
                WOLFSSL_MSG("Do not continue search for other certs in file");
                break;
 8008264:	e009      	b.n	800827a <ProcessChainBuffer+0x6e>
            }
        }
        else {
            WOLFSSL_MSG("   Processed a CA");
            gotOne = 1;
 8008266:	2301      	movs	r3, #1
 8008268:	617b      	str	r3, [r7, #20]
        }
        used += consumed;
 800826a:	693b      	ldr	r3, [r7, #16]
 800826c:	69fa      	ldr	r2, [r7, #28]
 800826e:	4413      	add	r3, r2
 8008270:	61fb      	str	r3, [r7, #28]
    while (used < sz) {
 8008272:	69fa      	ldr	r2, [r7, #28]
 8008274:	687b      	ldr	r3, [r7, #4]
 8008276:	429a      	cmp	r2, r3
 8008278:	dbd6      	blt.n	8008228 <ProcessChainBuffer+0x1c>
    }

    if (gotOne) {
 800827a:	697b      	ldr	r3, [r7, #20]
 800827c:	2b00      	cmp	r3, #0
 800827e:	d001      	beq.n	8008284 <ProcessChainBuffer+0x78>
        WOLFSSL_MSG("Processed at least one valid CA. Other stuff OK");
        return WOLFSSL_SUCCESS;
 8008280:	2301      	movs	r3, #1
 8008282:	e000      	b.n	8008286 <ProcessChainBuffer+0x7a>
    }
    return ret;
 8008284:	69bb      	ldr	r3, [r7, #24]
}
 8008286:	4618      	mov	r0, r3
 8008288:	3720      	adds	r7, #32
 800828a:	46bd      	mov	sp, r7
 800828c:	bd80      	pop	{r7, pc}

0800828e <CM_VerifyBuffer_ex>:

#if !defined(NO_WOLFSSL_CLIENT) || !defined(WOLFSSL_NO_CLIENT_AUTH)
/* Verify the certificate, WOLFSSL_SUCCESS for ok, < 0 for error */
int CM_VerifyBuffer_ex(WOLFSSL_CERT_MANAGER* cm, const byte* buff,
                                    long sz, int format, int err_val)
{
 800828e:	b580      	push	{r7, lr}
 8008290:	b092      	sub	sp, #72	; 0x48
 8008292:	af04      	add	r7, sp, #16
 8008294:	60f8      	str	r0, [r7, #12]
 8008296:	60b9      	str	r1, [r7, #8]
 8008298:	607a      	str	r2, [r7, #4]
 800829a:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800829c:	2300      	movs	r3, #0
 800829e:	637b      	str	r3, [r7, #52]	; 0x34
    DerBuffer* der = NULL;
 80082a0:	2300      	movs	r3, #0
 80082a2:	61bb      	str	r3, [r7, #24]
#endif

    WOLFSSL_ENTER("wolfSSL_CertManagerVerifyBuffer");

#ifdef WOLFSSL_SMALL_STACK
    cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), cm->heap,
 80082a4:	f44f 705f 	mov.w	r0, #892	; 0x37c
 80082a8:	f006 fe26 	bl	800eef8 <wolfSSL_Malloc>
 80082ac:	6338      	str	r0, [r7, #48]	; 0x30
                                 DYNAMIC_TYPE_DCERT);
    if (cert == NULL)
 80082ae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80082b0:	2b00      	cmp	r3, #0
 80082b2:	d102      	bne.n	80082ba <CM_VerifyBuffer_ex+0x2c>
        return MEMORY_E;
 80082b4:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 80082b8:	e099      	b.n	80083ee <CM_VerifyBuffer_ex+0x160>
#endif

    if (format == WOLFSSL_FILETYPE_PEM) {
 80082ba:	683b      	ldr	r3, [r7, #0]
 80082bc:	2b01      	cmp	r3, #1
 80082be:	d12b      	bne.n	8008318 <CM_VerifyBuffer_ex+0x8a>
#ifdef WOLFSSL_PEM_TO_DER
        ret = PemToDer(buff, sz, CERT_TYPE, &der, cm->heap, NULL, NULL);
 80082c0:	68fb      	ldr	r3, [r7, #12]
 80082c2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80082c4:	f107 0118 	add.w	r1, r7, #24
 80082c8:	2200      	movs	r2, #0
 80082ca:	9202      	str	r2, [sp, #8]
 80082cc:	2200      	movs	r2, #0
 80082ce:	9201      	str	r2, [sp, #4]
 80082d0:	9300      	str	r3, [sp, #0]
 80082d2:	460b      	mov	r3, r1
 80082d4:	2200      	movs	r2, #0
 80082d6:	6879      	ldr	r1, [r7, #4]
 80082d8:	68b8      	ldr	r0, [r7, #8]
 80082da:	f005 f881 	bl	800d3e0 <PemToDer>
 80082de:	6378      	str	r0, [r7, #52]	; 0x34
        if (ret != 0) {
 80082e0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80082e2:	2b00      	cmp	r3, #0
 80082e4:	d00e      	beq.n	8008304 <CM_VerifyBuffer_ex+0x76>
            FreeDer(&der);
 80082e6:	f107 0318 	add.w	r3, r7, #24
 80082ea:	4618      	mov	r0, r3
 80082ec:	f004 ff4c 	bl	800d188 <FreeDer>
        #ifdef WOLFSSL_SMALL_STACK
            XFREE(cert, cm->heap, DYNAMIC_TYPE_DCERT);
 80082f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80082f2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80082f4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80082f6:	2b00      	cmp	r3, #0
 80082f8:	d002      	beq.n	8008300 <CM_VerifyBuffer_ex+0x72>
 80082fa:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80082fc:	f006 fe18 	bl	800ef30 <wolfSSL_Free>
        #endif
            return ret;
 8008300:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008302:	e074      	b.n	80083ee <CM_VerifyBuffer_ex+0x160>
        }
        InitDecodedCert(cert, der->buffer, der->length, cm->heap);
 8008304:	69bb      	ldr	r3, [r7, #24]
 8008306:	6819      	ldr	r1, [r3, #0]
 8008308:	69bb      	ldr	r3, [r7, #24]
 800830a:	689a      	ldr	r2, [r3, #8]
 800830c:	68fb      	ldr	r3, [r7, #12]
 800830e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8008310:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8008312:	f001 fcf8 	bl	8009d06 <InitDecodedCert>
 8008316:	e006      	b.n	8008326 <CM_VerifyBuffer_ex+0x98>
#else
        ret = NOT_COMPILED_IN;
#endif
    }
    else {
        InitDecodedCert(cert, (byte*)buff, (word32)sz, cm->heap);
 8008318:	687a      	ldr	r2, [r7, #4]
 800831a:	68fb      	ldr	r3, [r7, #12]
 800831c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800831e:	68b9      	ldr	r1, [r7, #8]
 8008320:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8008322:	f001 fcf0 	bl	8009d06 <InitDecodedCert>
    }

    if (ret == 0)
 8008326:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008328:	2b00      	cmp	r3, #0
 800832a:	d106      	bne.n	800833a <CM_VerifyBuffer_ex+0xac>
        ret = ParseCertRelative(cert, CERT_TYPE, 1, cm);
 800832c:	68fb      	ldr	r3, [r7, #12]
 800832e:	2201      	movs	r2, #1
 8008330:	2100      	movs	r1, #0
 8008332:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8008334:	f004 fb7c 	bl	800ca30 <ParseCertRelative>
 8008338:	6378      	str	r0, [r7, #52]	; 0x34
        ret = CheckCertCRL(cm->crl, cert);
#endif

#ifndef NO_WOLFSSL_CM_VERIFY
    /* if verify callback has been set */
    if (cm->verifyCallback) {
 800833a:	68fb      	ldr	r3, [r7, #12]
 800833c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800833e:	2b00      	cmp	r3, #0
 8008340:	d03f      	beq.n	80083c2 <CM_VerifyBuffer_ex+0x134>
        buffer certBuf;
    #ifdef WOLFSSL_SMALL_STACK
        ProcPeerCertArgs* args;
        args = (ProcPeerCertArgs*)XMALLOC(
 8008342:	2028      	movs	r0, #40	; 0x28
 8008344:	f006 fdd8 	bl	800eef8 <wolfSSL_Malloc>
 8008348:	62b8      	str	r0, [r7, #40]	; 0x28
            sizeof(ProcPeerCertArgs), cm->heap, DYNAMIC_TYPE_TMP_BUFFER);
        if (args == NULL) {
 800834a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800834c:	2b00      	cmp	r3, #0
 800834e:	d10a      	bne.n	8008366 <CM_VerifyBuffer_ex+0xd8>
            XFREE(cert, cm->heap, DYNAMIC_TYPE_DCERT);
 8008350:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008352:	623b      	str	r3, [r7, #32]
 8008354:	6a3b      	ldr	r3, [r7, #32]
 8008356:	2b00      	cmp	r3, #0
 8008358:	d002      	beq.n	8008360 <CM_VerifyBuffer_ex+0xd2>
 800835a:	6a38      	ldr	r0, [r7, #32]
 800835c:	f006 fde8 	bl	800ef30 <wolfSSL_Free>
            return MEMORY_E;
 8008360:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 8008364:	e043      	b.n	80083ee <CM_VerifyBuffer_ex+0x160>
        }
    #else
        ProcPeerCertArgs  args[1];
    #endif

        certBuf.buffer = (byte*)buff;
 8008366:	68bb      	ldr	r3, [r7, #8]
 8008368:	613b      	str	r3, [r7, #16]
        certBuf.length = (unsigned int)sz;
 800836a:	687b      	ldr	r3, [r7, #4]
 800836c:	617b      	str	r3, [r7, #20]
        XMEMSET(args, 0, sizeof(ProcPeerCertArgs));
 800836e:	2228      	movs	r2, #40	; 0x28
 8008370:	2100      	movs	r1, #0
 8008372:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8008374:	f011 f863 	bl	801943e <memset>

        args->totalCerts = 1;
 8008378:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800837a:	2201      	movs	r2, #1
 800837c:	615a      	str	r2, [r3, #20]
        args->certs = &certBuf;
 800837e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008380:	f107 0210 	add.w	r2, r7, #16
 8008384:	601a      	str	r2, [r3, #0]
        args->dCert = cert;
 8008386:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008388:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800838a:	609a      	str	r2, [r3, #8]
        args->dCertInit = 1;
 800838c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800838e:	f892 3025 	ldrb.w	r3, [r2, #37]	; 0x25
 8008392:	f043 0304 	orr.w	r3, r3, #4
 8008396:	f882 3025 	strb.w	r3, [r2, #37]	; 0x25

        if (err_val != 0) {
 800839a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800839c:	2b00      	cmp	r3, #0
 800839e:	d001      	beq.n	80083a4 <CM_VerifyBuffer_ex+0x116>
            ret = err_val;
 80083a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80083a2:	637b      	str	r3, [r7, #52]	; 0x34
        }
        ret = DoVerifyCallback(cm, NULL, ret, args);
 80083a4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80083a6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80083a8:	2100      	movs	r1, #0
 80083aa:	68f8      	ldr	r0, [r7, #12]
 80083ac:	f7fe fb9c 	bl	8006ae8 <DoVerifyCallback>
 80083b0:	6378      	str	r0, [r7, #52]	; 0x34
    #ifdef WOLFSSL_SMALL_STACK
        XFREE(args, cm->heap, DYNAMIC_TYPE_TMP_BUFFER);
 80083b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80083b4:	627b      	str	r3, [r7, #36]	; 0x24
 80083b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80083b8:	2b00      	cmp	r3, #0
 80083ba:	d002      	beq.n	80083c2 <CM_VerifyBuffer_ex+0x134>
 80083bc:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80083be:	f006 fdb7 	bl	800ef30 <wolfSSL_Free>
    }
#else
    (void)err_val;
#endif

    FreeDecodedCert(cert);
 80083c2:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80083c4:	f001 fd1e 	bl	8009e04 <FreeDecodedCert>
    FreeDer(&der);
 80083c8:	f107 0318 	add.w	r3, r7, #24
 80083cc:	4618      	mov	r0, r3
 80083ce:	f004 fedb 	bl	800d188 <FreeDer>
#ifdef WOLFSSL_SMALL_STACK
    XFREE(cert, cm->heap, DYNAMIC_TYPE_DCERT);
 80083d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80083d4:	61fb      	str	r3, [r7, #28]
 80083d6:	69fb      	ldr	r3, [r7, #28]
 80083d8:	2b00      	cmp	r3, #0
 80083da:	d002      	beq.n	80083e2 <CM_VerifyBuffer_ex+0x154>
 80083dc:	69f8      	ldr	r0, [r7, #28]
 80083de:	f006 fda7 	bl	800ef30 <wolfSSL_Free>
#endif

    return ret == 0 ? WOLFSSL_SUCCESS : ret;
 80083e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80083e4:	2b00      	cmp	r3, #0
 80083e6:	d001      	beq.n	80083ec <CM_VerifyBuffer_ex+0x15e>
 80083e8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80083ea:	e000      	b.n	80083ee <CM_VerifyBuffer_ex+0x160>
 80083ec:	2301      	movs	r3, #1
}
 80083ee:	4618      	mov	r0, r3
 80083f0:	3738      	adds	r7, #56	; 0x38
 80083f2:	46bd      	mov	sp, r7
 80083f4:	bd80      	pop	{r7, pc}

080083f6 <wolfSSL_CTX_load_verify_buffer_ex>:

    int wolfSSL_CTX_load_verify_buffer_ex(WOLFSSL_CTX* ctx,
                                         const unsigned char* in,
                                         long sz, int format, int userChain,
                                         word32 flags)
    {
 80083f6:	b580      	push	{r7, lr}
 80083f8:	b08c      	sub	sp, #48	; 0x30
 80083fa:	af06      	add	r7, sp, #24
 80083fc:	60f8      	str	r0, [r7, #12]
 80083fe:	60b9      	str	r1, [r7, #8]
 8008400:	607a      	str	r2, [r7, #4]
 8008402:	603b      	str	r3, [r7, #0]
        int verify;
        int ret = WOLFSSL_FAILURE;
 8008404:	2300      	movs	r3, #0
 8008406:	613b      	str	r3, [r7, #16]

        WOLFSSL_ENTER("wolfSSL_CTX_load_verify_buffer_ex");

        verify = GET_VERIFY_SETTING_CTX(ctx);
 8008408:	68fb      	ldr	r3, [r7, #12]
 800840a:	2b00      	cmp	r3, #0
 800840c:	d007      	beq.n	800841e <wolfSSL_CTX_load_verify_buffer_ex+0x28>
 800840e:	68fb      	ldr	r3, [r7, #12]
 8008410:	f893 304d 	ldrb.w	r3, [r3, #77]	; 0x4d
 8008414:	f003 0302 	and.w	r3, r3, #2
 8008418:	b2db      	uxtb	r3, r3
 800841a:	2b00      	cmp	r3, #0
 800841c:	d101      	bne.n	8008422 <wolfSSL_CTX_load_verify_buffer_ex+0x2c>
 800841e:	2301      	movs	r3, #1
 8008420:	e000      	b.n	8008424 <wolfSSL_CTX_load_verify_buffer_ex+0x2e>
 8008422:	2300      	movs	r3, #0
 8008424:	617b      	str	r3, [r7, #20]
        if (flags & WOLFSSL_LOAD_FLAG_DATE_ERR_OKAY)
 8008426:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008428:	f003 0302 	and.w	r3, r3, #2
 800842c:	2b00      	cmp	r3, #0
 800842e:	d001      	beq.n	8008434 <wolfSSL_CTX_load_verify_buffer_ex+0x3e>
            verify = VERIFY_SKIP_DATE;
 8008430:	2305      	movs	r3, #5
 8008432:	617b      	str	r3, [r7, #20]

        if (format == WOLFSSL_FILETYPE_PEM)
 8008434:	683b      	ldr	r3, [r7, #0]
 8008436:	2b01      	cmp	r3, #1
 8008438:	d10d      	bne.n	8008456 <wolfSSL_CTX_load_verify_buffer_ex+0x60>
            ret = ProcessChainBuffer(ctx, in, sz, format, CA_TYPE, NULL,
 800843a:	697b      	ldr	r3, [r7, #20]
 800843c:	9302      	str	r3, [sp, #8]
 800843e:	2300      	movs	r3, #0
 8008440:	9301      	str	r3, [sp, #4]
 8008442:	2305      	movs	r3, #5
 8008444:	9300      	str	r3, [sp, #0]
 8008446:	683b      	ldr	r3, [r7, #0]
 8008448:	687a      	ldr	r2, [r7, #4]
 800844a:	68b9      	ldr	r1, [r7, #8]
 800844c:	68f8      	ldr	r0, [r7, #12]
 800844e:	f7ff fedd 	bl	800820c <ProcessChainBuffer>
 8008452:	6138      	str	r0, [r7, #16]
 8008454:	e010      	b.n	8008478 <wolfSSL_CTX_load_verify_buffer_ex+0x82>
                                      verify);
        else
            ret = ProcessBuffer(ctx, in, sz, format, CA_TYPE, NULL, NULL,
 8008456:	697b      	ldr	r3, [r7, #20]
 8008458:	9304      	str	r3, [sp, #16]
 800845a:	6a3b      	ldr	r3, [r7, #32]
 800845c:	9303      	str	r3, [sp, #12]
 800845e:	2300      	movs	r3, #0
 8008460:	9302      	str	r3, [sp, #8]
 8008462:	2300      	movs	r3, #0
 8008464:	9301      	str	r3, [sp, #4]
 8008466:	2305      	movs	r3, #5
 8008468:	9300      	str	r3, [sp, #0]
 800846a:	683b      	ldr	r3, [r7, #0]
 800846c:	687a      	ldr	r2, [r7, #4]
 800846e:	68b9      	ldr	r1, [r7, #8]
 8008470:	68f8      	ldr	r0, [r7, #12]
 8008472:	f7ff fae1 	bl	8007a38 <ProcessBuffer>
 8008476:	6138      	str	r0, [r7, #16]
                                 userChain, verify);
        WOLFSSL_LEAVE("wolfSSL_CTX_load_verify_buffer_ex", ret);
        return ret;
 8008478:	693b      	ldr	r3, [r7, #16]
    }
 800847a:	4618      	mov	r0, r3
 800847c:	3718      	adds	r7, #24
 800847e:	46bd      	mov	sp, r7
 8008480:	bd80      	pop	{r7, pc}

08008482 <wolfSSL_CTX_load_verify_buffer>:

    /* wolfSSL extension allows DER files to be loaded from buffers as well */
    int wolfSSL_CTX_load_verify_buffer(WOLFSSL_CTX* ctx,
                                       const unsigned char* in,
                                       long sz, int format)
    {
 8008482:	b580      	push	{r7, lr}
 8008484:	b086      	sub	sp, #24
 8008486:	af02      	add	r7, sp, #8
 8008488:	60f8      	str	r0, [r7, #12]
 800848a:	60b9      	str	r1, [r7, #8]
 800848c:	607a      	str	r2, [r7, #4]
 800848e:	603b      	str	r3, [r7, #0]
        return wolfSSL_CTX_load_verify_buffer_ex(ctx, in, sz, format, 0,
 8008490:	2300      	movs	r3, #0
 8008492:	9301      	str	r3, [sp, #4]
 8008494:	2300      	movs	r3, #0
 8008496:	9300      	str	r3, [sp, #0]
 8008498:	683b      	ldr	r3, [r7, #0]
 800849a:	687a      	ldr	r2, [r7, #4]
 800849c:	68b9      	ldr	r1, [r7, #8]
 800849e:	68f8      	ldr	r0, [r7, #12]
 80084a0:	f7ff ffa9 	bl	80083f6 <wolfSSL_CTX_load_verify_buffer_ex>
 80084a4:	4603      	mov	r3, r0
            WOLFSSL_LOAD_VERIFY_DEFAULT_FLAGS);
    }
 80084a6:	4618      	mov	r0, r3
 80084a8:	3710      	adds	r7, #16
 80084aa:	46bd      	mov	sp, r7
 80084ac:	bd80      	pop	{r7, pc}

080084ae <MakeTLSv1_2>:


#ifndef WOLFSSL_NO_TLS12

ProtocolVersion MakeTLSv1_2(void)
{
 80084ae:	b480      	push	{r7}
 80084b0:	b083      	sub	sp, #12
 80084b2:	af00      	add	r7, sp, #0
    ProtocolVersion pv;
    pv.major = SSLv3_MAJOR;
 80084b4:	2303      	movs	r3, #3
 80084b6:	703b      	strb	r3, [r7, #0]
    pv.minor = TLSv1_2_MINOR;
 80084b8:	2303      	movs	r3, #3
 80084ba:	707b      	strb	r3, [r7, #1]

    return pv;
 80084bc:	883b      	ldrh	r3, [r7, #0]
 80084be:	80bb      	strh	r3, [r7, #4]
 80084c0:	2300      	movs	r3, #0
 80084c2:	793a      	ldrb	r2, [r7, #4]
 80084c4:	f362 0307 	bfi	r3, r2, #0, #8
 80084c8:	797a      	ldrb	r2, [r7, #5]
 80084ca:	f362 230f 	bfi	r3, r2, #8, #8
}
 80084ce:	4618      	mov	r0, r3
 80084d0:	370c      	adds	r7, #12
 80084d2:	46bd      	mov	sp, r7
 80084d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80084d8:	4770      	bx	lr

080084da <TLSX_SupportedCurve_FreeAll>:

    return 0;
}

static void TLSX_SupportedCurve_FreeAll(SupportedCurve* list, void* heap)
{
 80084da:	b580      	push	{r7, lr}
 80084dc:	b084      	sub	sp, #16
 80084de:	af00      	add	r7, sp, #0
 80084e0:	6078      	str	r0, [r7, #4]
 80084e2:	6039      	str	r1, [r7, #0]
    SupportedCurve* curve;

    while ((curve = list)) {
 80084e4:	e00a      	b.n	80084fc <TLSX_SupportedCurve_FreeAll+0x22>
        list = curve->next;
 80084e6:	68fb      	ldr	r3, [r7, #12]
 80084e8:	685b      	ldr	r3, [r3, #4]
 80084ea:	607b      	str	r3, [r7, #4]
        XFREE(curve, heap, DYNAMIC_TYPE_TLSX);
 80084ec:	68fb      	ldr	r3, [r7, #12]
 80084ee:	60bb      	str	r3, [r7, #8]
 80084f0:	68bb      	ldr	r3, [r7, #8]
 80084f2:	2b00      	cmp	r3, #0
 80084f4:	d002      	beq.n	80084fc <TLSX_SupportedCurve_FreeAll+0x22>
 80084f6:	68b8      	ldr	r0, [r7, #8]
 80084f8:	f006 fd1a 	bl	800ef30 <wolfSSL_Free>
    while ((curve = list)) {
 80084fc:	687b      	ldr	r3, [r7, #4]
 80084fe:	60fb      	str	r3, [r7, #12]
 8008500:	68fb      	ldr	r3, [r7, #12]
 8008502:	2b00      	cmp	r3, #0
 8008504:	d1ef      	bne.n	80084e6 <TLSX_SupportedCurve_FreeAll+0xc>
    }
    (void)heap;
}
 8008506:	bf00      	nop
 8008508:	3710      	adds	r7, #16
 800850a:	46bd      	mov	sp, r7
 800850c:	bd80      	pop	{r7, pc}

0800850e <TLSX_PointFormat_FreeAll>:

static void TLSX_PointFormat_FreeAll(PointFormat* list, void* heap)
{
 800850e:	b580      	push	{r7, lr}
 8008510:	b084      	sub	sp, #16
 8008512:	af00      	add	r7, sp, #0
 8008514:	6078      	str	r0, [r7, #4]
 8008516:	6039      	str	r1, [r7, #0]
    PointFormat* point;

    while ((point = list)) {
 8008518:	e00a      	b.n	8008530 <TLSX_PointFormat_FreeAll+0x22>
        list = point->next;
 800851a:	68fb      	ldr	r3, [r7, #12]
 800851c:	685b      	ldr	r3, [r3, #4]
 800851e:	607b      	str	r3, [r7, #4]
        XFREE(point, heap, DYNAMIC_TYPE_TLSX);
 8008520:	68fb      	ldr	r3, [r7, #12]
 8008522:	60bb      	str	r3, [r7, #8]
 8008524:	68bb      	ldr	r3, [r7, #8]
 8008526:	2b00      	cmp	r3, #0
 8008528:	d002      	beq.n	8008530 <TLSX_PointFormat_FreeAll+0x22>
 800852a:	68b8      	ldr	r0, [r7, #8]
 800852c:	f006 fd00 	bl	800ef30 <wolfSSL_Free>
    while ((point = list)) {
 8008530:	687b      	ldr	r3, [r7, #4]
 8008532:	60fb      	str	r3, [r7, #12]
 8008534:	68fb      	ldr	r3, [r7, #12]
 8008536:	2b00      	cmp	r3, #0
 8008538:	d1ef      	bne.n	800851a <TLSX_PointFormat_FreeAll+0xc>
    }
    (void)heap;
}
 800853a:	bf00      	nop
 800853c:	3710      	adds	r7, #16
 800853e:	46bd      	mov	sp, r7
 8008540:	bd80      	pop	{r7, pc}

08008542 <TLSX_KeyShare_FreeAll>:
 *
 * list  The linked list of key share entry objects.
 * heap  The heap used for allocation.
 */
static void TLSX_KeyShare_FreeAll(KeyShareEntry* list, void* heap)
{
 8008542:	b580      	push	{r7, lr}
 8008544:	b088      	sub	sp, #32
 8008546:	af00      	add	r7, sp, #0
 8008548:	6078      	str	r0, [r7, #4]
 800854a:	6039      	str	r1, [r7, #0]
    KeyShareEntry* current;

    while ((current = list) != NULL) {
 800854c:	e03c      	b.n	80085c8 <TLSX_KeyShare_FreeAll+0x86>
        list = current->next;
 800854e:	69fb      	ldr	r3, [r7, #28]
 8008550:	69db      	ldr	r3, [r3, #28]
 8008552:	607b      	str	r3, [r7, #4]
        if ((current->group & NAMED_DH_MASK) == 0) {
 8008554:	69fb      	ldr	r3, [r7, #28]
 8008556:	881b      	ldrh	r3, [r3, #0]
 8008558:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800855c:	2b00      	cmp	r3, #0
 800855e:	d10c      	bne.n	800857a <TLSX_KeyShare_FreeAll+0x38>
            if (current->group == WOLFSSL_ECC_X25519) {
 8008560:	69fb      	ldr	r3, [r7, #28]
 8008562:	881b      	ldrh	r3, [r3, #0]
 8008564:	2b1d      	cmp	r3, #29
 8008566:	d008      	beq.n	800857a <TLSX_KeyShare_FreeAll+0x38>
#ifdef HAVE_CURVE25519
                wc_curve25519_free((curve25519_key*)current->key);
#endif
            }
            else if (current->group == WOLFSSL_ECC_X448) {
 8008568:	69fb      	ldr	r3, [r7, #28]
 800856a:	881b      	ldrh	r3, [r3, #0]
 800856c:	2b1e      	cmp	r3, #30
 800856e:	d004      	beq.n	800857a <TLSX_KeyShare_FreeAll+0x38>
                wc_curve448_free((curve448_key*)current->key);
#endif
            }
            else {
#ifdef HAVE_ECC
                wc_ecc_free((ecc_key*)(current->key));
 8008570:	69fb      	ldr	r3, [r7, #28]
 8008572:	68db      	ldr	r3, [r3, #12]
 8008574:	4618      	mov	r0, r3
 8008576:	f006 f899 	bl	800e6ac <wc_ecc_free>
#endif
            }
        }
        if (current->key != NULL)
 800857a:	69fb      	ldr	r3, [r7, #28]
 800857c:	68db      	ldr	r3, [r3, #12]
 800857e:	2b00      	cmp	r3, #0
 8008580:	d008      	beq.n	8008594 <TLSX_KeyShare_FreeAll+0x52>
            XFREE(current->key, heap, DYNAMIC_TYPE_PRIVATE_KEY);
 8008582:	69fb      	ldr	r3, [r7, #28]
 8008584:	68db      	ldr	r3, [r3, #12]
 8008586:	61bb      	str	r3, [r7, #24]
 8008588:	69bb      	ldr	r3, [r7, #24]
 800858a:	2b00      	cmp	r3, #0
 800858c:	d002      	beq.n	8008594 <TLSX_KeyShare_FreeAll+0x52>
 800858e:	69b8      	ldr	r0, [r7, #24]
 8008590:	f006 fcce 	bl	800ef30 <wolfSSL_Free>
        XFREE(current->pubKey, heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8008594:	69fb      	ldr	r3, [r7, #28]
 8008596:	695b      	ldr	r3, [r3, #20]
 8008598:	617b      	str	r3, [r7, #20]
 800859a:	697b      	ldr	r3, [r7, #20]
 800859c:	2b00      	cmp	r3, #0
 800859e:	d002      	beq.n	80085a6 <TLSX_KeyShare_FreeAll+0x64>
 80085a0:	6978      	ldr	r0, [r7, #20]
 80085a2:	f006 fcc5 	bl	800ef30 <wolfSSL_Free>
        XFREE(current->ke, heap, DYNAMIC_TYPE_PUBLIC_KEY);
 80085a6:	69fb      	ldr	r3, [r7, #28]
 80085a8:	685b      	ldr	r3, [r3, #4]
 80085aa:	613b      	str	r3, [r7, #16]
 80085ac:	693b      	ldr	r3, [r7, #16]
 80085ae:	2b00      	cmp	r3, #0
 80085b0:	d002      	beq.n	80085b8 <TLSX_KeyShare_FreeAll+0x76>
 80085b2:	6938      	ldr	r0, [r7, #16]
 80085b4:	f006 fcbc 	bl	800ef30 <wolfSSL_Free>
        XFREE(current, heap, DYNAMIC_TYPE_TLSX);
 80085b8:	69fb      	ldr	r3, [r7, #28]
 80085ba:	60fb      	str	r3, [r7, #12]
 80085bc:	68fb      	ldr	r3, [r7, #12]
 80085be:	2b00      	cmp	r3, #0
 80085c0:	d002      	beq.n	80085c8 <TLSX_KeyShare_FreeAll+0x86>
 80085c2:	68f8      	ldr	r0, [r7, #12]
 80085c4:	f006 fcb4 	bl	800ef30 <wolfSSL_Free>
    while ((current = list) != NULL) {
 80085c8:	687b      	ldr	r3, [r7, #4]
 80085ca:	61fb      	str	r3, [r7, #28]
 80085cc:	69fb      	ldr	r3, [r7, #28]
 80085ce:	2b00      	cmp	r3, #0
 80085d0:	d1bd      	bne.n	800854e <TLSX_KeyShare_FreeAll+0xc>
    }

    (void)heap;
}
 80085d2:	bf00      	nop
 80085d4:	3720      	adds	r7, #32
 80085d6:	46bd      	mov	sp, r7
 80085d8:	bd80      	pop	{r7, pc}

080085da <TLSX_FreeAll>:
    }
}

/** Releases all extensions in the provided list. */
void TLSX_FreeAll(TLSX* list, void* heap)
{
 80085da:	b580      	push	{r7, lr}
 80085dc:	b084      	sub	sp, #16
 80085de:	af00      	add	r7, sp, #0
 80085e0:	6078      	str	r0, [r7, #4]
 80085e2:	6039      	str	r1, [r7, #0]
    TLSX* extension;

    while ((extension = list)) {
 80085e4:	e05f      	b.n	80086a6 <TLSX_FreeAll+0xcc>
        list = extension->next;
 80085e6:	68fb      	ldr	r3, [r7, #12]
 80085e8:	691b      	ldr	r3, [r3, #16]
 80085ea:	607b      	str	r3, [r7, #4]

        switch (extension->type) {
 80085ec:	68fb      	ldr	r3, [r7, #12]
 80085ee:	881b      	ldrh	r3, [r3, #0]
 80085f0:	2b11      	cmp	r3, #17
 80085f2:	d041      	beq.n	8008678 <TLSX_FreeAll+0x9e>
 80085f4:	2b11      	cmp	r3, #17
 80085f6:	dc14      	bgt.n	8008622 <TLSX_FreeAll+0x48>
 80085f8:	2b05      	cmp	r3, #5
 80085fa:	d03f      	beq.n	800867c <TLSX_FreeAll+0xa2>
 80085fc:	2b05      	cmp	r3, #5
 80085fe:	dc05      	bgt.n	800860c <TLSX_FreeAll+0x32>
 8008600:	2b03      	cmp	r3, #3
 8008602:	d03d      	beq.n	8008680 <TLSX_FreeAll+0xa6>
 8008604:	2b03      	cmp	r3, #3
 8008606:	dc3d      	bgt.n	8008684 <TLSX_FreeAll+0xaa>
 8008608:	2b01      	cmp	r3, #1
                TCA_FREE_ALL((TCA*)extension->data, heap);
                break;

            case TLSX_MAX_FRAGMENT_LENGTH:
                MFL_FREE_ALL(extension->data, heap);
                break;
 800860a:	e044      	b.n	8008696 <TLSX_FreeAll+0xbc>
        switch (extension->type) {
 800860c:	2b0b      	cmp	r3, #11
 800860e:	d025      	beq.n	800865c <TLSX_FreeAll+0x82>
 8008610:	2b0b      	cmp	r3, #11
 8008612:	dc02      	bgt.n	800861a <TLSX_FreeAll+0x40>
 8008614:	2b0a      	cmp	r3, #10
 8008616:	d01a      	beq.n	800864e <TLSX_FreeAll+0x74>
 8008618:	e03d      	b.n	8008696 <TLSX_FreeAll+0xbc>
 800861a:	2b0d      	cmp	r3, #13
 800861c:	d034      	beq.n	8008688 <TLSX_FreeAll+0xae>
 800861e:	2b10      	cmp	r3, #16
                QSH_FREE_ALL((QSHScheme*)extension->data, heap);
                break;

            case TLSX_APPLICATION_LAYER_PROTOCOL:
                ALPN_FREE_ALL((ALPN*)extension->data, heap);
                break;
 8008620:	e039      	b.n	8008696 <TLSX_FreeAll+0xbc>
        switch (extension->type) {
 8008622:	2b23      	cmp	r3, #35	; 0x23
 8008624:	d032      	beq.n	800868c <TLSX_FreeAll+0xb2>
 8008626:	2b23      	cmp	r3, #35	; 0x23
 8008628:	dc05      	bgt.n	8008636 <TLSX_FreeAll+0x5c>
 800862a:	2b17      	cmp	r3, #23
 800862c:	d02a      	beq.n	8008684 <TLSX_FreeAll+0xaa>
 800862e:	2b18      	cmp	r3, #24
 8008630:	d02e      	beq.n	8008690 <TLSX_FreeAll+0xb6>
 8008632:	2b16      	cmp	r3, #22
            case TLSX_SIGNATURE_ALGORITHMS:
                break;
#endif
#if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
            case TLSX_ENCRYPT_THEN_MAC:
                break;
 8008634:	e02f      	b.n	8008696 <TLSX_FreeAll+0xbc>
        switch (extension->type) {
 8008636:	2b32      	cmp	r3, #50	; 0x32
 8008638:	d02c      	beq.n	8008694 <TLSX_FreeAll+0xba>
 800863a:	2b32      	cmp	r3, #50	; 0x32
 800863c:	dc01      	bgt.n	8008642 <TLSX_FreeAll+0x68>
 800863e:	2b2b      	cmp	r3, #43	; 0x2b
#endif
#ifdef WOLFSSL_TLS13
            case TLSX_SUPPORTED_VERSIONS:
                break;
 8008640:	e029      	b.n	8008696 <TLSX_FreeAll+0xbc>
        switch (extension->type) {
 8008642:	2b33      	cmp	r3, #51	; 0x33
 8008644:	d011      	beq.n	800866a <TLSX_FreeAll+0x90>
 8008646:	f64f 7201 	movw	r2, #65281	; 0xff01
 800864a:	4293      	cmp	r3, r2
                break;
 800864c:	e023      	b.n	8008696 <TLSX_FreeAll+0xbc>
                EC_FREE_ALL((SupportedCurve*)extension->data, heap);
 800864e:	68fb      	ldr	r3, [r7, #12]
 8008650:	685b      	ldr	r3, [r3, #4]
 8008652:	6839      	ldr	r1, [r7, #0]
 8008654:	4618      	mov	r0, r3
 8008656:	f7ff ff40 	bl	80084da <TLSX_SupportedCurve_FreeAll>
                break;
 800865a:	e01c      	b.n	8008696 <TLSX_FreeAll+0xbc>
                PF_FREE_ALL((PointFormat*)extension->data, heap);
 800865c:	68fb      	ldr	r3, [r7, #12]
 800865e:	685b      	ldr	r3, [r3, #4]
 8008660:	6839      	ldr	r1, [r7, #0]
 8008662:	4618      	mov	r0, r3
 8008664:	f7ff ff53 	bl	800850e <TLSX_PointFormat_FreeAll>
                break;
 8008668:	e015      	b.n	8008696 <TLSX_FreeAll+0xbc>
            case TLSX_SIGNATURE_ALGORITHMS_CERT:
                break;
    #endif

            case TLSX_KEY_SHARE:
                KS_FREE_ALL((KeyShareEntry*)extension->data, heap);
 800866a:	68fb      	ldr	r3, [r7, #12]
 800866c:	685b      	ldr	r3, [r3, #4]
 800866e:	6839      	ldr	r1, [r7, #0]
 8008670:	4618      	mov	r0, r3
 8008672:	f7ff ff66 	bl	8008542 <TLSX_KeyShare_FreeAll>
                break;
 8008676:	e00e      	b.n	8008696 <TLSX_FreeAll+0xbc>
                break;
 8008678:	bf00      	nop
 800867a:	e00c      	b.n	8008696 <TLSX_FreeAll+0xbc>
                break;
 800867c:	bf00      	nop
 800867e:	e00a      	b.n	8008696 <TLSX_FreeAll+0xbc>
                break;
 8008680:	bf00      	nop
 8008682:	e008      	b.n	8008696 <TLSX_FreeAll+0xbc>
                break;
 8008684:	bf00      	nop
 8008686:	e006      	b.n	8008696 <TLSX_FreeAll+0xbc>
                break;
 8008688:	bf00      	nop
 800868a:	e004      	b.n	8008696 <TLSX_FreeAll+0xbc>
                break;
 800868c:	bf00      	nop
 800868e:	e002      	b.n	8008696 <TLSX_FreeAll+0xbc>
                break;
 8008690:	bf00      	nop
 8008692:	e000      	b.n	8008696 <TLSX_FreeAll+0xbc>
                break;
 8008694:	bf00      	nop
#endif
        }

        XFREE(extension, heap, DYNAMIC_TYPE_TLSX);
 8008696:	68fb      	ldr	r3, [r7, #12]
 8008698:	60bb      	str	r3, [r7, #8]
 800869a:	68bb      	ldr	r3, [r7, #8]
 800869c:	2b00      	cmp	r3, #0
 800869e:	d002      	beq.n	80086a6 <TLSX_FreeAll+0xcc>
 80086a0:	68b8      	ldr	r0, [r7, #8]
 80086a2:	f006 fc45 	bl	800ef30 <wolfSSL_Free>
    while ((extension = list)) {
 80086a6:	687b      	ldr	r3, [r7, #4]
 80086a8:	60fb      	str	r3, [r7, #12]
 80086aa:	68fb      	ldr	r3, [r7, #12]
 80086ac:	2b00      	cmp	r3, #0
 80086ae:	d19a      	bne.n	80085e6 <TLSX_FreeAll+0xc>
    }

    (void)heap;
}
 80086b0:	bf00      	nop
 80086b2:	3710      	adds	r7, #16
 80086b4:	46bd      	mov	sp, r7
 80086b6:	bd80      	pop	{r7, pc}

080086b8 <wolfTLSv1_2_client_method>:
#endif /* !NO_OLD_TLS */

#ifndef WOLFSSL_NO_TLS12
    WOLFSSL_ABI
    WOLFSSL_METHOD* wolfTLSv1_2_client_method(void)
    {
 80086b8:	b580      	push	{r7, lr}
 80086ba:	af00      	add	r7, sp, #0
        return wolfTLSv1_2_client_method_ex(NULL);
 80086bc:	2000      	movs	r0, #0
 80086be:	f000 f803 	bl	80086c8 <wolfTLSv1_2_client_method_ex>
 80086c2:	4603      	mov	r3, r0
    }
 80086c4:	4618      	mov	r0, r3
 80086c6:	bd80      	pop	{r7, pc}

080086c8 <wolfTLSv1_2_client_method_ex>:
    WOLFSSL_METHOD* wolfTLSv1_2_client_method_ex(void* heap)
    {
 80086c8:	b580      	push	{r7, lr}
 80086ca:	b084      	sub	sp, #16
 80086cc:	af00      	add	r7, sp, #0
 80086ce:	6078      	str	r0, [r7, #4]
        WOLFSSL_METHOD* method =
 80086d0:	2004      	movs	r0, #4
 80086d2:	f006 fc11 	bl	800eef8 <wolfSSL_Malloc>
 80086d6:	60f8      	str	r0, [r7, #12]
                              (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
                                                     heap, DYNAMIC_TYPE_METHOD);
        (void)heap;
        WOLFSSL_ENTER("TLSv1_2_client_method_ex");
        if (method)
 80086d8:	68fb      	ldr	r3, [r7, #12]
 80086da:	2b00      	cmp	r3, #0
 80086dc:	d007      	beq.n	80086ee <wolfTLSv1_2_client_method_ex+0x26>
            InitSSL_Method(method, MakeTLSv1_2());
 80086de:	f7ff fee6 	bl	80084ae <MakeTLSv1_2>
 80086e2:	4603      	mov	r3, r0
 80086e4:	813b      	strh	r3, [r7, #8]
 80086e6:	68b9      	ldr	r1, [r7, #8]
 80086e8:	68f8      	ldr	r0, [r7, #12]
 80086ea:	f7fd fe2e 	bl	800634a <InitSSL_Method>
        return method;
 80086ee:	68fb      	ldr	r3, [r7, #12]
    }
 80086f0:	4618      	mov	r0, r3
 80086f2:	3710      	adds	r7, #16
 80086f4:	46bd      	mov	sp, r7
 80086f6:	bd80      	pop	{r7, pc}

080086f8 <ForceZero>:
{
 80086f8:	b480      	push	{r7}
 80086fa:	b085      	sub	sp, #20
 80086fc:	af00      	add	r7, sp, #0
 80086fe:	6078      	str	r0, [r7, #4]
 8008700:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 8008702:	687b      	ldr	r3, [r7, #4]
 8008704:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 8008706:	e004      	b.n	8008712 <ForceZero+0x1a>
 8008708:	68fb      	ldr	r3, [r7, #12]
 800870a:	1c5a      	adds	r2, r3, #1
 800870c:	60fa      	str	r2, [r7, #12]
 800870e:	2200      	movs	r2, #0
 8008710:	701a      	strb	r2, [r3, #0]
 8008712:	683b      	ldr	r3, [r7, #0]
 8008714:	1e5a      	subs	r2, r3, #1
 8008716:	603a      	str	r2, [r7, #0]
 8008718:	2b00      	cmp	r3, #0
 800871a:	d1f5      	bne.n	8008708 <ForceZero+0x10>
}
 800871c:	bf00      	nop
 800871e:	3714      	adds	r7, #20
 8008720:	46bd      	mov	sp, r7
 8008722:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008726:	4770      	bx	lr

08008728 <GetLength>:
                        word32 key_e_start, word32 key_e_len,
                        byte *tsip_encRsaKeyIdx);
#endif
int GetLength(const byte* input, word32* inOutIdx, int* len,
                           word32 maxIdx)
{
 8008728:	b580      	push	{r7, lr}
 800872a:	b086      	sub	sp, #24
 800872c:	af02      	add	r7, sp, #8
 800872e:	60f8      	str	r0, [r7, #12]
 8008730:	60b9      	str	r1, [r7, #8]
 8008732:	607a      	str	r2, [r7, #4]
 8008734:	603b      	str	r3, [r7, #0]
    return GetLength_ex(input, inOutIdx, len, maxIdx, 1);
 8008736:	2301      	movs	r3, #1
 8008738:	9300      	str	r3, [sp, #0]
 800873a:	683b      	ldr	r3, [r7, #0]
 800873c:	687a      	ldr	r2, [r7, #4]
 800873e:	68b9      	ldr	r1, [r7, #8]
 8008740:	68f8      	ldr	r0, [r7, #12]
 8008742:	f000 f805 	bl	8008750 <GetLength_ex>
 8008746:	4603      	mov	r3, r0
}
 8008748:	4618      	mov	r0, r3
 800874a:	3710      	adds	r7, #16
 800874c:	46bd      	mov	sp, r7
 800874e:	bd80      	pop	{r7, pc}

08008750 <GetLength_ex>:


/* give option to check length value found against index. 1 to check 0 to not */
int GetLength_ex(const byte* input, word32* inOutIdx, int* len,
                           word32 maxIdx, int check)
{
 8008750:	b480      	push	{r7}
 8008752:	b089      	sub	sp, #36	; 0x24
 8008754:	af00      	add	r7, sp, #0
 8008756:	60f8      	str	r0, [r7, #12]
 8008758:	60b9      	str	r1, [r7, #8]
 800875a:	607a      	str	r2, [r7, #4]
 800875c:	603b      	str	r3, [r7, #0]
    int     length = 0;
 800875e:	2300      	movs	r3, #0
 8008760:	61fb      	str	r3, [r7, #28]
    word32  idx = *inOutIdx;
 8008762:	68bb      	ldr	r3, [r7, #8]
 8008764:	681b      	ldr	r3, [r3, #0]
 8008766:	61bb      	str	r3, [r7, #24]
    byte    b;

    *len = 0;    /* default length */
 8008768:	687b      	ldr	r3, [r7, #4]
 800876a:	2200      	movs	r2, #0
 800876c:	601a      	str	r2, [r3, #0]

    if ((idx + 1) > maxIdx) {   /* for first read */
 800876e:	69bb      	ldr	r3, [r7, #24]
 8008770:	3301      	adds	r3, #1
 8008772:	683a      	ldr	r2, [r7, #0]
 8008774:	429a      	cmp	r2, r3
 8008776:	d202      	bcs.n	800877e <GetLength_ex+0x2e>
        WOLFSSL_MSG("GetLength bad index on input");
        return BUFFER_E;
 8008778:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800877c:	e04c      	b.n	8008818 <GetLength_ex+0xc8>
    }

    b = input[idx++];
 800877e:	69bb      	ldr	r3, [r7, #24]
 8008780:	1c5a      	adds	r2, r3, #1
 8008782:	61ba      	str	r2, [r7, #24]
 8008784:	68fa      	ldr	r2, [r7, #12]
 8008786:	4413      	add	r3, r2
 8008788:	781b      	ldrb	r3, [r3, #0]
 800878a:	74fb      	strb	r3, [r7, #19]
    if (b >= ASN_LONG_LENGTH) {
 800878c:	f997 3013 	ldrsb.w	r3, [r7, #19]
 8008790:	2b00      	cmp	r3, #0
 8008792:	da29      	bge.n	80087e8 <GetLength_ex+0x98>
        word32 bytes = b & 0x7F;
 8008794:	7cfb      	ldrb	r3, [r7, #19]
 8008796:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800879a:	617b      	str	r3, [r7, #20]

        if ((idx + bytes) > maxIdx) {   /* for reading bytes */
 800879c:	69ba      	ldr	r2, [r7, #24]
 800879e:	697b      	ldr	r3, [r7, #20]
 80087a0:	4413      	add	r3, r2
 80087a2:	683a      	ldr	r2, [r7, #0]
 80087a4:	429a      	cmp	r2, r3
 80087a6:	d202      	bcs.n	80087ae <GetLength_ex+0x5e>
            WOLFSSL_MSG("GetLength bad long length");
            return BUFFER_E;
 80087a8:	f06f 0383 	mvn.w	r3, #131	; 0x83
 80087ac:	e034      	b.n	8008818 <GetLength_ex+0xc8>
        }

        if (bytes > sizeof(length)) {
 80087ae:	697b      	ldr	r3, [r7, #20]
 80087b0:	2b04      	cmp	r3, #4
 80087b2:	d90e      	bls.n	80087d2 <GetLength_ex+0x82>
            return ASN_PARSE_E;
 80087b4:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 80087b8:	e02e      	b.n	8008818 <GetLength_ex+0xc8>
        }
        while (bytes--) {
            b = input[idx++];
 80087ba:	69bb      	ldr	r3, [r7, #24]
 80087bc:	1c5a      	adds	r2, r3, #1
 80087be:	61ba      	str	r2, [r7, #24]
 80087c0:	68fa      	ldr	r2, [r7, #12]
 80087c2:	4413      	add	r3, r2
 80087c4:	781b      	ldrb	r3, [r3, #0]
 80087c6:	74fb      	strb	r3, [r7, #19]
            length = (length << 8) | b;
 80087c8:	69fb      	ldr	r3, [r7, #28]
 80087ca:	021a      	lsls	r2, r3, #8
 80087cc:	7cfb      	ldrb	r3, [r7, #19]
 80087ce:	4313      	orrs	r3, r2
 80087d0:	61fb      	str	r3, [r7, #28]
        while (bytes--) {
 80087d2:	697b      	ldr	r3, [r7, #20]
 80087d4:	1e5a      	subs	r2, r3, #1
 80087d6:	617a      	str	r2, [r7, #20]
 80087d8:	2b00      	cmp	r3, #0
 80087da:	d1ee      	bne.n	80087ba <GetLength_ex+0x6a>
        }
        if (length < 0) {
 80087dc:	69fb      	ldr	r3, [r7, #28]
 80087de:	2b00      	cmp	r3, #0
 80087e0:	da04      	bge.n	80087ec <GetLength_ex+0x9c>
            return ASN_PARSE_E;
 80087e2:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 80087e6:	e017      	b.n	8008818 <GetLength_ex+0xc8>
        }
    }
    else
        length = b;
 80087e8:	7cfb      	ldrb	r3, [r7, #19]
 80087ea:	61fb      	str	r3, [r7, #28]

    if (check && (idx + length) > maxIdx) {   /* for user of length */
 80087ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80087ee:	2b00      	cmp	r3, #0
 80087f0:	d008      	beq.n	8008804 <GetLength_ex+0xb4>
 80087f2:	69fa      	ldr	r2, [r7, #28]
 80087f4:	69bb      	ldr	r3, [r7, #24]
 80087f6:	4413      	add	r3, r2
 80087f8:	683a      	ldr	r2, [r7, #0]
 80087fa:	429a      	cmp	r2, r3
 80087fc:	d202      	bcs.n	8008804 <GetLength_ex+0xb4>
        WOLFSSL_MSG("GetLength value exceeds buffer length");
        return BUFFER_E;
 80087fe:	f06f 0383 	mvn.w	r3, #131	; 0x83
 8008802:	e009      	b.n	8008818 <GetLength_ex+0xc8>
    }

    *inOutIdx = idx;
 8008804:	68bb      	ldr	r3, [r7, #8]
 8008806:	69ba      	ldr	r2, [r7, #24]
 8008808:	601a      	str	r2, [r3, #0]
    if (length > 0)
 800880a:	69fb      	ldr	r3, [r7, #28]
 800880c:	2b00      	cmp	r3, #0
 800880e:	dd02      	ble.n	8008816 <GetLength_ex+0xc6>
        *len = length;
 8008810:	687b      	ldr	r3, [r7, #4]
 8008812:	69fa      	ldr	r2, [r7, #28]
 8008814:	601a      	str	r2, [r3, #0]

    return length;
 8008816:	69fb      	ldr	r3, [r7, #28]
}
 8008818:	4618      	mov	r0, r3
 800881a:	3724      	adds	r7, #36	; 0x24
 800881c:	46bd      	mov	sp, r7
 800881e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008822:	4770      	bx	lr

08008824 <GetASNTag>:
 * tag : ASN tag value found
 *
 * returns 0 on success
 */
int GetASNTag(const byte* input, word32* inOutIdx, byte* tag, word32 maxIdx)
{
 8008824:	b480      	push	{r7}
 8008826:	b087      	sub	sp, #28
 8008828:	af00      	add	r7, sp, #0
 800882a:	60f8      	str	r0, [r7, #12]
 800882c:	60b9      	str	r1, [r7, #8]
 800882e:	607a      	str	r2, [r7, #4]
 8008830:	603b      	str	r3, [r7, #0]
    word32 idx;

    if (tag == NULL || inOutIdx == NULL || input == NULL) {
 8008832:	687b      	ldr	r3, [r7, #4]
 8008834:	2b00      	cmp	r3, #0
 8008836:	d005      	beq.n	8008844 <GetASNTag+0x20>
 8008838:	68bb      	ldr	r3, [r7, #8]
 800883a:	2b00      	cmp	r3, #0
 800883c:	d002      	beq.n	8008844 <GetASNTag+0x20>
 800883e:	68fb      	ldr	r3, [r7, #12]
 8008840:	2b00      	cmp	r3, #0
 8008842:	d102      	bne.n	800884a <GetASNTag+0x26>
        return BAD_FUNC_ARG;
 8008844:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8008848:	e015      	b.n	8008876 <GetASNTag+0x52>
    }

    idx = *inOutIdx;
 800884a:	68bb      	ldr	r3, [r7, #8]
 800884c:	681b      	ldr	r3, [r3, #0]
 800884e:	617b      	str	r3, [r7, #20]
    if (idx + ASN_TAG_SZ > maxIdx) {
 8008850:	697b      	ldr	r3, [r7, #20]
 8008852:	3301      	adds	r3, #1
 8008854:	683a      	ldr	r2, [r7, #0]
 8008856:	429a      	cmp	r2, r3
 8008858:	d202      	bcs.n	8008860 <GetASNTag+0x3c>
        WOLFSSL_MSG("Buffer too small for ASN tag");
        return BUFFER_E;
 800885a:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800885e:	e00a      	b.n	8008876 <GetASNTag+0x52>
    }

    *tag = input[idx];
 8008860:	68fa      	ldr	r2, [r7, #12]
 8008862:	697b      	ldr	r3, [r7, #20]
 8008864:	4413      	add	r3, r2
 8008866:	781a      	ldrb	r2, [r3, #0]
 8008868:	687b      	ldr	r3, [r7, #4]
 800886a:	701a      	strb	r2, [r3, #0]
    *inOutIdx = idx + ASN_TAG_SZ;
 800886c:	697b      	ldr	r3, [r7, #20]
 800886e:	1c5a      	adds	r2, r3, #1
 8008870:	68bb      	ldr	r3, [r7, #8]
 8008872:	601a      	str	r2, [r3, #0]
    return 0;
 8008874:	2300      	movs	r3, #0
}
 8008876:	4618      	mov	r0, r3
 8008878:	371c      	adds	r7, #28
 800887a:	46bd      	mov	sp, r7
 800887c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008880:	4770      	bx	lr

08008882 <GetASNHeader_ex>:


static int GetASNHeader_ex(const byte* input, byte tag, word32* inOutIdx, int* len,
                        word32 maxIdx, int check)
{
 8008882:	b580      	push	{r7, lr}
 8008884:	b08a      	sub	sp, #40	; 0x28
 8008886:	af02      	add	r7, sp, #8
 8008888:	60f8      	str	r0, [r7, #12]
 800888a:	607a      	str	r2, [r7, #4]
 800888c:	603b      	str	r3, [r7, #0]
 800888e:	460b      	mov	r3, r1
 8008890:	72fb      	strb	r3, [r7, #11]
    word32 idx = *inOutIdx;
 8008892:	687b      	ldr	r3, [r7, #4]
 8008894:	681b      	ldr	r3, [r3, #0]
 8008896:	61fb      	str	r3, [r7, #28]
    byte   tagFound;
    int    length;

    if (GetASNTag(input, &idx, &tagFound, maxIdx) != 0)
 8008898:	f107 021b 	add.w	r2, r7, #27
 800889c:	f107 011c 	add.w	r1, r7, #28
 80088a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80088a2:	68f8      	ldr	r0, [r7, #12]
 80088a4:	f7ff ffbe 	bl	8008824 <GetASNTag>
 80088a8:	4603      	mov	r3, r0
 80088aa:	2b00      	cmp	r3, #0
 80088ac:	d002      	beq.n	80088b4 <GetASNHeader_ex+0x32>
        return ASN_PARSE_E;
 80088ae:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 80088b2:	e01d      	b.n	80088f0 <GetASNHeader_ex+0x6e>

    if (tagFound != tag)
 80088b4:	7efb      	ldrb	r3, [r7, #27]
 80088b6:	7afa      	ldrb	r2, [r7, #11]
 80088b8:	429a      	cmp	r2, r3
 80088ba:	d002      	beq.n	80088c2 <GetASNHeader_ex+0x40>
        return ASN_PARSE_E;
 80088bc:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 80088c0:	e016      	b.n	80088f0 <GetASNHeader_ex+0x6e>

    if (GetLength_ex(input, &idx, &length, maxIdx, check) < 0)
 80088c2:	f107 0214 	add.w	r2, r7, #20
 80088c6:	f107 011c 	add.w	r1, r7, #28
 80088ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80088cc:	9300      	str	r3, [sp, #0]
 80088ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80088d0:	68f8      	ldr	r0, [r7, #12]
 80088d2:	f7ff ff3d 	bl	8008750 <GetLength_ex>
 80088d6:	4603      	mov	r3, r0
 80088d8:	2b00      	cmp	r3, #0
 80088da:	da02      	bge.n	80088e2 <GetASNHeader_ex+0x60>
        return ASN_PARSE_E;
 80088dc:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 80088e0:	e006      	b.n	80088f0 <GetASNHeader_ex+0x6e>

    *len      = length;
 80088e2:	697a      	ldr	r2, [r7, #20]
 80088e4:	683b      	ldr	r3, [r7, #0]
 80088e6:	601a      	str	r2, [r3, #0]
    *inOutIdx = idx;
 80088e8:	69fa      	ldr	r2, [r7, #28]
 80088ea:	687b      	ldr	r3, [r7, #4]
 80088ec:	601a      	str	r2, [r3, #0]
    return length;
 80088ee:	697b      	ldr	r3, [r7, #20]
}
 80088f0:	4618      	mov	r0, r3
 80088f2:	3720      	adds	r7, #32
 80088f4:	46bd      	mov	sp, r7
 80088f6:	bd80      	pop	{r7, pc}

080088f8 <GetASNHeader>:
 *         ASN_PARSE_E when the expected tag is not found or length is invalid.
 *         Otherwise, the number of bytes in the ASN.1 data.
 */
static int GetASNHeader(const byte* input, byte tag, word32* inOutIdx, int* len,
                        word32 maxIdx)
{
 80088f8:	b580      	push	{r7, lr}
 80088fa:	b086      	sub	sp, #24
 80088fc:	af02      	add	r7, sp, #8
 80088fe:	60f8      	str	r0, [r7, #12]
 8008900:	607a      	str	r2, [r7, #4]
 8008902:	603b      	str	r3, [r7, #0]
 8008904:	460b      	mov	r3, r1
 8008906:	72fb      	strb	r3, [r7, #11]
    return GetASNHeader_ex(input, tag, inOutIdx, len, maxIdx, 1);
 8008908:	7af9      	ldrb	r1, [r7, #11]
 800890a:	2301      	movs	r3, #1
 800890c:	9301      	str	r3, [sp, #4]
 800890e:	69bb      	ldr	r3, [r7, #24]
 8008910:	9300      	str	r3, [sp, #0]
 8008912:	683b      	ldr	r3, [r7, #0]
 8008914:	687a      	ldr	r2, [r7, #4]
 8008916:	68f8      	ldr	r0, [r7, #12]
 8008918:	f7ff ffb3 	bl	8008882 <GetASNHeader_ex>
 800891c:	4603      	mov	r3, r0
}
 800891e:	4618      	mov	r0, r3
 8008920:	3710      	adds	r7, #16
 8008922:	46bd      	mov	sp, r7
 8008924:	bd80      	pop	{r7, pc}

08008926 <GetHeader>:

static int GetHeader(const byte* input, byte* tag, word32* inOutIdx, int* len,
                     word32 maxIdx, int check)
{
 8008926:	b580      	push	{r7, lr}
 8008928:	b088      	sub	sp, #32
 800892a:	af02      	add	r7, sp, #8
 800892c:	60f8      	str	r0, [r7, #12]
 800892e:	60b9      	str	r1, [r7, #8]
 8008930:	607a      	str	r2, [r7, #4]
 8008932:	603b      	str	r3, [r7, #0]
    word32 idx = *inOutIdx;
 8008934:	687b      	ldr	r3, [r7, #4]
 8008936:	681b      	ldr	r3, [r3, #0]
 8008938:	617b      	str	r3, [r7, #20]
    int    length;

    if ((idx + 1) > maxIdx)
 800893a:	697b      	ldr	r3, [r7, #20]
 800893c:	3301      	adds	r3, #1
 800893e:	6a3a      	ldr	r2, [r7, #32]
 8008940:	429a      	cmp	r2, r3
 8008942:	d202      	bcs.n	800894a <GetHeader+0x24>
        return BUFFER_E;
 8008944:	f06f 0383 	mvn.w	r3, #131	; 0x83
 8008948:	e01e      	b.n	8008988 <GetHeader+0x62>

    *tag = input[idx++];
 800894a:	697b      	ldr	r3, [r7, #20]
 800894c:	1c5a      	adds	r2, r3, #1
 800894e:	617a      	str	r2, [r7, #20]
 8008950:	68fa      	ldr	r2, [r7, #12]
 8008952:	4413      	add	r3, r2
 8008954:	781a      	ldrb	r2, [r3, #0]
 8008956:	68bb      	ldr	r3, [r7, #8]
 8008958:	701a      	strb	r2, [r3, #0]

    if (GetLength_ex(input, &idx, &length, maxIdx, check) < 0)
 800895a:	f107 0210 	add.w	r2, r7, #16
 800895e:	f107 0114 	add.w	r1, r7, #20
 8008962:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008964:	9300      	str	r3, [sp, #0]
 8008966:	6a3b      	ldr	r3, [r7, #32]
 8008968:	68f8      	ldr	r0, [r7, #12]
 800896a:	f7ff fef1 	bl	8008750 <GetLength_ex>
 800896e:	4603      	mov	r3, r0
 8008970:	2b00      	cmp	r3, #0
 8008972:	da02      	bge.n	800897a <GetHeader+0x54>
        return ASN_PARSE_E;
 8008974:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8008978:	e006      	b.n	8008988 <GetHeader+0x62>

    *len      = length;
 800897a:	693a      	ldr	r2, [r7, #16]
 800897c:	683b      	ldr	r3, [r7, #0]
 800897e:	601a      	str	r2, [r3, #0]
    *inOutIdx = idx;
 8008980:	697a      	ldr	r2, [r7, #20]
 8008982:	687b      	ldr	r3, [r7, #4]
 8008984:	601a      	str	r2, [r3, #0]
    return length;
 8008986:	693b      	ldr	r3, [r7, #16]
}
 8008988:	4618      	mov	r0, r3
 800898a:	3718      	adds	r7, #24
 800898c:	46bd      	mov	sp, r7
 800898e:	bd80      	pop	{r7, pc}

08008990 <GetSequence>:

int GetSequence(const byte* input, word32* inOutIdx, int* len,
                           word32 maxIdx)
{
 8008990:	b580      	push	{r7, lr}
 8008992:	b086      	sub	sp, #24
 8008994:	af02      	add	r7, sp, #8
 8008996:	60f8      	str	r0, [r7, #12]
 8008998:	60b9      	str	r1, [r7, #8]
 800899a:	607a      	str	r2, [r7, #4]
 800899c:	603b      	str	r3, [r7, #0]
    return GetASNHeader(input, ASN_SEQUENCE | ASN_CONSTRUCTED, inOutIdx, len,
 800899e:	683b      	ldr	r3, [r7, #0]
 80089a0:	9300      	str	r3, [sp, #0]
 80089a2:	687b      	ldr	r3, [r7, #4]
 80089a4:	68ba      	ldr	r2, [r7, #8]
 80089a6:	2130      	movs	r1, #48	; 0x30
 80089a8:	68f8      	ldr	r0, [r7, #12]
 80089aa:	f7ff ffa5 	bl	80088f8 <GetASNHeader>
 80089ae:	4603      	mov	r3, r0
                        maxIdx);
}
 80089b0:	4618      	mov	r0, r3
 80089b2:	3710      	adds	r7, #16
 80089b4:	46bd      	mov	sp, r7
 80089b6:	bd80      	pop	{r7, pc}

080089b8 <GetSet>:
}


int GetSet(const byte* input, word32* inOutIdx, int* len,
                        word32 maxIdx)
{
 80089b8:	b580      	push	{r7, lr}
 80089ba:	b086      	sub	sp, #24
 80089bc:	af02      	add	r7, sp, #8
 80089be:	60f8      	str	r0, [r7, #12]
 80089c0:	60b9      	str	r1, [r7, #8]
 80089c2:	607a      	str	r2, [r7, #4]
 80089c4:	603b      	str	r3, [r7, #0]
    return GetASNHeader(input, ASN_SET | ASN_CONSTRUCTED, inOutIdx, len,
 80089c6:	683b      	ldr	r3, [r7, #0]
 80089c8:	9300      	str	r3, [sp, #0]
 80089ca:	687b      	ldr	r3, [r7, #4]
 80089cc:	68ba      	ldr	r2, [r7, #8]
 80089ce:	2131      	movs	r1, #49	; 0x31
 80089d0:	68f8      	ldr	r0, [r7, #12]
 80089d2:	f7ff ff91 	bl	80088f8 <GetASNHeader>
 80089d6:	4603      	mov	r3, r0
                        maxIdx);
}
 80089d8:	4618      	mov	r0, r3
 80089da:	3710      	adds	r7, #16
 80089dc:	46bd      	mov	sp, r7
 80089de:	bd80      	pop	{r7, pc}

080089e0 <GetASNNull>:
 *         ASN_TAG_NULL_E when the NULL tag is not found.
 *         ASN_EXPECT_0_E when the length is not zero.
 *         Otherwise, 0 to indicate success.
 */
static int GetASNNull(const byte* input, word32* inOutIdx, word32 maxIdx)
{
 80089e0:	b480      	push	{r7}
 80089e2:	b087      	sub	sp, #28
 80089e4:	af00      	add	r7, sp, #0
 80089e6:	60f8      	str	r0, [r7, #12]
 80089e8:	60b9      	str	r1, [r7, #8]
 80089ea:	607a      	str	r2, [r7, #4]
    word32 idx = *inOutIdx;
 80089ec:	68bb      	ldr	r3, [r7, #8]
 80089ee:	681b      	ldr	r3, [r3, #0]
 80089f0:	617b      	str	r3, [r7, #20]
    byte   b;

    if ((idx + 2) > maxIdx)
 80089f2:	697b      	ldr	r3, [r7, #20]
 80089f4:	3302      	adds	r3, #2
 80089f6:	687a      	ldr	r2, [r7, #4]
 80089f8:	429a      	cmp	r2, r3
 80089fa:	d202      	bcs.n	8008a02 <GetASNNull+0x22>
        return BUFFER_E;
 80089fc:	f06f 0383 	mvn.w	r3, #131	; 0x83
 8008a00:	e01b      	b.n	8008a3a <GetASNNull+0x5a>

    b = input[idx++];
 8008a02:	697b      	ldr	r3, [r7, #20]
 8008a04:	1c5a      	adds	r2, r3, #1
 8008a06:	617a      	str	r2, [r7, #20]
 8008a08:	68fa      	ldr	r2, [r7, #12]
 8008a0a:	4413      	add	r3, r2
 8008a0c:	781b      	ldrb	r3, [r3, #0]
 8008a0e:	74fb      	strb	r3, [r7, #19]
    if (b != ASN_TAG_NULL)
 8008a10:	7cfb      	ldrb	r3, [r7, #19]
 8008a12:	2b05      	cmp	r3, #5
 8008a14:	d002      	beq.n	8008a1c <GetASNNull+0x3c>
        return ASN_TAG_NULL_E;
 8008a16:	f06f 0390 	mvn.w	r3, #144	; 0x90
 8008a1a:	e00e      	b.n	8008a3a <GetASNNull+0x5a>

    if (input[idx++] != 0)
 8008a1c:	697b      	ldr	r3, [r7, #20]
 8008a1e:	1c5a      	adds	r2, r3, #1
 8008a20:	617a      	str	r2, [r7, #20]
 8008a22:	68fa      	ldr	r2, [r7, #12]
 8008a24:	4413      	add	r3, r2
 8008a26:	781b      	ldrb	r3, [r3, #0]
 8008a28:	2b00      	cmp	r3, #0
 8008a2a:	d002      	beq.n	8008a32 <GetASNNull+0x52>
        return ASN_EXPECT_0_E;
 8008a2c:	f06f 0391 	mvn.w	r3, #145	; 0x91
 8008a30:	e003      	b.n	8008a3a <GetASNNull+0x5a>

    *inOutIdx = idx;
 8008a32:	68bb      	ldr	r3, [r7, #8]
 8008a34:	697a      	ldr	r2, [r7, #20]
 8008a36:	601a      	str	r2, [r3, #0]
    return 0;
 8008a38:	2300      	movs	r3, #0
}
 8008a3a:	4618      	mov	r0, r3
 8008a3c:	371c      	adds	r7, #28
 8008a3e:	46bd      	mov	sp, r7
 8008a40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a44:	4770      	bx	lr

08008a46 <SetASNNull>:
 *
 * output  Buffer to write into.
 * returns the number of bytes added to the buffer.
 */
static int SetASNNull(byte* output)
{
 8008a46:	b480      	push	{r7}
 8008a48:	b083      	sub	sp, #12
 8008a4a:	af00      	add	r7, sp, #0
 8008a4c:	6078      	str	r0, [r7, #4]
    output[0] = ASN_TAG_NULL;
 8008a4e:	687b      	ldr	r3, [r7, #4]
 8008a50:	2205      	movs	r2, #5
 8008a52:	701a      	strb	r2, [r3, #0]
    output[1] = 0;
 8008a54:	687b      	ldr	r3, [r7, #4]
 8008a56:	3301      	adds	r3, #1
 8008a58:	2200      	movs	r2, #0
 8008a5a:	701a      	strb	r2, [r3, #0]

    return 2;
 8008a5c:	2302      	movs	r3, #2
}
 8008a5e:	4618      	mov	r0, r3
 8008a60:	370c      	adds	r7, #12
 8008a62:	46bd      	mov	sp, r7
 8008a64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a68:	4770      	bx	lr

08008a6a <GetBoolean>:
 * returns BUFFER_E when there is not enough data to parse.
 *         ASN_PARSE_E when the BOOLEAN tag is not found or length is not 1.
 *         Otherwise, 0 to indicate the value was false and 1 to indicate true.
 */
static int GetBoolean(const byte* input, word32* inOutIdx, word32 maxIdx)
{
 8008a6a:	b480      	push	{r7}
 8008a6c:	b087      	sub	sp, #28
 8008a6e:	af00      	add	r7, sp, #0
 8008a70:	60f8      	str	r0, [r7, #12]
 8008a72:	60b9      	str	r1, [r7, #8]
 8008a74:	607a      	str	r2, [r7, #4]
    word32 idx = *inOutIdx;
 8008a76:	68bb      	ldr	r3, [r7, #8]
 8008a78:	681b      	ldr	r3, [r3, #0]
 8008a7a:	617b      	str	r3, [r7, #20]
    byte   b;

    if ((idx + 3) > maxIdx)
 8008a7c:	697b      	ldr	r3, [r7, #20]
 8008a7e:	3303      	adds	r3, #3
 8008a80:	687a      	ldr	r2, [r7, #4]
 8008a82:	429a      	cmp	r2, r3
 8008a84:	d202      	bcs.n	8008a8c <GetBoolean+0x22>
        return BUFFER_E;
 8008a86:	f06f 0383 	mvn.w	r3, #131	; 0x83
 8008a8a:	e027      	b.n	8008adc <GetBoolean+0x72>

    b = input[idx++];
 8008a8c:	697b      	ldr	r3, [r7, #20]
 8008a8e:	1c5a      	adds	r2, r3, #1
 8008a90:	617a      	str	r2, [r7, #20]
 8008a92:	68fa      	ldr	r2, [r7, #12]
 8008a94:	4413      	add	r3, r2
 8008a96:	781b      	ldrb	r3, [r3, #0]
 8008a98:	74fb      	strb	r3, [r7, #19]
    if (b != ASN_BOOLEAN)
 8008a9a:	7cfb      	ldrb	r3, [r7, #19]
 8008a9c:	2b01      	cmp	r3, #1
 8008a9e:	d002      	beq.n	8008aa6 <GetBoolean+0x3c>
        return ASN_PARSE_E;
 8008aa0:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8008aa4:	e01a      	b.n	8008adc <GetBoolean+0x72>

    if (input[idx++] != 1)
 8008aa6:	697b      	ldr	r3, [r7, #20]
 8008aa8:	1c5a      	adds	r2, r3, #1
 8008aaa:	617a      	str	r2, [r7, #20]
 8008aac:	68fa      	ldr	r2, [r7, #12]
 8008aae:	4413      	add	r3, r2
 8008ab0:	781b      	ldrb	r3, [r3, #0]
 8008ab2:	2b01      	cmp	r3, #1
 8008ab4:	d002      	beq.n	8008abc <GetBoolean+0x52>
        return ASN_PARSE_E;
 8008ab6:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8008aba:	e00f      	b.n	8008adc <GetBoolean+0x72>

    b = input[idx++] != 0;
 8008abc:	697b      	ldr	r3, [r7, #20]
 8008abe:	1c5a      	adds	r2, r3, #1
 8008ac0:	617a      	str	r2, [r7, #20]
 8008ac2:	68fa      	ldr	r2, [r7, #12]
 8008ac4:	4413      	add	r3, r2
 8008ac6:	781b      	ldrb	r3, [r3, #0]
 8008ac8:	2b00      	cmp	r3, #0
 8008aca:	bf14      	ite	ne
 8008acc:	2301      	movne	r3, #1
 8008ace:	2300      	moveq	r3, #0
 8008ad0:	b2db      	uxtb	r3, r3
 8008ad2:	74fb      	strb	r3, [r7, #19]

    *inOutIdx = idx;
 8008ad4:	68bb      	ldr	r3, [r7, #8]
 8008ad6:	697a      	ldr	r2, [r7, #20]
 8008ad8:	601a      	str	r2, [r3, #0]
    return b;
 8008ada:	7cfb      	ldrb	r3, [r7, #19]
}
 8008adc:	4618      	mov	r0, r3
 8008ade:	371c      	adds	r7, #28
 8008ae0:	46bd      	mov	sp, r7
 8008ae2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008ae6:	4770      	bx	lr

08008ae8 <GetOctetString>:
 *         invalid.
 *         Otherwise, the number of bytes in the ASN.1 data.
 */
int GetOctetString(const byte* input, word32* inOutIdx, int* len,
                          word32 maxIdx)
{
 8008ae8:	b580      	push	{r7, lr}
 8008aea:	b086      	sub	sp, #24
 8008aec:	af02      	add	r7, sp, #8
 8008aee:	60f8      	str	r0, [r7, #12]
 8008af0:	60b9      	str	r1, [r7, #8]
 8008af2:	607a      	str	r2, [r7, #4]
 8008af4:	603b      	str	r3, [r7, #0]
    return GetASNHeader(input, ASN_OCTET_STRING, inOutIdx, len, maxIdx);
 8008af6:	683b      	ldr	r3, [r7, #0]
 8008af8:	9300      	str	r3, [sp, #0]
 8008afa:	687b      	ldr	r3, [r7, #4]
 8008afc:	68ba      	ldr	r2, [r7, #8]
 8008afe:	2104      	movs	r1, #4
 8008b00:	68f8      	ldr	r0, [r7, #12]
 8008b02:	f7ff fef9 	bl	80088f8 <GetASNHeader>
 8008b06:	4603      	mov	r3, r0
}
 8008b08:	4618      	mov	r0, r3
 8008b0a:	3710      	adds	r7, #16
 8008b0c:	46bd      	mov	sp, r7
 8008b0e:	bd80      	pop	{r7, pc}

08008b10 <GetASNInt>:
 *         or invalid use of or missing leading zero.
 *         Otherwise, 0 to indicate success.
 */
static int GetASNInt(const byte* input, word32* inOutIdx, int* len,
                     word32 maxIdx)
{
 8008b10:	b580      	push	{r7, lr}
 8008b12:	b088      	sub	sp, #32
 8008b14:	af02      	add	r7, sp, #8
 8008b16:	60f8      	str	r0, [r7, #12]
 8008b18:	60b9      	str	r1, [r7, #8]
 8008b1a:	607a      	str	r2, [r7, #4]
 8008b1c:	603b      	str	r3, [r7, #0]
    int    ret;

    ret = GetASNHeader(input, ASN_INTEGER, inOutIdx, len, maxIdx);
 8008b1e:	683b      	ldr	r3, [r7, #0]
 8008b20:	9300      	str	r3, [sp, #0]
 8008b22:	687b      	ldr	r3, [r7, #4]
 8008b24:	68ba      	ldr	r2, [r7, #8]
 8008b26:	2102      	movs	r1, #2
 8008b28:	68f8      	ldr	r0, [r7, #12]
 8008b2a:	f7ff fee5 	bl	80088f8 <GetASNHeader>
 8008b2e:	6178      	str	r0, [r7, #20]
    if (ret < 0)
 8008b30:	697b      	ldr	r3, [r7, #20]
 8008b32:	2b00      	cmp	r3, #0
 8008b34:	da01      	bge.n	8008b3a <GetASNInt+0x2a>
        return ret;
 8008b36:	697b      	ldr	r3, [r7, #20]
 8008b38:	e03f      	b.n	8008bba <GetASNInt+0xaa>

    if (*len > 0) {
 8008b3a:	687b      	ldr	r3, [r7, #4]
 8008b3c:	681b      	ldr	r3, [r3, #0]
 8008b3e:	2b00      	cmp	r3, #0
 8008b40:	dd3a      	ble.n	8008bb8 <GetASNInt+0xa8>

#ifndef WOLFSSL_ASN_INT_LEAD_0_ANY
        /* check for invalid padding on negative integer.
         * c.f. X.690 (ISO/IEC 8825-2:2003 (E)) 10.4.6; RFC 5280 4.1
         */
        if (*len > 1) {
 8008b42:	687b      	ldr	r3, [r7, #4]
 8008b44:	681b      	ldr	r3, [r3, #0]
 8008b46:	2b01      	cmp	r3, #1
 8008b48:	dd12      	ble.n	8008b70 <GetASNInt+0x60>
            if ((input[*inOutIdx] == 0xff) && (input[*inOutIdx + 1] & 0x80))
 8008b4a:	68bb      	ldr	r3, [r7, #8]
 8008b4c:	681b      	ldr	r3, [r3, #0]
 8008b4e:	68fa      	ldr	r2, [r7, #12]
 8008b50:	4413      	add	r3, r2
 8008b52:	781b      	ldrb	r3, [r3, #0]
 8008b54:	2bff      	cmp	r3, #255	; 0xff
 8008b56:	d10b      	bne.n	8008b70 <GetASNInt+0x60>
 8008b58:	68bb      	ldr	r3, [r7, #8]
 8008b5a:	681b      	ldr	r3, [r3, #0]
 8008b5c:	3301      	adds	r3, #1
 8008b5e:	68fa      	ldr	r2, [r7, #12]
 8008b60:	4413      	add	r3, r2
 8008b62:	781b      	ldrb	r3, [r3, #0]
 8008b64:	b25b      	sxtb	r3, r3
 8008b66:	2b00      	cmp	r3, #0
 8008b68:	da02      	bge.n	8008b70 <GetASNInt+0x60>
                return ASN_PARSE_E;
 8008b6a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8008b6e:	e024      	b.n	8008bba <GetASNInt+0xaa>
        }
#endif

        /* remove leading zero, unless there is only one 0x00 byte */
        if ((input[*inOutIdx] == 0x00) && (*len > 1)) {
 8008b70:	68bb      	ldr	r3, [r7, #8]
 8008b72:	681b      	ldr	r3, [r3, #0]
 8008b74:	68fa      	ldr	r2, [r7, #12]
 8008b76:	4413      	add	r3, r2
 8008b78:	781b      	ldrb	r3, [r3, #0]
 8008b7a:	2b00      	cmp	r3, #0
 8008b7c:	d11c      	bne.n	8008bb8 <GetASNInt+0xa8>
 8008b7e:	687b      	ldr	r3, [r7, #4]
 8008b80:	681b      	ldr	r3, [r3, #0]
 8008b82:	2b01      	cmp	r3, #1
 8008b84:	dd18      	ble.n	8008bb8 <GetASNInt+0xa8>
            (*inOutIdx)++;
 8008b86:	68bb      	ldr	r3, [r7, #8]
 8008b88:	681b      	ldr	r3, [r3, #0]
 8008b8a:	1c5a      	adds	r2, r3, #1
 8008b8c:	68bb      	ldr	r3, [r7, #8]
 8008b8e:	601a      	str	r2, [r3, #0]
            (*len)--;
 8008b90:	687b      	ldr	r3, [r7, #4]
 8008b92:	681b      	ldr	r3, [r3, #0]
 8008b94:	1e5a      	subs	r2, r3, #1
 8008b96:	687b      	ldr	r3, [r7, #4]
 8008b98:	601a      	str	r2, [r3, #0]

#ifndef WOLFSSL_ASN_INT_LEAD_0_ANY
            if (*len > 0 && (input[*inOutIdx] & 0x80) == 0)
 8008b9a:	687b      	ldr	r3, [r7, #4]
 8008b9c:	681b      	ldr	r3, [r3, #0]
 8008b9e:	2b00      	cmp	r3, #0
 8008ba0:	dd0a      	ble.n	8008bb8 <GetASNInt+0xa8>
 8008ba2:	68bb      	ldr	r3, [r7, #8]
 8008ba4:	681b      	ldr	r3, [r3, #0]
 8008ba6:	68fa      	ldr	r2, [r7, #12]
 8008ba8:	4413      	add	r3, r2
 8008baa:	781b      	ldrb	r3, [r3, #0]
 8008bac:	b25b      	sxtb	r3, r3
 8008bae:	2b00      	cmp	r3, #0
 8008bb0:	db02      	blt.n	8008bb8 <GetASNInt+0xa8>
                return ASN_PARSE_E;
 8008bb2:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8008bb6:	e000      	b.n	8008bba <GetASNInt+0xaa>
#endif
        }
    }

    return 0;
 8008bb8:	2300      	movs	r3, #0
}
 8008bba:	4618      	mov	r0, r3
 8008bbc:	3718      	adds	r7, #24
 8008bbe:	46bd      	mov	sp, r7
 8008bc0:	bd80      	pop	{r7, pc}

08008bc2 <GetInteger7Bit>:
 * returns BUFFER_E when there is not enough data to parse.
 *         ASN_PARSE_E when the INTEGER tag is not found or length is invalid.
 *         Otherwise, the 7-bit value.
 */
static int GetInteger7Bit(const byte* input, word32* inOutIdx, word32 maxIdx)
{
 8008bc2:	b580      	push	{r7, lr}
 8008bc4:	b086      	sub	sp, #24
 8008bc6:	af00      	add	r7, sp, #0
 8008bc8:	60f8      	str	r0, [r7, #12]
 8008bca:	60b9      	str	r1, [r7, #8]
 8008bcc:	607a      	str	r2, [r7, #4]
    word32 idx = *inOutIdx;
 8008bce:	68bb      	ldr	r3, [r7, #8]
 8008bd0:	681b      	ldr	r3, [r3, #0]
 8008bd2:	617b      	str	r3, [r7, #20]
    byte   b;

    if ((idx + 3) > maxIdx)
 8008bd4:	697b      	ldr	r3, [r7, #20]
 8008bd6:	3303      	adds	r3, #3
 8008bd8:	687a      	ldr	r2, [r7, #4]
 8008bda:	429a      	cmp	r2, r3
 8008bdc:	d202      	bcs.n	8008be4 <GetInteger7Bit+0x22>
        return BUFFER_E;
 8008bde:	f06f 0383 	mvn.w	r3, #131	; 0x83
 8008be2:	e029      	b.n	8008c38 <GetInteger7Bit+0x76>

    if (GetASNTag(input, &idx, &b, maxIdx) != 0)
 8008be4:	f107 0213 	add.w	r2, r7, #19
 8008be8:	f107 0114 	add.w	r1, r7, #20
 8008bec:	687b      	ldr	r3, [r7, #4]
 8008bee:	68f8      	ldr	r0, [r7, #12]
 8008bf0:	f7ff fe18 	bl	8008824 <GetASNTag>
 8008bf4:	4603      	mov	r3, r0
 8008bf6:	2b00      	cmp	r3, #0
 8008bf8:	d002      	beq.n	8008c00 <GetInteger7Bit+0x3e>
        return ASN_PARSE_E;
 8008bfa:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8008bfe:	e01b      	b.n	8008c38 <GetInteger7Bit+0x76>
    if (b != ASN_INTEGER)
 8008c00:	7cfb      	ldrb	r3, [r7, #19]
 8008c02:	2b02      	cmp	r3, #2
 8008c04:	d002      	beq.n	8008c0c <GetInteger7Bit+0x4a>
        return ASN_PARSE_E;
 8008c06:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8008c0a:	e015      	b.n	8008c38 <GetInteger7Bit+0x76>
    if (input[idx++] != 1)
 8008c0c:	697b      	ldr	r3, [r7, #20]
 8008c0e:	1c5a      	adds	r2, r3, #1
 8008c10:	617a      	str	r2, [r7, #20]
 8008c12:	68fa      	ldr	r2, [r7, #12]
 8008c14:	4413      	add	r3, r2
 8008c16:	781b      	ldrb	r3, [r3, #0]
 8008c18:	2b01      	cmp	r3, #1
 8008c1a:	d002      	beq.n	8008c22 <GetInteger7Bit+0x60>
        return ASN_PARSE_E;
 8008c1c:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8008c20:	e00a      	b.n	8008c38 <GetInteger7Bit+0x76>
    b = input[idx++];
 8008c22:	697b      	ldr	r3, [r7, #20]
 8008c24:	1c5a      	adds	r2, r3, #1
 8008c26:	617a      	str	r2, [r7, #20]
 8008c28:	68fa      	ldr	r2, [r7, #12]
 8008c2a:	4413      	add	r3, r2
 8008c2c:	781b      	ldrb	r3, [r3, #0]
 8008c2e:	74fb      	strb	r3, [r7, #19]

    *inOutIdx = idx;
 8008c30:	697a      	ldr	r2, [r7, #20]
 8008c32:	68bb      	ldr	r3, [r7, #8]
 8008c34:	601a      	str	r2, [r3, #0]
    return b;
 8008c36:	7cfb      	ldrb	r3, [r7, #19]
}
 8008c38:	4618      	mov	r0, r3
 8008c3a:	3718      	adds	r7, #24
 8008c3c:	46bd      	mov	sp, r7
 8008c3e:	bd80      	pop	{r7, pc}

08008c40 <GetMyVersion>:
#endif /* !NO_RSA && HAVE_USER_RSA && WOLFSSL_CERT_GEN */

/* Windows header clash for WinCE using GetVersion */
int GetMyVersion(const byte* input, word32* inOutIdx,
                               int* version, word32 maxIdx)
{
 8008c40:	b580      	push	{r7, lr}
 8008c42:	b086      	sub	sp, #24
 8008c44:	af00      	add	r7, sp, #0
 8008c46:	60f8      	str	r0, [r7, #12]
 8008c48:	60b9      	str	r1, [r7, #8]
 8008c4a:	607a      	str	r2, [r7, #4]
 8008c4c:	603b      	str	r3, [r7, #0]
    word32 idx = *inOutIdx;
 8008c4e:	68bb      	ldr	r3, [r7, #8]
 8008c50:	681b      	ldr	r3, [r3, #0]
 8008c52:	617b      	str	r3, [r7, #20]
    byte   tag;

    if ((idx + MIN_VERSION_SZ) > maxIdx)
 8008c54:	697b      	ldr	r3, [r7, #20]
 8008c56:	3303      	adds	r3, #3
 8008c58:	683a      	ldr	r2, [r7, #0]
 8008c5a:	429a      	cmp	r2, r3
 8008c5c:	d202      	bcs.n	8008c64 <GetMyVersion+0x24>
        return ASN_PARSE_E;
 8008c5e:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8008c62:	e02c      	b.n	8008cbe <GetMyVersion+0x7e>

    if (GetASNTag(input, &idx, &tag, maxIdx) != 0)
 8008c64:	f107 0213 	add.w	r2, r7, #19
 8008c68:	f107 0114 	add.w	r1, r7, #20
 8008c6c:	683b      	ldr	r3, [r7, #0]
 8008c6e:	68f8      	ldr	r0, [r7, #12]
 8008c70:	f7ff fdd8 	bl	8008824 <GetASNTag>
 8008c74:	4603      	mov	r3, r0
 8008c76:	2b00      	cmp	r3, #0
 8008c78:	d002      	beq.n	8008c80 <GetMyVersion+0x40>
        return ASN_PARSE_E;
 8008c7a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8008c7e:	e01e      	b.n	8008cbe <GetMyVersion+0x7e>

    if (tag != ASN_INTEGER)
 8008c80:	7cfb      	ldrb	r3, [r7, #19]
 8008c82:	2b02      	cmp	r3, #2
 8008c84:	d002      	beq.n	8008c8c <GetMyVersion+0x4c>
        return ASN_PARSE_E;
 8008c86:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8008c8a:	e018      	b.n	8008cbe <GetMyVersion+0x7e>

    if (input[idx++] != 0x01)
 8008c8c:	697b      	ldr	r3, [r7, #20]
 8008c8e:	1c5a      	adds	r2, r3, #1
 8008c90:	617a      	str	r2, [r7, #20]
 8008c92:	68fa      	ldr	r2, [r7, #12]
 8008c94:	4413      	add	r3, r2
 8008c96:	781b      	ldrb	r3, [r3, #0]
 8008c98:	2b01      	cmp	r3, #1
 8008c9a:	d002      	beq.n	8008ca2 <GetMyVersion+0x62>
        return ASN_VERSION_E;
 8008c9c:	f06f 038c 	mvn.w	r3, #140	; 0x8c
 8008ca0:	e00d      	b.n	8008cbe <GetMyVersion+0x7e>

    *version  = input[idx++];
 8008ca2:	697b      	ldr	r3, [r7, #20]
 8008ca4:	1c5a      	adds	r2, r3, #1
 8008ca6:	617a      	str	r2, [r7, #20]
 8008ca8:	68fa      	ldr	r2, [r7, #12]
 8008caa:	4413      	add	r3, r2
 8008cac:	781b      	ldrb	r3, [r3, #0]
 8008cae:	461a      	mov	r2, r3
 8008cb0:	687b      	ldr	r3, [r7, #4]
 8008cb2:	601a      	str	r2, [r3, #0]
    *inOutIdx = idx;
 8008cb4:	697a      	ldr	r2, [r7, #20]
 8008cb6:	68bb      	ldr	r3, [r7, #8]
 8008cb8:	601a      	str	r2, [r3, #0]

    return *version;
 8008cba:	687b      	ldr	r3, [r7, #4]
 8008cbc:	681b      	ldr	r3, [r3, #0]
}
 8008cbe:	4618      	mov	r0, r3
 8008cc0:	3718      	adds	r7, #24
 8008cc2:	46bd      	mov	sp, r7
 8008cc4:	bd80      	pop	{r7, pc}

08008cc6 <GetExplicitVersion>:
#endif /* !NO_PWDBASED */

/* May not have one, not an error */
static int GetExplicitVersion(const byte* input, word32* inOutIdx, int* version,
                              word32 maxIdx)
{
 8008cc6:	b580      	push	{r7, lr}
 8008cc8:	b088      	sub	sp, #32
 8008cca:	af00      	add	r7, sp, #0
 8008ccc:	60f8      	str	r0, [r7, #12]
 8008cce:	60b9      	str	r1, [r7, #8]
 8008cd0:	607a      	str	r2, [r7, #4]
 8008cd2:	603b      	str	r3, [r7, #0]
    word32 idx = *inOutIdx;
 8008cd4:	68bb      	ldr	r3, [r7, #8]
 8008cd6:	681b      	ldr	r3, [r3, #0]
 8008cd8:	61bb      	str	r3, [r7, #24]
    byte tag;

    WOLFSSL_ENTER("GetExplicitVersion");

    if (GetASNTag(input, &idx, &tag, maxIdx) != 0)
 8008cda:	f107 0217 	add.w	r2, r7, #23
 8008cde:	f107 0118 	add.w	r1, r7, #24
 8008ce2:	683b      	ldr	r3, [r7, #0]
 8008ce4:	68f8      	ldr	r0, [r7, #12]
 8008ce6:	f7ff fd9d 	bl	8008824 <GetASNTag>
 8008cea:	4603      	mov	r3, r0
 8008cec:	2b00      	cmp	r3, #0
 8008cee:	d002      	beq.n	8008cf6 <GetExplicitVersion+0x30>
        return ASN_PARSE_E;
 8008cf0:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8008cf4:	e023      	b.n	8008d3e <GetExplicitVersion+0x78>

    if (tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED)) {
 8008cf6:	7dfb      	ldrb	r3, [r7, #23]
 8008cf8:	2ba0      	cmp	r3, #160	; 0xa0
 8008cfa:	d11c      	bne.n	8008d36 <GetExplicitVersion+0x70>
        int ret;

        *inOutIdx = ++idx;  /* skip header */
 8008cfc:	69bb      	ldr	r3, [r7, #24]
 8008cfe:	3301      	adds	r3, #1
 8008d00:	61bb      	str	r3, [r7, #24]
 8008d02:	69ba      	ldr	r2, [r7, #24]
 8008d04:	68bb      	ldr	r3, [r7, #8]
 8008d06:	601a      	str	r2, [r3, #0]
        ret = GetMyVersion(input, inOutIdx, version, maxIdx);
 8008d08:	683b      	ldr	r3, [r7, #0]
 8008d0a:	687a      	ldr	r2, [r7, #4]
 8008d0c:	68b9      	ldr	r1, [r7, #8]
 8008d0e:	68f8      	ldr	r0, [r7, #12]
 8008d10:	f7ff ff96 	bl	8008c40 <GetMyVersion>
 8008d14:	61f8      	str	r0, [r7, #28]
        if (ret >= 0) {
 8008d16:	69fb      	ldr	r3, [r7, #28]
 8008d18:	2b00      	cmp	r3, #0
 8008d1a:	db0a      	blt.n	8008d32 <GetExplicitVersion+0x6c>
            /* check if version is expected value rfc 5280 4.1 {0, 1, 2} */
            if (*version > MAX_X509_VERSION || *version < MIN_X509_VERSION) {
 8008d1c:	687b      	ldr	r3, [r7, #4]
 8008d1e:	681b      	ldr	r3, [r3, #0]
 8008d20:	2b03      	cmp	r3, #3
 8008d22:	dc03      	bgt.n	8008d2c <GetExplicitVersion+0x66>
 8008d24:	687b      	ldr	r3, [r7, #4]
 8008d26:	681b      	ldr	r3, [r3, #0]
 8008d28:	2b00      	cmp	r3, #0
 8008d2a:	da02      	bge.n	8008d32 <GetExplicitVersion+0x6c>
                WOLFSSL_MSG("Unexpected certificate version");
                ret = ASN_VERSION_E;
 8008d2c:	f06f 038c 	mvn.w	r3, #140	; 0x8c
 8008d30:	61fb      	str	r3, [r7, #28]
            }
        }
        return ret;
 8008d32:	69fb      	ldr	r3, [r7, #28]
 8008d34:	e003      	b.n	8008d3e <GetExplicitVersion+0x78>
    }

    /* go back as is */
    *version = 0;
 8008d36:	687b      	ldr	r3, [r7, #4]
 8008d38:	2200      	movs	r2, #0
 8008d3a:	601a      	str	r2, [r3, #0]

    return 0;
 8008d3c:	2300      	movs	r3, #0
}
 8008d3e:	4618      	mov	r0, r3
 8008d40:	3720      	adds	r7, #32
 8008d42:	46bd      	mov	sp, r7
 8008d44:	bd80      	pop	{r7, pc}

08008d46 <GetInt>:

int GetInt(mp_int* mpi, const byte* input, word32* inOutIdx, word32 maxIdx)
{
 8008d46:	b580      	push	{r7, lr}
 8008d48:	b088      	sub	sp, #32
 8008d4a:	af00      	add	r7, sp, #0
 8008d4c:	60f8      	str	r0, [r7, #12]
 8008d4e:	60b9      	str	r1, [r7, #8]
 8008d50:	607a      	str	r2, [r7, #4]
 8008d52:	603b      	str	r3, [r7, #0]
    word32 idx = *inOutIdx;
 8008d54:	687b      	ldr	r3, [r7, #4]
 8008d56:	681b      	ldr	r3, [r3, #0]
 8008d58:	61bb      	str	r3, [r7, #24]
    int    ret;
    int    length;

    ret = GetASNInt(input, &idx, &length, maxIdx);
 8008d5a:	f107 0214 	add.w	r2, r7, #20
 8008d5e:	f107 0118 	add.w	r1, r7, #24
 8008d62:	683b      	ldr	r3, [r7, #0]
 8008d64:	68b8      	ldr	r0, [r7, #8]
 8008d66:	f7ff fed3 	bl	8008b10 <GetASNInt>
 8008d6a:	61f8      	str	r0, [r7, #28]
    if (ret != 0)
 8008d6c:	69fb      	ldr	r3, [r7, #28]
 8008d6e:	2b00      	cmp	r3, #0
 8008d70:	d001      	beq.n	8008d76 <GetInt+0x30>
        return ret;
 8008d72:	69fb      	ldr	r3, [r7, #28]
 8008d74:	e01f      	b.n	8008db6 <GetInt+0x70>

    if (mp_init(mpi) != MP_OKAY)
 8008d76:	68f8      	ldr	r0, [r7, #12]
 8008d78:	f00f fdc8 	bl	801890c <sp_init>
 8008d7c:	4603      	mov	r3, r0
 8008d7e:	2b00      	cmp	r3, #0
 8008d80:	d002      	beq.n	8008d88 <GetInt+0x42>
        return MP_INIT_E;
 8008d82:	f06f 036d 	mvn.w	r3, #109	; 0x6d
 8008d86:	e016      	b.n	8008db6 <GetInt+0x70>

    if (mp_read_unsigned_bin(mpi, (byte*)input + idx, length) != 0) {
 8008d88:	69bb      	ldr	r3, [r7, #24]
 8008d8a:	68ba      	ldr	r2, [r7, #8]
 8008d8c:	4413      	add	r3, r2
 8008d8e:	697a      	ldr	r2, [r7, #20]
 8008d90:	4619      	mov	r1, r3
 8008d92:	68f8      	ldr	r0, [r7, #12]
 8008d94:	f010 f882 	bl	8018e9c <sp_read_unsigned_bin>
 8008d98:	4603      	mov	r3, r0
 8008d9a:	2b00      	cmp	r3, #0
 8008d9c:	d005      	beq.n	8008daa <GetInt+0x64>
        mp_clear(mpi);
 8008d9e:	68f8      	ldr	r0, [r7, #12]
 8008da0:	f00f fe65 	bl	8018a6e <sp_clear>
        return ASN_GETINT_E;
 8008da4:	f06f 038d 	mvn.w	r3, #141	; 0x8d
 8008da8:	e005      	b.n	8008db6 <GetInt+0x70>
        mp_clear(mpi);
        return ASN_GETINT_E;
    }
#endif /* HAVE_WOLF_BIGINT */

    *inOutIdx = idx + length;
 8008daa:	69bb      	ldr	r3, [r7, #24]
 8008dac:	697a      	ldr	r2, [r7, #20]
 8008dae:	441a      	add	r2, r3
 8008db0:	687b      	ldr	r3, [r7, #4]
 8008db2:	601a      	str	r2, [r3, #0]

    return 0;
 8008db4:	2300      	movs	r3, #0
}
 8008db6:	4618      	mov	r0, r3
 8008db8:	3720      	adds	r7, #32
 8008dba:	46bd      	mov	sp, r7
 8008dbc:	bd80      	pop	{r7, pc}

08008dbe <CheckBitString>:
#endif
#endif

int CheckBitString(const byte* input, word32* inOutIdx, int* len,
                          word32 maxIdx, int zeroBits, byte* unusedBits)
{
 8008dbe:	b580      	push	{r7, lr}
 8008dc0:	b088      	sub	sp, #32
 8008dc2:	af00      	add	r7, sp, #0
 8008dc4:	60f8      	str	r0, [r7, #12]
 8008dc6:	60b9      	str	r1, [r7, #8]
 8008dc8:	607a      	str	r2, [r7, #4]
 8008dca:	603b      	str	r3, [r7, #0]
    word32 idx = *inOutIdx;
 8008dcc:	68bb      	ldr	r3, [r7, #8]
 8008dce:	681b      	ldr	r3, [r3, #0]
 8008dd0:	61fb      	str	r3, [r7, #28]
    int    length;
    byte   b;

    if (GetASNTag(input, &idx, &b, maxIdx) != 0) {
 8008dd2:	f107 0217 	add.w	r2, r7, #23
 8008dd6:	f107 011c 	add.w	r1, r7, #28
 8008dda:	683b      	ldr	r3, [r7, #0]
 8008ddc:	68f8      	ldr	r0, [r7, #12]
 8008dde:	f7ff fd21 	bl	8008824 <GetASNTag>
 8008de2:	4603      	mov	r3, r0
 8008de4:	2b00      	cmp	r3, #0
 8008de6:	d002      	beq.n	8008dee <CheckBitString+0x30>
        return ASN_BITSTR_E;
 8008de8:	f06f 0392 	mvn.w	r3, #146	; 0x92
 8008dec:	e061      	b.n	8008eb2 <CheckBitString+0xf4>
    }

    if (b != ASN_BIT_STRING) {
 8008dee:	7dfb      	ldrb	r3, [r7, #23]
 8008df0:	2b03      	cmp	r3, #3
 8008df2:	d002      	beq.n	8008dfa <CheckBitString+0x3c>
        return ASN_BITSTR_E;
 8008df4:	f06f 0392 	mvn.w	r3, #146	; 0x92
 8008df8:	e05b      	b.n	8008eb2 <CheckBitString+0xf4>
    }

    if (GetLength(input, &idx, &length, maxIdx) < 0)
 8008dfa:	f107 0218 	add.w	r2, r7, #24
 8008dfe:	f107 011c 	add.w	r1, r7, #28
 8008e02:	683b      	ldr	r3, [r7, #0]
 8008e04:	68f8      	ldr	r0, [r7, #12]
 8008e06:	f7ff fc8f 	bl	8008728 <GetLength>
 8008e0a:	4603      	mov	r3, r0
 8008e0c:	2b00      	cmp	r3, #0
 8008e0e:	da02      	bge.n	8008e16 <CheckBitString+0x58>
        return ASN_PARSE_E;
 8008e10:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8008e14:	e04d      	b.n	8008eb2 <CheckBitString+0xf4>

    /* extra sanity check that length is greater than 0 */
    if (length <= 0) {
 8008e16:	69bb      	ldr	r3, [r7, #24]
 8008e18:	2b00      	cmp	r3, #0
 8008e1a:	dc02      	bgt.n	8008e22 <CheckBitString+0x64>
        WOLFSSL_MSG("Error length was 0 in CheckBitString");
        return BUFFER_E;
 8008e1c:	f06f 0383 	mvn.w	r3, #131	; 0x83
 8008e20:	e047      	b.n	8008eb2 <CheckBitString+0xf4>
    }

    if (idx + 1 > maxIdx) {
 8008e22:	69fb      	ldr	r3, [r7, #28]
 8008e24:	3301      	adds	r3, #1
 8008e26:	683a      	ldr	r2, [r7, #0]
 8008e28:	429a      	cmp	r2, r3
 8008e2a:	d202      	bcs.n	8008e32 <CheckBitString+0x74>
        WOLFSSL_MSG("Attempted buffer read larger than input buffer");
        return BUFFER_E;
 8008e2c:	f06f 0383 	mvn.w	r3, #131	; 0x83
 8008e30:	e03f      	b.n	8008eb2 <CheckBitString+0xf4>
    }

    b = input[idx];
 8008e32:	69fb      	ldr	r3, [r7, #28]
 8008e34:	68fa      	ldr	r2, [r7, #12]
 8008e36:	4413      	add	r3, r2
 8008e38:	781b      	ldrb	r3, [r3, #0]
 8008e3a:	75fb      	strb	r3, [r7, #23]
    if (zeroBits && b != 0x00)
 8008e3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008e3e:	2b00      	cmp	r3, #0
 8008e40:	d005      	beq.n	8008e4e <CheckBitString+0x90>
 8008e42:	7dfb      	ldrb	r3, [r7, #23]
 8008e44:	2b00      	cmp	r3, #0
 8008e46:	d002      	beq.n	8008e4e <CheckBitString+0x90>
        return ASN_EXPECT_0_E;
 8008e48:	f06f 0391 	mvn.w	r3, #145	; 0x91
 8008e4c:	e031      	b.n	8008eb2 <CheckBitString+0xf4>
    if (b >= 0x08)
 8008e4e:	7dfb      	ldrb	r3, [r7, #23]
 8008e50:	2b07      	cmp	r3, #7
 8008e52:	d902      	bls.n	8008e5a <CheckBitString+0x9c>
        return ASN_PARSE_E;
 8008e54:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8008e58:	e02b      	b.n	8008eb2 <CheckBitString+0xf4>
    if (b != 0) {
 8008e5a:	7dfb      	ldrb	r3, [r7, #23]
 8008e5c:	2b00      	cmp	r3, #0
 8008e5e:	d012      	beq.n	8008e86 <CheckBitString+0xc8>
        if ((byte)(input[idx + length - 1] << (8 - b)) != 0)
 8008e60:	69fb      	ldr	r3, [r7, #28]
 8008e62:	69ba      	ldr	r2, [r7, #24]
 8008e64:	4413      	add	r3, r2
 8008e66:	3b01      	subs	r3, #1
 8008e68:	68fa      	ldr	r2, [r7, #12]
 8008e6a:	4413      	add	r3, r2
 8008e6c:	781b      	ldrb	r3, [r3, #0]
 8008e6e:	461a      	mov	r2, r3
 8008e70:	7dfb      	ldrb	r3, [r7, #23]
 8008e72:	f1c3 0308 	rsb	r3, r3, #8
 8008e76:	fa02 f303 	lsl.w	r3, r2, r3
 8008e7a:	b2db      	uxtb	r3, r3
 8008e7c:	2b00      	cmp	r3, #0
 8008e7e:	d002      	beq.n	8008e86 <CheckBitString+0xc8>
            return ASN_PARSE_E;
 8008e80:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8008e84:	e015      	b.n	8008eb2 <CheckBitString+0xf4>
    }
    idx++;
 8008e86:	69fb      	ldr	r3, [r7, #28]
 8008e88:	3301      	adds	r3, #1
 8008e8a:	61fb      	str	r3, [r7, #28]
    length--; /* length has been checked for greater than 0 */
 8008e8c:	69bb      	ldr	r3, [r7, #24]
 8008e8e:	3b01      	subs	r3, #1
 8008e90:	61bb      	str	r3, [r7, #24]

    *inOutIdx = idx;
 8008e92:	69fa      	ldr	r2, [r7, #28]
 8008e94:	68bb      	ldr	r3, [r7, #8]
 8008e96:	601a      	str	r2, [r3, #0]
    if (len != NULL)
 8008e98:	687b      	ldr	r3, [r7, #4]
 8008e9a:	2b00      	cmp	r3, #0
 8008e9c:	d002      	beq.n	8008ea4 <CheckBitString+0xe6>
        *len = length;
 8008e9e:	69ba      	ldr	r2, [r7, #24]
 8008ea0:	687b      	ldr	r3, [r7, #4]
 8008ea2:	601a      	str	r2, [r3, #0]
    if (unusedBits != NULL)
 8008ea4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008ea6:	2b00      	cmp	r3, #0
 8008ea8:	d002      	beq.n	8008eb0 <CheckBitString+0xf2>
        *unusedBits = b;
 8008eaa:	7dfa      	ldrb	r2, [r7, #23]
 8008eac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008eae:	701a      	strb	r2, [r3, #0]

    return 0;
 8008eb0:	2300      	movs	r3, #0
}
 8008eb2:	4618      	mov	r0, r3
 8008eb4:	3720      	adds	r7, #32
 8008eb6:	46bd      	mov	sp, r7
 8008eb8:	bd80      	pop	{r7, pc}
	...

08008ebc <OidFromId>:
#endif


/* returns a pointer to the OID string on success and NULL on fail */
const byte* OidFromId(word32 id, word32 type, word32* oidSz)
{
 8008ebc:	b580      	push	{r7, lr}
 8008ebe:	b086      	sub	sp, #24
 8008ec0:	af00      	add	r7, sp, #0
 8008ec2:	60f8      	str	r0, [r7, #12]
 8008ec4:	60b9      	str	r1, [r7, #8]
 8008ec6:	607a      	str	r2, [r7, #4]
    const byte* oid = NULL;
 8008ec8:	2300      	movs	r3, #0
 8008eca:	617b      	str	r3, [r7, #20]

    *oidSz = 0;
 8008ecc:	687b      	ldr	r3, [r7, #4]
 8008ece:	2200      	movs	r2, #0
 8008ed0:	601a      	str	r2, [r3, #0]

    switch (type) {
 8008ed2:	68bb      	ldr	r3, [r7, #8]
 8008ed4:	2b13      	cmp	r3, #19
 8008ed6:	f200 82db 	bhi.w	8009490 <OidFromId+0x5d4>
 8008eda:	a201      	add	r2, pc, #4	; (adr r2, 8008ee0 <OidFromId+0x24>)
 8008edc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008ee0:	08008f31 	.word	0x08008f31
 8008ee4:	08008f49 	.word	0x08008f49
 8008ee8:	08008f75 	.word	0x08008f75
 8008eec:	08008fb7 	.word	0x08008fb7
 8008ef0:	08008fc7 	.word	0x08008fc7
 8008ef4:	08009491 	.word	0x08009491
 8008ef8:	080090d7 	.word	0x080090d7
 8008efc:	08009333 	.word	0x08009333
 8008f00:	08009349 	.word	0x08009349
 8008f04:	0800935f 	.word	0x0800935f
 8008f08:	08009375 	.word	0x08009375
 8008f0c:	080093f1 	.word	0x080093f1
 8008f10:	0800941f 	.word	0x0800941f
 8008f14:	08009461 	.word	0x08009461
 8008f18:	08009409 	.word	0x08009409
 8008f1c:	08009477 	.word	0x08009477
 8008f20:	08009491 	.word	0x08009491
 8008f24:	08009491 	.word	0x08009491
 8008f28:	08009491 	.word	0x08009491
 8008f2c:	08009491 	.word	0x08009491

        case oidHashType:
            switch (id) {
 8008f30:	68fb      	ldr	r3, [r7, #12]
 8008f32:	f5b3 7fcf 	cmp.w	r3, #414	; 0x19e
 8008f36:	d000      	beq.n	8008f3a <OidFromId+0x7e>
                    oid = hashSha512hOid;
                    *oidSz = sizeof(hashSha512hOid);
                    break;
            #endif
            }
            break;
 8008f38:	e2af      	b.n	800949a <OidFromId+0x5de>
                    oid = hashSha256hOid;
 8008f3a:	4bd2      	ldr	r3, [pc, #840]	; (8009284 <OidFromId+0x3c8>)
 8008f3c:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(hashSha256hOid);
 8008f3e:	687b      	ldr	r3, [r7, #4]
 8008f40:	2209      	movs	r2, #9
 8008f42:	601a      	str	r2, [r3, #0]
                    break;
 8008f44:	bf00      	nop
            break;
 8008f46:	e2a8      	b.n	800949a <OidFromId+0x5de>

        case oidSigType:
            switch (id) {
 8008f48:	68fb      	ldr	r3, [r7, #12]
 8008f4a:	f5b3 7f03 	cmp.w	r3, #524	; 0x20c
 8008f4e:	d00a      	beq.n	8008f66 <OidFromId+0xaa>
 8008f50:	f240 228f 	movw	r2, #655	; 0x28f
 8008f54:	4293      	cmp	r3, r2
 8008f56:	d000      	beq.n	8008f5a <OidFromId+0x9e>
                    oid = sigEd448Oid;
                    *oidSz = sizeof(sigEd448Oid);
                    break;
                #endif
                default:
                    break;
 8008f58:	e00b      	b.n	8008f72 <OidFromId+0xb6>
                    oid = sigSha256wRsaOid;
 8008f5a:	4bcb      	ldr	r3, [pc, #812]	; (8009288 <OidFromId+0x3cc>)
 8008f5c:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(sigSha256wRsaOid);
 8008f5e:	687b      	ldr	r3, [r7, #4]
 8008f60:	2209      	movs	r2, #9
 8008f62:	601a      	str	r2, [r3, #0]
                    break;
 8008f64:	e005      	b.n	8008f72 <OidFromId+0xb6>
                    oid = sigSha256wEcdsaOid;
 8008f66:	4bc9      	ldr	r3, [pc, #804]	; (800928c <OidFromId+0x3d0>)
 8008f68:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(sigSha256wEcdsaOid);
 8008f6a:	687b      	ldr	r3, [r7, #4]
 8008f6c:	2208      	movs	r2, #8
 8008f6e:	601a      	str	r2, [r3, #0]
                    break;
 8008f70:	bf00      	nop
            }
            break;
 8008f72:	e292      	b.n	800949a <OidFromId+0x5de>

        case oidKeyType:
            switch (id) {
 8008f74:	68fb      	ldr	r3, [r7, #12]
 8008f76:	f240 2285 	movw	r2, #645	; 0x285
 8008f7a:	4293      	cmp	r3, r2
 8008f7c:	d008      	beq.n	8008f90 <OidFromId+0xd4>
 8008f7e:	f240 2287 	movw	r2, #647	; 0x287
 8008f82:	4293      	cmp	r3, r2
 8008f84:	d010      	beq.n	8008fa8 <OidFromId+0xec>
 8008f86:	f240 2206 	movw	r2, #518	; 0x206
 8008f8a:	4293      	cmp	r3, r2
 8008f8c:	d006      	beq.n	8008f9c <OidFromId+0xe0>
                    oid = keyDhOid;
                    *oidSz = sizeof(keyDhOid);
                    break;
                #endif /* !NO_DH */
                default:
                    break;
 8008f8e:	e011      	b.n	8008fb4 <OidFromId+0xf8>
                    oid = keyRsaOid;
 8008f90:	4bbf      	ldr	r3, [pc, #764]	; (8009290 <OidFromId+0x3d4>)
 8008f92:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(keyRsaOid);
 8008f94:	687b      	ldr	r3, [r7, #4]
 8008f96:	2209      	movs	r2, #9
 8008f98:	601a      	str	r2, [r3, #0]
                    break;
 8008f9a:	e00b      	b.n	8008fb4 <OidFromId+0xf8>
                    oid = keyEcdsaOid;
 8008f9c:	4bbd      	ldr	r3, [pc, #756]	; (8009294 <OidFromId+0x3d8>)
 8008f9e:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(keyEcdsaOid);
 8008fa0:	687b      	ldr	r3, [r7, #4]
 8008fa2:	2207      	movs	r2, #7
 8008fa4:	601a      	str	r2, [r3, #0]
                    break;
 8008fa6:	e005      	b.n	8008fb4 <OidFromId+0xf8>
                    oid = keyDhOid;
 8008fa8:	4bbb      	ldr	r3, [pc, #748]	; (8009298 <OidFromId+0x3dc>)
 8008faa:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(keyDhOid);
 8008fac:	687b      	ldr	r3, [r7, #4]
 8008fae:	2209      	movs	r2, #9
 8008fb0:	601a      	str	r2, [r3, #0]
                    break;
 8008fb2:	bf00      	nop
            }
            break;
 8008fb4:	e271      	b.n	800949a <OidFromId+0x5de>

        #ifdef HAVE_ECC
        case oidCurveType:
            if (wc_ecc_get_oid(id, &oid, oidSz) < 0) {
 8008fb6:	f107 0314 	add.w	r3, r7, #20
 8008fba:	687a      	ldr	r2, [r7, #4]
 8008fbc:	4619      	mov	r1, r3
 8008fbe:	68f8      	ldr	r0, [r7, #12]
 8008fc0:	f005 fe82 	bl	800ecc8 <wc_ecc_get_oid>
                WOLFSSL_MSG("ECC OID not found");
            }
            break;
 8008fc4:	e269      	b.n	800949a <OidFromId+0x5de>
        #endif /* HAVE_ECC */

        case oidBlkType:
            switch (id) {
 8008fc6:	68fb      	ldr	r3, [r7, #12]
 8008fc8:	f5a3 73cf 	sub.w	r3, r3, #414	; 0x19e
 8008fcc:	2b2c      	cmp	r3, #44	; 0x2c
 8008fce:	f200 8261 	bhi.w	8009494 <OidFromId+0x5d8>
 8008fd2:	a201      	add	r2, pc, #4	; (adr r2, 8008fd8 <OidFromId+0x11c>)
 8008fd4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008fd8:	0800908d 	.word	0x0800908d
 8008fdc:	08009495 	.word	0x08009495
 8008fe0:	08009495 	.word	0x08009495
 8008fe4:	08009495 	.word	0x08009495
 8008fe8:	080090b1 	.word	0x080090b1
 8008fec:	08009495 	.word	0x08009495
 8008ff0:	08009495 	.word	0x08009495
 8008ff4:	08009495 	.word	0x08009495
 8008ff8:	08009495 	.word	0x08009495
 8008ffc:	08009495 	.word	0x08009495
 8009000:	08009495 	.word	0x08009495
 8009004:	08009495 	.word	0x08009495
 8009008:	08009495 	.word	0x08009495
 800900c:	08009495 	.word	0x08009495
 8009010:	08009495 	.word	0x08009495
 8009014:	08009495 	.word	0x08009495
 8009018:	08009495 	.word	0x08009495
 800901c:	08009495 	.word	0x08009495
 8009020:	08009495 	.word	0x08009495
 8009024:	08009495 	.word	0x08009495
 8009028:	08009099 	.word	0x08009099
 800902c:	08009495 	.word	0x08009495
 8009030:	08009495 	.word	0x08009495
 8009034:	08009495 	.word	0x08009495
 8009038:	080090bd 	.word	0x080090bd
 800903c:	08009495 	.word	0x08009495
 8009040:	08009495 	.word	0x08009495
 8009044:	08009495 	.word	0x08009495
 8009048:	08009495 	.word	0x08009495
 800904c:	08009495 	.word	0x08009495
 8009050:	08009495 	.word	0x08009495
 8009054:	08009495 	.word	0x08009495
 8009058:	08009495 	.word	0x08009495
 800905c:	08009495 	.word	0x08009495
 8009060:	08009495 	.word	0x08009495
 8009064:	08009495 	.word	0x08009495
 8009068:	08009495 	.word	0x08009495
 800906c:	08009495 	.word	0x08009495
 8009070:	08009495 	.word	0x08009495
 8009074:	08009495 	.word	0x08009495
 8009078:	080090a5 	.word	0x080090a5
 800907c:	08009495 	.word	0x08009495
 8009080:	08009495 	.word	0x08009495
 8009084:	08009495 	.word	0x08009495
 8009088:	080090c9 	.word	0x080090c9
    #ifdef HAVE_AES_CBC
        #ifdef WOLFSSL_AES_128
                case AES128CBCb:
                    oid = blkAes128CbcOid;
 800908c:	4b83      	ldr	r3, [pc, #524]	; (800929c <OidFromId+0x3e0>)
 800908e:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes128CbcOid);
 8009090:	687b      	ldr	r3, [r7, #4]
 8009092:	2209      	movs	r2, #9
 8009094:	601a      	str	r2, [r3, #0]
                    break;
 8009096:	e01d      	b.n	80090d4 <OidFromId+0x218>
        #endif
        #ifdef WOLFSSL_AES_192
                case AES192CBCb:
                    oid = blkAes192CbcOid;
 8009098:	4b81      	ldr	r3, [pc, #516]	; (80092a0 <OidFromId+0x3e4>)
 800909a:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes192CbcOid);
 800909c:	687b      	ldr	r3, [r7, #4]
 800909e:	2209      	movs	r2, #9
 80090a0:	601a      	str	r2, [r3, #0]
                    break;
 80090a2:	e017      	b.n	80090d4 <OidFromId+0x218>
        #endif
        #ifdef WOLFSSL_AES_256
                case AES256CBCb:
                    oid = blkAes256CbcOid;
 80090a4:	4b7f      	ldr	r3, [pc, #508]	; (80092a4 <OidFromId+0x3e8>)
 80090a6:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes256CbcOid);
 80090a8:	687b      	ldr	r3, [r7, #4]
 80090aa:	2209      	movs	r2, #9
 80090ac:	601a      	str	r2, [r3, #0]
                    break;
 80090ae:	e011      	b.n	80090d4 <OidFromId+0x218>
        #endif
    #endif /* HAVE_AES_CBC */
    #ifdef HAVE_AESGCM
        #ifdef WOLFSSL_AES_128
                case AES128GCMb:
                    oid = blkAes128GcmOid;
 80090b0:	4b7d      	ldr	r3, [pc, #500]	; (80092a8 <OidFromId+0x3ec>)
 80090b2:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes128GcmOid);
 80090b4:	687b      	ldr	r3, [r7, #4]
 80090b6:	2209      	movs	r2, #9
 80090b8:	601a      	str	r2, [r3, #0]
                    break;
 80090ba:	e00b      	b.n	80090d4 <OidFromId+0x218>
        #endif
        #ifdef WOLFSSL_AES_192
                case AES192GCMb:
                    oid = blkAes192GcmOid;
 80090bc:	4b7b      	ldr	r3, [pc, #492]	; (80092ac <OidFromId+0x3f0>)
 80090be:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes192GcmOid);
 80090c0:	687b      	ldr	r3, [r7, #4]
 80090c2:	2209      	movs	r2, #9
 80090c4:	601a      	str	r2, [r3, #0]
                    break;
 80090c6:	e005      	b.n	80090d4 <OidFromId+0x218>
        #endif
        #ifdef WOLFSSL_AES_256
                case AES256GCMb:
                    oid = blkAes256GcmOid;
 80090c8:	4b79      	ldr	r3, [pc, #484]	; (80092b0 <OidFromId+0x3f4>)
 80090ca:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes256GcmOid);
 80090cc:	687b      	ldr	r3, [r7, #4]
 80090ce:	2209      	movs	r2, #9
 80090d0:	601a      	str	r2, [r3, #0]
                    break;
 80090d2:	bf00      	nop
                    oid = blkDes3CbcOid;
                    *oidSz = sizeof(blkDes3CbcOid);
                    break;
    #endif /* !NO_DES3 */
            }
            break;
 80090d4:	e1de      	b.n	8009494 <OidFromId+0x5d8>
            }
            break;
        #endif /* HAVE_OCSP */

        case oidCertExtType:
            switch (id) {
 80090d6:	68fb      	ldr	r3, [r7, #12]
 80090d8:	3b45      	subs	r3, #69	; 0x45
 80090da:	2b63      	cmp	r3, #99	; 0x63
 80090dc:	f200 81dc 	bhi.w	8009498 <OidFromId+0x5dc>
 80090e0:	a201      	add	r2, pc, #4	; (adr r2, 80090e8 <OidFromId+0x22c>)
 80090e2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80090e6:	bf00      	nop
 80090e8:	080092d1 	.word	0x080092d1
 80090ec:	08009499 	.word	0x08009499
 80090f0:	08009499 	.word	0x08009499
 80090f4:	08009499 	.word	0x08009499
 80090f8:	08009499 	.word	0x08009499
 80090fc:	08009499 	.word	0x08009499
 8009100:	08009499 	.word	0x08009499
 8009104:	08009499 	.word	0x08009499
 8009108:	08009499 	.word	0x08009499
 800910c:	08009499 	.word	0x08009499
 8009110:	08009499 	.word	0x08009499
 8009114:	08009499 	.word	0x08009499
 8009118:	08009499 	.word	0x08009499
 800911c:	08009499 	.word	0x08009499
 8009120:	08009499 	.word	0x08009499
 8009124:	08009499 	.word	0x08009499
 8009128:	08009499 	.word	0x08009499
 800912c:	08009499 	.word	0x08009499
 8009130:	08009499 	.word	0x08009499
 8009134:	08009499 	.word	0x08009499
 8009138:	08009499 	.word	0x08009499
 800913c:	08009499 	.word	0x08009499
 8009140:	08009499 	.word	0x08009499
 8009144:	08009499 	.word	0x08009499
 8009148:	08009499 	.word	0x08009499
 800914c:	08009499 	.word	0x08009499
 8009150:	08009499 	.word	0x08009499
 8009154:	08009499 	.word	0x08009499
 8009158:	08009499 	.word	0x08009499
 800915c:	08009499 	.word	0x08009499
 8009160:	08009499 	.word	0x08009499
 8009164:	08009499 	.word	0x08009499
 8009168:	08009499 	.word	0x08009499
 800916c:	08009499 	.word	0x08009499
 8009170:	08009499 	.word	0x08009499
 8009174:	08009499 	.word	0x08009499
 8009178:	08009499 	.word	0x08009499
 800917c:	08009499 	.word	0x08009499
 8009180:	08009499 	.word	0x08009499
 8009184:	08009499 	.word	0x08009499
 8009188:	08009499 	.word	0x08009499
 800918c:	08009499 	.word	0x08009499
 8009190:	08009499 	.word	0x08009499
 8009194:	08009499 	.word	0x08009499
 8009198:	08009499 	.word	0x08009499
 800919c:	08009499 	.word	0x08009499
 80091a0:	08009499 	.word	0x08009499
 80091a4:	08009499 	.word	0x08009499
 80091a8:	08009499 	.word	0x08009499
 80091ac:	08009499 	.word	0x08009499
 80091b0:	08009499 	.word	0x08009499
 80091b4:	08009499 	.word	0x08009499
 80091b8:	08009499 	.word	0x08009499
 80091bc:	08009499 	.word	0x08009499
 80091c0:	08009499 	.word	0x08009499
 80091c4:	08009499 	.word	0x08009499
 80091c8:	08009499 	.word	0x08009499
 80091cc:	08009499 	.word	0x08009499
 80091d0:	08009499 	.word	0x08009499
 80091d4:	080092e9 	.word	0x080092e9
 80091d8:	08009301 	.word	0x08009301
 80091dc:	08009499 	.word	0x08009499
 80091e0:	080092b9 	.word	0x080092b9
 80091e4:	08009499 	.word	0x08009499
 80091e8:	08009279 	.word	0x08009279
 80091ec:	08009499 	.word	0x08009499
 80091f0:	08009499 	.word	0x08009499
 80091f4:	08009499 	.word	0x08009499
 80091f8:	08009499 	.word	0x08009499
 80091fc:	08009499 	.word	0x08009499
 8009200:	08009499 	.word	0x08009499
 8009204:	08009499 	.word	0x08009499
 8009208:	08009499 	.word	0x08009499
 800920c:	08009499 	.word	0x08009499
 8009210:	08009499 	.word	0x08009499
 8009214:	08009325 	.word	0x08009325
 8009218:	080092c5 	.word	0x080092c5
 800921c:	080092f5 	.word	0x080092f5
 8009220:	08009499 	.word	0x08009499
 8009224:	08009499 	.word	0x08009499
 8009228:	080092dd 	.word	0x080092dd
 800922c:	08009499 	.word	0x08009499
 8009230:	08009319 	.word	0x08009319
 8009234:	08009499 	.word	0x08009499
 8009238:	08009499 	.word	0x08009499
 800923c:	08009499 	.word	0x08009499
 8009240:	08009499 	.word	0x08009499
 8009244:	08009499 	.word	0x08009499
 8009248:	08009499 	.word	0x08009499
 800924c:	08009499 	.word	0x08009499
 8009250:	08009499 	.word	0x08009499
 8009254:	08009499 	.word	0x08009499
 8009258:	08009499 	.word	0x08009499
 800925c:	08009499 	.word	0x08009499
 8009260:	08009499 	.word	0x08009499
 8009264:	08009499 	.word	0x08009499
 8009268:	08009499 	.word	0x08009499
 800926c:	08009499 	.word	0x08009499
 8009270:	08009499 	.word	0x08009499
 8009274:	0800930d 	.word	0x0800930d
                case BASIC_CA_OID:
                    oid = extBasicCaOid;
 8009278:	4b0e      	ldr	r3, [pc, #56]	; (80092b4 <OidFromId+0x3f8>)
 800927a:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extBasicCaOid);
 800927c:	687b      	ldr	r3, [r7, #4]
 800927e:	2203      	movs	r2, #3
 8009280:	601a      	str	r2, [r3, #0]
                    break;
 8009282:	e055      	b.n	8009330 <OidFromId+0x474>
 8009284:	0801abe8 	.word	0x0801abe8
 8009288:	0801abfc 	.word	0x0801abfc
 800928c:	0801ac08 	.word	0x0801ac08
 8009290:	0801ac10 	.word	0x0801ac10
 8009294:	0801ac1c 	.word	0x0801ac1c
 8009298:	0801ac24 	.word	0x0801ac24
 800929c:	0801ac30 	.word	0x0801ac30
 80092a0:	0801ac3c 	.word	0x0801ac3c
 80092a4:	0801ac48 	.word	0x0801ac48
 80092a8:	0801ac54 	.word	0x0801ac54
 80092ac:	0801ac60 	.word	0x0801ac60
 80092b0:	0801ac6c 	.word	0x0801ac6c
 80092b4:	0801aca4 	.word	0x0801aca4
                case ALT_NAMES_OID:
                    oid = extAltNamesOid;
 80092b8:	4b7a      	ldr	r3, [pc, #488]	; (80094a4 <OidFromId+0x5e8>)
 80092ba:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAltNamesOid);
 80092bc:	687b      	ldr	r3, [r7, #4]
 80092be:	2203      	movs	r2, #3
 80092c0:	601a      	str	r2, [r3, #0]
                    break;
 80092c2:	e035      	b.n	8009330 <OidFromId+0x474>
                case CRL_DIST_OID:
                    oid = extCrlDistOid;
 80092c4:	4b78      	ldr	r3, [pc, #480]	; (80094a8 <OidFromId+0x5ec>)
 80092c6:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extCrlDistOid);
 80092c8:	687b      	ldr	r3, [r7, #4]
 80092ca:	2203      	movs	r2, #3
 80092cc:	601a      	str	r2, [r3, #0]
                    break;
 80092ce:	e02f      	b.n	8009330 <OidFromId+0x474>
                case AUTH_INFO_OID:
                    oid = extAuthInfoOid;
 80092d0:	4b76      	ldr	r3, [pc, #472]	; (80094ac <OidFromId+0x5f0>)
 80092d2:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAuthInfoOid);
 80092d4:	687b      	ldr	r3, [r7, #4]
 80092d6:	2208      	movs	r2, #8
 80092d8:	601a      	str	r2, [r3, #0]
                    break;
 80092da:	e029      	b.n	8009330 <OidFromId+0x474>
                case AUTH_KEY_OID:
                    oid = extAuthKeyOid;
 80092dc:	4b74      	ldr	r3, [pc, #464]	; (80094b0 <OidFromId+0x5f4>)
 80092de:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAuthKeyOid);
 80092e0:	687b      	ldr	r3, [r7, #4]
 80092e2:	2203      	movs	r2, #3
 80092e4:	601a      	str	r2, [r3, #0]
                    break;
 80092e6:	e023      	b.n	8009330 <OidFromId+0x474>
                case SUBJ_KEY_OID:
                    oid = extSubjKeyOid;
 80092e8:	4b72      	ldr	r3, [pc, #456]	; (80094b4 <OidFromId+0x5f8>)
 80092ea:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extSubjKeyOid);
 80092ec:	687b      	ldr	r3, [r7, #4]
 80092ee:	2203      	movs	r2, #3
 80092f0:	601a      	str	r2, [r3, #0]
                    break;
 80092f2:	e01d      	b.n	8009330 <OidFromId+0x474>
                case CERT_POLICY_OID:
                    oid = extCertPolicyOid;
 80092f4:	4b70      	ldr	r3, [pc, #448]	; (80094b8 <OidFromId+0x5fc>)
 80092f6:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extCertPolicyOid);
 80092f8:	687b      	ldr	r3, [r7, #4]
 80092fa:	2203      	movs	r2, #3
 80092fc:	601a      	str	r2, [r3, #0]
                    break;
 80092fe:	e017      	b.n	8009330 <OidFromId+0x474>
                case KEY_USAGE_OID:
                    oid = extKeyUsageOid;
 8009300:	4b6e      	ldr	r3, [pc, #440]	; (80094bc <OidFromId+0x600>)
 8009302:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extKeyUsageOid);
 8009304:	687b      	ldr	r3, [r7, #4]
 8009306:	2203      	movs	r2, #3
 8009308:	601a      	str	r2, [r3, #0]
                    break;
 800930a:	e011      	b.n	8009330 <OidFromId+0x474>
                case INHIBIT_ANY_OID:
                    oid = extInhibitAnyOid;
 800930c:	4b6c      	ldr	r3, [pc, #432]	; (80094c0 <OidFromId+0x604>)
 800930e:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extInhibitAnyOid);
 8009310:	687b      	ldr	r3, [r7, #4]
 8009312:	2203      	movs	r2, #3
 8009314:	601a      	str	r2, [r3, #0]
                    break;
 8009316:	e00b      	b.n	8009330 <OidFromId+0x474>
                case EXT_KEY_USAGE_OID:
                    oid = extExtKeyUsageOid;
 8009318:	4b6a      	ldr	r3, [pc, #424]	; (80094c4 <OidFromId+0x608>)
 800931a:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageOid);
 800931c:	687b      	ldr	r3, [r7, #4]
 800931e:	2203      	movs	r2, #3
 8009320:	601a      	str	r2, [r3, #0]
                    break;
 8009322:	e005      	b.n	8009330 <OidFromId+0x474>
            #ifndef IGNORE_NAME_CONSTRAINTS
                case NAME_CONS_OID:
                    oid = extNameConsOid;
 8009324:	4b68      	ldr	r3, [pc, #416]	; (80094c8 <OidFromId+0x60c>)
 8009326:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extNameConsOid);
 8009328:	687b      	ldr	r3, [r7, #4]
 800932a:	2203      	movs	r2, #3
 800932c:	601a      	str	r2, [r3, #0]
                    break;
 800932e:	bf00      	nop
                    oid = ocspNoCheckOid;
                    *oidSz = sizeof(ocspNoCheckOid);
                    break;
            #endif
            }
            break;
 8009330:	e0b2      	b.n	8009498 <OidFromId+0x5dc>
            }
            #endif
            break;

        case oidCertAuthInfoType:
            switch (id) {
 8009332:	68fb      	ldr	r3, [r7, #12]
 8009334:	2b75      	cmp	r3, #117	; 0x75
 8009336:	d000      	beq.n	800933a <OidFromId+0x47e>
                case AIA_CA_ISSUER_OID:
                    oid = extAuthInfoCaIssuerOid;
                    *oidSz = sizeof(extAuthInfoCaIssuerOid);
                    break;
            }
            break;
 8009338:	e0af      	b.n	800949a <OidFromId+0x5de>
                    oid = extAuthInfoCaIssuerOid;
 800933a:	4b64      	ldr	r3, [pc, #400]	; (80094cc <OidFromId+0x610>)
 800933c:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAuthInfoCaIssuerOid);
 800933e:	687b      	ldr	r3, [r7, #4]
 8009340:	2208      	movs	r2, #8
 8009342:	601a      	str	r2, [r3, #0]
                    break;
 8009344:	bf00      	nop
            break;
 8009346:	e0a8      	b.n	800949a <OidFromId+0x5de>

        case oidCertPolicyType:
            switch (id) {
 8009348:	68fb      	ldr	r3, [r7, #12]
 800934a:	2b92      	cmp	r3, #146	; 0x92
 800934c:	d000      	beq.n	8009350 <OidFromId+0x494>
                case CP_ANY_OID:
                    oid = extCertPolicyAnyOid;
                    *oidSz = sizeof(extCertPolicyAnyOid);
                    break;
            }
            break;
 800934e:	e0a4      	b.n	800949a <OidFromId+0x5de>
                    oid = extCertPolicyAnyOid;
 8009350:	4b5f      	ldr	r3, [pc, #380]	; (80094d0 <OidFromId+0x614>)
 8009352:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extCertPolicyAnyOid);
 8009354:	687b      	ldr	r3, [r7, #4]
 8009356:	2204      	movs	r2, #4
 8009358:	601a      	str	r2, [r3, #0]
                    break;
 800935a:	bf00      	nop
            break;
 800935c:	e09d      	b.n	800949a <OidFromId+0x5de>

        case oidCertAltNameType:
            switch (id) {
 800935e:	68fb      	ldr	r3, [r7, #12]
 8009360:	2b4f      	cmp	r3, #79	; 0x4f
 8009362:	d000      	beq.n	8009366 <OidFromId+0x4aa>
                case HW_NAME_OID:
                    oid = extAltNamesHwNameOid;
                    *oidSz = sizeof(extAltNamesHwNameOid);
                    break;
            }
            break;
 8009364:	e099      	b.n	800949a <OidFromId+0x5de>
                    oid = extAltNamesHwNameOid;
 8009366:	4b5b      	ldr	r3, [pc, #364]	; (80094d4 <OidFromId+0x618>)
 8009368:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAltNamesHwNameOid);
 800936a:	687b      	ldr	r3, [r7, #4]
 800936c:	2208      	movs	r2, #8
 800936e:	601a      	str	r2, [r3, #0]
                    break;
 8009370:	bf00      	nop
            break;
 8009372:	e092      	b.n	800949a <OidFromId+0x5de>

        case oidCertKeyUseType:
            switch (id) {
 8009374:	68fb      	ldr	r3, [r7, #12]
 8009376:	2b4a      	cmp	r3, #74	; 0x4a
 8009378:	d027      	beq.n	80093ca <OidFromId+0x50e>
 800937a:	2b4a      	cmp	r3, #74	; 0x4a
 800937c:	d806      	bhi.n	800938c <OidFromId+0x4d0>
 800937e:	2b48      	cmp	r3, #72	; 0x48
 8009380:	d017      	beq.n	80093b2 <OidFromId+0x4f6>
 8009382:	2b48      	cmp	r3, #72	; 0x48
 8009384:	d81b      	bhi.n	80093be <OidFromId+0x502>
 8009386:	2b47      	cmp	r3, #71	; 0x47
 8009388:	d00d      	beq.n	80093a6 <OidFromId+0x4ea>
                case EKU_OCSP_SIGN_OID:
                    oid = extExtKeyUsageOcspSignOid;
                    *oidSz = sizeof(extExtKeyUsageOcspSignOid);
                    break;
            }
            break;
 800938a:	e086      	b.n	800949a <OidFromId+0x5de>
            switch (id) {
 800938c:	2b4f      	cmp	r3, #79	; 0x4f
 800938e:	d028      	beq.n	80093e2 <OidFromId+0x526>
 8009390:	2b97      	cmp	r3, #151	; 0x97
 8009392:	d002      	beq.n	800939a <OidFromId+0x4de>
 8009394:	2b4e      	cmp	r3, #78	; 0x4e
 8009396:	d01e      	beq.n	80093d6 <OidFromId+0x51a>
            break;
 8009398:	e07f      	b.n	800949a <OidFromId+0x5de>
                    oid = extExtKeyUsageAnyOid;
 800939a:	4b4f      	ldr	r3, [pc, #316]	; (80094d8 <OidFromId+0x61c>)
 800939c:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageAnyOid);
 800939e:	687b      	ldr	r3, [r7, #4]
 80093a0:	2204      	movs	r2, #4
 80093a2:	601a      	str	r2, [r3, #0]
                    break;
 80093a4:	e023      	b.n	80093ee <OidFromId+0x532>
                    oid = extExtKeyUsageServerAuthOid;
 80093a6:	4b4d      	ldr	r3, [pc, #308]	; (80094dc <OidFromId+0x620>)
 80093a8:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageServerAuthOid);
 80093aa:	687b      	ldr	r3, [r7, #4]
 80093ac:	2208      	movs	r2, #8
 80093ae:	601a      	str	r2, [r3, #0]
                    break;
 80093b0:	e01d      	b.n	80093ee <OidFromId+0x532>
                    oid = extExtKeyUsageClientAuthOid;
 80093b2:	4b4b      	ldr	r3, [pc, #300]	; (80094e0 <OidFromId+0x624>)
 80093b4:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageClientAuthOid);
 80093b6:	687b      	ldr	r3, [r7, #4]
 80093b8:	2208      	movs	r2, #8
 80093ba:	601a      	str	r2, [r3, #0]
                    break;
 80093bc:	e017      	b.n	80093ee <OidFromId+0x532>
                    oid = extExtKeyUsageCodeSigningOid;
 80093be:	4b49      	ldr	r3, [pc, #292]	; (80094e4 <OidFromId+0x628>)
 80093c0:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageCodeSigningOid);
 80093c2:	687b      	ldr	r3, [r7, #4]
 80093c4:	2208      	movs	r2, #8
 80093c6:	601a      	str	r2, [r3, #0]
                    break;
 80093c8:	e011      	b.n	80093ee <OidFromId+0x532>
                    oid = extExtKeyUsageEmailProtectOid;
 80093ca:	4b47      	ldr	r3, [pc, #284]	; (80094e8 <OidFromId+0x62c>)
 80093cc:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageEmailProtectOid);
 80093ce:	687b      	ldr	r3, [r7, #4]
 80093d0:	2208      	movs	r2, #8
 80093d2:	601a      	str	r2, [r3, #0]
                    break;
 80093d4:	e00b      	b.n	80093ee <OidFromId+0x532>
                    oid = extExtKeyUsageTimestampOid;
 80093d6:	4b45      	ldr	r3, [pc, #276]	; (80094ec <OidFromId+0x630>)
 80093d8:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageTimestampOid);
 80093da:	687b      	ldr	r3, [r7, #4]
 80093dc:	2208      	movs	r2, #8
 80093de:	601a      	str	r2, [r3, #0]
                    break;
 80093e0:	e005      	b.n	80093ee <OidFromId+0x532>
                    oid = extExtKeyUsageOcspSignOid;
 80093e2:	4b43      	ldr	r3, [pc, #268]	; (80094f0 <OidFromId+0x634>)
 80093e4:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageOcspSignOid);
 80093e6:	687b      	ldr	r3, [r7, #4]
 80093e8:	2208      	movs	r2, #8
 80093ea:	601a      	str	r2, [r3, #0]
                    break;
 80093ec:	bf00      	nop
            break;
 80093ee:	e054      	b.n	800949a <OidFromId+0x5de>

        case oidKdfType:
            switch (id) {
 80093f0:	68fb      	ldr	r3, [r7, #12]
 80093f2:	f5b3 7f25 	cmp.w	r3, #660	; 0x294
 80093f6:	d000      	beq.n	80093fa <OidFromId+0x53e>
                case PBKDF2_OID:
                    oid = pbkdf2Oid;
                    *oidSz = sizeof(pbkdf2Oid);
                    break;
            }
            break;
 80093f8:	e04f      	b.n	800949a <OidFromId+0x5de>
                    oid = pbkdf2Oid;
 80093fa:	4b3e      	ldr	r3, [pc, #248]	; (80094f4 <OidFromId+0x638>)
 80093fc:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(pbkdf2Oid);
 80093fe:	687b      	ldr	r3, [r7, #4]
 8009400:	2209      	movs	r2, #9
 8009402:	601a      	str	r2, [r3, #0]
                    break;
 8009404:	bf00      	nop
            break;
 8009406:	e048      	b.n	800949a <OidFromId+0x5de>

        case oidPBEType:
            switch (id) {
 8009408:	68fb      	ldr	r3, [r7, #12]
 800940a:	2b0d      	cmp	r3, #13
 800940c:	d000      	beq.n	8009410 <OidFromId+0x554>
                case PBES2:
                    oid = pbes2;
                    *oidSz = sizeof(pbes2);
                    break;
            }
            break;
 800940e:	e044      	b.n	800949a <OidFromId+0x5de>
                    oid = pbes2;
 8009410:	4b39      	ldr	r3, [pc, #228]	; (80094f8 <OidFromId+0x63c>)
 8009412:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(pbes2);
 8009414:	687b      	ldr	r3, [r7, #4]
 8009416:	2209      	movs	r2, #9
 8009418:	601a      	str	r2, [r3, #0]
                    break;
 800941a:	bf00      	nop
            break;
 800941c:	e03d      	b.n	800949a <OidFromId+0x5de>

        case oidKeyWrapType:
            switch (id) {
 800941e:	68fb      	ldr	r3, [r7, #12]
 8009420:	f240 12b5 	movw	r2, #437	; 0x1b5
 8009424:	4293      	cmp	r3, r2
 8009426:	d00e      	beq.n	8009446 <OidFromId+0x58a>
 8009428:	f240 12c9 	movw	r2, #457	; 0x1c9
 800942c:	4293      	cmp	r3, r2
 800942e:	d010      	beq.n	8009452 <OidFromId+0x596>
 8009430:	f240 12a1 	movw	r2, #417	; 0x1a1
 8009434:	4293      	cmp	r3, r2
 8009436:	d000      	beq.n	800943a <OidFromId+0x57e>
                    oid = wrapPwriKekOid;
                    *oidSz = sizeof(wrapPwriKekOid);
                    break;
            #endif
            }
            break;
 8009438:	e02f      	b.n	800949a <OidFromId+0x5de>
                    oid = wrapAes128Oid;
 800943a:	4b30      	ldr	r3, [pc, #192]	; (80094fc <OidFromId+0x640>)
 800943c:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(wrapAes128Oid);
 800943e:	687b      	ldr	r3, [r7, #4]
 8009440:	2209      	movs	r2, #9
 8009442:	601a      	str	r2, [r3, #0]
                    break;
 8009444:	e00b      	b.n	800945e <OidFromId+0x5a2>
                    oid = wrapAes192Oid;
 8009446:	4b2e      	ldr	r3, [pc, #184]	; (8009500 <OidFromId+0x644>)
 8009448:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(wrapAes192Oid);
 800944a:	687b      	ldr	r3, [r7, #4]
 800944c:	2209      	movs	r2, #9
 800944e:	601a      	str	r2, [r3, #0]
                    break;
 8009450:	e005      	b.n	800945e <OidFromId+0x5a2>
                    oid = wrapAes256Oid;
 8009452:	4b2c      	ldr	r3, [pc, #176]	; (8009504 <OidFromId+0x648>)
 8009454:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(wrapAes256Oid);
 8009456:	687b      	ldr	r3, [r7, #4]
 8009458:	2209      	movs	r2, #9
 800945a:	601a      	str	r2, [r3, #0]
                    break;
 800945c:	bf00      	nop
            break;
 800945e:	e01c      	b.n	800949a <OidFromId+0x5de>

        case oidCmsKeyAgreeType:
            switch (id) {
 8009460:	68fb      	ldr	r3, [r7, #12]
 8009462:	2bbd      	cmp	r3, #189	; 0xbd
 8009464:	d000      	beq.n	8009468 <OidFromId+0x5ac>
                    oid = dhSinglePass_stdDH_sha512kdf_Oid;
                    *oidSz = sizeof(dhSinglePass_stdDH_sha512kdf_Oid);
                    break;
            #endif
            }
            break;
 8009466:	e018      	b.n	800949a <OidFromId+0x5de>
                    oid = dhSinglePass_stdDH_sha256kdf_Oid;
 8009468:	4b27      	ldr	r3, [pc, #156]	; (8009508 <OidFromId+0x64c>)
 800946a:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(dhSinglePass_stdDH_sha256kdf_Oid);
 800946c:	687b      	ldr	r3, [r7, #4]
 800946e:	2206      	movs	r2, #6
 8009470:	601a      	str	r2, [r3, #0]
                    break;
 8009472:	bf00      	nop
            break;
 8009474:	e011      	b.n	800949a <OidFromId+0x5de>

#ifndef NO_HMAC
        case oidHmacType:
            switch (id) {
 8009476:	68fb      	ldr	r3, [r7, #12]
 8009478:	f240 228d 	movw	r2, #653	; 0x28d
 800947c:	4293      	cmp	r3, r2
 800947e:	d000      	beq.n	8009482 <OidFromId+0x5c6>
                    oid = hmacSha512Oid;
                    *oidSz = sizeof(hmacSha512Oid);
                    break;
        #endif
            }
            break;
 8009480:	e00b      	b.n	800949a <OidFromId+0x5de>
                    oid = hmacSha256Oid;
 8009482:	4b22      	ldr	r3, [pc, #136]	; (800950c <OidFromId+0x650>)
 8009484:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(hmacSha256Oid);
 8009486:	687b      	ldr	r3, [r7, #4]
 8009488:	2208      	movs	r2, #8
 800948a:	601a      	str	r2, [r3, #0]
                    break;
 800948c:	bf00      	nop
            break;
 800948e:	e004      	b.n	800949a <OidFromId+0x5de>
            }
            break;
#endif
        case oidIgnoreType:
        default:
            break;
 8009490:	bf00      	nop
 8009492:	e002      	b.n	800949a <OidFromId+0x5de>
            break;
 8009494:	bf00      	nop
 8009496:	e000      	b.n	800949a <OidFromId+0x5de>
            break;
 8009498:	bf00      	nop
    }

    return oid;
 800949a:	697b      	ldr	r3, [r7, #20]
}
 800949c:	4618      	mov	r0, r3
 800949e:	3718      	adds	r7, #24
 80094a0:	46bd      	mov	sp, r7
 80094a2:	bd80      	pop	{r7, pc}
 80094a4:	0801aca8 	.word	0x0801aca8
 80094a8:	0801acac 	.word	0x0801acac
 80094ac:	0801acb0 	.word	0x0801acb0
 80094b0:	0801acb8 	.word	0x0801acb8
 80094b4:	0801acbc 	.word	0x0801acbc
 80094b8:	0801acc0 	.word	0x0801acc0
 80094bc:	0801acc4 	.word	0x0801acc4
 80094c0:	0801acc8 	.word	0x0801acc8
 80094c4:	0801accc 	.word	0x0801accc
 80094c8:	0801acd0 	.word	0x0801acd0
 80094cc:	0801acd4 	.word	0x0801acd4
 80094d0:	0801acdc 	.word	0x0801acdc
 80094d4:	0801ace0 	.word	0x0801ace0
 80094d8:	0801ace8 	.word	0x0801ace8
 80094dc:	0801acec 	.word	0x0801acec
 80094e0:	0801acf4 	.word	0x0801acf4
 80094e4:	0801acfc 	.word	0x0801acfc
 80094e8:	0801ad04 	.word	0x0801ad04
 80094ec:	0801ad0c 	.word	0x0801ad0c
 80094f0:	0801ad14 	.word	0x0801ad14
 80094f4:	0801ad1c 	.word	0x0801ad1c
 80094f8:	0801ad28 	.word	0x0801ad28
 80094fc:	0801ac78 	.word	0x0801ac78
 8009500:	0801ac84 	.word	0x0801ac84
 8009504:	0801ac90 	.word	0x0801ac90
 8009508:	0801ac9c 	.word	0x0801ac9c
 800950c:	0801abf4 	.word	0x0801abf4

08009510 <GetASNObjectId>:
 *         ASN_PARSE_E when length is invalid.
 *         Otherwise, 0 to indicate success.
 */
int GetASNObjectId(const byte* input, word32* inOutIdx, int* len,
                          word32 maxIdx)
{
 8009510:	b580      	push	{r7, lr}
 8009512:	b088      	sub	sp, #32
 8009514:	af00      	add	r7, sp, #0
 8009516:	60f8      	str	r0, [r7, #12]
 8009518:	60b9      	str	r1, [r7, #8]
 800951a:	607a      	str	r2, [r7, #4]
 800951c:	603b      	str	r3, [r7, #0]
    word32 idx = *inOutIdx;
 800951e:	68bb      	ldr	r3, [r7, #8]
 8009520:	681b      	ldr	r3, [r3, #0]
 8009522:	61fb      	str	r3, [r7, #28]
    int    length;
    byte   tag;

    if ((idx + 1) > maxIdx)
 8009524:	69fb      	ldr	r3, [r7, #28]
 8009526:	3301      	adds	r3, #1
 8009528:	683a      	ldr	r2, [r7, #0]
 800952a:	429a      	cmp	r2, r3
 800952c:	d202      	bcs.n	8009534 <GetASNObjectId+0x24>
        return BUFFER_E;
 800952e:	f06f 0383 	mvn.w	r3, #131	; 0x83
 8009532:	e028      	b.n	8009586 <GetASNObjectId+0x76>

    if (GetASNTag(input, &idx, &tag, maxIdx) != 0)
 8009534:	f107 0217 	add.w	r2, r7, #23
 8009538:	f107 011c 	add.w	r1, r7, #28
 800953c:	683b      	ldr	r3, [r7, #0]
 800953e:	68f8      	ldr	r0, [r7, #12]
 8009540:	f7ff f970 	bl	8008824 <GetASNTag>
 8009544:	4603      	mov	r3, r0
 8009546:	2b00      	cmp	r3, #0
 8009548:	d002      	beq.n	8009550 <GetASNObjectId+0x40>
        return ASN_PARSE_E;
 800954a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800954e:	e01a      	b.n	8009586 <GetASNObjectId+0x76>

    if (tag != ASN_OBJECT_ID)
 8009550:	7dfb      	ldrb	r3, [r7, #23]
 8009552:	2b06      	cmp	r3, #6
 8009554:	d002      	beq.n	800955c <GetASNObjectId+0x4c>
        return ASN_OBJECT_ID_E;
 8009556:	f06f 038f 	mvn.w	r3, #143	; 0x8f
 800955a:	e014      	b.n	8009586 <GetASNObjectId+0x76>

    if (GetLength(input, &idx, &length, maxIdx) < 0)
 800955c:	f107 0218 	add.w	r2, r7, #24
 8009560:	f107 011c 	add.w	r1, r7, #28
 8009564:	683b      	ldr	r3, [r7, #0]
 8009566:	68f8      	ldr	r0, [r7, #12]
 8009568:	f7ff f8de 	bl	8008728 <GetLength>
 800956c:	4603      	mov	r3, r0
 800956e:	2b00      	cmp	r3, #0
 8009570:	da02      	bge.n	8009578 <GetASNObjectId+0x68>
        return ASN_PARSE_E;
 8009572:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8009576:	e006      	b.n	8009586 <GetASNObjectId+0x76>

    *len = length;
 8009578:	69ba      	ldr	r2, [r7, #24]
 800957a:	687b      	ldr	r3, [r7, #4]
 800957c:	601a      	str	r2, [r3, #0]
    *inOutIdx = idx;
 800957e:	69fa      	ldr	r2, [r7, #28]
 8009580:	68bb      	ldr	r3, [r7, #8]
 8009582:	601a      	str	r2, [r3, #0]
    return 0;
 8009584:	2300      	movs	r3, #0
}
 8009586:	4618      	mov	r0, r3
 8009588:	3720      	adds	r7, #32
 800958a:	46bd      	mov	sp, r7
 800958c:	bd80      	pop	{r7, pc}

0800958e <SetObjectId>:
 * len         Length of the OBJECT_ID data.
 * output      Buffer to write into.
 * returns the number of bytes added to the buffer.
 */
int SetObjectId(int len, byte* output)
{
 800958e:	b580      	push	{r7, lr}
 8009590:	b084      	sub	sp, #16
 8009592:	af00      	add	r7, sp, #0
 8009594:	6078      	str	r0, [r7, #4]
 8009596:	6039      	str	r1, [r7, #0]
    int idx = 0;
 8009598:	2300      	movs	r3, #0
 800959a:	60fb      	str	r3, [r7, #12]

    if (output)
 800959c:	683b      	ldr	r3, [r7, #0]
 800959e:	2b00      	cmp	r3, #0
 80095a0:	d008      	beq.n	80095b4 <SetObjectId+0x26>
        output[idx++] = ASN_OBJECT_ID;
 80095a2:	68fb      	ldr	r3, [r7, #12]
 80095a4:	1c5a      	adds	r2, r3, #1
 80095a6:	60fa      	str	r2, [r7, #12]
 80095a8:	461a      	mov	r2, r3
 80095aa:	683b      	ldr	r3, [r7, #0]
 80095ac:	4413      	add	r3, r2
 80095ae:	2206      	movs	r2, #6
 80095b0:	701a      	strb	r2, [r3, #0]
 80095b2:	e002      	b.n	80095ba <SetObjectId+0x2c>
    else
        idx++;
 80095b4:	68fb      	ldr	r3, [r7, #12]
 80095b6:	3301      	adds	r3, #1
 80095b8:	60fb      	str	r3, [r7, #12]
    idx += SetLength(len, output ? output + idx : NULL);
 80095ba:	6878      	ldr	r0, [r7, #4]
 80095bc:	683b      	ldr	r3, [r7, #0]
 80095be:	2b00      	cmp	r3, #0
 80095c0:	d003      	beq.n	80095ca <SetObjectId+0x3c>
 80095c2:	68fb      	ldr	r3, [r7, #12]
 80095c4:	683a      	ldr	r2, [r7, #0]
 80095c6:	4413      	add	r3, r2
 80095c8:	e000      	b.n	80095cc <SetObjectId+0x3e>
 80095ca:	2300      	movs	r3, #0
 80095cc:	4619      	mov	r1, r3
 80095ce:	f001 fb38 	bl	800ac42 <SetLength>
 80095d2:	4602      	mov	r2, r0
 80095d4:	68fb      	ldr	r3, [r7, #12]
 80095d6:	4413      	add	r3, r2
 80095d8:	60fb      	str	r3, [r7, #12]

    return idx;
 80095da:	68fb      	ldr	r3, [r7, #12]
}
 80095dc:	4618      	mov	r0, r3
 80095de:	3710      	adds	r7, #16
 80095e0:	46bd      	mov	sp, r7
 80095e2:	bd80      	pop	{r7, pc}

080095e4 <GetObjectId>:

int GetObjectId(const byte* input, word32* inOutIdx, word32* oid,
                                  word32 oidType, word32 maxIdx)
{
 80095e4:	b580      	push	{r7, lr}
 80095e6:	b08c      	sub	sp, #48	; 0x30
 80095e8:	af00      	add	r7, sp, #0
 80095ea:	60f8      	str	r0, [r7, #12]
 80095ec:	60b9      	str	r1, [r7, #8]
 80095ee:	607a      	str	r2, [r7, #4]
 80095f0:	603b      	str	r3, [r7, #0]
    int    ret = 0, length;
 80095f2:	2300      	movs	r3, #0
 80095f4:	62bb      	str	r3, [r7, #40]	; 0x28
    word32 idx = *inOutIdx;
 80095f6:	68bb      	ldr	r3, [r7, #8]
 80095f8:	681b      	ldr	r3, [r3, #0]
 80095fa:	61bb      	str	r3, [r7, #24]
#ifndef NO_VERIFY_OID
    word32 actualOidSz = 0;
 80095fc:	2300      	movs	r3, #0
 80095fe:	62fb      	str	r3, [r7, #44]	; 0x2c
    const byte* actualOid;
#endif /* NO_VERIFY_OID */

    (void)oidType;
    WOLFSSL_ENTER("GetObjectId()");
    *oid = 0;
 8009600:	687b      	ldr	r3, [r7, #4]
 8009602:	2200      	movs	r2, #0
 8009604:	601a      	str	r2, [r3, #0]

    ret = GetASNObjectId(input, &idx, &length, maxIdx);
 8009606:	f107 021c 	add.w	r2, r7, #28
 800960a:	f107 0118 	add.w	r1, r7, #24
 800960e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009610:	68f8      	ldr	r0, [r7, #12]
 8009612:	f7ff ff7d 	bl	8009510 <GetASNObjectId>
 8009616:	62b8      	str	r0, [r7, #40]	; 0x28
    if (ret != 0)
 8009618:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800961a:	2b00      	cmp	r3, #0
 800961c:	d001      	beq.n	8009622 <GetObjectId+0x3e>
        return ret;
 800961e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009620:	e03f      	b.n	80096a2 <GetObjectId+0xbe>

#ifndef NO_VERIFY_OID
    actualOid = &input[idx];
 8009622:	69bb      	ldr	r3, [r7, #24]
 8009624:	68fa      	ldr	r2, [r7, #12]
 8009626:	4413      	add	r3, r2
 8009628:	627b      	str	r3, [r7, #36]	; 0x24
    if (length > 0)
 800962a:	69fb      	ldr	r3, [r7, #28]
 800962c:	2b00      	cmp	r3, #0
 800962e:	dd0e      	ble.n	800964e <GetObjectId+0x6a>
        actualOidSz = (word32)length;
 8009630:	69fb      	ldr	r3, [r7, #28]
 8009632:	62fb      	str	r3, [r7, #44]	; 0x2c
#endif /* NO_VERIFY_OID */

    while (length--) {
 8009634:	e00b      	b.n	800964e <GetObjectId+0x6a>
        /* odd HC08 compiler behavior here when input[idx++] */
        *oid += (word32)input[idx];
 8009636:	687b      	ldr	r3, [r7, #4]
 8009638:	681b      	ldr	r3, [r3, #0]
 800963a:	69ba      	ldr	r2, [r7, #24]
 800963c:	68f9      	ldr	r1, [r7, #12]
 800963e:	440a      	add	r2, r1
 8009640:	7812      	ldrb	r2, [r2, #0]
 8009642:	441a      	add	r2, r3
 8009644:	687b      	ldr	r3, [r7, #4]
 8009646:	601a      	str	r2, [r3, #0]
        idx++;
 8009648:	69bb      	ldr	r3, [r7, #24]
 800964a:	3301      	adds	r3, #1
 800964c:	61bb      	str	r3, [r7, #24]
    while (length--) {
 800964e:	69fb      	ldr	r3, [r7, #28]
 8009650:	1e5a      	subs	r2, r3, #1
 8009652:	61fa      	str	r2, [r7, #28]
 8009654:	2b00      	cmp	r3, #0
 8009656:	d1ee      	bne.n	8009636 <GetObjectId+0x52>
    }
    /* just sum it up for now */

    *inOutIdx = idx;
 8009658:	69ba      	ldr	r2, [r7, #24]
 800965a:	68bb      	ldr	r3, [r7, #8]
 800965c:	601a      	str	r2, [r3, #0]

#ifndef NO_VERIFY_OID
    {
        const byte* checkOid = NULL;
 800965e:	2300      	movs	r3, #0
 8009660:	623b      	str	r3, [r7, #32]
        word32 checkOidSz;
    #ifdef ASN_DUMP_OID
        word32 i;
    #endif

        if (oidType != oidIgnoreType) {
 8009662:	683b      	ldr	r3, [r7, #0]
 8009664:	2b15      	cmp	r3, #21
 8009666:	d01b      	beq.n	80096a0 <GetObjectId+0xbc>
            checkOid = OidFromId(*oid, oidType, &checkOidSz);
 8009668:	687b      	ldr	r3, [r7, #4]
 800966a:	681b      	ldr	r3, [r3, #0]
 800966c:	f107 0214 	add.w	r2, r7, #20
 8009670:	6839      	ldr	r1, [r7, #0]
 8009672:	4618      	mov	r0, r3
 8009674:	f7ff fc22 	bl	8008ebc <OidFromId>
 8009678:	6238      	str	r0, [r7, #32]
                }
            }
            #endif /* HAVE_OID_DECODING */
        #endif /* ASN_DUMP_OID */

            if (checkOid != NULL &&
 800967a:	6a3b      	ldr	r3, [r7, #32]
 800967c:	2b00      	cmp	r3, #0
 800967e:	d00f      	beq.n	80096a0 <GetObjectId+0xbc>
                (checkOidSz != actualOidSz ||
 8009680:	697b      	ldr	r3, [r7, #20]
            if (checkOid != NULL &&
 8009682:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8009684:	429a      	cmp	r2, r3
 8009686:	d108      	bne.n	800969a <GetObjectId+0xb6>
                    XMEMCMP(actualOid, checkOid, checkOidSz) != 0)) {
 8009688:	697b      	ldr	r3, [r7, #20]
 800968a:	461a      	mov	r2, r3
 800968c:	6a39      	ldr	r1, [r7, #32]
 800968e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8009690:	f00f fea2 	bl	80193d8 <memcmp>
 8009694:	4603      	mov	r3, r0
                (checkOidSz != actualOidSz ||
 8009696:	2b00      	cmp	r3, #0
 8009698:	d002      	beq.n	80096a0 <GetObjectId+0xbc>
                WOLFSSL_MSG("OID Check Failed");
                return ASN_UNKNOWN_OID_E;
 800969a:	f06f 0393 	mvn.w	r3, #147	; 0x93
 800969e:	e000      	b.n	80096a2 <GetObjectId+0xbe>
            }
        }
    }
#endif /* NO_VERIFY_OID */

    return ret;
 80096a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
}
 80096a2:	4618      	mov	r0, r3
 80096a4:	3730      	adds	r7, #48	; 0x30
 80096a6:	46bd      	mov	sp, r7
 80096a8:	bd80      	pop	{r7, pc}

080096aa <SkipObjectId>:

static int SkipObjectId(const byte* input, word32* inOutIdx, word32 maxIdx)
{
 80096aa:	b580      	push	{r7, lr}
 80096ac:	b088      	sub	sp, #32
 80096ae:	af00      	add	r7, sp, #0
 80096b0:	60f8      	str	r0, [r7, #12]
 80096b2:	60b9      	str	r1, [r7, #8]
 80096b4:	607a      	str	r2, [r7, #4]
    word32 idx = *inOutIdx;
 80096b6:	68bb      	ldr	r3, [r7, #8]
 80096b8:	681b      	ldr	r3, [r3, #0]
 80096ba:	61bb      	str	r3, [r7, #24]
    int    length;
    int ret;

    ret = GetASNObjectId(input, &idx, &length, maxIdx);
 80096bc:	f107 0214 	add.w	r2, r7, #20
 80096c0:	f107 0118 	add.w	r1, r7, #24
 80096c4:	687b      	ldr	r3, [r7, #4]
 80096c6:	68f8      	ldr	r0, [r7, #12]
 80096c8:	f7ff ff22 	bl	8009510 <GetASNObjectId>
 80096cc:	61f8      	str	r0, [r7, #28]
    if (ret != 0)
 80096ce:	69fb      	ldr	r3, [r7, #28]
 80096d0:	2b00      	cmp	r3, #0
 80096d2:	d001      	beq.n	80096d8 <SkipObjectId+0x2e>
        return ret;
 80096d4:	69fb      	ldr	r3, [r7, #28]
 80096d6:	e007      	b.n	80096e8 <SkipObjectId+0x3e>

    idx += length;
 80096d8:	69bb      	ldr	r3, [r7, #24]
 80096da:	697a      	ldr	r2, [r7, #20]
 80096dc:	4413      	add	r3, r2
 80096de:	61bb      	str	r3, [r7, #24]
    *inOutIdx = idx;
 80096e0:	69ba      	ldr	r2, [r7, #24]
 80096e2:	68bb      	ldr	r3, [r7, #8]
 80096e4:	601a      	str	r2, [r3, #0]

    return 0;
 80096e6:	2300      	movs	r3, #0
}
 80096e8:	4618      	mov	r0, r3
 80096ea:	3720      	adds	r7, #32
 80096ec:	46bd      	mov	sp, r7
 80096ee:	bd80      	pop	{r7, pc}

080096f0 <GetAlgoId>:

int GetAlgoId(const byte* input, word32* inOutIdx, word32* oid,
                     word32 oidType, word32 maxIdx)
{
 80096f0:	b580      	push	{r7, lr}
 80096f2:	b08c      	sub	sp, #48	; 0x30
 80096f4:	af02      	add	r7, sp, #8
 80096f6:	60f8      	str	r0, [r7, #12]
 80096f8:	60b9      	str	r1, [r7, #8]
 80096fa:	607a      	str	r2, [r7, #4]
 80096fc:	603b      	str	r3, [r7, #0]
    int    length;
    word32 idx = *inOutIdx;
 80096fe:	68bb      	ldr	r3, [r7, #8]
 8009700:	681b      	ldr	r3, [r3, #0]
 8009702:	61fb      	str	r3, [r7, #28]
    int    ret;
    *oid = 0;
 8009704:	687b      	ldr	r3, [r7, #4]
 8009706:	2200      	movs	r2, #0
 8009708:	601a      	str	r2, [r3, #0]

    WOLFSSL_ENTER("GetAlgoId");

    if (GetSequence(input, &idx, &length, maxIdx) < 0)
 800970a:	f107 0220 	add.w	r2, r7, #32
 800970e:	f107 011c 	add.w	r1, r7, #28
 8009712:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009714:	68f8      	ldr	r0, [r7, #12]
 8009716:	f7ff f93b 	bl	8008990 <GetSequence>
 800971a:	4603      	mov	r3, r0
 800971c:	2b00      	cmp	r3, #0
 800971e:	da02      	bge.n	8009726 <GetAlgoId+0x36>
        return ASN_PARSE_E;
 8009720:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8009724:	e033      	b.n	800978e <GetAlgoId+0x9e>

    if (GetObjectId(input, &idx, oid, oidType, maxIdx) < 0)
 8009726:	f107 011c 	add.w	r1, r7, #28
 800972a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800972c:	9300      	str	r3, [sp, #0]
 800972e:	683b      	ldr	r3, [r7, #0]
 8009730:	687a      	ldr	r2, [r7, #4]
 8009732:	68f8      	ldr	r0, [r7, #12]
 8009734:	f7ff ff56 	bl	80095e4 <GetObjectId>
 8009738:	4603      	mov	r3, r0
 800973a:	2b00      	cmp	r3, #0
 800973c:	da02      	bge.n	8009744 <GetAlgoId+0x54>
        return ASN_OBJECT_ID_E;
 800973e:	f06f 038f 	mvn.w	r3, #143	; 0x8f
 8009742:	e024      	b.n	800978e <GetAlgoId+0x9e>

    /* could have NULL tag and 0 terminator, but may not */
    if (idx < maxIdx) {
 8009744:	69fb      	ldr	r3, [r7, #28]
 8009746:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8009748:	429a      	cmp	r2, r3
 800974a:	d91c      	bls.n	8009786 <GetAlgoId+0x96>
        word32 localIdx = idx; /*use localIdx to not advance when checking tag*/
 800974c:	69fb      	ldr	r3, [r7, #28]
 800974e:	61bb      	str	r3, [r7, #24]
        byte   tag;

        if (GetASNTag(input, &localIdx, &tag, maxIdx) == 0) {
 8009750:	f107 0217 	add.w	r2, r7, #23
 8009754:	f107 0118 	add.w	r1, r7, #24
 8009758:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800975a:	68f8      	ldr	r0, [r7, #12]
 800975c:	f7ff f862 	bl	8008824 <GetASNTag>
 8009760:	4603      	mov	r3, r0
 8009762:	2b00      	cmp	r3, #0
 8009764:	d10f      	bne.n	8009786 <GetAlgoId+0x96>
            if (tag == ASN_TAG_NULL) {
 8009766:	7dfb      	ldrb	r3, [r7, #23]
 8009768:	2b05      	cmp	r3, #5
 800976a:	d10c      	bne.n	8009786 <GetAlgoId+0x96>
                ret = GetASNNull(input, &idx, maxIdx);
 800976c:	f107 031c 	add.w	r3, r7, #28
 8009770:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8009772:	4619      	mov	r1, r3
 8009774:	68f8      	ldr	r0, [r7, #12]
 8009776:	f7ff f933 	bl	80089e0 <GetASNNull>
 800977a:	6278      	str	r0, [r7, #36]	; 0x24
                if (ret != 0)
 800977c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800977e:	2b00      	cmp	r3, #0
 8009780:	d001      	beq.n	8009786 <GetAlgoId+0x96>
                    return ret;
 8009782:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009784:	e003      	b.n	800978e <GetAlgoId+0x9e>
            }
        }
    }

    *inOutIdx = idx;
 8009786:	69fa      	ldr	r2, [r7, #28]
 8009788:	68bb      	ldr	r3, [r7, #8]
 800978a:	601a      	str	r2, [r3, #0]

    return 0;
 800978c:	2300      	movs	r3, #0
}
 800978e:	4618      	mov	r0, r3
 8009790:	3728      	adds	r7, #40	; 0x28
 8009792:	46bd      	mov	sp, r7
 8009794:	bd80      	pop	{r7, pc}

08009796 <wc_RsaPrivateKeyDecode>:
#ifndef NO_RSA

#ifndef HAVE_USER_RSA
int wc_RsaPrivateKeyDecode(const byte* input, word32* inOutIdx, RsaKey* key,
                        word32 inSz)
{
 8009796:	b580      	push	{r7, lr}
 8009798:	b086      	sub	sp, #24
 800979a:	af00      	add	r7, sp, #0
 800979c:	60f8      	str	r0, [r7, #12]
 800979e:	60b9      	str	r1, [r7, #8]
 80097a0:	607a      	str	r2, [r7, #4]
 80097a2:	603b      	str	r3, [r7, #0]
    int version, length;

    if (inOutIdx == NULL || input == NULL || key == NULL) {
 80097a4:	68bb      	ldr	r3, [r7, #8]
 80097a6:	2b00      	cmp	r3, #0
 80097a8:	d005      	beq.n	80097b6 <wc_RsaPrivateKeyDecode+0x20>
 80097aa:	68fb      	ldr	r3, [r7, #12]
 80097ac:	2b00      	cmp	r3, #0
 80097ae:	d002      	beq.n	80097b6 <wc_RsaPrivateKeyDecode+0x20>
 80097b0:	687b      	ldr	r3, [r7, #4]
 80097b2:	2b00      	cmp	r3, #0
 80097b4:	d102      	bne.n	80097bc <wc_RsaPrivateKeyDecode+0x26>
        return BAD_FUNC_ARG;
 80097b6:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 80097ba:	e07e      	b.n	80098ba <wc_RsaPrivateKeyDecode+0x124>
    }
    if (GetSequence(input, inOutIdx, &length, inSz) < 0)
 80097bc:	f107 0210 	add.w	r2, r7, #16
 80097c0:	683b      	ldr	r3, [r7, #0]
 80097c2:	68b9      	ldr	r1, [r7, #8]
 80097c4:	68f8      	ldr	r0, [r7, #12]
 80097c6:	f7ff f8e3 	bl	8008990 <GetSequence>
 80097ca:	4603      	mov	r3, r0
 80097cc:	2b00      	cmp	r3, #0
 80097ce:	da02      	bge.n	80097d6 <wc_RsaPrivateKeyDecode+0x40>
        return ASN_PARSE_E;
 80097d0:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 80097d4:	e071      	b.n	80098ba <wc_RsaPrivateKeyDecode+0x124>

    if (GetMyVersion(input, inOutIdx, &version, inSz) < 0)
 80097d6:	f107 0214 	add.w	r2, r7, #20
 80097da:	683b      	ldr	r3, [r7, #0]
 80097dc:	68b9      	ldr	r1, [r7, #8]
 80097de:	68f8      	ldr	r0, [r7, #12]
 80097e0:	f7ff fa2e 	bl	8008c40 <GetMyVersion>
 80097e4:	4603      	mov	r3, r0
 80097e6:	2b00      	cmp	r3, #0
 80097e8:	da02      	bge.n	80097f0 <wc_RsaPrivateKeyDecode+0x5a>
        return ASN_PARSE_E;
 80097ea:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 80097ee:	e064      	b.n	80098ba <wc_RsaPrivateKeyDecode+0x124>

    key->type = RSA_PRIVATE;
 80097f0:	687b      	ldr	r3, [r7, #4]
 80097f2:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 80097f6:	3308      	adds	r3, #8
 80097f8:	2201      	movs	r2, #1
 80097fa:	601a      	str	r2, [r3, #0]

    if (GetInt(&key->n,  input, inOutIdx, inSz) < 0 ||
 80097fc:	6878      	ldr	r0, [r7, #4]
 80097fe:	683b      	ldr	r3, [r7, #0]
 8009800:	68ba      	ldr	r2, [r7, #8]
 8009802:	68f9      	ldr	r1, [r7, #12]
 8009804:	f7ff fa9f 	bl	8008d46 <GetInt>
 8009808:	4603      	mov	r3, r0
 800980a:	2b00      	cmp	r3, #0
 800980c:	db2b      	blt.n	8009866 <wc_RsaPrivateKeyDecode+0xd0>
        GetInt(&key->e,  input, inOutIdx, inSz) < 0 ||
 800980e:	687b      	ldr	r3, [r7, #4]
 8009810:	f503 7043 	add.w	r0, r3, #780	; 0x30c
 8009814:	683b      	ldr	r3, [r7, #0]
 8009816:	68ba      	ldr	r2, [r7, #8]
 8009818:	68f9      	ldr	r1, [r7, #12]
 800981a:	f7ff fa94 	bl	8008d46 <GetInt>
 800981e:	4603      	mov	r3, r0
    if (GetInt(&key->n,  input, inOutIdx, inSz) < 0 ||
 8009820:	2b00      	cmp	r3, #0
 8009822:	db20      	blt.n	8009866 <wc_RsaPrivateKeyDecode+0xd0>
#ifndef WOLFSSL_RSA_PUBLIC_ONLY
        GetInt(&key->d,  input, inOutIdx, inSz) < 0 ||
 8009824:	687b      	ldr	r3, [r7, #4]
 8009826:	f503 60c3 	add.w	r0, r3, #1560	; 0x618
 800982a:	683b      	ldr	r3, [r7, #0]
 800982c:	68ba      	ldr	r2, [r7, #8]
 800982e:	68f9      	ldr	r1, [r7, #12]
 8009830:	f7ff fa89 	bl	8008d46 <GetInt>
 8009834:	4603      	mov	r3, r0
        GetInt(&key->e,  input, inOutIdx, inSz) < 0 ||
 8009836:	2b00      	cmp	r3, #0
 8009838:	db15      	blt.n	8009866 <wc_RsaPrivateKeyDecode+0xd0>
        GetInt(&key->p,  input, inOutIdx, inSz) < 0 ||
 800983a:	687b      	ldr	r3, [r7, #4]
 800983c:	f603 1024 	addw	r0, r3, #2340	; 0x924
 8009840:	683b      	ldr	r3, [r7, #0]
 8009842:	68ba      	ldr	r2, [r7, #8]
 8009844:	68f9      	ldr	r1, [r7, #12]
 8009846:	f7ff fa7e 	bl	8008d46 <GetInt>
 800984a:	4603      	mov	r3, r0
        GetInt(&key->d,  input, inOutIdx, inSz) < 0 ||
 800984c:	2b00      	cmp	r3, #0
 800984e:	db0a      	blt.n	8009866 <wc_RsaPrivateKeyDecode+0xd0>
        GetInt(&key->q,  input, inOutIdx, inSz) < 0)
 8009850:	687b      	ldr	r3, [r7, #4]
 8009852:	f503 6043 	add.w	r0, r3, #3120	; 0xc30
 8009856:	683b      	ldr	r3, [r7, #0]
 8009858:	68ba      	ldr	r2, [r7, #8]
 800985a:	68f9      	ldr	r1, [r7, #12]
 800985c:	f7ff fa73 	bl	8008d46 <GetInt>
 8009860:	4603      	mov	r3, r0
        GetInt(&key->p,  input, inOutIdx, inSz) < 0 ||
 8009862:	2b00      	cmp	r3, #0
 8009864:	da02      	bge.n	800986c <wc_RsaPrivateKeyDecode+0xd6>
        SkipInt(input, inOutIdx, inSz) < 0 ||
        SkipInt(input, inOutIdx, inSz) < 0 ||
        SkipInt(input, inOutIdx, inSz) < 0 )

#endif
            return ASN_RSA_KEY_E;
 8009866:	f06f 038e 	mvn.w	r3, #142	; 0x8e
 800986a:	e026      	b.n	80098ba <wc_RsaPrivateKeyDecode+0x124>
#if (defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA) || !defined(RSA_LOW_MEM)) \
    && !defined(WOLFSSL_RSA_PUBLIC_ONLY)
    if (GetInt(&key->dP, input, inOutIdx, inSz) < 0 ||
 800986c:	687b      	ldr	r3, [r7, #4]
 800986e:	f603 703c 	addw	r0, r3, #3900	; 0xf3c
 8009872:	683b      	ldr	r3, [r7, #0]
 8009874:	68ba      	ldr	r2, [r7, #8]
 8009876:	68f9      	ldr	r1, [r7, #12]
 8009878:	f7ff fa65 	bl	8008d46 <GetInt>
 800987c:	4603      	mov	r3, r0
 800987e:	2b00      	cmp	r3, #0
 8009880:	db17      	blt.n	80098b2 <wc_RsaPrivateKeyDecode+0x11c>
        GetInt(&key->dQ, input, inOutIdx, inSz) < 0 ||
 8009882:	687b      	ldr	r3, [r7, #4]
 8009884:	f503 5092 	add.w	r0, r3, #4672	; 0x1240
 8009888:	3008      	adds	r0, #8
 800988a:	683b      	ldr	r3, [r7, #0]
 800988c:	68ba      	ldr	r2, [r7, #8]
 800988e:	68f9      	ldr	r1, [r7, #12]
 8009890:	f7ff fa59 	bl	8008d46 <GetInt>
 8009894:	4603      	mov	r3, r0
    if (GetInt(&key->dP, input, inOutIdx, inSz) < 0 ||
 8009896:	2b00      	cmp	r3, #0
 8009898:	db0b      	blt.n	80098b2 <wc_RsaPrivateKeyDecode+0x11c>
        GetInt(&key->u,  input, inOutIdx, inSz) < 0 )  return ASN_RSA_KEY_E;
 800989a:	687b      	ldr	r3, [r7, #4]
 800989c:	f503 50aa 	add.w	r0, r3, #5440	; 0x1540
 80098a0:	3014      	adds	r0, #20
 80098a2:	683b      	ldr	r3, [r7, #0]
 80098a4:	68ba      	ldr	r2, [r7, #8]
 80098a6:	68f9      	ldr	r1, [r7, #12]
 80098a8:	f7ff fa4d 	bl	8008d46 <GetInt>
 80098ac:	4603      	mov	r3, r0
        GetInt(&key->dQ, input, inOutIdx, inSz) < 0 ||
 80098ae:	2b00      	cmp	r3, #0
 80098b0:	da02      	bge.n	80098b8 <wc_RsaPrivateKeyDecode+0x122>
        GetInt(&key->u,  input, inOutIdx, inSz) < 0 )  return ASN_RSA_KEY_E;
 80098b2:	f06f 038e 	mvn.w	r3, #142	; 0x8e
 80098b6:	e000      	b.n	80098ba <wc_RsaPrivateKeyDecode+0x124>
    if (wc_InitRsaHw(key) != 0) {
        return BAD_STATE_E;
    }
#endif

    return 0;
 80098b8:	2300      	movs	r3, #0
}
 80098ba:	4618      	mov	r0, r3
 80098bc:	3718      	adds	r7, #24
 80098be:	46bd      	mov	sp, r7
 80098c0:	bd80      	pop	{r7, pc}

080098c2 <ToTraditionalInline_ex>:

/* Remove PKCS8 header, place inOutIdx at beginning of traditional,
 * return traditional length on success, negative on error */
int ToTraditionalInline_ex(const byte* input, word32* inOutIdx, word32 sz,
                           word32* algId)
{
 80098c2:	b580      	push	{r7, lr}
 80098c4:	b08c      	sub	sp, #48	; 0x30
 80098c6:	af02      	add	r7, sp, #8
 80098c8:	60f8      	str	r0, [r7, #12]
 80098ca:	60b9      	str	r1, [r7, #8]
 80098cc:	607a      	str	r2, [r7, #4]
 80098ce:	603b      	str	r3, [r7, #0]
    word32 idx;
    int    version, length;
    int    ret;
    byte   tag;

    if (input == NULL || inOutIdx == NULL)
 80098d0:	68fb      	ldr	r3, [r7, #12]
 80098d2:	2b00      	cmp	r3, #0
 80098d4:	d002      	beq.n	80098dc <ToTraditionalInline_ex+0x1a>
 80098d6:	68bb      	ldr	r3, [r7, #8]
 80098d8:	2b00      	cmp	r3, #0
 80098da:	d102      	bne.n	80098e2 <ToTraditionalInline_ex+0x20>
        return BAD_FUNC_ARG;
 80098dc:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 80098e0:	e065      	b.n	80099ae <ToTraditionalInline_ex+0xec>

    idx = *inOutIdx;
 80098e2:	68bb      	ldr	r3, [r7, #8]
 80098e4:	681b      	ldr	r3, [r3, #0]
 80098e6:	623b      	str	r3, [r7, #32]

    if (GetSequence(input, &idx, &length, sz) < 0)
 80098e8:	f107 0218 	add.w	r2, r7, #24
 80098ec:	f107 0120 	add.w	r1, r7, #32
 80098f0:	687b      	ldr	r3, [r7, #4]
 80098f2:	68f8      	ldr	r0, [r7, #12]
 80098f4:	f7ff f84c 	bl	8008990 <GetSequence>
 80098f8:	4603      	mov	r3, r0
 80098fa:	2b00      	cmp	r3, #0
 80098fc:	da02      	bge.n	8009904 <ToTraditionalInline_ex+0x42>
        return ASN_PARSE_E;
 80098fe:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8009902:	e054      	b.n	80099ae <ToTraditionalInline_ex+0xec>

    if (GetMyVersion(input, &idx, &version, sz) < 0)
 8009904:	f107 021c 	add.w	r2, r7, #28
 8009908:	f107 0120 	add.w	r1, r7, #32
 800990c:	687b      	ldr	r3, [r7, #4]
 800990e:	68f8      	ldr	r0, [r7, #12]
 8009910:	f7ff f996 	bl	8008c40 <GetMyVersion>
 8009914:	4603      	mov	r3, r0
 8009916:	2b00      	cmp	r3, #0
 8009918:	da02      	bge.n	8009920 <ToTraditionalInline_ex+0x5e>
        return ASN_PARSE_E;
 800991a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800991e:	e046      	b.n	80099ae <ToTraditionalInline_ex+0xec>

    if (GetAlgoId(input, &idx, algId, oidKeyType, sz) < 0)
 8009920:	f107 0120 	add.w	r1, r7, #32
 8009924:	687b      	ldr	r3, [r7, #4]
 8009926:	9300      	str	r3, [sp, #0]
 8009928:	2302      	movs	r3, #2
 800992a:	683a      	ldr	r2, [r7, #0]
 800992c:	68f8      	ldr	r0, [r7, #12]
 800992e:	f7ff fedf 	bl	80096f0 <GetAlgoId>
 8009932:	4603      	mov	r3, r0
 8009934:	2b00      	cmp	r3, #0
 8009936:	da02      	bge.n	800993e <ToTraditionalInline_ex+0x7c>
        return ASN_PARSE_E;
 8009938:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800993c:	e037      	b.n	80099ae <ToTraditionalInline_ex+0xec>

    if (GetASNTag(input, &idx, &tag, sz) < 0)
 800993e:	f107 0217 	add.w	r2, r7, #23
 8009942:	f107 0120 	add.w	r1, r7, #32
 8009946:	687b      	ldr	r3, [r7, #4]
 8009948:	68f8      	ldr	r0, [r7, #12]
 800994a:	f7fe ff6b 	bl	8008824 <GetASNTag>
 800994e:	4603      	mov	r3, r0
 8009950:	2b00      	cmp	r3, #0
 8009952:	da02      	bge.n	800995a <ToTraditionalInline_ex+0x98>
        return ASN_PARSE_E;
 8009954:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8009958:	e029      	b.n	80099ae <ToTraditionalInline_ex+0xec>
    idx = idx - 1; /* reset idx after finding tag */
 800995a:	6a3b      	ldr	r3, [r7, #32]
 800995c:	3b01      	subs	r3, #1
 800995e:	623b      	str	r3, [r7, #32]

    if (tag == ASN_OBJECT_ID) {
 8009960:	7dfb      	ldrb	r3, [r7, #23]
 8009962:	2b06      	cmp	r3, #6
 8009964:	d10c      	bne.n	8009980 <ToTraditionalInline_ex+0xbe>
        if (SkipObjectId(input, &idx, sz) < 0)
 8009966:	f107 0320 	add.w	r3, r7, #32
 800996a:	687a      	ldr	r2, [r7, #4]
 800996c:	4619      	mov	r1, r3
 800996e:	68f8      	ldr	r0, [r7, #12]
 8009970:	f7ff fe9b 	bl	80096aa <SkipObjectId>
 8009974:	4603      	mov	r3, r0
 8009976:	2b00      	cmp	r3, #0
 8009978:	da02      	bge.n	8009980 <ToTraditionalInline_ex+0xbe>
            return ASN_PARSE_E;
 800997a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800997e:	e016      	b.n	80099ae <ToTraditionalInline_ex+0xec>
    }

    ret = GetOctetString(input, &idx, &length, sz);
 8009980:	f107 0218 	add.w	r2, r7, #24
 8009984:	f107 0120 	add.w	r1, r7, #32
 8009988:	687b      	ldr	r3, [r7, #4]
 800998a:	68f8      	ldr	r0, [r7, #12]
 800998c:	f7ff f8ac 	bl	8008ae8 <GetOctetString>
 8009990:	6278      	str	r0, [r7, #36]	; 0x24
    if (ret < 0) {
 8009992:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009994:	2b00      	cmp	r3, #0
 8009996:	da06      	bge.n	80099a6 <ToTraditionalInline_ex+0xe4>
        if (ret == BUFFER_E)
 8009998:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800999a:	f113 0f84 	cmn.w	r3, #132	; 0x84
 800999e:	d102      	bne.n	80099a6 <ToTraditionalInline_ex+0xe4>
            return ASN_PARSE_E;
 80099a0:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 80099a4:	e003      	b.n	80099ae <ToTraditionalInline_ex+0xec>
        /* Some private keys don't expect an octet string */
        WOLFSSL_MSG("Couldn't find Octet string");
    }

    *inOutIdx = idx;
 80099a6:	6a3a      	ldr	r2, [r7, #32]
 80099a8:	68bb      	ldr	r3, [r7, #8]
 80099aa:	601a      	str	r2, [r3, #0]

    return length;
 80099ac:	69bb      	ldr	r3, [r7, #24]
}
 80099ae:	4618      	mov	r0, r3
 80099b0:	3728      	adds	r7, #40	; 0x28
 80099b2:	46bd      	mov	sp, r7
 80099b4:	bd80      	pop	{r7, pc}

080099b6 <ToTraditional_ex>:
    return ToTraditionalInline_ex(input, inOutIdx, sz, &oid);
}

/* Remove PKCS8 header, move beginning of traditional to beginning of input */
int ToTraditional_ex(byte* input, word32 sz, word32* algId)
{
 80099b6:	b580      	push	{r7, lr}
 80099b8:	b086      	sub	sp, #24
 80099ba:	af00      	add	r7, sp, #0
 80099bc:	60f8      	str	r0, [r7, #12]
 80099be:	60b9      	str	r1, [r7, #8]
 80099c0:	607a      	str	r2, [r7, #4]
    word32 inOutIdx = 0;
 80099c2:	2300      	movs	r3, #0
 80099c4:	613b      	str	r3, [r7, #16]
    int    length;

    if (input == NULL)
 80099c6:	68fb      	ldr	r3, [r7, #12]
 80099c8:	2b00      	cmp	r3, #0
 80099ca:	d102      	bne.n	80099d2 <ToTraditional_ex+0x1c>
        return BAD_FUNC_ARG;
 80099cc:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 80099d0:	e01e      	b.n	8009a10 <ToTraditional_ex+0x5a>

    length = ToTraditionalInline_ex(input, &inOutIdx, sz, algId);
 80099d2:	f107 0110 	add.w	r1, r7, #16
 80099d6:	687b      	ldr	r3, [r7, #4]
 80099d8:	68ba      	ldr	r2, [r7, #8]
 80099da:	68f8      	ldr	r0, [r7, #12]
 80099dc:	f7ff ff71 	bl	80098c2 <ToTraditionalInline_ex>
 80099e0:	6178      	str	r0, [r7, #20]
    if (length < 0)
 80099e2:	697b      	ldr	r3, [r7, #20]
 80099e4:	2b00      	cmp	r3, #0
 80099e6:	da01      	bge.n	80099ec <ToTraditional_ex+0x36>
        return length;
 80099e8:	697b      	ldr	r3, [r7, #20]
 80099ea:	e011      	b.n	8009a10 <ToTraditional_ex+0x5a>

    if (length + inOutIdx > sz)
 80099ec:	697a      	ldr	r2, [r7, #20]
 80099ee:	693b      	ldr	r3, [r7, #16]
 80099f0:	4413      	add	r3, r2
 80099f2:	68ba      	ldr	r2, [r7, #8]
 80099f4:	429a      	cmp	r2, r3
 80099f6:	d202      	bcs.n	80099fe <ToTraditional_ex+0x48>
        return BUFFER_E;
 80099f8:	f06f 0383 	mvn.w	r3, #131	; 0x83
 80099fc:	e008      	b.n	8009a10 <ToTraditional_ex+0x5a>

    XMEMMOVE(input, input + inOutIdx, length);
 80099fe:	693b      	ldr	r3, [r7, #16]
 8009a00:	68fa      	ldr	r2, [r7, #12]
 8009a02:	4413      	add	r3, r2
 8009a04:	697a      	ldr	r2, [r7, #20]
 8009a06:	4619      	mov	r1, r3
 8009a08:	68f8      	ldr	r0, [r7, #12]
 8009a0a:	f00f fcff 	bl	801940c <memmove>

    return length;
 8009a0e:	697b      	ldr	r3, [r7, #20]
}
 8009a10:	4618      	mov	r0, r3
 8009a12:	3718      	adds	r7, #24
 8009a14:	46bd      	mov	sp, r7
 8009a16:	bd80      	pop	{r7, pc}

08009a18 <wc_RsaPublicKeyDecode_ex>:
}
#endif /* WOLFSSL_RENESAS_TSIP */

int wc_RsaPublicKeyDecode_ex(const byte* input, word32* inOutIdx, word32 inSz,
    const byte** n, word32* nSz, const byte** e, word32* eSz)
{
 8009a18:	b580      	push	{r7, lr}
 8009a1a:	b08a      	sub	sp, #40	; 0x28
 8009a1c:	af02      	add	r7, sp, #8
 8009a1e:	60f8      	str	r0, [r7, #12]
 8009a20:	60b9      	str	r1, [r7, #8]
 8009a22:	607a      	str	r2, [r7, #4]
 8009a24:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8009a26:	2300      	movs	r3, #0
 8009a28:	61fb      	str	r3, [r7, #28]
    int length = 0;
 8009a2a:	2300      	movs	r3, #0
 8009a2c:	61bb      	str	r3, [r7, #24]
#if defined(OPENSSL_EXTRA) || defined(RSA_DECODE_EXTRA)
    word32 localIdx;
    byte   tag;
#endif

    if (input == NULL || inOutIdx == NULL)
 8009a2e:	68fb      	ldr	r3, [r7, #12]
 8009a30:	2b00      	cmp	r3, #0
 8009a32:	d002      	beq.n	8009a3a <wc_RsaPublicKeyDecode_ex+0x22>
 8009a34:	68bb      	ldr	r3, [r7, #8]
 8009a36:	2b00      	cmp	r3, #0
 8009a38:	d102      	bne.n	8009a40 <wc_RsaPublicKeyDecode_ex+0x28>
        return BAD_FUNC_ARG;
 8009a3a:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8009a3e:	e0c5      	b.n	8009bcc <wc_RsaPublicKeyDecode_ex+0x1b4>

    if (GetSequence(input, inOutIdx, &length, inSz) < 0)
 8009a40:	f107 0218 	add.w	r2, r7, #24
 8009a44:	687b      	ldr	r3, [r7, #4]
 8009a46:	68b9      	ldr	r1, [r7, #8]
 8009a48:	68f8      	ldr	r0, [r7, #12]
 8009a4a:	f7fe ffa1 	bl	8008990 <GetSequence>
 8009a4e:	4603      	mov	r3, r0
 8009a50:	2b00      	cmp	r3, #0
 8009a52:	da02      	bge.n	8009a5a <wc_RsaPublicKeyDecode_ex+0x42>
        return ASN_PARSE_E;
 8009a54:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8009a58:	e0b8      	b.n	8009bcc <wc_RsaPublicKeyDecode_ex+0x1b4>

#if defined(OPENSSL_EXTRA) || defined(RSA_DECODE_EXTRA)
    localIdx = *inOutIdx;
 8009a5a:	68bb      	ldr	r3, [r7, #8]
 8009a5c:	681b      	ldr	r3, [r3, #0]
 8009a5e:	617b      	str	r3, [r7, #20]
    if (GetASNTag(input, &localIdx, &tag, inSz) < 0)
 8009a60:	f107 0213 	add.w	r2, r7, #19
 8009a64:	f107 0114 	add.w	r1, r7, #20
 8009a68:	687b      	ldr	r3, [r7, #4]
 8009a6a:	68f8      	ldr	r0, [r7, #12]
 8009a6c:	f7fe feda 	bl	8008824 <GetASNTag>
 8009a70:	4603      	mov	r3, r0
 8009a72:	2b00      	cmp	r3, #0
 8009a74:	da02      	bge.n	8009a7c <wc_RsaPublicKeyDecode_ex+0x64>
        return BUFFER_E;
 8009a76:	f06f 0383 	mvn.w	r3, #131	; 0x83
 8009a7a:	e0a7      	b.n	8009bcc <wc_RsaPublicKeyDecode_ex+0x1b4>

    if (tag != ASN_INTEGER) {
 8009a7c:	7cfb      	ldrb	r3, [r7, #19]
 8009a7e:	2b02      	cmp	r3, #2
 8009a80:	d05b      	beq.n	8009b3a <wc_RsaPublicKeyDecode_ex+0x122>
        /* not from decoded cert, will have algo id, skip past */
        if (GetSequence(input, inOutIdx, &length, inSz) < 0)
 8009a82:	f107 0218 	add.w	r2, r7, #24
 8009a86:	687b      	ldr	r3, [r7, #4]
 8009a88:	68b9      	ldr	r1, [r7, #8]
 8009a8a:	68f8      	ldr	r0, [r7, #12]
 8009a8c:	f7fe ff80 	bl	8008990 <GetSequence>
 8009a90:	4603      	mov	r3, r0
 8009a92:	2b00      	cmp	r3, #0
 8009a94:	da02      	bge.n	8009a9c <wc_RsaPublicKeyDecode_ex+0x84>
            return ASN_PARSE_E;
 8009a96:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8009a9a:	e097      	b.n	8009bcc <wc_RsaPublicKeyDecode_ex+0x1b4>

        if (SkipObjectId(input, inOutIdx, inSz) < 0)
 8009a9c:	687a      	ldr	r2, [r7, #4]
 8009a9e:	68b9      	ldr	r1, [r7, #8]
 8009aa0:	68f8      	ldr	r0, [r7, #12]
 8009aa2:	f7ff fe02 	bl	80096aa <SkipObjectId>
 8009aa6:	4603      	mov	r3, r0
 8009aa8:	2b00      	cmp	r3, #0
 8009aaa:	da02      	bge.n	8009ab2 <wc_RsaPublicKeyDecode_ex+0x9a>
            return ASN_PARSE_E;
 8009aac:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8009ab0:	e08c      	b.n	8009bcc <wc_RsaPublicKeyDecode_ex+0x1b4>

        /* Option NULL ASN.1 tag */
        if (*inOutIdx  >= inSz) {
 8009ab2:	68bb      	ldr	r3, [r7, #8]
 8009ab4:	681b      	ldr	r3, [r3, #0]
 8009ab6:	687a      	ldr	r2, [r7, #4]
 8009ab8:	429a      	cmp	r2, r3
 8009aba:	d802      	bhi.n	8009ac2 <wc_RsaPublicKeyDecode_ex+0xaa>
            return BUFFER_E;
 8009abc:	f06f 0383 	mvn.w	r3, #131	; 0x83
 8009ac0:	e084      	b.n	8009bcc <wc_RsaPublicKeyDecode_ex+0x1b4>
        }

        localIdx = *inOutIdx;
 8009ac2:	68bb      	ldr	r3, [r7, #8]
 8009ac4:	681b      	ldr	r3, [r3, #0]
 8009ac6:	617b      	str	r3, [r7, #20]
        if (GetASNTag(input, &localIdx, &tag, inSz) < 0)
 8009ac8:	f107 0213 	add.w	r2, r7, #19
 8009acc:	f107 0114 	add.w	r1, r7, #20
 8009ad0:	687b      	ldr	r3, [r7, #4]
 8009ad2:	68f8      	ldr	r0, [r7, #12]
 8009ad4:	f7fe fea6 	bl	8008824 <GetASNTag>
 8009ad8:	4603      	mov	r3, r0
 8009ada:	2b00      	cmp	r3, #0
 8009adc:	da02      	bge.n	8009ae4 <wc_RsaPublicKeyDecode_ex+0xcc>
            return ASN_PARSE_E;
 8009ade:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8009ae2:	e073      	b.n	8009bcc <wc_RsaPublicKeyDecode_ex+0x1b4>

        if (tag == ASN_TAG_NULL) {
 8009ae4:	7cfb      	ldrb	r3, [r7, #19]
 8009ae6:	2b05      	cmp	r3, #5
 8009ae8:	d10a      	bne.n	8009b00 <wc_RsaPublicKeyDecode_ex+0xe8>
            ret = GetASNNull(input, inOutIdx, inSz);
 8009aea:	687a      	ldr	r2, [r7, #4]
 8009aec:	68b9      	ldr	r1, [r7, #8]
 8009aee:	68f8      	ldr	r0, [r7, #12]
 8009af0:	f7fe ff76 	bl	80089e0 <GetASNNull>
 8009af4:	61f8      	str	r0, [r7, #28]
            if (ret != 0)
 8009af6:	69fb      	ldr	r3, [r7, #28]
 8009af8:	2b00      	cmp	r3, #0
 8009afa:	d001      	beq.n	8009b00 <wc_RsaPublicKeyDecode_ex+0xe8>
                return ret;
 8009afc:	69fb      	ldr	r3, [r7, #28]
 8009afe:	e065      	b.n	8009bcc <wc_RsaPublicKeyDecode_ex+0x1b4>
        }

        /* should have bit tag length and seq next */
        ret = CheckBitString(input, inOutIdx, NULL, inSz, 1, NULL);
 8009b00:	2300      	movs	r3, #0
 8009b02:	9301      	str	r3, [sp, #4]
 8009b04:	2301      	movs	r3, #1
 8009b06:	9300      	str	r3, [sp, #0]
 8009b08:	687b      	ldr	r3, [r7, #4]
 8009b0a:	2200      	movs	r2, #0
 8009b0c:	68b9      	ldr	r1, [r7, #8]
 8009b0e:	68f8      	ldr	r0, [r7, #12]
 8009b10:	f7ff f955 	bl	8008dbe <CheckBitString>
 8009b14:	61f8      	str	r0, [r7, #28]
        if (ret != 0)
 8009b16:	69fb      	ldr	r3, [r7, #28]
 8009b18:	2b00      	cmp	r3, #0
 8009b1a:	d001      	beq.n	8009b20 <wc_RsaPublicKeyDecode_ex+0x108>
            return ret;
 8009b1c:	69fb      	ldr	r3, [r7, #28]
 8009b1e:	e055      	b.n	8009bcc <wc_RsaPublicKeyDecode_ex+0x1b4>

        if (GetSequence(input, inOutIdx, &length, inSz) < 0)
 8009b20:	f107 0218 	add.w	r2, r7, #24
 8009b24:	687b      	ldr	r3, [r7, #4]
 8009b26:	68b9      	ldr	r1, [r7, #8]
 8009b28:	68f8      	ldr	r0, [r7, #12]
 8009b2a:	f7fe ff31 	bl	8008990 <GetSequence>
 8009b2e:	4603      	mov	r3, r0
 8009b30:	2b00      	cmp	r3, #0
 8009b32:	da02      	bge.n	8009b3a <wc_RsaPublicKeyDecode_ex+0x122>
            return ASN_PARSE_E;
 8009b34:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8009b38:	e048      	b.n	8009bcc <wc_RsaPublicKeyDecode_ex+0x1b4>
    }
#endif /* OPENSSL_EXTRA */

    /* Get modulus */
    ret = GetASNInt(input, inOutIdx, &length, inSz);
 8009b3a:	f107 0218 	add.w	r2, r7, #24
 8009b3e:	687b      	ldr	r3, [r7, #4]
 8009b40:	68b9      	ldr	r1, [r7, #8]
 8009b42:	68f8      	ldr	r0, [r7, #12]
 8009b44:	f7fe ffe4 	bl	8008b10 <GetASNInt>
 8009b48:	61f8      	str	r0, [r7, #28]
    if (ret < 0) {
 8009b4a:	69fb      	ldr	r3, [r7, #28]
 8009b4c:	2b00      	cmp	r3, #0
 8009b4e:	da02      	bge.n	8009b56 <wc_RsaPublicKeyDecode_ex+0x13e>
        return ASN_RSA_KEY_E;
 8009b50:	f06f 038e 	mvn.w	r3, #142	; 0x8e
 8009b54:	e03a      	b.n	8009bcc <wc_RsaPublicKeyDecode_ex+0x1b4>
    }
    if (nSz)
 8009b56:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009b58:	2b00      	cmp	r3, #0
 8009b5a:	d003      	beq.n	8009b64 <wc_RsaPublicKeyDecode_ex+0x14c>
        *nSz = length;
 8009b5c:	69bb      	ldr	r3, [r7, #24]
 8009b5e:	461a      	mov	r2, r3
 8009b60:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009b62:	601a      	str	r2, [r3, #0]
    if (n)
 8009b64:	683b      	ldr	r3, [r7, #0]
 8009b66:	2b00      	cmp	r3, #0
 8009b68:	d005      	beq.n	8009b76 <wc_RsaPublicKeyDecode_ex+0x15e>
        *n = &input[*inOutIdx];
 8009b6a:	68bb      	ldr	r3, [r7, #8]
 8009b6c:	681b      	ldr	r3, [r3, #0]
 8009b6e:	68fa      	ldr	r2, [r7, #12]
 8009b70:	441a      	add	r2, r3
 8009b72:	683b      	ldr	r3, [r7, #0]
 8009b74:	601a      	str	r2, [r3, #0]
    *inOutIdx += length;
 8009b76:	68bb      	ldr	r3, [r7, #8]
 8009b78:	681b      	ldr	r3, [r3, #0]
 8009b7a:	69ba      	ldr	r2, [r7, #24]
 8009b7c:	441a      	add	r2, r3
 8009b7e:	68bb      	ldr	r3, [r7, #8]
 8009b80:	601a      	str	r2, [r3, #0]

    /* Get exponent */
    ret = GetASNInt(input, inOutIdx, &length, inSz);
 8009b82:	f107 0218 	add.w	r2, r7, #24
 8009b86:	687b      	ldr	r3, [r7, #4]
 8009b88:	68b9      	ldr	r1, [r7, #8]
 8009b8a:	68f8      	ldr	r0, [r7, #12]
 8009b8c:	f7fe ffc0 	bl	8008b10 <GetASNInt>
 8009b90:	61f8      	str	r0, [r7, #28]
    if (ret < 0) {
 8009b92:	69fb      	ldr	r3, [r7, #28]
 8009b94:	2b00      	cmp	r3, #0
 8009b96:	da02      	bge.n	8009b9e <wc_RsaPublicKeyDecode_ex+0x186>
        return ASN_RSA_KEY_E;
 8009b98:	f06f 038e 	mvn.w	r3, #142	; 0x8e
 8009b9c:	e016      	b.n	8009bcc <wc_RsaPublicKeyDecode_ex+0x1b4>
    }
    if (eSz)
 8009b9e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009ba0:	2b00      	cmp	r3, #0
 8009ba2:	d003      	beq.n	8009bac <wc_RsaPublicKeyDecode_ex+0x194>
        *eSz = length;
 8009ba4:	69bb      	ldr	r3, [r7, #24]
 8009ba6:	461a      	mov	r2, r3
 8009ba8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009baa:	601a      	str	r2, [r3, #0]
    if (e)
 8009bac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009bae:	2b00      	cmp	r3, #0
 8009bb0:	d005      	beq.n	8009bbe <wc_RsaPublicKeyDecode_ex+0x1a6>
        *e = &input[*inOutIdx];
 8009bb2:	68bb      	ldr	r3, [r7, #8]
 8009bb4:	681b      	ldr	r3, [r3, #0]
 8009bb6:	68fa      	ldr	r2, [r7, #12]
 8009bb8:	441a      	add	r2, r3
 8009bba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009bbc:	601a      	str	r2, [r3, #0]
    *inOutIdx += length;
 8009bbe:	68bb      	ldr	r3, [r7, #8]
 8009bc0:	681b      	ldr	r3, [r3, #0]
 8009bc2:	69ba      	ldr	r2, [r7, #24]
 8009bc4:	441a      	add	r2, r3
 8009bc6:	68bb      	ldr	r3, [r7, #8]
 8009bc8:	601a      	str	r2, [r3, #0]

    return ret;
 8009bca:	69fb      	ldr	r3, [r7, #28]
}
 8009bcc:	4618      	mov	r0, r3
 8009bce:	3720      	adds	r7, #32
 8009bd0:	46bd      	mov	sp, r7
 8009bd2:	bd80      	pop	{r7, pc}

08009bd4 <wc_RsaPublicKeyDecode>:

int wc_RsaPublicKeyDecode(const byte* input, word32* inOutIdx, RsaKey* key,
                       word32 inSz)
{
 8009bd4:	b590      	push	{r4, r7, lr}
 8009bd6:	b08f      	sub	sp, #60	; 0x3c
 8009bd8:	af04      	add	r7, sp, #16
 8009bda:	60f8      	str	r0, [r7, #12]
 8009bdc:	60b9      	str	r1, [r7, #8]
 8009bde:	607a      	str	r2, [r7, #4]
 8009be0:	603b      	str	r3, [r7, #0]
    int ret;
    const byte *n = NULL, *e = NULL;
 8009be2:	2300      	movs	r3, #0
 8009be4:	623b      	str	r3, [r7, #32]
 8009be6:	2300      	movs	r3, #0
 8009be8:	61fb      	str	r3, [r7, #28]
    word32 nSz = 0, eSz = 0;
 8009bea:	2300      	movs	r3, #0
 8009bec:	61bb      	str	r3, [r7, #24]
 8009bee:	2300      	movs	r3, #0
 8009bf0:	617b      	str	r3, [r7, #20]

    if (key == NULL)
 8009bf2:	687b      	ldr	r3, [r7, #4]
 8009bf4:	2b00      	cmp	r3, #0
 8009bf6:	d102      	bne.n	8009bfe <wc_RsaPublicKeyDecode+0x2a>
        return BAD_FUNC_ARG;
 8009bf8:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8009bfc:	e01f      	b.n	8009c3e <wc_RsaPublicKeyDecode+0x6a>

    ret = wc_RsaPublicKeyDecode_ex(input, inOutIdx, inSz, &n, &nSz, &e, &eSz);
 8009bfe:	f107 0220 	add.w	r2, r7, #32
 8009c02:	f107 0314 	add.w	r3, r7, #20
 8009c06:	9302      	str	r3, [sp, #8]
 8009c08:	f107 031c 	add.w	r3, r7, #28
 8009c0c:	9301      	str	r3, [sp, #4]
 8009c0e:	f107 0318 	add.w	r3, r7, #24
 8009c12:	9300      	str	r3, [sp, #0]
 8009c14:	4613      	mov	r3, r2
 8009c16:	683a      	ldr	r2, [r7, #0]
 8009c18:	68b9      	ldr	r1, [r7, #8]
 8009c1a:	68f8      	ldr	r0, [r7, #12]
 8009c1c:	f7ff fefc 	bl	8009a18 <wc_RsaPublicKeyDecode_ex>
 8009c20:	6278      	str	r0, [r7, #36]	; 0x24
    if (ret == 0) {
 8009c22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009c24:	2b00      	cmp	r3, #0
 8009c26:	d109      	bne.n	8009c3c <wc_RsaPublicKeyDecode+0x68>
        ret = wc_RsaPublicKeyDecodeRaw(n, nSz, e, eSz, key);
 8009c28:	6a38      	ldr	r0, [r7, #32]
 8009c2a:	69b9      	ldr	r1, [r7, #24]
 8009c2c:	69fa      	ldr	r2, [r7, #28]
 8009c2e:	697c      	ldr	r4, [r7, #20]
 8009c30:	687b      	ldr	r3, [r7, #4]
 8009c32:	9300      	str	r3, [sp, #0]
 8009c34:	4623      	mov	r3, r4
 8009c36:	f000 f806 	bl	8009c46 <wc_RsaPublicKeyDecodeRaw>
 8009c3a:	6278      	str	r0, [r7, #36]	; 0x24
    }

    return ret;
 8009c3c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8009c3e:	4618      	mov	r0, r3
 8009c40:	372c      	adds	r7, #44	; 0x2c
 8009c42:	46bd      	mov	sp, r7
 8009c44:	bd90      	pop	{r4, r7, pc}

08009c46 <wc_RsaPublicKeyDecodeRaw>:

/* import RSA public key elements (n, e) into RsaKey structure (key) */
int wc_RsaPublicKeyDecodeRaw(const byte* n, word32 nSz, const byte* e,
                             word32 eSz, RsaKey* key)
{
 8009c46:	b580      	push	{r7, lr}
 8009c48:	b084      	sub	sp, #16
 8009c4a:	af00      	add	r7, sp, #0
 8009c4c:	60f8      	str	r0, [r7, #12]
 8009c4e:	60b9      	str	r1, [r7, #8]
 8009c50:	607a      	str	r2, [r7, #4]
 8009c52:	603b      	str	r3, [r7, #0]
    if (n == NULL || e == NULL || key == NULL)
 8009c54:	68fb      	ldr	r3, [r7, #12]
 8009c56:	2b00      	cmp	r3, #0
 8009c58:	d005      	beq.n	8009c66 <wc_RsaPublicKeyDecodeRaw+0x20>
 8009c5a:	687b      	ldr	r3, [r7, #4]
 8009c5c:	2b00      	cmp	r3, #0
 8009c5e:	d002      	beq.n	8009c66 <wc_RsaPublicKeyDecodeRaw+0x20>
 8009c60:	69bb      	ldr	r3, [r7, #24]
 8009c62:	2b00      	cmp	r3, #0
 8009c64:	d102      	bne.n	8009c6c <wc_RsaPublicKeyDecodeRaw+0x26>
        return BAD_FUNC_ARG;
 8009c66:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8009c6a:	e048      	b.n	8009cfe <wc_RsaPublicKeyDecodeRaw+0xb8>

    key->type = RSA_PUBLIC;
 8009c6c:	69bb      	ldr	r3, [r7, #24]
 8009c6e:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 8009c72:	3308      	adds	r3, #8
 8009c74:	2200      	movs	r2, #0
 8009c76:	601a      	str	r2, [r3, #0]

    if (mp_init(&key->n) != MP_OKAY)
 8009c78:	69bb      	ldr	r3, [r7, #24]
 8009c7a:	4618      	mov	r0, r3
 8009c7c:	f00e fe46 	bl	801890c <sp_init>
 8009c80:	4603      	mov	r3, r0
 8009c82:	2b00      	cmp	r3, #0
 8009c84:	d002      	beq.n	8009c8c <wc_RsaPublicKeyDecodeRaw+0x46>
        return MP_INIT_E;
 8009c86:	f06f 036d 	mvn.w	r3, #109	; 0x6d
 8009c8a:	e038      	b.n	8009cfe <wc_RsaPublicKeyDecodeRaw+0xb8>

    if (mp_read_unsigned_bin(&key->n, n, nSz) != 0) {
 8009c8c:	69bb      	ldr	r3, [r7, #24]
 8009c8e:	68ba      	ldr	r2, [r7, #8]
 8009c90:	68f9      	ldr	r1, [r7, #12]
 8009c92:	4618      	mov	r0, r3
 8009c94:	f00f f902 	bl	8018e9c <sp_read_unsigned_bin>
 8009c98:	4603      	mov	r3, r0
 8009c9a:	2b00      	cmp	r3, #0
 8009c9c:	d006      	beq.n	8009cac <wc_RsaPublicKeyDecodeRaw+0x66>
        mp_clear(&key->n);
 8009c9e:	69bb      	ldr	r3, [r7, #24]
 8009ca0:	4618      	mov	r0, r3
 8009ca2:	f00e fee4 	bl	8018a6e <sp_clear>
        return ASN_GETINT_E;
 8009ca6:	f06f 038d 	mvn.w	r3, #141	; 0x8d
 8009caa:	e028      	b.n	8009cfe <wc_RsaPublicKeyDecodeRaw+0xb8>
        mp_clear(&key->n);
        return ASN_GETINT_E;
    }
#endif /* HAVE_WOLF_BIGINT */

    if (mp_init(&key->e) != MP_OKAY) {
 8009cac:	69bb      	ldr	r3, [r7, #24]
 8009cae:	f503 7343 	add.w	r3, r3, #780	; 0x30c
 8009cb2:	4618      	mov	r0, r3
 8009cb4:	f00e fe2a 	bl	801890c <sp_init>
 8009cb8:	4603      	mov	r3, r0
 8009cba:	2b00      	cmp	r3, #0
 8009cbc:	d006      	beq.n	8009ccc <wc_RsaPublicKeyDecodeRaw+0x86>
        mp_clear(&key->n);
 8009cbe:	69bb      	ldr	r3, [r7, #24]
 8009cc0:	4618      	mov	r0, r3
 8009cc2:	f00e fed4 	bl	8018a6e <sp_clear>
        return MP_INIT_E;
 8009cc6:	f06f 036d 	mvn.w	r3, #109	; 0x6d
 8009cca:	e018      	b.n	8009cfe <wc_RsaPublicKeyDecodeRaw+0xb8>
    }

    if (mp_read_unsigned_bin(&key->e, e, eSz) != 0) {
 8009ccc:	69bb      	ldr	r3, [r7, #24]
 8009cce:	f503 7343 	add.w	r3, r3, #780	; 0x30c
 8009cd2:	683a      	ldr	r2, [r7, #0]
 8009cd4:	6879      	ldr	r1, [r7, #4]
 8009cd6:	4618      	mov	r0, r3
 8009cd8:	f00f f8e0 	bl	8018e9c <sp_read_unsigned_bin>
 8009cdc:	4603      	mov	r3, r0
 8009cde:	2b00      	cmp	r3, #0
 8009ce0:	d00c      	beq.n	8009cfc <wc_RsaPublicKeyDecodeRaw+0xb6>
        mp_clear(&key->n);
 8009ce2:	69bb      	ldr	r3, [r7, #24]
 8009ce4:	4618      	mov	r0, r3
 8009ce6:	f00e fec2 	bl	8018a6e <sp_clear>
        mp_clear(&key->e);
 8009cea:	69bb      	ldr	r3, [r7, #24]
 8009cec:	f503 7343 	add.w	r3, r3, #780	; 0x30c
 8009cf0:	4618      	mov	r0, r3
 8009cf2:	f00e febc 	bl	8018a6e <sp_clear>
        return ASN_GETINT_E;
 8009cf6:	f06f 038d 	mvn.w	r3, #141	; 0x8d
 8009cfa:	e000      	b.n	8009cfe <wc_RsaPublicKeyDecodeRaw+0xb8>
    if (wc_InitRsaHw(key) != 0) {
        return BAD_STATE_E;
    }
#endif

    return 0;
 8009cfc:	2300      	movs	r3, #0
}
 8009cfe:	4618      	mov	r0, r3
 8009d00:	3710      	adds	r7, #16
 8009d02:	46bd      	mov	sp, r7
 8009d04:	bd80      	pop	{r7, pc}

08009d06 <InitDecodedCert>:

#endif /* NO_DSA */

void InitDecodedCert(DecodedCert* cert,
                     const byte* source, word32 inSz, void* heap)
{
 8009d06:	b580      	push	{r7, lr}
 8009d08:	b084      	sub	sp, #16
 8009d0a:	af00      	add	r7, sp, #0
 8009d0c:	60f8      	str	r0, [r7, #12]
 8009d0e:	60b9      	str	r1, [r7, #8]
 8009d10:	607a      	str	r2, [r7, #4]
 8009d12:	603b      	str	r3, [r7, #0]
    if (cert != NULL) {
 8009d14:	68fb      	ldr	r3, [r7, #12]
 8009d16:	2b00      	cmp	r3, #0
 8009d18:	d02a      	beq.n	8009d70 <InitDecodedCert+0x6a>
        XMEMSET(cert, 0, sizeof(DecodedCert));
 8009d1a:	f44f 725f 	mov.w	r2, #892	; 0x37c
 8009d1e:	2100      	movs	r1, #0
 8009d20:	68f8      	ldr	r0, [r7, #12]
 8009d22:	f00f fb8c 	bl	801943e <memset>

        cert->subjectCNEnc    = CTC_UTF8;
 8009d26:	68fb      	ldr	r3, [r7, #12]
 8009d28:	220c      	movs	r2, #12
 8009d2a:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84
        cert->issuer[0]       = '\0';
 8009d2e:	68fb      	ldr	r3, [r7, #12]
 8009d30:	2200      	movs	r2, #0
 8009d32:	f883 2085 	strb.w	r2, [r3, #133]	; 0x85
        cert->subject[0]      = '\0';
 8009d36:	68fb      	ldr	r3, [r7, #12]
 8009d38:	2200      	movs	r2, #0
 8009d3a:	f883 2185 	strb.w	r2, [r3, #389]	; 0x185
        cert->source          = source;  /* don't own */
 8009d3e:	68fb      	ldr	r3, [r7, #12]
 8009d40:	68ba      	ldr	r2, [r7, #8]
 8009d42:	f8c3 228c 	str.w	r2, [r3, #652]	; 0x28c
        cert->maxIdx          = inSz;    /* can't go over this index */
 8009d46:	68fb      	ldr	r3, [r7, #12]
 8009d48:	687a      	ldr	r2, [r7, #4]
 8009d4a:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
        cert->heap            = heap;
 8009d4e:	68fb      	ldr	r3, [r7, #12]
 8009d50:	683a      	ldr	r2, [r7, #0]
 8009d52:	f8c3 2298 	str.w	r2, [r3, #664]	; 0x298
        cert->maxPathLen      = WOLFSSL_MAX_PATH_LEN;
 8009d56:	68fb      	ldr	r3, [r7, #12]
 8009d58:	227f      	movs	r2, #127	; 0x7f
 8009d5a:	f883 231d 	strb.w	r2, [r3, #797]	; 0x31d
        cert->subjectOEnc     = CTC_UTF8;
        cert->subjectOUEnc    = CTC_UTF8;
    #endif /* WOLFSSL_CERT_GEN */

    #ifndef NO_CERTS
        InitSignatureCtx(&cert->sigCtx, heap, INVALID_DEVID);
 8009d5e:	68fb      	ldr	r3, [r7, #12]
 8009d60:	f503 7351 	add.w	r3, r3, #836	; 0x344
 8009d64:	f06f 0201 	mvn.w	r2, #1
 8009d68:	6839      	ldr	r1, [r7, #0]
 8009d6a:	4618      	mov	r0, r3
 8009d6c:	f001 f8f0 	bl	800af50 <InitSignatureCtx>
    #endif
    }
}
 8009d70:	bf00      	nop
 8009d72:	3710      	adds	r7, #16
 8009d74:	46bd      	mov	sp, r7
 8009d76:	bd80      	pop	{r7, pc}

08009d78 <FreeAltNames>:


void FreeAltNames(DNS_entry* altNames, void* heap)
{
 8009d78:	b580      	push	{r7, lr}
 8009d7a:	b086      	sub	sp, #24
 8009d7c:	af00      	add	r7, sp, #0
 8009d7e:	6078      	str	r0, [r7, #4]
 8009d80:	6039      	str	r1, [r7, #0]
    (void)heap;

    while (altNames) {
 8009d82:	e015      	b.n	8009db0 <FreeAltNames+0x38>
        DNS_entry* tmp = altNames->next;
 8009d84:	687b      	ldr	r3, [r7, #4]
 8009d86:	681b      	ldr	r3, [r3, #0]
 8009d88:	617b      	str	r3, [r7, #20]

        XFREE(altNames->name, heap, DYNAMIC_TYPE_ALTNAME);
 8009d8a:	687b      	ldr	r3, [r7, #4]
 8009d8c:	68db      	ldr	r3, [r3, #12]
 8009d8e:	613b      	str	r3, [r7, #16]
 8009d90:	693b      	ldr	r3, [r7, #16]
 8009d92:	2b00      	cmp	r3, #0
 8009d94:	d002      	beq.n	8009d9c <FreeAltNames+0x24>
 8009d96:	6938      	ldr	r0, [r7, #16]
 8009d98:	f005 f8ca 	bl	800ef30 <wolfSSL_Free>
        XFREE(altNames,       heap, DYNAMIC_TYPE_ALTNAME);
 8009d9c:	687b      	ldr	r3, [r7, #4]
 8009d9e:	60fb      	str	r3, [r7, #12]
 8009da0:	68fb      	ldr	r3, [r7, #12]
 8009da2:	2b00      	cmp	r3, #0
 8009da4:	d002      	beq.n	8009dac <FreeAltNames+0x34>
 8009da6:	68f8      	ldr	r0, [r7, #12]
 8009da8:	f005 f8c2 	bl	800ef30 <wolfSSL_Free>
        altNames = tmp;
 8009dac:	697b      	ldr	r3, [r7, #20]
 8009dae:	607b      	str	r3, [r7, #4]
    while (altNames) {
 8009db0:	687b      	ldr	r3, [r7, #4]
 8009db2:	2b00      	cmp	r3, #0
 8009db4:	d1e6      	bne.n	8009d84 <FreeAltNames+0xc>
    }
}
 8009db6:	bf00      	nop
 8009db8:	3718      	adds	r7, #24
 8009dba:	46bd      	mov	sp, r7
 8009dbc:	bd80      	pop	{r7, pc}

08009dbe <FreeNameSubtrees>:

#ifndef IGNORE_NAME_CONSTRAINTS

void FreeNameSubtrees(Base_entry* names, void* heap)
{
 8009dbe:	b580      	push	{r7, lr}
 8009dc0:	b086      	sub	sp, #24
 8009dc2:	af00      	add	r7, sp, #0
 8009dc4:	6078      	str	r0, [r7, #4]
 8009dc6:	6039      	str	r1, [r7, #0]
    (void)heap;

    while (names) {
 8009dc8:	e015      	b.n	8009df6 <FreeNameSubtrees+0x38>
        Base_entry* tmp = names->next;
 8009dca:	687b      	ldr	r3, [r7, #4]
 8009dcc:	681b      	ldr	r3, [r3, #0]
 8009dce:	617b      	str	r3, [r7, #20]

        XFREE(names->name, heap, DYNAMIC_TYPE_ALTNAME);
 8009dd0:	687b      	ldr	r3, [r7, #4]
 8009dd2:	685b      	ldr	r3, [r3, #4]
 8009dd4:	613b      	str	r3, [r7, #16]
 8009dd6:	693b      	ldr	r3, [r7, #16]
 8009dd8:	2b00      	cmp	r3, #0
 8009dda:	d002      	beq.n	8009de2 <FreeNameSubtrees+0x24>
 8009ddc:	6938      	ldr	r0, [r7, #16]
 8009dde:	f005 f8a7 	bl	800ef30 <wolfSSL_Free>
        XFREE(names,       heap, DYNAMIC_TYPE_ALTNAME);
 8009de2:	687b      	ldr	r3, [r7, #4]
 8009de4:	60fb      	str	r3, [r7, #12]
 8009de6:	68fb      	ldr	r3, [r7, #12]
 8009de8:	2b00      	cmp	r3, #0
 8009dea:	d002      	beq.n	8009df2 <FreeNameSubtrees+0x34>
 8009dec:	68f8      	ldr	r0, [r7, #12]
 8009dee:	f005 f89f 	bl	800ef30 <wolfSSL_Free>
        names = tmp;
 8009df2:	697b      	ldr	r3, [r7, #20]
 8009df4:	607b      	str	r3, [r7, #4]
    while (names) {
 8009df6:	687b      	ldr	r3, [r7, #4]
 8009df8:	2b00      	cmp	r3, #0
 8009dfa:	d1e6      	bne.n	8009dca <FreeNameSubtrees+0xc>
    }
}
 8009dfc:	bf00      	nop
 8009dfe:	3718      	adds	r7, #24
 8009e00:	46bd      	mov	sp, r7
 8009e02:	bd80      	pop	{r7, pc}

08009e04 <FreeDecodedCert>:

#endif /* IGNORE_NAME_CONSTRAINTS */

void FreeDecodedCert(DecodedCert* cert)
{
 8009e04:	b580      	push	{r7, lr}
 8009e06:	b084      	sub	sp, #16
 8009e08:	af00      	add	r7, sp, #0
 8009e0a:	6078      	str	r0, [r7, #4]
    if (cert == NULL)
 8009e0c:	687b      	ldr	r3, [r7, #4]
 8009e0e:	2b00      	cmp	r3, #0
 8009e10:	d06d      	beq.n	8009eee <FreeDecodedCert+0xea>
        return;
    if (cert->subjectCNStored == 1)
 8009e12:	687b      	ldr	r3, [r7, #4]
 8009e14:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 8009e18:	f003 0301 	and.w	r3, r3, #1
 8009e1c:	b2db      	uxtb	r3, r3
 8009e1e:	2b00      	cmp	r3, #0
 8009e20:	d008      	beq.n	8009e34 <FreeDecodedCert+0x30>
        XFREE(cert->subjectCN, cert->heap, DYNAMIC_TYPE_SUBJECT_CN);
 8009e22:	687b      	ldr	r3, [r7, #4]
 8009e24:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8009e26:	60fb      	str	r3, [r7, #12]
 8009e28:	68fb      	ldr	r3, [r7, #12]
 8009e2a:	2b00      	cmp	r3, #0
 8009e2c:	d002      	beq.n	8009e34 <FreeDecodedCert+0x30>
 8009e2e:	68f8      	ldr	r0, [r7, #12]
 8009e30:	f005 f87e 	bl	800ef30 <wolfSSL_Free>
    if (cert->pubKeyStored == 1)
 8009e34:	687b      	ldr	r3, [r7, #4]
 8009e36:	689b      	ldr	r3, [r3, #8]
 8009e38:	2b01      	cmp	r3, #1
 8009e3a:	d108      	bne.n	8009e4e <FreeDecodedCert+0x4a>
        XFREE((void*)cert->publicKey, cert->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8009e3c:	687b      	ldr	r3, [r7, #4]
 8009e3e:	681b      	ldr	r3, [r3, #0]
 8009e40:	60bb      	str	r3, [r7, #8]
 8009e42:	68bb      	ldr	r3, [r7, #8]
 8009e44:	2b00      	cmp	r3, #0
 8009e46:	d002      	beq.n	8009e4e <FreeDecodedCert+0x4a>
 8009e48:	68b8      	ldr	r0, [r7, #8]
 8009e4a:	f005 f871 	bl	800ef30 <wolfSSL_Free>
    if (cert->weOwnAltNames && cert->altNames)
 8009e4e:	687b      	ldr	r3, [r7, #4]
 8009e50:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 8009e54:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009e58:	b2db      	uxtb	r3, r3
 8009e5a:	2b00      	cmp	r3, #0
 8009e5c:	d00c      	beq.n	8009e78 <FreeDecodedCert+0x74>
 8009e5e:	687b      	ldr	r3, [r7, #4]
 8009e60:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009e62:	2b00      	cmp	r3, #0
 8009e64:	d008      	beq.n	8009e78 <FreeDecodedCert+0x74>
        FreeAltNames(cert->altNames, cert->heap);
 8009e66:	687b      	ldr	r3, [r7, #4]
 8009e68:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009e6a:	687b      	ldr	r3, [r7, #4]
 8009e6c:	f8d3 3298 	ldr.w	r3, [r3, #664]	; 0x298
 8009e70:	4619      	mov	r1, r3
 8009e72:	4610      	mov	r0, r2
 8009e74:	f7ff ff80 	bl	8009d78 <FreeAltNames>
#ifndef IGNORE_NAME_CONSTRAINTS
    if (cert->altEmailNames)
 8009e78:	687b      	ldr	r3, [r7, #4]
 8009e7a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009e7c:	2b00      	cmp	r3, #0
 8009e7e:	d008      	beq.n	8009e92 <FreeDecodedCert+0x8e>
        FreeAltNames(cert->altEmailNames, cert->heap);
 8009e80:	687b      	ldr	r3, [r7, #4]
 8009e82:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8009e84:	687b      	ldr	r3, [r7, #4]
 8009e86:	f8d3 3298 	ldr.w	r3, [r3, #664]	; 0x298
 8009e8a:	4619      	mov	r1, r3
 8009e8c:	4610      	mov	r0, r2
 8009e8e:	f7ff ff73 	bl	8009d78 <FreeAltNames>
    if (cert->altDirNames)
 8009e92:	687b      	ldr	r3, [r7, #4]
 8009e94:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009e96:	2b00      	cmp	r3, #0
 8009e98:	d008      	beq.n	8009eac <FreeDecodedCert+0xa8>
        FreeAltNames(cert->altDirNames, cert->heap);
 8009e9a:	687b      	ldr	r3, [r7, #4]
 8009e9c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8009e9e:	687b      	ldr	r3, [r7, #4]
 8009ea0:	f8d3 3298 	ldr.w	r3, [r3, #664]	; 0x298
 8009ea4:	4619      	mov	r1, r3
 8009ea6:	4610      	mov	r0, r2
 8009ea8:	f7ff ff66 	bl	8009d78 <FreeAltNames>
    if (cert->permittedNames)
 8009eac:	687b      	ldr	r3, [r7, #4]
 8009eae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009eb0:	2b00      	cmp	r3, #0
 8009eb2:	d008      	beq.n	8009ec6 <FreeDecodedCert+0xc2>
        FreeNameSubtrees(cert->permittedNames, cert->heap);
 8009eb4:	687b      	ldr	r3, [r7, #4]
 8009eb6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009eb8:	687b      	ldr	r3, [r7, #4]
 8009eba:	f8d3 3298 	ldr.w	r3, [r3, #664]	; 0x298
 8009ebe:	4619      	mov	r1, r3
 8009ec0:	4610      	mov	r0, r2
 8009ec2:	f7ff ff7c 	bl	8009dbe <FreeNameSubtrees>
    if (cert->excludedNames)
 8009ec6:	687b      	ldr	r3, [r7, #4]
 8009ec8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009eca:	2b00      	cmp	r3, #0
 8009ecc:	d008      	beq.n	8009ee0 <FreeDecodedCert+0xdc>
        FreeNameSubtrees(cert->excludedNames, cert->heap);
 8009ece:	687b      	ldr	r3, [r7, #4]
 8009ed0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8009ed2:	687b      	ldr	r3, [r7, #4]
 8009ed4:	f8d3 3298 	ldr.w	r3, [r3, #664]	; 0x298
 8009ed8:	4619      	mov	r1, r3
 8009eda:	4610      	mov	r0, r2
 8009edc:	f7ff ff6f 	bl	8009dbe <FreeNameSubtrees>
#ifdef WOLFSSL_RENESAS_TSIP_TLS
    if (cert->tsip_encRsaKeyIdx != NULL)
        XFREE(cert->tsip_encRsaKeyIdx, cert->heap, DYNAMIC_TYPE_RSA);
#endif
#ifndef NO_CERTS
    FreeSignatureCtx(&cert->sigCtx);
 8009ee0:	687b      	ldr	r3, [r7, #4]
 8009ee2:	f503 7351 	add.w	r3, r3, #836	; 0x344
 8009ee6:	4618      	mov	r0, r3
 8009ee8:	f001 f84a 	bl	800af80 <FreeSignatureCtx>
 8009eec:	e000      	b.n	8009ef0 <FreeDecodedCert+0xec>
        return;
 8009eee:	bf00      	nop
#endif
}
 8009ef0:	3710      	adds	r7, #16
 8009ef2:	46bd      	mov	sp, r7
 8009ef4:	bd80      	pop	{r7, pc}

08009ef6 <GetCertHeader>:

static int GetCertHeader(DecodedCert* cert)
{
 8009ef6:	b590      	push	{r4, r7, lr}
 8009ef8:	b087      	sub	sp, #28
 8009efa:	af02      	add	r7, sp, #8
 8009efc:	6078      	str	r0, [r7, #4]
    int ret = 0, len;
 8009efe:	2300      	movs	r3, #0
 8009f00:	60fb      	str	r3, [r7, #12]

    if (GetSequence(cert->source, &cert->srcIdx, &len, cert->maxIdx) < 0)
 8009f02:	687b      	ldr	r3, [r7, #4]
 8009f04:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 8009f08:	687b      	ldr	r3, [r7, #4]
 8009f0a:	f503 7124 	add.w	r1, r3, #656	; 0x290
 8009f0e:	687b      	ldr	r3, [r7, #4]
 8009f10:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 8009f14:	f107 0208 	add.w	r2, r7, #8
 8009f18:	f7fe fd3a 	bl	8008990 <GetSequence>
 8009f1c:	4603      	mov	r3, r0
 8009f1e:	2b00      	cmp	r3, #0
 8009f20:	da02      	bge.n	8009f28 <GetCertHeader+0x32>
        return ASN_PARSE_E;
 8009f22:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8009f26:	e05c      	b.n	8009fe2 <GetCertHeader+0xec>

    /* Reset the max index for the size indicated in the outer wrapper. */
    cert->maxIdx = len + cert->srcIdx;
 8009f28:	687b      	ldr	r3, [r7, #4]
 8009f2a:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 8009f2e:	68ba      	ldr	r2, [r7, #8]
 8009f30:	441a      	add	r2, r3
 8009f32:	687b      	ldr	r3, [r7, #4]
 8009f34:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
    cert->certBegin = cert->srcIdx;
 8009f38:	687b      	ldr	r3, [r7, #4]
 8009f3a:	f8d3 2290 	ldr.w	r2, [r3, #656]	; 0x290
 8009f3e:	687b      	ldr	r3, [r7, #4]
 8009f40:	60da      	str	r2, [r3, #12]

    if (GetSequence(cert->source, &cert->srcIdx, &len, cert->maxIdx) < 0)
 8009f42:	687b      	ldr	r3, [r7, #4]
 8009f44:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 8009f48:	687b      	ldr	r3, [r7, #4]
 8009f4a:	f503 7124 	add.w	r1, r3, #656	; 0x290
 8009f4e:	687b      	ldr	r3, [r7, #4]
 8009f50:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 8009f54:	f107 0208 	add.w	r2, r7, #8
 8009f58:	f7fe fd1a 	bl	8008990 <GetSequence>
 8009f5c:	4603      	mov	r3, r0
 8009f5e:	2b00      	cmp	r3, #0
 8009f60:	da02      	bge.n	8009f68 <GetCertHeader+0x72>
        return ASN_PARSE_E;
 8009f62:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8009f66:	e03c      	b.n	8009fe2 <GetCertHeader+0xec>

    cert->sigIndex = len + cert->srcIdx;
 8009f68:	687b      	ldr	r3, [r7, #4]
 8009f6a:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 8009f6e:	68ba      	ldr	r2, [r7, #8]
 8009f70:	441a      	add	r2, r3
 8009f72:	687b      	ldr	r3, [r7, #4]
 8009f74:	611a      	str	r2, [r3, #16]
    if (cert->sigIndex > cert->maxIdx)
 8009f76:	687b      	ldr	r3, [r7, #4]
 8009f78:	691a      	ldr	r2, [r3, #16]
 8009f7a:	687b      	ldr	r3, [r7, #4]
 8009f7c:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 8009f80:	429a      	cmp	r2, r3
 8009f82:	d902      	bls.n	8009f8a <GetCertHeader+0x94>
        return ASN_PARSE_E;
 8009f84:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8009f88:	e02b      	b.n	8009fe2 <GetCertHeader+0xec>

    if (GetExplicitVersion(cert->source, &cert->srcIdx, &cert->version,
 8009f8a:	687b      	ldr	r3, [r7, #4]
 8009f8c:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 8009f90:	687b      	ldr	r3, [r7, #4]
 8009f92:	f503 7124 	add.w	r1, r3, #656	; 0x290
 8009f96:	687b      	ldr	r3, [r7, #4]
 8009f98:	f103 0220 	add.w	r2, r3, #32
 8009f9c:	687b      	ldr	r3, [r7, #4]
 8009f9e:	691b      	ldr	r3, [r3, #16]
 8009fa0:	f7fe fe91 	bl	8008cc6 <GetExplicitVersion>
 8009fa4:	4603      	mov	r3, r0
 8009fa6:	2b00      	cmp	r3, #0
 8009fa8:	da02      	bge.n	8009fb0 <GetCertHeader+0xba>
                                                            cert->sigIndex) < 0)
        return ASN_PARSE_E;
 8009faa:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8009fae:	e018      	b.n	8009fe2 <GetCertHeader+0xec>

    if (GetSerialNumber(cert->source, &cert->srcIdx, cert->serial,
 8009fb0:	687b      	ldr	r3, [r7, #4]
 8009fb2:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 8009fb6:	687b      	ldr	r3, [r7, #4]
 8009fb8:	f503 7124 	add.w	r1, r3, #656	; 0x290
 8009fbc:	687b      	ldr	r3, [r7, #4]
 8009fbe:	f503 7227 	add.w	r2, r3, #668	; 0x29c
 8009fc2:	687b      	ldr	r3, [r7, #4]
 8009fc4:	f503 742f 	add.w	r4, r3, #700	; 0x2bc
 8009fc8:	687b      	ldr	r3, [r7, #4]
 8009fca:	691b      	ldr	r3, [r3, #16]
 8009fcc:	9300      	str	r3, [sp, #0]
 8009fce:	4623      	mov	r3, r4
 8009fd0:	f003 f81c 	bl	800d00c <GetSerialNumber>
 8009fd4:	4603      	mov	r3, r0
 8009fd6:	2b00      	cmp	r3, #0
 8009fd8:	da02      	bge.n	8009fe0 <GetCertHeader+0xea>
                                           &cert->serialSz, cert->sigIndex) < 0)
        return ASN_PARSE_E;
 8009fda:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8009fde:	e000      	b.n	8009fe2 <GetCertHeader+0xec>

    return ret;
 8009fe0:	68fb      	ldr	r3, [r7, #12]
}
 8009fe2:	4618      	mov	r0, r3
 8009fe4:	3714      	adds	r7, #20
 8009fe6:	46bd      	mov	sp, r7
 8009fe8:	bd90      	pop	{r4, r7, pc}

08009fea <StoreRsaKey>:

#if !defined(NO_RSA)
/* Store Rsa Key, may save later, Dsa could use in future */
static int StoreRsaKey(DecodedCert* cert, word32 bitStringEnd)
{
 8009fea:	b580      	push	{r7, lr}
 8009fec:	b084      	sub	sp, #16
 8009fee:	af00      	add	r7, sp, #0
 8009ff0:	6078      	str	r0, [r7, #4]
 8009ff2:	6039      	str	r1, [r7, #0]
    int    length;
    word32 recvd = cert->srcIdx;
 8009ff4:	687b      	ldr	r3, [r7, #4]
 8009ff6:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 8009ffa:	60fb      	str	r3, [r7, #12]

    if (GetSequence(cert->source, &cert->srcIdx, &length, bitStringEnd) < 0)
 8009ffc:	687b      	ldr	r3, [r7, #4]
 8009ffe:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a002:	687b      	ldr	r3, [r7, #4]
 800a004:	f503 7124 	add.w	r1, r3, #656	; 0x290
 800a008:	f107 0208 	add.w	r2, r7, #8
 800a00c:	683b      	ldr	r3, [r7, #0]
 800a00e:	f7fe fcbf 	bl	8008990 <GetSequence>
 800a012:	4603      	mov	r3, r0
 800a014:	2b00      	cmp	r3, #0
 800a016:	da02      	bge.n	800a01e <StoreRsaKey+0x34>
        return ASN_PARSE_E;
 800a018:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800a01c:	e02d      	b.n	800a07a <StoreRsaKey+0x90>

    recvd = cert->srcIdx - recvd;
 800a01e:	687b      	ldr	r3, [r7, #4]
 800a020:	f8d3 2290 	ldr.w	r2, [r3, #656]	; 0x290
 800a024:	68fb      	ldr	r3, [r7, #12]
 800a026:	1ad3      	subs	r3, r2, r3
 800a028:	60fb      	str	r3, [r7, #12]
    length += recvd;
 800a02a:	68bb      	ldr	r3, [r7, #8]
 800a02c:	461a      	mov	r2, r3
 800a02e:	68fb      	ldr	r3, [r7, #12]
 800a030:	4413      	add	r3, r2
 800a032:	60bb      	str	r3, [r7, #8]

    while (recvd--)
 800a034:	e006      	b.n	800a044 <StoreRsaKey+0x5a>
       cert->srcIdx--;
 800a036:	687b      	ldr	r3, [r7, #4]
 800a038:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a03c:	1e5a      	subs	r2, r3, #1
 800a03e:	687b      	ldr	r3, [r7, #4]
 800a040:	f8c3 2290 	str.w	r2, [r3, #656]	; 0x290
    while (recvd--)
 800a044:	68fb      	ldr	r3, [r7, #12]
 800a046:	1e5a      	subs	r2, r3, #1
 800a048:	60fa      	str	r2, [r7, #12]
 800a04a:	2b00      	cmp	r3, #0
 800a04c:	d1f3      	bne.n	800a036 <StoreRsaKey+0x4c>
#if defined(WOLFSSL_RENESAS_TSIP)
    cert->sigCtx.pubkey_n_start = cert->sigCtx.pubkey_e_start = cert->srcIdx;
#endif
    cert->pubKeySize = length;
 800a04e:	68bb      	ldr	r3, [r7, #8]
 800a050:	461a      	mov	r2, r3
 800a052:	687b      	ldr	r3, [r7, #4]
 800a054:	605a      	str	r2, [r3, #4]
    cert->publicKey = cert->source + cert->srcIdx;
 800a056:	687b      	ldr	r3, [r7, #4]
 800a058:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 800a05c:	687b      	ldr	r3, [r7, #4]
 800a05e:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a062:	441a      	add	r2, r3
 800a064:	687b      	ldr	r3, [r7, #4]
 800a066:	601a      	str	r2, [r3, #0]
    cert->srcIdx += length;
 800a068:	687b      	ldr	r3, [r7, #4]
 800a06a:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a06e:	68ba      	ldr	r2, [r7, #8]
 800a070:	441a      	add	r2, r3
 800a072:	687b      	ldr	r3, [r7, #4]
 800a074:	f8c3 2290 	str.w	r2, [r3, #656]	; 0x290

    return 0;
 800a078:	2300      	movs	r3, #0
}
 800a07a:	4618      	mov	r0, r3
 800a07c:	3710      	adds	r7, #16
 800a07e:	46bd      	mov	sp, r7
 800a080:	bd80      	pop	{r7, pc}

0800a082 <CheckCurve>:

#ifdef HAVE_ECC

    /* return 0 on success if the ECC curve oid sum is supported */
    static int CheckCurve(word32 oid)
    {
 800a082:	b580      	push	{r7, lr}
 800a084:	b084      	sub	sp, #16
 800a086:	af00      	add	r7, sp, #0
 800a088:	6078      	str	r0, [r7, #4]
        int ret = 0;
 800a08a:	2300      	movs	r3, #0
 800a08c:	60fb      	str	r3, [r7, #12]
        word32 oidSz = 0;
 800a08e:	2300      	movs	r3, #0
 800a090:	60bb      	str	r3, [r7, #8]

        ret = wc_ecc_get_oid(oid, NULL, &oidSz);
 800a092:	f107 0308 	add.w	r3, r7, #8
 800a096:	461a      	mov	r2, r3
 800a098:	2100      	movs	r1, #0
 800a09a:	6878      	ldr	r0, [r7, #4]
 800a09c:	f004 fe14 	bl	800ecc8 <wc_ecc_get_oid>
 800a0a0:	60f8      	str	r0, [r7, #12]
        if (ret < 0 || oidSz == 0) {
 800a0a2:	68fb      	ldr	r3, [r7, #12]
 800a0a4:	2b00      	cmp	r3, #0
 800a0a6:	db02      	blt.n	800a0ae <CheckCurve+0x2c>
 800a0a8:	68bb      	ldr	r3, [r7, #8]
 800a0aa:	2b00      	cmp	r3, #0
 800a0ac:	d102      	bne.n	800a0b4 <CheckCurve+0x32>
            WOLFSSL_MSG("CheckCurve not found");
            ret = ALGO_ID_E;
 800a0ae:	f06f 0384 	mvn.w	r3, #132	; 0x84
 800a0b2:	60fb      	str	r3, [r7, #12]
        }

        return ret;
 800a0b4:	68fb      	ldr	r3, [r7, #12]
    }
 800a0b6:	4618      	mov	r0, r3
 800a0b8:	3710      	adds	r7, #16
 800a0ba:	46bd      	mov	sp, r7
 800a0bc:	bd80      	pop	{r7, pc}

0800a0be <GetKey>:

#endif /* HAVE_ECC */

static int GetKey(DecodedCert* cert)
{
 800a0be:	b590      	push	{r4, r7, lr}
 800a0c0:	b08f      	sub	sp, #60	; 0x3c
 800a0c2:	af02      	add	r7, sp, #8
 800a0c4:	6078      	str	r0, [r7, #4]
    int length;
#ifndef NO_DSA
    int tmpLen;
#endif
#if defined(HAVE_ECC) || defined(HAVE_NTRU) || !defined(NO_DSA)
    int tmpIdx = cert->srcIdx;
 800a0c6:	687b      	ldr	r3, [r7, #4]
 800a0c8:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a0cc:	62fb      	str	r3, [r7, #44]	; 0x2c
#endif

    if (GetSequence(cert->source, &cert->srcIdx, &length, cert->maxIdx) < 0)
 800a0ce:	687b      	ldr	r3, [r7, #4]
 800a0d0:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a0d4:	687b      	ldr	r3, [r7, #4]
 800a0d6:	f503 7124 	add.w	r1, r3, #656	; 0x290
 800a0da:	687b      	ldr	r3, [r7, #4]
 800a0dc:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 800a0e0:	f107 0218 	add.w	r2, r7, #24
 800a0e4:	f7fe fc54 	bl	8008990 <GetSequence>
 800a0e8:	4603      	mov	r3, r0
 800a0ea:	2b00      	cmp	r3, #0
 800a0ec:	da02      	bge.n	800a0f4 <GetKey+0x36>
        return ASN_PARSE_E;
 800a0ee:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800a0f2:	e0cc      	b.n	800a28e <GetKey+0x1d0>

#ifndef NO_DSA
    tmpLen = length + 4;
#endif

    if (GetAlgoId(cert->source, &cert->srcIdx,
 800a0f4:	687b      	ldr	r3, [r7, #4]
 800a0f6:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a0fa:	687b      	ldr	r3, [r7, #4]
 800a0fc:	f503 7124 	add.w	r1, r3, #656	; 0x290
 800a100:	687b      	ldr	r3, [r7, #4]
 800a102:	f103 021c 	add.w	r2, r3, #28
 800a106:	687b      	ldr	r3, [r7, #4]
 800a108:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 800a10c:	9300      	str	r3, [sp, #0]
 800a10e:	2302      	movs	r3, #2
 800a110:	f7ff faee 	bl	80096f0 <GetAlgoId>
 800a114:	4603      	mov	r3, r0
 800a116:	2b00      	cmp	r3, #0
 800a118:	da02      	bge.n	800a120 <GetKey+0x62>
                  &cert->keyOID, oidKeyType, cert->maxIdx) < 0)
        return ASN_PARSE_E;
 800a11a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800a11e:	e0b6      	b.n	800a28e <GetKey+0x1d0>

    switch (cert->keyOID) {
 800a120:	687b      	ldr	r3, [r7, #4]
 800a122:	69db      	ldr	r3, [r3, #28]
 800a124:	f240 2206 	movw	r2, #518	; 0x206
 800a128:	4293      	cmp	r3, r2
 800a12a:	d027      	beq.n	800a17c <GetKey+0xbe>
 800a12c:	f240 2285 	movw	r2, #645	; 0x285
 800a130:	4293      	cmp	r3, r2
 800a132:	f040 80aa 	bne.w	800a28a <GetKey+0x1cc>
   #ifndef NO_RSA
        case RSAk:
        {
            int ret;

            ret = CheckBitString(cert->source, &cert->srcIdx, &length,
 800a136:	687b      	ldr	r3, [r7, #4]
 800a138:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a13c:	687b      	ldr	r3, [r7, #4]
 800a13e:	f503 7124 	add.w	r1, r3, #656	; 0x290
 800a142:	687b      	ldr	r3, [r7, #4]
 800a144:	f8d3 4294 	ldr.w	r4, [r3, #660]	; 0x294
 800a148:	f107 0218 	add.w	r2, r7, #24
 800a14c:	2300      	movs	r3, #0
 800a14e:	9301      	str	r3, [sp, #4]
 800a150:	2301      	movs	r3, #1
 800a152:	9300      	str	r3, [sp, #0]
 800a154:	4623      	mov	r3, r4
 800a156:	f7fe fe32 	bl	8008dbe <CheckBitString>
 800a15a:	62b8      	str	r0, [r7, #40]	; 0x28
                                 cert->maxIdx, 1, NULL);
            if (ret != 0)
 800a15c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a15e:	2b00      	cmp	r3, #0
 800a160:	d001      	beq.n	800a166 <GetKey+0xa8>
                return ret;
 800a162:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a164:	e093      	b.n	800a28e <GetKey+0x1d0>
                        cert->subjectKeyHash);
                if (ret != 0)
                    return ret;
            #endif

            return StoreRsaKey(cert, cert->srcIdx + length);
 800a166:	687b      	ldr	r3, [r7, #4]
 800a168:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a16c:	69ba      	ldr	r2, [r7, #24]
 800a16e:	4413      	add	r3, r2
 800a170:	4619      	mov	r1, r3
 800a172:	6878      	ldr	r0, [r7, #4]
 800a174:	f7ff ff39 	bl	8009fea <StoreRsaKey>
 800a178:	4603      	mov	r3, r0
 800a17a:	e088      	b.n	800a28e <GetKey+0x1d0>
    #ifdef HAVE_ECC
        case ECDSAk:
        {
            int ret;
            byte seq[5];
            int pubLen = length + 1 + SetLength(length, seq);
 800a17c:	69bb      	ldr	r3, [r7, #24]
 800a17e:	461a      	mov	r2, r3
 800a180:	f107 0310 	add.w	r3, r7, #16
 800a184:	4619      	mov	r1, r3
 800a186:	4610      	mov	r0, r2
 800a188:	f000 fd5b 	bl	800ac42 <SetLength>
 800a18c:	4602      	mov	r2, r0
 800a18e:	69bb      	ldr	r3, [r7, #24]
 800a190:	4413      	add	r3, r2
 800a192:	3301      	adds	r3, #1
 800a194:	627b      	str	r3, [r7, #36]	; 0x24
            word32 localIdx;
            byte* publicKey;
            byte  tag;

            localIdx = cert->srcIdx;
 800a196:	687b      	ldr	r3, [r7, #4]
 800a198:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a19c:	60fb      	str	r3, [r7, #12]
            if (GetASNTag(cert->source, &localIdx, &tag, cert->maxIdx) < 0)
 800a19e:	687b      	ldr	r3, [r7, #4]
 800a1a0:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a1a4:	687b      	ldr	r3, [r7, #4]
 800a1a6:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 800a1aa:	f107 020b 	add.w	r2, r7, #11
 800a1ae:	f107 010c 	add.w	r1, r7, #12
 800a1b2:	f7fe fb37 	bl	8008824 <GetASNTag>
 800a1b6:	4603      	mov	r3, r0
 800a1b8:	2b00      	cmp	r3, #0
 800a1ba:	da02      	bge.n	800a1c2 <GetKey+0x104>
                return ASN_PARSE_E;
 800a1bc:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800a1c0:	e065      	b.n	800a28e <GetKey+0x1d0>

            if (tag != (ASN_SEQUENCE | ASN_CONSTRUCTED)) {
 800a1c2:	7afb      	ldrb	r3, [r7, #11]
 800a1c4:	2b30      	cmp	r3, #48	; 0x30
 800a1c6:	d039      	beq.n	800a23c <GetKey+0x17e>
                if (GetObjectId(cert->source, &cert->srcIdx,
 800a1c8:	687b      	ldr	r3, [r7, #4]
 800a1ca:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a1ce:	687b      	ldr	r3, [r7, #4]
 800a1d0:	f503 7124 	add.w	r1, r3, #656	; 0x290
 800a1d4:	687b      	ldr	r3, [r7, #4]
 800a1d6:	f503 7249 	add.w	r2, r3, #804	; 0x324
 800a1da:	687b      	ldr	r3, [r7, #4]
 800a1dc:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 800a1e0:	9300      	str	r3, [sp, #0]
 800a1e2:	2303      	movs	r3, #3
 800a1e4:	f7ff f9fe 	bl	80095e4 <GetObjectId>
 800a1e8:	4603      	mov	r3, r0
 800a1ea:	2b00      	cmp	r3, #0
 800a1ec:	da02      	bge.n	800a1f4 <GetKey+0x136>
                            &cert->pkCurveOID, oidCurveType, cert->maxIdx) < 0)
                    return ASN_PARSE_E;
 800a1ee:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800a1f2:	e04c      	b.n	800a28e <GetKey+0x1d0>

                if (CheckCurve(cert->pkCurveOID) < 0)
 800a1f4:	687b      	ldr	r3, [r7, #4]
 800a1f6:	f8d3 3324 	ldr.w	r3, [r3, #804]	; 0x324
 800a1fa:	4618      	mov	r0, r3
 800a1fc:	f7ff ff41 	bl	800a082 <CheckCurve>
 800a200:	4603      	mov	r3, r0
 800a202:	2b00      	cmp	r3, #0
 800a204:	da02      	bge.n	800a20c <GetKey+0x14e>
                    return ECC_CURVE_OID_E;
 800a206:	f06f 03ab 	mvn.w	r3, #171	; 0xab
 800a20a:	e040      	b.n	800a28e <GetKey+0x1d0>

                /* key header */
                ret = CheckBitString(cert->source, &cert->srcIdx, &length,
 800a20c:	687b      	ldr	r3, [r7, #4]
 800a20e:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a212:	687b      	ldr	r3, [r7, #4]
 800a214:	f503 7124 	add.w	r1, r3, #656	; 0x290
 800a218:	687b      	ldr	r3, [r7, #4]
 800a21a:	f8d3 4294 	ldr.w	r4, [r3, #660]	; 0x294
 800a21e:	f107 0218 	add.w	r2, r7, #24
 800a222:	2300      	movs	r3, #0
 800a224:	9301      	str	r3, [sp, #4]
 800a226:	2301      	movs	r3, #1
 800a228:	9300      	str	r3, [sp, #0]
 800a22a:	4623      	mov	r3, r4
 800a22c:	f7fe fdc7 	bl	8008dbe <CheckBitString>
 800a230:	6238      	str	r0, [r7, #32]
                                                         cert->maxIdx, 1, NULL);
                if (ret != 0)
 800a232:	6a3b      	ldr	r3, [r7, #32]
 800a234:	2b00      	cmp	r3, #0
 800a236:	d001      	beq.n	800a23c <GetKey+0x17e>
                    return ret;
 800a238:	6a3b      	ldr	r3, [r7, #32]
 800a23a:	e028      	b.n	800a28e <GetKey+0x1d0>
                if (ret != 0)
                    return ret;
            #endif
            }

            publicKey = (byte*)XMALLOC(pubLen, cert->heap,
 800a23c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a23e:	4618      	mov	r0, r3
 800a240:	f004 fe5a 	bl	800eef8 <wolfSSL_Malloc>
 800a244:	61f8      	str	r0, [r7, #28]
                                       DYNAMIC_TYPE_PUBLIC_KEY);
            if (publicKey == NULL)
 800a246:	69fb      	ldr	r3, [r7, #28]
 800a248:	2b00      	cmp	r3, #0
 800a24a:	d102      	bne.n	800a252 <GetKey+0x194>
                return MEMORY_E;
 800a24c:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800a250:	e01d      	b.n	800a28e <GetKey+0x1d0>
            XMEMCPY(publicKey, &cert->source[tmpIdx], pubLen);
 800a252:	687b      	ldr	r3, [r7, #4]
 800a254:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 800a258:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a25a:	4413      	add	r3, r2
 800a25c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800a25e:	4619      	mov	r1, r3
 800a260:	69f8      	ldr	r0, [r7, #28]
 800a262:	f00f f8c8 	bl	80193f6 <memcpy>
            cert->publicKey = publicKey;
 800a266:	687b      	ldr	r3, [r7, #4]
 800a268:	69fa      	ldr	r2, [r7, #28]
 800a26a:	601a      	str	r2, [r3, #0]
            cert->pubKeyStored = 1;
 800a26c:	687b      	ldr	r3, [r7, #4]
 800a26e:	2201      	movs	r2, #1
 800a270:	609a      	str	r2, [r3, #8]
            cert->pubKeySize   = pubLen;
 800a272:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800a274:	687b      	ldr	r3, [r7, #4]
 800a276:	605a      	str	r2, [r3, #4]

            cert->srcIdx = tmpIdx + pubLen;
 800a278:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800a27a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a27c:	4413      	add	r3, r2
 800a27e:	461a      	mov	r2, r3
 800a280:	687b      	ldr	r3, [r7, #4]
 800a282:	f8c3 2290 	str.w	r2, [r3, #656]	; 0x290

            return 0;
 800a286:	2300      	movs	r3, #0
 800a288:	e001      	b.n	800a28e <GetKey+0x1d0>
            return 0;
        }
    #endif /* NO_DSA */
        default:
            WOLFSSL_MSG("Unknown or not compiled in key OID");
            return ASN_UNKNOWN_OID_E;
 800a28a:	f06f 0393 	mvn.w	r3, #147	; 0x93
    }
}
 800a28e:	4618      	mov	r0, r3
 800a290:	3734      	adds	r7, #52	; 0x34
 800a292:	46bd      	mov	sp, r7
 800a294:	bd90      	pop	{r4, r7, pc}

0800a296 <CalcHashId>:
}
#endif

/* Routine for calculating hashId */
int CalcHashId(const byte* data, word32 len, byte* hash)
{
 800a296:	b580      	push	{r7, lr}
 800a298:	b086      	sub	sp, #24
 800a29a:	af00      	add	r7, sp, #0
 800a29c:	60f8      	str	r0, [r7, #12]
 800a29e:	60b9      	str	r1, [r7, #8]
 800a2a0:	607a      	str	r2, [r7, #4]
    int ret;

#if defined(NO_SHA) && !defined(NO_SHA256)
    ret = wc_Sha256Hash(data, len, hash);
 800a2a2:	687a      	ldr	r2, [r7, #4]
 800a2a4:	68b9      	ldr	r1, [r7, #8]
 800a2a6:	68f8      	ldr	r0, [r7, #12]
 800a2a8:	f004 fdea 	bl	800ee80 <wc_Sha256Hash>
 800a2ac:	6178      	str	r0, [r7, #20]
    ret = wc_ShaHash(data, len, hash);
#else
    ret = NOT_COMPILED_IN;
#endif

    return ret;
 800a2ae:	697b      	ldr	r3, [r7, #20]
}
 800a2b0:	4618      	mov	r0, r3
 800a2b2:	3718      	adds	r7, #24
 800a2b4:	46bd      	mov	sp, r7
 800a2b6:	bd80      	pop	{r7, pc}

0800a2b8 <GetName>:

/* process NAME, either issuer or subject
 * returns 0 on success and negative values on fail */
int GetName(DecodedCert* cert, int nameType, int maxIdx)
{
 800a2b8:	b5b0      	push	{r4, r5, r7, lr}
 800a2ba:	b098      	sub	sp, #96	; 0x60
 800a2bc:	af02      	add	r7, sp, #8
 800a2be:	60f8      	str	r0, [r7, #12]
 800a2c0:	60b9      	str	r1, [r7, #8]
 800a2c2:	607a      	str	r2, [r7, #4]
    int    length;  /* length of all distinguished names */
    int    dummy;
    int    ret;
    char*  full;
    byte*  hash;
    word32 idx, localIdx = 0;
 800a2c4:	2300      	movs	r3, #0
 800a2c6:	627b      	str	r3, [r7, #36]	; 0x24
    WOLFSSL_X509_NAME* dName;
#endif /* OPENSSL_EXTRA */

    WOLFSSL_MSG("Getting Cert Name");

    if (nameType == ISSUER) {
 800a2c8:	68bb      	ldr	r3, [r7, #8]
 800a2ca:	2b00      	cmp	r3, #0
 800a2cc:	d106      	bne.n	800a2dc <GetName+0x24>
        full = cert->issuer;
 800a2ce:	68fb      	ldr	r3, [r7, #12]
 800a2d0:	3385      	adds	r3, #133	; 0x85
 800a2d2:	657b      	str	r3, [r7, #84]	; 0x54
        hash = cert->issuerHash;
 800a2d4:	68fb      	ldr	r3, [r7, #12]
 800a2d6:	3358      	adds	r3, #88	; 0x58
 800a2d8:	653b      	str	r3, [r7, #80]	; 0x50
 800a2da:	e006      	b.n	800a2ea <GetName+0x32>
    }
    else {
        full = cert->subject;
 800a2dc:	68fb      	ldr	r3, [r7, #12]
 800a2de:	f203 1385 	addw	r3, r3, #389	; 0x185
 800a2e2:	657b      	str	r3, [r7, #84]	; 0x54
        hash = cert->subjectHash;
 800a2e4:	68fb      	ldr	r3, [r7, #12]
 800a2e6:	3338      	adds	r3, #56	; 0x38
 800a2e8:	653b      	str	r3, [r7, #80]	; 0x50
    }

    if (cert->srcIdx >= (word32)maxIdx) {
 800a2ea:	68fb      	ldr	r3, [r7, #12]
 800a2ec:	f8d3 2290 	ldr.w	r2, [r3, #656]	; 0x290
 800a2f0:	687b      	ldr	r3, [r7, #4]
 800a2f2:	429a      	cmp	r2, r3
 800a2f4:	d302      	bcc.n	800a2fc <GetName+0x44>
        return BUFFER_E;
 800a2f6:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800a2fa:	e251      	b.n	800a7a0 <GetName+0x4e8>
    }

    localIdx = cert->srcIdx;
 800a2fc:	68fb      	ldr	r3, [r7, #12]
 800a2fe:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a302:	627b      	str	r3, [r7, #36]	; 0x24
    if (GetASNTag(cert->source, &localIdx, &tag, maxIdx) < 0) {
 800a304:	68fb      	ldr	r3, [r7, #12]
 800a306:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a30a:	687b      	ldr	r3, [r7, #4]
 800a30c:	f107 0223 	add.w	r2, r7, #35	; 0x23
 800a310:	f107 0124 	add.w	r1, r7, #36	; 0x24
 800a314:	f7fe fa86 	bl	8008824 <GetASNTag>
 800a318:	4603      	mov	r3, r0
 800a31a:	2b00      	cmp	r3, #0
 800a31c:	da02      	bge.n	800a324 <GetName+0x6c>
        return ASN_PARSE_E;
 800a31e:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800a322:	e23d      	b.n	800a7a0 <GetName+0x4e8>
    }

    if (tag == ASN_OBJECT_ID) {
 800a324:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800a328:	2b06      	cmp	r3, #6
 800a32a:	d10f      	bne.n	800a34c <GetName+0x94>
        WOLFSSL_MSG("Trying optional prefix...");

        if (SkipObjectId(cert->source, &cert->srcIdx, maxIdx) < 0)
 800a32c:	68fb      	ldr	r3, [r7, #12]
 800a32e:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a332:	68fb      	ldr	r3, [r7, #12]
 800a334:	f503 7324 	add.w	r3, r3, #656	; 0x290
 800a338:	687a      	ldr	r2, [r7, #4]
 800a33a:	4619      	mov	r1, r3
 800a33c:	f7ff f9b5 	bl	80096aa <SkipObjectId>
 800a340:	4603      	mov	r3, r0
 800a342:	2b00      	cmp	r3, #0
 800a344:	da02      	bge.n	800a34c <GetName+0x94>
            return ASN_PARSE_E;
 800a346:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800a34a:	e229      	b.n	800a7a0 <GetName+0x4e8>
    }

    /* For OCSP, RFC2560 section 4.1.1 states the issuer hash should be
     * calculated over the entire DER encoding of the Name field, including
     * the tag and length. */
    idx = cert->srcIdx;
 800a34c:	68fb      	ldr	r3, [r7, #12]
 800a34e:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a352:	64fb      	str	r3, [r7, #76]	; 0x4c
    if (GetSequence(cert->source, &cert->srcIdx, &length, maxIdx) < 0)
 800a354:	68fb      	ldr	r3, [r7, #12]
 800a356:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a35a:	68fb      	ldr	r3, [r7, #12]
 800a35c:	f503 7124 	add.w	r1, r3, #656	; 0x290
 800a360:	687b      	ldr	r3, [r7, #4]
 800a362:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 800a366:	f7fe fb13 	bl	8008990 <GetSequence>
 800a36a:	4603      	mov	r3, r0
 800a36c:	2b00      	cmp	r3, #0
 800a36e:	da02      	bge.n	800a376 <GetName+0xbe>
        return ASN_PARSE_E;
 800a370:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800a374:	e214      	b.n	800a7a0 <GetName+0x4e8>

    ret = CalcHashId(&cert->source[idx], length + cert->srcIdx - idx, hash);
 800a376:	68fb      	ldr	r3, [r7, #12]
 800a378:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 800a37c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a37e:	18d0      	adds	r0, r2, r3
 800a380:	68fb      	ldr	r3, [r7, #12]
 800a382:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a386:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800a388:	441a      	add	r2, r3
 800a38a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a38c:	1ad3      	subs	r3, r2, r3
 800a38e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800a390:	4619      	mov	r1, r3
 800a392:	f7ff ff80 	bl	800a296 <CalcHashId>
 800a396:	63b8      	str	r0, [r7, #56]	; 0x38
    if (ret != 0)
 800a398:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a39a:	2b00      	cmp	r3, #0
 800a39c:	d001      	beq.n	800a3a2 <GetName+0xea>
        return ret;
 800a39e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a3a0:	e1fe      	b.n	800a7a0 <GetName+0x4e8>

    length += cert->srcIdx;
 800a3a2:	68fb      	ldr	r3, [r7, #12]
 800a3a4:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a3a8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800a3aa:	4413      	add	r3, r2
 800a3ac:	62fb      	str	r3, [r7, #44]	; 0x2c
    idx = 0;
 800a3ae:	2300      	movs	r3, #0
 800a3b0:	64fb      	str	r3, [r7, #76]	; 0x4c
        cert->issuerRaw = &cert->source[cert->srcIdx];
        cert->issuerRawLen = length - cert->srcIdx;
    }
#endif
#ifndef IGNORE_NAME_CONSTRAINTS
    if (nameType == SUBJECT) {
 800a3b2:	68bb      	ldr	r3, [r7, #8]
 800a3b4:	2b01      	cmp	r3, #1
 800a3b6:	f040 81e4 	bne.w	800a782 <GetName+0x4ca>
        cert->subjectRaw = &cert->source[cert->srcIdx];
 800a3ba:	68fb      	ldr	r3, [r7, #12]
 800a3bc:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 800a3c0:	68fb      	ldr	r3, [r7, #12]
 800a3c2:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a3c6:	441a      	add	r2, r3
 800a3c8:	68fb      	ldr	r3, [r7, #12]
 800a3ca:	f8c3 2338 	str.w	r2, [r3, #824]	; 0x338
        cert->subjectRawLen = length - cert->srcIdx;
 800a3ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a3d0:	461a      	mov	r2, r3
 800a3d2:	68fb      	ldr	r3, [r7, #12]
 800a3d4:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a3d8:	1ad3      	subs	r3, r2, r3
 800a3da:	461a      	mov	r2, r3
 800a3dc:	68fb      	ldr	r3, [r7, #12]
 800a3de:	f8c3 233c 	str.w	r2, [r3, #828]	; 0x33c
    if (dName == NULL) {
        return MEMORY_E;
    }
#endif /* OPENSSL_EXTRA */

    while (cert->srcIdx < (word32)length) {
 800a3e2:	e1ce      	b.n	800a782 <GetName+0x4ca>
        byte        b       = 0;
 800a3e4:	2300      	movs	r3, #0
 800a3e6:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
        byte        joint[3];
        byte        tooBig  = FALSE;
 800a3ea:	2300      	movs	r3, #0
 800a3ec:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
        int         oidSz;
        const char* copy    = NULL;
 800a3f0:	2300      	movs	r3, #0
 800a3f2:	647b      	str	r3, [r7, #68]	; 0x44
        int         copyLen = 0;
 800a3f4:	2300      	movs	r3, #0
 800a3f6:	643b      	str	r3, [r7, #64]	; 0x40
        int         strLen  = 0;
 800a3f8:	2300      	movs	r3, #0
 800a3fa:	617b      	str	r3, [r7, #20]
        byte        id      = 0;
 800a3fc:	2300      	movs	r3, #0
 800a3fe:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
                && !defined(WOLFCRYPT_ONLY)
         int        nid = NID_undef;
         int        enc;
    #endif /* OPENSSL_EXTRA */

        if (GetSet(cert->source, &cert->srcIdx, &dummy, maxIdx) < 0) {
 800a402:	68fb      	ldr	r3, [r7, #12]
 800a404:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a408:	68fb      	ldr	r3, [r7, #12]
 800a40a:	f503 7124 	add.w	r1, r3, #656	; 0x290
 800a40e:	687b      	ldr	r3, [r7, #4]
 800a410:	f107 0228 	add.w	r2, r7, #40	; 0x28
 800a414:	f7fe fad0 	bl	80089b8 <GetSet>
            WOLFSSL_MSG("Cert name lacks set header, trying sequence");
        }

        if (GetSequence(cert->source, &cert->srcIdx, &dummy, maxIdx) <= 0) {
 800a418:	68fb      	ldr	r3, [r7, #12]
 800a41a:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a41e:	68fb      	ldr	r3, [r7, #12]
 800a420:	f503 7124 	add.w	r1, r3, #656	; 0x290
 800a424:	687b      	ldr	r3, [r7, #4]
 800a426:	f107 0228 	add.w	r2, r7, #40	; 0x28
 800a42a:	f7fe fab1 	bl	8008990 <GetSequence>
 800a42e:	4603      	mov	r3, r0
 800a430:	2b00      	cmp	r3, #0
 800a432:	dc02      	bgt.n	800a43a <GetName+0x182>
        #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \
            !defined(WOLFCRYPT_ONLY)
            wolfSSL_X509_NAME_free(dName);
        #endif /* OPENSSL_EXTRA */
            return ASN_PARSE_E;
 800a434:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800a438:	e1b2      	b.n	800a7a0 <GetName+0x4e8>
        }

        ret = GetASNObjectId(cert->source, &cert->srcIdx, &oidSz, maxIdx);
 800a43a:	68fb      	ldr	r3, [r7, #12]
 800a43c:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a440:	68fb      	ldr	r3, [r7, #12]
 800a442:	f503 7124 	add.w	r1, r3, #656	; 0x290
 800a446:	687b      	ldr	r3, [r7, #4]
 800a448:	f107 0218 	add.w	r2, r7, #24
 800a44c:	f7ff f860 	bl	8009510 <GetASNObjectId>
 800a450:	63b8      	str	r0, [r7, #56]	; 0x38
        if (ret != 0) {
 800a452:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a454:	2b00      	cmp	r3, #0
 800a456:	d001      	beq.n	800a45c <GetName+0x1a4>
        #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \
            !defined(WOLFCRYPT_ONLY)
            wolfSSL_X509_NAME_free(dName);
        #endif /* OPENSSL_EXTRA */
            return ret;
 800a458:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a45a:	e1a1      	b.n	800a7a0 <GetName+0x4e8>
        }

        /* make sure there is room for joint */
        if ((cert->srcIdx + sizeof(joint)) > (word32)maxIdx) {
 800a45c:	68fb      	ldr	r3, [r7, #12]
 800a45e:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a462:	1cda      	adds	r2, r3, #3
 800a464:	687b      	ldr	r3, [r7, #4]
 800a466:	429a      	cmp	r2, r3
 800a468:	d902      	bls.n	800a470 <GetName+0x1b8>
        #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \
            !defined(WOLFCRYPT_ONLY)
            wolfSSL_X509_NAME_free(dName);
        #endif /* OPENSSL_EXTRA */
            return ASN_PARSE_E;
 800a46a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800a46e:	e197      	b.n	800a7a0 <GetName+0x4e8>
        }

        XMEMCPY(joint, &cert->source[cert->srcIdx], sizeof(joint));
 800a470:	68fb      	ldr	r3, [r7, #12]
 800a472:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 800a476:	68fb      	ldr	r3, [r7, #12]
 800a478:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a47c:	441a      	add	r2, r3
 800a47e:	f107 031c 	add.w	r3, r7, #28
 800a482:	8811      	ldrh	r1, [r2, #0]
 800a484:	7892      	ldrb	r2, [r2, #2]
 800a486:	8019      	strh	r1, [r3, #0]
 800a488:	709a      	strb	r2, [r3, #2]

        /* v1 name types */
        if (joint[0] == 0x55 && joint[1] == 0x04) {
 800a48a:	7f3b      	ldrb	r3, [r7, #28]
 800a48c:	2b55      	cmp	r3, #85	; 0x55
 800a48e:	f040 8083 	bne.w	800a598 <GetName+0x2e0>
 800a492:	7f7b      	ldrb	r3, [r7, #29]
 800a494:	2b04      	cmp	r3, #4
 800a496:	d17f      	bne.n	800a598 <GetName+0x2e0>
            cert->srcIdx += 3;
 800a498:	68fb      	ldr	r3, [r7, #12]
 800a49a:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a49e:	1cda      	adds	r2, r3, #3
 800a4a0:	68fb      	ldr	r3, [r7, #12]
 800a4a2:	f8c3 2290 	str.w	r2, [r3, #656]	; 0x290
            id = joint[2];
 800a4a6:	7fbb      	ldrb	r3, [r7, #30]
 800a4a8:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
            if (GetHeader(cert->source, &b, &cert->srcIdx, &strLen,
 800a4ac:	68fb      	ldr	r3, [r7, #12]
 800a4ae:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a4b2:	68fb      	ldr	r3, [r7, #12]
 800a4b4:	f503 7424 	add.w	r4, r3, #656	; 0x290
 800a4b8:	687b      	ldr	r3, [r7, #4]
 800a4ba:	f107 0514 	add.w	r5, r7, #20
 800a4be:	f107 0122 	add.w	r1, r7, #34	; 0x22
 800a4c2:	2201      	movs	r2, #1
 800a4c4:	9201      	str	r2, [sp, #4]
 800a4c6:	9300      	str	r3, [sp, #0]
 800a4c8:	462b      	mov	r3, r5
 800a4ca:	4622      	mov	r2, r4
 800a4cc:	f7fe fa2b 	bl	8008926 <GetHeader>
 800a4d0:	4603      	mov	r3, r0
 800a4d2:	2b00      	cmp	r3, #0
 800a4d4:	da02      	bge.n	800a4dc <GetName+0x224>
                          maxIdx, 1) < 0) {
            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \
            !defined(WOLFCRYPT_ONLY)
                wolfSSL_X509_NAME_free(dName);
            #endif /* OPENSSL_EXTRA */
                return ASN_PARSE_E;
 800a4d6:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800a4da:	e161      	b.n	800a7a0 <GetName+0x4e8>
            }

            if (id == ASN_COMMON_NAME) {
 800a4dc:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 800a4e0:	2b03      	cmp	r3, #3
 800a4e2:	d119      	bne.n	800a518 <GetName+0x260>
                if (nameType == SUBJECT) {
 800a4e4:	68bb      	ldr	r3, [r7, #8]
 800a4e6:	2b01      	cmp	r3, #1
 800a4e8:	d111      	bne.n	800a50e <GetName+0x256>
                    cert->subjectCN = (char *)&cert->source[cert->srcIdx];
 800a4ea:	68fb      	ldr	r3, [r7, #12]
 800a4ec:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 800a4f0:	68fb      	ldr	r3, [r7, #12]
 800a4f2:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a4f6:	441a      	add	r2, r3
 800a4f8:	68fb      	ldr	r3, [r7, #12]
 800a4fa:	67da      	str	r2, [r3, #124]	; 0x7c
                    cert->subjectCNLen = strLen;
 800a4fc:	697a      	ldr	r2, [r7, #20]
 800a4fe:	68fb      	ldr	r3, [r7, #12]
 800a500:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
                    cert->subjectCNEnc = b;
 800a504:	f897 2022 	ldrb.w	r2, [r7, #34]	; 0x22
 800a508:	68fb      	ldr	r3, [r7, #12]
 800a50a:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84
                }

                copy = WOLFSSL_COMMON_NAME;
 800a50e:	4ba6      	ldr	r3, [pc, #664]	; (800a7a8 <GetName+0x4f0>)
 800a510:	647b      	str	r3, [r7, #68]	; 0x44
                copyLen = sizeof(WOLFSSL_COMMON_NAME) - 1;
 800a512:	2304      	movs	r3, #4
 800a514:	643b      	str	r3, [r7, #64]	; 0x40
            if (id == ASN_COMMON_NAME) {
 800a516:	e0f8      	b.n	800a70a <GetName+0x452>
            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) \
                && !defined(WOLFCRYPT_ONLY)
                nid = NID_commonName;
            #endif /* OPENSSL_EXTRA */
            }
            else if (id == ASN_SUR_NAME) {
 800a518:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 800a51c:	2b04      	cmp	r3, #4
 800a51e:	d104      	bne.n	800a52a <GetName+0x272>
                copy = WOLFSSL_SUR_NAME;
 800a520:	4ba2      	ldr	r3, [pc, #648]	; (800a7ac <GetName+0x4f4>)
 800a522:	647b      	str	r3, [r7, #68]	; 0x44
                copyLen = sizeof(WOLFSSL_SUR_NAME) - 1;
 800a524:	2304      	movs	r3, #4
 800a526:	643b      	str	r3, [r7, #64]	; 0x40
            if (id == ASN_COMMON_NAME) {
 800a528:	e0ef      	b.n	800a70a <GetName+0x452>
                        defined(OPENSSL_EXTRA_X509_SMALL)) \
                        && !defined(WOLFCRYPT_ONLY)
                    nid = NID_surname;
                #endif /* OPENSSL_EXTRA */
            }
            else if (id == ASN_COUNTRY_NAME) {
 800a52a:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 800a52e:	2b06      	cmp	r3, #6
 800a530:	d104      	bne.n	800a53c <GetName+0x284>
                copy = WOLFSSL_COUNTRY_NAME;
 800a532:	4b9f      	ldr	r3, [pc, #636]	; (800a7b0 <GetName+0x4f8>)
 800a534:	647b      	str	r3, [r7, #68]	; 0x44
                copyLen = sizeof(WOLFSSL_COUNTRY_NAME) - 1;
 800a536:	2303      	movs	r3, #3
 800a538:	643b      	str	r3, [r7, #64]	; 0x40
            if (id == ASN_COMMON_NAME) {
 800a53a:	e0e6      	b.n	800a70a <GetName+0x452>
                        defined(OPENSSL_EXTRA_X509_SMALL)) \
                        && !defined(WOLFCRYPT_ONLY)
                    nid = NID_countryName;
                #endif /* OPENSSL_EXTRA */
            }
            else if (id == ASN_LOCALITY_NAME) {
 800a53c:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 800a540:	2b07      	cmp	r3, #7
 800a542:	d104      	bne.n	800a54e <GetName+0x296>
                copy = WOLFSSL_LOCALITY_NAME;
 800a544:	4b9b      	ldr	r3, [pc, #620]	; (800a7b4 <GetName+0x4fc>)
 800a546:	647b      	str	r3, [r7, #68]	; 0x44
                copyLen = sizeof(WOLFSSL_LOCALITY_NAME) - 1;
 800a548:	2303      	movs	r3, #3
 800a54a:	643b      	str	r3, [r7, #64]	; 0x40
            if (id == ASN_COMMON_NAME) {
 800a54c:	e0dd      	b.n	800a70a <GetName+0x452>
                        defined(OPENSSL_EXTRA_X509_SMALL)) \
                        && !defined(WOLFCRYPT_ONLY)
                    nid = NID_localityName;
                #endif /* OPENSSL_EXTRA */
            }
            else if (id == ASN_STATE_NAME) {
 800a54e:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 800a552:	2b08      	cmp	r3, #8
 800a554:	d104      	bne.n	800a560 <GetName+0x2a8>
                copy = WOLFSSL_STATE_NAME;
 800a556:	4b98      	ldr	r3, [pc, #608]	; (800a7b8 <GetName+0x500>)
 800a558:	647b      	str	r3, [r7, #68]	; 0x44
                copyLen = sizeof(WOLFSSL_STATE_NAME) - 1;
 800a55a:	2304      	movs	r3, #4
 800a55c:	643b      	str	r3, [r7, #64]	; 0x40
            if (id == ASN_COMMON_NAME) {
 800a55e:	e0d4      	b.n	800a70a <GetName+0x452>
                        defined(OPENSSL_EXTRA_X509_SMALL)) \
                        && !defined(WOLFCRYPT_ONLY)
                    nid = NID_stateOrProvinceName;
                #endif /* OPENSSL_EXTRA */
            }
            else if (id == ASN_ORG_NAME) {
 800a560:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 800a564:	2b0a      	cmp	r3, #10
 800a566:	d104      	bne.n	800a572 <GetName+0x2ba>
                copy = WOLFSSL_ORG_NAME;
 800a568:	4b94      	ldr	r3, [pc, #592]	; (800a7bc <GetName+0x504>)
 800a56a:	647b      	str	r3, [r7, #68]	; 0x44
                copyLen = sizeof(WOLFSSL_ORG_NAME) - 1;
 800a56c:	2303      	movs	r3, #3
 800a56e:	643b      	str	r3, [r7, #64]	; 0x40
            if (id == ASN_COMMON_NAME) {
 800a570:	e0cb      	b.n	800a70a <GetName+0x452>
                        defined(OPENSSL_EXTRA_X509_SMALL)) \
                        && !defined(WOLFCRYPT_ONLY)
                    nid = NID_organizationName;
                #endif /* OPENSSL_EXTRA */
            }
            else if (id == ASN_ORGUNIT_NAME) {
 800a572:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 800a576:	2b0b      	cmp	r3, #11
 800a578:	d104      	bne.n	800a584 <GetName+0x2cc>
                copy = WOLFSSL_ORGUNIT_NAME;
 800a57a:	4b91      	ldr	r3, [pc, #580]	; (800a7c0 <GetName+0x508>)
 800a57c:	647b      	str	r3, [r7, #68]	; 0x44
                copyLen = sizeof(WOLFSSL_ORGUNIT_NAME) - 1;
 800a57e:	2304      	movs	r3, #4
 800a580:	643b      	str	r3, [r7, #64]	; 0x40
            if (id == ASN_COMMON_NAME) {
 800a582:	e0c2      	b.n	800a70a <GetName+0x452>
                        defined(OPENSSL_EXTRA_X509_SMALL)) \
                        && !defined(WOLFCRYPT_ONLY)
                    nid = NID_organizationalUnitName;
                #endif /* OPENSSL_EXTRA */
            }
            else if (id == ASN_SERIAL_NUMBER) {
 800a584:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 800a588:	2b05      	cmp	r3, #5
 800a58a:	f040 80be 	bne.w	800a70a <GetName+0x452>
                copy = WOLFSSL_SERIAL_NUMBER;
 800a58e:	4b8d      	ldr	r3, [pc, #564]	; (800a7c4 <GetName+0x50c>)
 800a590:	647b      	str	r3, [r7, #68]	; 0x44
                copyLen = sizeof(WOLFSSL_SERIAL_NUMBER) - 1;
 800a592:	230e      	movs	r3, #14
 800a594:	643b      	str	r3, [r7, #64]	; 0x40
            if (id == ASN_COMMON_NAME) {
 800a596:	e0b8      	b.n	800a70a <GetName+0x452>
            }
        }
    #endif /* WOLFSSL_CERT_EXT */
        else {
            /* skip */
            byte email = FALSE;
 800a598:	2300      	movs	r3, #0
 800a59a:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
            byte pilot = FALSE;
 800a59e:	2300      	movs	r3, #0
 800a5a0:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d

            if (joint[0] == 0x2a && joint[1] == 0x86) {  /* email id hdr */
 800a5a4:	7f3b      	ldrb	r3, [r7, #28]
 800a5a6:	2b2a      	cmp	r3, #42	; 0x2a
 800a5a8:	d108      	bne.n	800a5bc <GetName+0x304>
 800a5aa:	7f7b      	ldrb	r3, [r7, #29]
 800a5ac:	2b86      	cmp	r3, #134	; 0x86
 800a5ae:	d105      	bne.n	800a5bc <GetName+0x304>
                id = ASN_EMAIL_NAME;
 800a5b0:	2398      	movs	r3, #152	; 0x98
 800a5b2:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
                email = TRUE;
 800a5b6:	2301      	movs	r3, #1
 800a5b8:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
            }

            if (joint[0] == 0x9  && joint[1] == 0x92) { /* uid id hdr */
 800a5bc:	7f3b      	ldrb	r3, [r7, #28]
 800a5be:	2b09      	cmp	r3, #9
 800a5c0:	d112      	bne.n	800a5e8 <GetName+0x330>
 800a5c2:	7f7b      	ldrb	r3, [r7, #29]
 800a5c4:	2b92      	cmp	r3, #146	; 0x92
 800a5c6:	d10f      	bne.n	800a5e8 <GetName+0x330>
                /* last value of OID is the type of pilot attribute */
                id    = cert->source[cert->srcIdx + oidSz - 1];
 800a5c8:	68fb      	ldr	r3, [r7, #12]
 800a5ca:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 800a5ce:	68fb      	ldr	r3, [r7, #12]
 800a5d0:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a5d4:	69b9      	ldr	r1, [r7, #24]
 800a5d6:	440b      	add	r3, r1
 800a5d8:	3b01      	subs	r3, #1
 800a5da:	4413      	add	r3, r2
 800a5dc:	781b      	ldrb	r3, [r3, #0]
 800a5de:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
                pilot = TRUE;
 800a5e2:	2301      	movs	r3, #1
 800a5e4:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d
            }

            cert->srcIdx += oidSz + 1;
 800a5e8:	68fb      	ldr	r3, [r7, #12]
 800a5ea:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a5ee:	69ba      	ldr	r2, [r7, #24]
 800a5f0:	4413      	add	r3, r2
 800a5f2:	1c5a      	adds	r2, r3, #1
 800a5f4:	68fb      	ldr	r3, [r7, #12]
 800a5f6:	f8c3 2290 	str.w	r2, [r3, #656]	; 0x290

            if (GetLength(cert->source, &cert->srcIdx, &strLen, maxIdx) < 0) {
 800a5fa:	68fb      	ldr	r3, [r7, #12]
 800a5fc:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a600:	68fb      	ldr	r3, [r7, #12]
 800a602:	f503 7124 	add.w	r1, r3, #656	; 0x290
 800a606:	687b      	ldr	r3, [r7, #4]
 800a608:	f107 0214 	add.w	r2, r7, #20
 800a60c:	f7fe f88c 	bl	8008728 <GetLength>
 800a610:	4603      	mov	r3, r0
 800a612:	2b00      	cmp	r3, #0
 800a614:	da02      	bge.n	800a61c <GetName+0x364>
            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \
            !defined(WOLFCRYPT_ONLY)
                wolfSSL_X509_NAME_free(dName);
            #endif /* OPENSSL_EXTRA */
                return ASN_PARSE_E;
 800a616:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800a61a:	e0c1      	b.n	800a7a0 <GetName+0x4e8>
            }

            if (strLen > (int)(ASN_NAME_MAX - idx)) {
 800a61c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a61e:	f5c3 7380 	rsb	r3, r3, #256	; 0x100
 800a622:	461a      	mov	r2, r3
 800a624:	697b      	ldr	r3, [r7, #20]
 800a626:	429a      	cmp	r2, r3
 800a628:	da02      	bge.n	800a630 <GetName+0x378>
                WOLFSSL_MSG("ASN name too big, skipping");
                tooBig = TRUE;
 800a62a:	2301      	movs	r3, #1
 800a62c:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
            }

            if (email) {
 800a630:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 800a634:	2b00      	cmp	r3, #0
 800a636:	d050      	beq.n	800a6da <GetName+0x422>
                copyLen = sizeof(WOLFSSL_EMAIL_ADDR) - 1;
 800a638:	230e      	movs	r3, #14
 800a63a:	643b      	str	r3, [r7, #64]	; 0x40
                if ((copyLen + strLen) > (int)(ASN_NAME_MAX - idx)) {
 800a63c:	697a      	ldr	r2, [r7, #20]
 800a63e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a640:	4413      	add	r3, r2
 800a642:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800a644:	f5c2 7280 	rsb	r2, r2, #256	; 0x100
 800a648:	4293      	cmp	r3, r2
 800a64a:	dd03      	ble.n	800a654 <GetName+0x39c>
                    WOLFSSL_MSG("ASN name too big, skipping");
                    tooBig = TRUE;
 800a64c:	2301      	movs	r3, #1
 800a64e:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
 800a652:	e001      	b.n	800a658 <GetName+0x3a0>
                }
                else {
                    copy = WOLFSSL_EMAIL_ADDR;
 800a654:	4b5c      	ldr	r3, [pc, #368]	; (800a7c8 <GetName+0x510>)
 800a656:	647b      	str	r3, [r7, #68]	; 0x44
                #endif /* OPENSSL_EXTRA */
                #ifndef IGNORE_NAME_CONSTRAINTS
                    {
                        DNS_entry* emailName;

                        emailName = (DNS_entry*)XMALLOC(sizeof(DNS_entry),
 800a658:	2010      	movs	r0, #16
 800a65a:	f004 fc4d 	bl	800eef8 <wolfSSL_Malloc>
 800a65e:	6378      	str	r0, [r7, #52]	; 0x34
                                              cert->heap, DYNAMIC_TYPE_ALTNAME);
                        if (emailName == NULL) {
 800a660:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a662:	2b00      	cmp	r3, #0
 800a664:	d102      	bne.n	800a66c <GetName+0x3b4>
                        #if (defined(OPENSSL_EXTRA) || \
                                defined(OPENSSL_EXTRA_X509_SMALL)) && \
                                !defined(WOLFCRYPT_ONLY)
                            wolfSSL_X509_NAME_free(dName);
                        #endif /* OPENSSL_EXTRA */
                            return MEMORY_E;
 800a666:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800a66a:	e099      	b.n	800a7a0 <GetName+0x4e8>
                        }
                        emailName->type = 0;
 800a66c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a66e:	2200      	movs	r2, #0
 800a670:	605a      	str	r2, [r3, #4]
                        emailName->name = (char*)XMALLOC(strLen + 1,
 800a672:	697b      	ldr	r3, [r7, #20]
 800a674:	3301      	adds	r3, #1
 800a676:	4618      	mov	r0, r3
 800a678:	f004 fc3e 	bl	800eef8 <wolfSSL_Malloc>
 800a67c:	4602      	mov	r2, r0
 800a67e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a680:	60da      	str	r2, [r3, #12]
                                              cert->heap, DYNAMIC_TYPE_ALTNAME);
                        if (emailName->name == NULL) {
 800a682:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a684:	68db      	ldr	r3, [r3, #12]
 800a686:	2b00      	cmp	r3, #0
 800a688:	d10a      	bne.n	800a6a0 <GetName+0x3e8>
                            WOLFSSL_MSG("\tOut of Memory");
                            XFREE(emailName, cert->heap, DYNAMIC_TYPE_ALTNAME);
 800a68a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a68c:	633b      	str	r3, [r7, #48]	; 0x30
 800a68e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a690:	2b00      	cmp	r3, #0
 800a692:	d002      	beq.n	800a69a <GetName+0x3e2>
 800a694:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800a696:	f004 fc4b 	bl	800ef30 <wolfSSL_Free>
                        #if (defined(OPENSSL_EXTRA) || \
                                defined(OPENSSL_EXTRA_X509_SMALL)) && \
                                !defined(WOLFCRYPT_ONLY)
                            wolfSSL_X509_NAME_free(dName);
                        #endif /* OPENSSL_EXTRA */
                            return MEMORY_E;
 800a69a:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800a69e:	e07f      	b.n	800a7a0 <GetName+0x4e8>
                        }
                        emailName->len = strLen;
 800a6a0:	697a      	ldr	r2, [r7, #20]
 800a6a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a6a4:	609a      	str	r2, [r3, #8]
                        XMEMCPY(emailName->name, &cert->source[cert->srcIdx],
 800a6a6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a6a8:	68d8      	ldr	r0, [r3, #12]
 800a6aa:	68fb      	ldr	r3, [r7, #12]
 800a6ac:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 800a6b0:	68fb      	ldr	r3, [r7, #12]
 800a6b2:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a6b6:	4413      	add	r3, r2
 800a6b8:	697a      	ldr	r2, [r7, #20]
 800a6ba:	4619      	mov	r1, r3
 800a6bc:	f00e fe9b 	bl	80193f6 <memcpy>
                                                                        strLen);
                        emailName->name[strLen] = '\0';
 800a6c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a6c2:	68db      	ldr	r3, [r3, #12]
 800a6c4:	697a      	ldr	r2, [r7, #20]
 800a6c6:	4413      	add	r3, r2
 800a6c8:	2200      	movs	r2, #0
 800a6ca:	701a      	strb	r2, [r3, #0]

                        emailName->next = cert->altEmailNames;
 800a6cc:	68fb      	ldr	r3, [r7, #12]
 800a6ce:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800a6d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a6d2:	601a      	str	r2, [r3, #0]
                        cert->altEmailNames = emailName;
 800a6d4:	68fb      	ldr	r3, [r7, #12]
 800a6d6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a6d8:	629a      	str	r2, [r3, #40]	; 0x28
                    }
                #endif /* IGNORE_NAME_CONSTRAINTS */
            }

            if (pilot) {
 800a6da:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 800a6de:	2b00      	cmp	r3, #0
 800a6e0:	d015      	beq.n	800a70e <GetName+0x456>
                switch (id) {
 800a6e2:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 800a6e6:	2b01      	cmp	r3, #1
 800a6e8:	d002      	beq.n	800a6f0 <GetName+0x438>
 800a6ea:	2b19      	cmp	r3, #25
 800a6ec:	d005      	beq.n	800a6fa <GetName+0x442>
 800a6ee:	e009      	b.n	800a704 <GetName+0x44c>
                    case ASN_USER_ID:
                        copy = WOLFSSL_USER_ID;
 800a6f0:	4b36      	ldr	r3, [pc, #216]	; (800a7cc <GetName+0x514>)
 800a6f2:	647b      	str	r3, [r7, #68]	; 0x44
                        copyLen = sizeof(WOLFSSL_USER_ID) - 1;
 800a6f4:	2305      	movs	r3, #5
 800a6f6:	643b      	str	r3, [r7, #64]	; 0x40
                    #if (defined(OPENSSL_EXTRA) || \
                        defined(OPENSSL_EXTRA_X509_SMALL)) \
                        && !defined(WOLFCRYPT_ONLY)
                        nid = NID_userId;
                    #endif /* OPENSSL_EXTRA */
                        break;
 800a6f8:	e00a      	b.n	800a710 <GetName+0x458>

                    case ASN_DOMAIN_COMPONENT:
                        copy = WOLFSSL_DOMAIN_COMPONENT;
 800a6fa:	4b35      	ldr	r3, [pc, #212]	; (800a7d0 <GetName+0x518>)
 800a6fc:	647b      	str	r3, [r7, #68]	; 0x44
                        copyLen = sizeof(WOLFSSL_DOMAIN_COMPONENT) - 1;
 800a6fe:	2304      	movs	r3, #4
 800a700:	643b      	str	r3, [r7, #64]	; 0x40
                    #if (defined(OPENSSL_EXTRA) || \
                        defined(OPENSSL_EXTRA_X509_SMALL)) \
                        && !defined(WOLFCRYPT_ONLY)
                        nid = NID_domainComponent;
                    #endif /* OPENSSL_EXTRA */
                        break;
 800a702:	e005      	b.n	800a710 <GetName+0x458>
                    #if (defined(OPENSSL_EXTRA) || \
                                defined(OPENSSL_EXTRA_X509_SMALL)) && \
                                !defined(WOLFCRYPT_ONLY)
                        wolfSSL_X509_NAME_free(dName);
                    #endif /* OPENSSL_EXTRA */
                        return ASN_PARSE_E;
 800a704:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800a708:	e04a      	b.n	800a7a0 <GetName+0x4e8>
            if (id == ASN_COMMON_NAME) {
 800a70a:	bf00      	nop
 800a70c:	e000      	b.n	800a710 <GetName+0x458>
                }
            }
 800a70e:	bf00      	nop
        }
        if ((copyLen + strLen) > (int)(ASN_NAME_MAX - idx))
 800a710:	697a      	ldr	r2, [r7, #20]
 800a712:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a714:	4413      	add	r3, r2
 800a716:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800a718:	f5c2 7280 	rsb	r2, r2, #256	; 0x100
 800a71c:	4293      	cmp	r3, r2
 800a71e:	dd02      	ble.n	800a726 <GetName+0x46e>
        {
            WOLFSSL_MSG("ASN Name too big, skipping");
            tooBig = TRUE;
 800a720:	2301      	movs	r3, #1
 800a722:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
        }
        if ((copy != NULL) && !tooBig) {
 800a726:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a728:	2b00      	cmp	r3, #0
 800a72a:	d022      	beq.n	800a772 <GetName+0x4ba>
 800a72c:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 800a730:	2b00      	cmp	r3, #0
 800a732:	d11e      	bne.n	800a772 <GetName+0x4ba>
            XMEMCPY(&full[idx], copy, copyLen);
 800a734:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800a736:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a738:	4413      	add	r3, r2
 800a73a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800a73c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800a73e:	4618      	mov	r0, r3
 800a740:	f00e fe59 	bl	80193f6 <memcpy>
            idx += copyLen;
 800a744:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a746:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800a748:	4413      	add	r3, r2
 800a74a:	64fb      	str	r3, [r7, #76]	; 0x4c
            XMEMCPY(&full[idx], &cert->source[cert->srcIdx], strLen);
 800a74c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800a74e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a750:	18d0      	adds	r0, r2, r3
 800a752:	68fb      	ldr	r3, [r7, #12]
 800a754:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 800a758:	68fb      	ldr	r3, [r7, #12]
 800a75a:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a75e:	4413      	add	r3, r2
 800a760:	697a      	ldr	r2, [r7, #20]
 800a762:	4619      	mov	r1, r3
 800a764:	f00e fe47 	bl	80193f6 <memcpy>
            idx += strLen;
 800a768:	697b      	ldr	r3, [r7, #20]
 800a76a:	461a      	mov	r2, r3
 800a76c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a76e:	4413      	add	r3, r2
 800a770:	64fb      	str	r3, [r7, #76]	; 0x4c
                wolfSSL_X509_NAME_free(dName);
                return ASN_PARSE_E;
            }
        }
        #endif /* OPENSSL_EXTRA */
        cert->srcIdx += strLen;
 800a772:	68fb      	ldr	r3, [r7, #12]
 800a774:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a778:	697a      	ldr	r2, [r7, #20]
 800a77a:	441a      	add	r2, r3
 800a77c:	68fb      	ldr	r3, [r7, #12]
 800a77e:	f8c3 2290 	str.w	r2, [r3, #656]	; 0x290
    while (cert->srcIdx < (word32)length) {
 800a782:	68fb      	ldr	r3, [r7, #12]
 800a784:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a788:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800a78a:	4293      	cmp	r3, r2
 800a78c:	f4ff ae2a 	bcc.w	800a3e4 <GetName+0x12c>
    }
    full[idx++] = 0;
 800a790:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a792:	1c5a      	adds	r2, r3, #1
 800a794:	64fa      	str	r2, [r7, #76]	; 0x4c
 800a796:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800a798:	4413      	add	r3, r2
 800a79a:	2200      	movs	r2, #0
 800a79c:	701a      	strb	r2, [r3, #0]
    }
    else {
        cert->subjectName = dName;
    }
#endif
    return 0;
 800a79e:	2300      	movs	r3, #0
}
 800a7a0:	4618      	mov	r0, r3
 800a7a2:	3758      	adds	r7, #88	; 0x58
 800a7a4:	46bd      	mov	sp, r7
 800a7a6:	bdb0      	pop	{r4, r5, r7, pc}
 800a7a8:	0801a40c 	.word	0x0801a40c
 800a7ac:	0801a414 	.word	0x0801a414
 800a7b0:	0801a41c 	.word	0x0801a41c
 800a7b4:	0801a420 	.word	0x0801a420
 800a7b8:	0801a424 	.word	0x0801a424
 800a7bc:	0801a42c 	.word	0x0801a42c
 800a7c0:	0801a430 	.word	0x0801a430
 800a7c4:	0801a438 	.word	0x0801a438
 800a7c8:	0801a448 	.word	0x0801a448
 800a7cc:	0801a458 	.word	0x0801a458
 800a7d0:	0801a460 	.word	0x0801a460

0800a7d4 <GetDateInfo>:


/* Get date buffer, format and length. Returns 0=success or error */
static int GetDateInfo(const byte* source, word32* idx, const byte** pDate,
                        byte* pFormat, int* pLength, word32 maxIdx)
{
 800a7d4:	b580      	push	{r7, lr}
 800a7d6:	b086      	sub	sp, #24
 800a7d8:	af00      	add	r7, sp, #0
 800a7da:	60f8      	str	r0, [r7, #12]
 800a7dc:	60b9      	str	r1, [r7, #8]
 800a7de:	607a      	str	r2, [r7, #4]
 800a7e0:	603b      	str	r3, [r7, #0]
    int length;
    byte format;

    if (source == NULL || idx == NULL)
 800a7e2:	68fb      	ldr	r3, [r7, #12]
 800a7e4:	2b00      	cmp	r3, #0
 800a7e6:	d002      	beq.n	800a7ee <GetDateInfo+0x1a>
 800a7e8:	68bb      	ldr	r3, [r7, #8]
 800a7ea:	2b00      	cmp	r3, #0
 800a7ec:	d102      	bne.n	800a7f4 <GetDateInfo+0x20>
        return BAD_FUNC_ARG;
 800a7ee:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800a7f2:	e04e      	b.n	800a892 <GetDateInfo+0xbe>

    /* get ASN format header */
    if (*idx+1 > maxIdx)
 800a7f4:	68bb      	ldr	r3, [r7, #8]
 800a7f6:	681b      	ldr	r3, [r3, #0]
 800a7f8:	3301      	adds	r3, #1
 800a7fa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800a7fc:	429a      	cmp	r2, r3
 800a7fe:	d202      	bcs.n	800a806 <GetDateInfo+0x32>
        return BUFFER_E;
 800a800:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800a804:	e045      	b.n	800a892 <GetDateInfo+0xbe>
    format = source[*idx];
 800a806:	68bb      	ldr	r3, [r7, #8]
 800a808:	681b      	ldr	r3, [r3, #0]
 800a80a:	68fa      	ldr	r2, [r7, #12]
 800a80c:	4413      	add	r3, r2
 800a80e:	781b      	ldrb	r3, [r3, #0]
 800a810:	75fb      	strb	r3, [r7, #23]
    *idx += 1;
 800a812:	68bb      	ldr	r3, [r7, #8]
 800a814:	681b      	ldr	r3, [r3, #0]
 800a816:	1c5a      	adds	r2, r3, #1
 800a818:	68bb      	ldr	r3, [r7, #8]
 800a81a:	601a      	str	r2, [r3, #0]
    if (format != ASN_UTC_TIME && format != ASN_GENERALIZED_TIME)
 800a81c:	7dfb      	ldrb	r3, [r7, #23]
 800a81e:	2b17      	cmp	r3, #23
 800a820:	d005      	beq.n	800a82e <GetDateInfo+0x5a>
 800a822:	7dfb      	ldrb	r3, [r7, #23]
 800a824:	2b18      	cmp	r3, #24
 800a826:	d002      	beq.n	800a82e <GetDateInfo+0x5a>
        return ASN_TIME_E;
 800a828:	f06f 0398 	mvn.w	r3, #152	; 0x98
 800a82c:	e031      	b.n	800a892 <GetDateInfo+0xbe>

    /* get length */
    if (GetLength(source, idx, &length, maxIdx) < 0)
 800a82e:	f107 0210 	add.w	r2, r7, #16
 800a832:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a834:	68b9      	ldr	r1, [r7, #8]
 800a836:	68f8      	ldr	r0, [r7, #12]
 800a838:	f7fd ff76 	bl	8008728 <GetLength>
 800a83c:	4603      	mov	r3, r0
 800a83e:	2b00      	cmp	r3, #0
 800a840:	da02      	bge.n	800a848 <GetDateInfo+0x74>
        return ASN_PARSE_E;
 800a842:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800a846:	e024      	b.n	800a892 <GetDateInfo+0xbe>
    if (length > MAX_DATE_SIZE || length < MIN_DATE_SIZE)
 800a848:	693b      	ldr	r3, [r7, #16]
 800a84a:	2b20      	cmp	r3, #32
 800a84c:	dc02      	bgt.n	800a854 <GetDateInfo+0x80>
 800a84e:	693b      	ldr	r3, [r7, #16]
 800a850:	2b0b      	cmp	r3, #11
 800a852:	dc02      	bgt.n	800a85a <GetDateInfo+0x86>
        return ASN_DATE_SZ_E;
 800a854:	f06f 0394 	mvn.w	r3, #148	; 0x94
 800a858:	e01b      	b.n	800a892 <GetDateInfo+0xbe>

    /* return format, date and length */
    if (pFormat)
 800a85a:	683b      	ldr	r3, [r7, #0]
 800a85c:	2b00      	cmp	r3, #0
 800a85e:	d002      	beq.n	800a866 <GetDateInfo+0x92>
        *pFormat = format;
 800a860:	683b      	ldr	r3, [r7, #0]
 800a862:	7dfa      	ldrb	r2, [r7, #23]
 800a864:	701a      	strb	r2, [r3, #0]
    if (pDate)
 800a866:	687b      	ldr	r3, [r7, #4]
 800a868:	2b00      	cmp	r3, #0
 800a86a:	d005      	beq.n	800a878 <GetDateInfo+0xa4>
        *pDate = &source[*idx];
 800a86c:	68bb      	ldr	r3, [r7, #8]
 800a86e:	681b      	ldr	r3, [r3, #0]
 800a870:	68fa      	ldr	r2, [r7, #12]
 800a872:	441a      	add	r2, r3
 800a874:	687b      	ldr	r3, [r7, #4]
 800a876:	601a      	str	r2, [r3, #0]
    if (pLength)
 800a878:	6a3b      	ldr	r3, [r7, #32]
 800a87a:	2b00      	cmp	r3, #0
 800a87c:	d002      	beq.n	800a884 <GetDateInfo+0xb0>
        *pLength = length;
 800a87e:	693a      	ldr	r2, [r7, #16]
 800a880:	6a3b      	ldr	r3, [r7, #32]
 800a882:	601a      	str	r2, [r3, #0]

    *idx += length;
 800a884:	68bb      	ldr	r3, [r7, #8]
 800a886:	681b      	ldr	r3, [r3, #0]
 800a888:	693a      	ldr	r2, [r7, #16]
 800a88a:	441a      	add	r2, r3
 800a88c:	68bb      	ldr	r3, [r7, #8]
 800a88e:	601a      	str	r2, [r3, #0]

    return 0;
 800a890:	2300      	movs	r3, #0
}
 800a892:	4618      	mov	r0, r3
 800a894:	3718      	adds	r7, #24
 800a896:	46bd      	mov	sp, r7
 800a898:	bd80      	pop	{r7, pc}

0800a89a <GetDate>:

static int GetDate(DecodedCert* cert, int dateType, int verify, int maxIdx)
{
 800a89a:	b590      	push	{r4, r7, lr}
 800a89c:	b095      	sub	sp, #84	; 0x54
 800a89e:	af02      	add	r7, sp, #8
 800a8a0:	60f8      	str	r0, [r7, #12]
 800a8a2:	60b9      	str	r1, [r7, #8]
 800a8a4:	607a      	str	r2, [r7, #4]
 800a8a6:	603b      	str	r3, [r7, #0]
    int    ret, length;
    const byte *datePtr = NULL;
 800a8a8:	2300      	movs	r3, #0
 800a8aa:	63bb      	str	r3, [r7, #56]	; 0x38
    byte   date[MAX_DATE_SIZE];
    byte   format;
    word32 startIdx = 0;
 800a8ac:	2300      	movs	r3, #0
 800a8ae:	647b      	str	r3, [r7, #68]	; 0x44

    if (dateType == BEFORE)
 800a8b0:	68bb      	ldr	r3, [r7, #8]
 800a8b2:	2b00      	cmp	r3, #0
 800a8b4:	d10a      	bne.n	800a8cc <GetDate+0x32>
        cert->beforeDate = &cert->source[cert->srcIdx];
 800a8b6:	68fb      	ldr	r3, [r7, #12]
 800a8b8:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 800a8bc:	68fb      	ldr	r3, [r7, #12]
 800a8be:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a8c2:	441a      	add	r2, r3
 800a8c4:	68fb      	ldr	r3, [r7, #12]
 800a8c6:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328
 800a8ca:	e009      	b.n	800a8e0 <GetDate+0x46>
    else
        cert->afterDate = &cert->source[cert->srcIdx];
 800a8cc:	68fb      	ldr	r3, [r7, #12]
 800a8ce:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 800a8d2:	68fb      	ldr	r3, [r7, #12]
 800a8d4:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a8d8:	441a      	add	r2, r3
 800a8da:	68fb      	ldr	r3, [r7, #12]
 800a8dc:	f8c3 2330 	str.w	r2, [r3, #816]	; 0x330
    startIdx = cert->srcIdx;
 800a8e0:	68fb      	ldr	r3, [r7, #12]
 800a8e2:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a8e6:	647b      	str	r3, [r7, #68]	; 0x44

    ret = GetDateInfo(cert->source, &cert->srcIdx, &datePtr, &format,
 800a8e8:	68fb      	ldr	r3, [r7, #12]
 800a8ea:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a8ee:	68fb      	ldr	r3, [r7, #12]
 800a8f0:	f503 7124 	add.w	r1, r3, #656	; 0x290
 800a8f4:	683b      	ldr	r3, [r7, #0]
 800a8f6:	f107 0417 	add.w	r4, r7, #23
 800a8fa:	f107 0238 	add.w	r2, r7, #56	; 0x38
 800a8fe:	9301      	str	r3, [sp, #4]
 800a900:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800a904:	9300      	str	r3, [sp, #0]
 800a906:	4623      	mov	r3, r4
 800a908:	f7ff ff64 	bl	800a7d4 <GetDateInfo>
 800a90c:	6438      	str	r0, [r7, #64]	; 0x40
                      &length, maxIdx);
    if (ret < 0)
 800a90e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a910:	2b00      	cmp	r3, #0
 800a912:	da01      	bge.n	800a918 <GetDate+0x7e>
        return ret;
 800a914:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a916:	e025      	b.n	800a964 <GetDate+0xca>

    XMEMSET(date, 0, MAX_DATE_SIZE);
 800a918:	f107 0318 	add.w	r3, r7, #24
 800a91c:	2220      	movs	r2, #32
 800a91e:	2100      	movs	r1, #0
 800a920:	4618      	mov	r0, r3
 800a922:	f00e fd8c 	bl	801943e <memset>
    XMEMCPY(date, datePtr, length);
 800a926:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800a928:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a92a:	461a      	mov	r2, r3
 800a92c:	f107 0318 	add.w	r3, r7, #24
 800a930:	4618      	mov	r0, r3
 800a932:	f00e fd60 	bl	80193f6 <memcpy>

    if (dateType == BEFORE)
 800a936:	68bb      	ldr	r3, [r7, #8]
 800a938:	2b00      	cmp	r3, #0
 800a93a:	d109      	bne.n	800a950 <GetDate+0xb6>
        cert->beforeDateLen = cert->srcIdx - startIdx;
 800a93c:	68fb      	ldr	r3, [r7, #12]
 800a93e:	f8d3 2290 	ldr.w	r2, [r3, #656]	; 0x290
 800a942:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a944:	1ad3      	subs	r3, r2, r3
 800a946:	461a      	mov	r2, r3
 800a948:	68fb      	ldr	r3, [r7, #12]
 800a94a:	f8c3 232c 	str.w	r2, [r3, #812]	; 0x32c
 800a94e:	e008      	b.n	800a962 <GetDate+0xc8>
    else
        cert->afterDateLen  = cert->srcIdx - startIdx;
 800a950:	68fb      	ldr	r3, [r7, #12]
 800a952:	f8d3 2290 	ldr.w	r2, [r3, #656]	; 0x290
 800a956:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a958:	1ad3      	subs	r3, r2, r3
 800a95a:	461a      	mov	r2, r3
 800a95c:	68fb      	ldr	r3, [r7, #12]
 800a95e:	f8c3 2334 	str.w	r2, [r3, #820]	; 0x334
    }
#else
    (void)verify;
#endif

    return 0;
 800a962:	2300      	movs	r3, #0
}
 800a964:	4618      	mov	r0, r3
 800a966:	374c      	adds	r7, #76	; 0x4c
 800a968:	46bd      	mov	sp, r7
 800a96a:	bd90      	pop	{r4, r7, pc}

0800a96c <GetValidity>:

static int GetValidity(DecodedCert* cert, int verify, int maxIdx)
{
 800a96c:	b580      	push	{r7, lr}
 800a96e:	b086      	sub	sp, #24
 800a970:	af00      	add	r7, sp, #0
 800a972:	60f8      	str	r0, [r7, #12]
 800a974:	60b9      	str	r1, [r7, #8]
 800a976:	607a      	str	r2, [r7, #4]
    int length;
    int badDate = 0;
 800a978:	2300      	movs	r3, #0
 800a97a:	617b      	str	r3, [r7, #20]

    if (GetSequence(cert->source, &cert->srcIdx, &length, maxIdx) < 0)
 800a97c:	68fb      	ldr	r3, [r7, #12]
 800a97e:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800a982:	68fb      	ldr	r3, [r7, #12]
 800a984:	f503 7124 	add.w	r1, r3, #656	; 0x290
 800a988:	687b      	ldr	r3, [r7, #4]
 800a98a:	f107 0210 	add.w	r2, r7, #16
 800a98e:	f7fd ffff 	bl	8008990 <GetSequence>
 800a992:	4603      	mov	r3, r0
 800a994:	2b00      	cmp	r3, #0
 800a996:	da02      	bge.n	800a99e <GetValidity+0x32>
        return ASN_PARSE_E;
 800a998:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800a99c:	e023      	b.n	800a9e6 <GetValidity+0x7a>

    maxIdx = cert->srcIdx + length;
 800a99e:	68fb      	ldr	r3, [r7, #12]
 800a9a0:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800a9a4:	693a      	ldr	r2, [r7, #16]
 800a9a6:	4413      	add	r3, r2
 800a9a8:	607b      	str	r3, [r7, #4]

    if (GetDate(cert, BEFORE, verify, maxIdx) < 0)
 800a9aa:	687b      	ldr	r3, [r7, #4]
 800a9ac:	68ba      	ldr	r2, [r7, #8]
 800a9ae:	2100      	movs	r1, #0
 800a9b0:	68f8      	ldr	r0, [r7, #12]
 800a9b2:	f7ff ff72 	bl	800a89a <GetDate>
 800a9b6:	4603      	mov	r3, r0
 800a9b8:	2b00      	cmp	r3, #0
 800a9ba:	da02      	bge.n	800a9c2 <GetValidity+0x56>
        badDate = ASN_BEFORE_DATE_E; /* continue parsing */
 800a9bc:	f06f 0395 	mvn.w	r3, #149	; 0x95
 800a9c0:	617b      	str	r3, [r7, #20]

    if (GetDate(cert, AFTER, verify, maxIdx) < 0)
 800a9c2:	687b      	ldr	r3, [r7, #4]
 800a9c4:	68ba      	ldr	r2, [r7, #8]
 800a9c6:	2101      	movs	r1, #1
 800a9c8:	68f8      	ldr	r0, [r7, #12]
 800a9ca:	f7ff ff66 	bl	800a89a <GetDate>
 800a9ce:	4603      	mov	r3, r0
 800a9d0:	2b00      	cmp	r3, #0
 800a9d2:	da02      	bge.n	800a9da <GetValidity+0x6e>
        return ASN_AFTER_DATE_E;
 800a9d4:	f06f 0396 	mvn.w	r3, #150	; 0x96
 800a9d8:	e005      	b.n	800a9e6 <GetValidity+0x7a>

    if (badDate != 0)
 800a9da:	697b      	ldr	r3, [r7, #20]
 800a9dc:	2b00      	cmp	r3, #0
 800a9de:	d001      	beq.n	800a9e4 <GetValidity+0x78>
        return badDate;
 800a9e0:	697b      	ldr	r3, [r7, #20]
 800a9e2:	e000      	b.n	800a9e6 <GetValidity+0x7a>

    return 0;
 800a9e4:	2300      	movs	r3, #0
}
 800a9e6:	4618      	mov	r0, r3
 800a9e8:	3718      	adds	r7, #24
 800a9ea:	46bd      	mov	sp, r7
 800a9ec:	bd80      	pop	{r7, pc}

0800a9ee <wc_GetPubX509>:
 * if cert date is invalid then badDate gets set to error value, otherwise is 0
 *
 * returns a negative value on fail case
 */
int wc_GetPubX509(DecodedCert* cert, int verify, int* badDate)
{
 800a9ee:	b580      	push	{r7, lr}
 800a9f0:	b088      	sub	sp, #32
 800a9f2:	af02      	add	r7, sp, #8
 800a9f4:	60f8      	str	r0, [r7, #12]
 800a9f6:	60b9      	str	r1, [r7, #8]
 800a9f8:	607a      	str	r2, [r7, #4]
    int ret;

    if (cert == NULL || badDate == NULL)
 800a9fa:	68fb      	ldr	r3, [r7, #12]
 800a9fc:	2b00      	cmp	r3, #0
 800a9fe:	d002      	beq.n	800aa06 <wc_GetPubX509+0x18>
 800aa00:	687b      	ldr	r3, [r7, #4]
 800aa02:	2b00      	cmp	r3, #0
 800aa04:	d102      	bne.n	800aa0c <wc_GetPubX509+0x1e>
        return BAD_FUNC_ARG;
 800aa06:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800aa0a:	e049      	b.n	800aaa0 <wc_GetPubX509+0xb2>

    *badDate = 0;
 800aa0c:	687b      	ldr	r3, [r7, #4]
 800aa0e:	2200      	movs	r2, #0
 800aa10:	601a      	str	r2, [r3, #0]
    if ( (ret = GetCertHeader(cert)) < 0)
 800aa12:	68f8      	ldr	r0, [r7, #12]
 800aa14:	f7ff fa6f 	bl	8009ef6 <GetCertHeader>
 800aa18:	6178      	str	r0, [r7, #20]
 800aa1a:	697b      	ldr	r3, [r7, #20]
 800aa1c:	2b00      	cmp	r3, #0
 800aa1e:	da01      	bge.n	800aa24 <wc_GetPubX509+0x36>
        return ret;
 800aa20:	697b      	ldr	r3, [r7, #20]
 800aa22:	e03d      	b.n	800aaa0 <wc_GetPubX509+0xb2>
#ifdef WOLFSSL_CERT_REQ
    if (!cert->isCSR) {
#endif
        /* Using the sigIndex as the upper bound because that's where the
         * actual certificate data ends. */
        if ( (ret = GetAlgoId(cert->source, &cert->srcIdx, &cert->signatureOID,
 800aa24:	68fb      	ldr	r3, [r7, #12]
 800aa26:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800aa2a:	68fb      	ldr	r3, [r7, #12]
 800aa2c:	f503 7124 	add.w	r1, r3, #656	; 0x290
 800aa30:	68fb      	ldr	r3, [r7, #12]
 800aa32:	f103 0218 	add.w	r2, r3, #24
 800aa36:	68fb      	ldr	r3, [r7, #12]
 800aa38:	691b      	ldr	r3, [r3, #16]
 800aa3a:	9300      	str	r3, [sp, #0]
 800aa3c:	2301      	movs	r3, #1
 800aa3e:	f7fe fe57 	bl	80096f0 <GetAlgoId>
 800aa42:	6178      	str	r0, [r7, #20]
 800aa44:	697b      	ldr	r3, [r7, #20]
 800aa46:	2b00      	cmp	r3, #0
 800aa48:	da01      	bge.n	800aa4e <wc_GetPubX509+0x60>
                              oidSigType, cert->sigIndex)) < 0)
            return ret;
 800aa4a:	697b      	ldr	r3, [r7, #20]
 800aa4c:	e028      	b.n	800aaa0 <wc_GetPubX509+0xb2>

        WOLFSSL_MSG("Got Algo ID");

        if ( (ret = GetName(cert, ISSUER, cert->sigIndex)) < 0)
 800aa4e:	68fb      	ldr	r3, [r7, #12]
 800aa50:	691b      	ldr	r3, [r3, #16]
 800aa52:	461a      	mov	r2, r3
 800aa54:	2100      	movs	r1, #0
 800aa56:	68f8      	ldr	r0, [r7, #12]
 800aa58:	f7ff fc2e 	bl	800a2b8 <GetName>
 800aa5c:	6178      	str	r0, [r7, #20]
 800aa5e:	697b      	ldr	r3, [r7, #20]
 800aa60:	2b00      	cmp	r3, #0
 800aa62:	da01      	bge.n	800aa68 <wc_GetPubX509+0x7a>
            return ret;
 800aa64:	697b      	ldr	r3, [r7, #20]
 800aa66:	e01b      	b.n	800aaa0 <wc_GetPubX509+0xb2>

        if ( (ret = GetValidity(cert, verify, cert->sigIndex)) < 0)
 800aa68:	68fb      	ldr	r3, [r7, #12]
 800aa6a:	691b      	ldr	r3, [r3, #16]
 800aa6c:	461a      	mov	r2, r3
 800aa6e:	68b9      	ldr	r1, [r7, #8]
 800aa70:	68f8      	ldr	r0, [r7, #12]
 800aa72:	f7ff ff7b 	bl	800a96c <GetValidity>
 800aa76:	6178      	str	r0, [r7, #20]
 800aa78:	697b      	ldr	r3, [r7, #20]
 800aa7a:	2b00      	cmp	r3, #0
 800aa7c:	da02      	bge.n	800aa84 <wc_GetPubX509+0x96>
            *badDate = ret;
 800aa7e:	687b      	ldr	r3, [r7, #4]
 800aa80:	697a      	ldr	r2, [r7, #20]
 800aa82:	601a      	str	r2, [r3, #0]
#ifdef WOLFSSL_CERT_REQ
    }
#endif

    if ( (ret = GetName(cert, SUBJECT, cert->sigIndex)) < 0)
 800aa84:	68fb      	ldr	r3, [r7, #12]
 800aa86:	691b      	ldr	r3, [r3, #16]
 800aa88:	461a      	mov	r2, r3
 800aa8a:	2101      	movs	r1, #1
 800aa8c:	68f8      	ldr	r0, [r7, #12]
 800aa8e:	f7ff fc13 	bl	800a2b8 <GetName>
 800aa92:	6178      	str	r0, [r7, #20]
 800aa94:	697b      	ldr	r3, [r7, #20]
 800aa96:	2b00      	cmp	r3, #0
 800aa98:	da01      	bge.n	800aa9e <wc_GetPubX509+0xb0>
        return ret;
 800aa9a:	697b      	ldr	r3, [r7, #20]
 800aa9c:	e000      	b.n	800aaa0 <wc_GetPubX509+0xb2>

    WOLFSSL_MSG("Got Subject Name");
    return ret;
 800aa9e:	697b      	ldr	r3, [r7, #20]
}
 800aaa0:	4618      	mov	r0, r3
 800aaa2:	3718      	adds	r7, #24
 800aaa4:	46bd      	mov	sp, r7
 800aaa6:	bd80      	pop	{r7, pc}

0800aaa8 <DecodeToKey>:

int DecodeToKey(DecodedCert* cert, int verify)
{
 800aaa8:	b580      	push	{r7, lr}
 800aaaa:	b084      	sub	sp, #16
 800aaac:	af00      	add	r7, sp, #0
 800aaae:	6078      	str	r0, [r7, #4]
 800aab0:	6039      	str	r1, [r7, #0]
    int badDate = 0;
 800aab2:	2300      	movs	r3, #0
 800aab4:	60bb      	str	r3, [r7, #8]
    int ret;

    if ( (ret = wc_GetPubX509(cert, verify, &badDate)) < 0)
 800aab6:	f107 0308 	add.w	r3, r7, #8
 800aaba:	461a      	mov	r2, r3
 800aabc:	6839      	ldr	r1, [r7, #0]
 800aabe:	6878      	ldr	r0, [r7, #4]
 800aac0:	f7ff ff95 	bl	800a9ee <wc_GetPubX509>
 800aac4:	60f8      	str	r0, [r7, #12]
 800aac6:	68fb      	ldr	r3, [r7, #12]
 800aac8:	2b00      	cmp	r3, #0
 800aaca:	da01      	bge.n	800aad0 <DecodeToKey+0x28>
        return ret;
 800aacc:	68fb      	ldr	r3, [r7, #12]
 800aace:	e024      	b.n	800ab1a <DecodeToKey+0x72>

    /* Determine if self signed */
    cert->selfSigned = XMEMCMP(cert->issuerHash,
 800aad0:	687b      	ldr	r3, [r7, #4]
 800aad2:	f103 0058 	add.w	r0, r3, #88	; 0x58
 800aad6:	687b      	ldr	r3, [r7, #4]
 800aad8:	3338      	adds	r3, #56	; 0x38
 800aada:	2220      	movs	r2, #32
 800aadc:	4619      	mov	r1, r3
 800aade:	f00e fc7b 	bl	80193d8 <memcmp>
 800aae2:	4603      	mov	r3, r0
                               cert->subjectHash,
                               KEYID_SIZE) == 0 ? 1 : 0;
 800aae4:	2b00      	cmp	r3, #0
 800aae6:	bf0c      	ite	eq
 800aae8:	2301      	moveq	r3, #1
 800aaea:	2300      	movne	r3, #0
 800aaec:	b2d9      	uxtb	r1, r3
    cert->selfSigned = XMEMCMP(cert->issuerHash,
 800aaee:	687a      	ldr	r2, [r7, #4]
 800aaf0:	f892 3379 	ldrb.w	r3, [r2, #889]	; 0x379
 800aaf4:	f361 1386 	bfi	r3, r1, #6, #1
 800aaf8:	f882 3379 	strb.w	r3, [r2, #889]	; 0x379

    if ( (ret = GetKey(cert)) < 0)
 800aafc:	6878      	ldr	r0, [r7, #4]
 800aafe:	f7ff fade 	bl	800a0be <GetKey>
 800ab02:	60f8      	str	r0, [r7, #12]
 800ab04:	68fb      	ldr	r3, [r7, #12]
 800ab06:	2b00      	cmp	r3, #0
 800ab08:	da01      	bge.n	800ab0e <DecodeToKey+0x66>
        return ret;
 800ab0a:	68fb      	ldr	r3, [r7, #12]
 800ab0c:	e005      	b.n	800ab1a <DecodeToKey+0x72>

    WOLFSSL_MSG("Got Key");

    if (badDate != 0)
 800ab0e:	68bb      	ldr	r3, [r7, #8]
 800ab10:	2b00      	cmp	r3, #0
 800ab12:	d001      	beq.n	800ab18 <DecodeToKey+0x70>
        return badDate;
 800ab14:	68bb      	ldr	r3, [r7, #8]
 800ab16:	e000      	b.n	800ab1a <DecodeToKey+0x72>

    return ret;
 800ab18:	68fb      	ldr	r3, [r7, #12]
}
 800ab1a:	4618      	mov	r0, r3
 800ab1c:	3710      	adds	r7, #16
 800ab1e:	46bd      	mov	sp, r7
 800ab20:	bd80      	pop	{r7, pc}

0800ab22 <GetSignature>:

static int GetSignature(DecodedCert* cert)
{
 800ab22:	b590      	push	{r4, r7, lr}
 800ab24:	b087      	sub	sp, #28
 800ab26:	af02      	add	r7, sp, #8
 800ab28:	6078      	str	r0, [r7, #4]
    int length;
    int ret;

    ret = CheckBitString(cert->source, &cert->srcIdx, &length, cert->maxIdx, 1,
 800ab2a:	687b      	ldr	r3, [r7, #4]
 800ab2c:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800ab30:	687b      	ldr	r3, [r7, #4]
 800ab32:	f503 7124 	add.w	r1, r3, #656	; 0x290
 800ab36:	687b      	ldr	r3, [r7, #4]
 800ab38:	f8d3 4294 	ldr.w	r4, [r3, #660]	; 0x294
 800ab3c:	f107 0208 	add.w	r2, r7, #8
 800ab40:	2300      	movs	r3, #0
 800ab42:	9301      	str	r3, [sp, #4]
 800ab44:	2301      	movs	r3, #1
 800ab46:	9300      	str	r3, [sp, #0]
 800ab48:	4623      	mov	r3, r4
 800ab4a:	f7fe f938 	bl	8008dbe <CheckBitString>
 800ab4e:	60f8      	str	r0, [r7, #12]
                         NULL);
    if (ret != 0)
 800ab50:	68fb      	ldr	r3, [r7, #12]
 800ab52:	2b00      	cmp	r3, #0
 800ab54:	d001      	beq.n	800ab5a <GetSignature+0x38>
        return ret;
 800ab56:	68fb      	ldr	r3, [r7, #12]
 800ab58:	e021      	b.n	800ab9e <GetSignature+0x7c>

    cert->sigLength = length;
 800ab5a:	68bb      	ldr	r3, [r7, #8]
 800ab5c:	461a      	mov	r2, r3
 800ab5e:	687b      	ldr	r3, [r7, #4]
 800ab60:	615a      	str	r2, [r3, #20]
    cert->signature = &cert->source[cert->srcIdx];
 800ab62:	687b      	ldr	r3, [r7, #4]
 800ab64:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 800ab68:	687b      	ldr	r3, [r7, #4]
 800ab6a:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800ab6e:	441a      	add	r2, r3
 800ab70:	687b      	ldr	r3, [r7, #4]
 800ab72:	679a      	str	r2, [r3, #120]	; 0x78
    cert->srcIdx += cert->sigLength;
 800ab74:	687b      	ldr	r3, [r7, #4]
 800ab76:	f8d3 2290 	ldr.w	r2, [r3, #656]	; 0x290
 800ab7a:	687b      	ldr	r3, [r7, #4]
 800ab7c:	695b      	ldr	r3, [r3, #20]
 800ab7e:	441a      	add	r2, r3
 800ab80:	687b      	ldr	r3, [r7, #4]
 800ab82:	f8c3 2290 	str.w	r2, [r3, #656]	; 0x290

    if (cert->srcIdx != cert->maxIdx)
 800ab86:	687b      	ldr	r3, [r7, #4]
 800ab88:	f8d3 2290 	ldr.w	r2, [r3, #656]	; 0x290
 800ab8c:	687b      	ldr	r3, [r7, #4]
 800ab8e:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 800ab92:	429a      	cmp	r2, r3
 800ab94:	d002      	beq.n	800ab9c <GetSignature+0x7a>
        return ASN_PARSE_E;
 800ab96:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800ab9a:	e000      	b.n	800ab9e <GetSignature+0x7c>

    return 0;
 800ab9c:	2300      	movs	r3, #0
}
 800ab9e:	4618      	mov	r0, r3
 800aba0:	3714      	adds	r7, #20
 800aba2:	46bd      	mov	sp, r7
 800aba4:	bd90      	pop	{r4, r7, pc}

0800aba6 <SetOctetString8Bit>:

static word32 SetOctetString8Bit(word32 len, byte* output)
{
 800aba6:	b480      	push	{r7}
 800aba8:	b083      	sub	sp, #12
 800abaa:	af00      	add	r7, sp, #0
 800abac:	6078      	str	r0, [r7, #4]
 800abae:	6039      	str	r1, [r7, #0]
    output[0] = ASN_OCTET_STRING;
 800abb0:	683b      	ldr	r3, [r7, #0]
 800abb2:	2204      	movs	r2, #4
 800abb4:	701a      	strb	r2, [r3, #0]
    output[1] = (byte)len;
 800abb6:	683b      	ldr	r3, [r7, #0]
 800abb8:	3301      	adds	r3, #1
 800abba:	687a      	ldr	r2, [r7, #4]
 800abbc:	b2d2      	uxtb	r2, r2
 800abbe:	701a      	strb	r2, [r3, #0]
    return 2;
 800abc0:	2302      	movs	r3, #2
}
 800abc2:	4618      	mov	r0, r3
 800abc4:	370c      	adds	r7, #12
 800abc6:	46bd      	mov	sp, r7
 800abc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800abcc:	4770      	bx	lr

0800abce <SetDigest>:

static word32 SetDigest(const byte* digest, word32 digSz, byte* output)
{
 800abce:	b580      	push	{r7, lr}
 800abd0:	b086      	sub	sp, #24
 800abd2:	af00      	add	r7, sp, #0
 800abd4:	60f8      	str	r0, [r7, #12]
 800abd6:	60b9      	str	r1, [r7, #8]
 800abd8:	607a      	str	r2, [r7, #4]
    word32 idx = SetOctetString8Bit(digSz, output);
 800abda:	6879      	ldr	r1, [r7, #4]
 800abdc:	68b8      	ldr	r0, [r7, #8]
 800abde:	f7ff ffe2 	bl	800aba6 <SetOctetString8Bit>
 800abe2:	6178      	str	r0, [r7, #20]
    XMEMCPY(&output[idx], digest, digSz);
 800abe4:	687a      	ldr	r2, [r7, #4]
 800abe6:	697b      	ldr	r3, [r7, #20]
 800abe8:	4413      	add	r3, r2
 800abea:	68ba      	ldr	r2, [r7, #8]
 800abec:	68f9      	ldr	r1, [r7, #12]
 800abee:	4618      	mov	r0, r3
 800abf0:	f00e fc01 	bl	80193f6 <memcpy>

    return idx + digSz;
 800abf4:	697a      	ldr	r2, [r7, #20]
 800abf6:	68bb      	ldr	r3, [r7, #8]
 800abf8:	4413      	add	r3, r2
}
 800abfa:	4618      	mov	r0, r3
 800abfc:	3718      	adds	r7, #24
 800abfe:	46bd      	mov	sp, r7
 800ac00:	bd80      	pop	{r7, pc}

0800ac02 <BytePrecision>:


static word32 BytePrecision(word32 value)
{
 800ac02:	b480      	push	{r7}
 800ac04:	b085      	sub	sp, #20
 800ac06:	af00      	add	r7, sp, #0
 800ac08:	6078      	str	r0, [r7, #4]
    word32 i;
    for (i = sizeof(value); i; --i)
 800ac0a:	2304      	movs	r3, #4
 800ac0c:	60fb      	str	r3, [r7, #12]
 800ac0e:	e00c      	b.n	800ac2a <BytePrecision+0x28>
        if (value >> ((i - 1) * WOLFSSL_BIT_SIZE))
 800ac10:	68fb      	ldr	r3, [r7, #12]
 800ac12:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800ac16:	3b01      	subs	r3, #1
 800ac18:	00db      	lsls	r3, r3, #3
 800ac1a:	687a      	ldr	r2, [r7, #4]
 800ac1c:	fa22 f303 	lsr.w	r3, r2, r3
 800ac20:	2b00      	cmp	r3, #0
 800ac22:	d106      	bne.n	800ac32 <BytePrecision+0x30>
    for (i = sizeof(value); i; --i)
 800ac24:	68fb      	ldr	r3, [r7, #12]
 800ac26:	3b01      	subs	r3, #1
 800ac28:	60fb      	str	r3, [r7, #12]
 800ac2a:	68fb      	ldr	r3, [r7, #12]
 800ac2c:	2b00      	cmp	r3, #0
 800ac2e:	d1ef      	bne.n	800ac10 <BytePrecision+0xe>
 800ac30:	e000      	b.n	800ac34 <BytePrecision+0x32>
            break;
 800ac32:	bf00      	nop

    return i;
 800ac34:	68fb      	ldr	r3, [r7, #12]
}
 800ac36:	4618      	mov	r0, r3
 800ac38:	3714      	adds	r7, #20
 800ac3a:	46bd      	mov	sp, r7
 800ac3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ac40:	4770      	bx	lr

0800ac42 <SetLength>:


word32 SetLength(word32 length, byte* output)
{
 800ac42:	b580      	push	{r7, lr}
 800ac44:	b084      	sub	sp, #16
 800ac46:	af00      	add	r7, sp, #0
 800ac48:	6078      	str	r0, [r7, #4]
 800ac4a:	6039      	str	r1, [r7, #0]
    word32 i = 0, j;
 800ac4c:	2300      	movs	r3, #0
 800ac4e:	60fb      	str	r3, [r7, #12]

    if (length < ASN_LONG_LENGTH) {
 800ac50:	687b      	ldr	r3, [r7, #4]
 800ac52:	2b7f      	cmp	r3, #127	; 0x7f
 800ac54:	d80c      	bhi.n	800ac70 <SetLength+0x2e>
        if (output)
 800ac56:	683b      	ldr	r3, [r7, #0]
 800ac58:	2b00      	cmp	r3, #0
 800ac5a:	d005      	beq.n	800ac68 <SetLength+0x26>
            output[i] = (byte)length;
 800ac5c:	683a      	ldr	r2, [r7, #0]
 800ac5e:	68fb      	ldr	r3, [r7, #12]
 800ac60:	4413      	add	r3, r2
 800ac62:	687a      	ldr	r2, [r7, #4]
 800ac64:	b2d2      	uxtb	r2, r2
 800ac66:	701a      	strb	r2, [r3, #0]
        i++;
 800ac68:	68fb      	ldr	r3, [r7, #12]
 800ac6a:	3301      	adds	r3, #1
 800ac6c:	60fb      	str	r3, [r7, #12]
 800ac6e:	e02f      	b.n	800acd0 <SetLength+0x8e>
    }
    else {
        if (output)
 800ac70:	683b      	ldr	r3, [r7, #0]
 800ac72:	2b00      	cmp	r3, #0
 800ac74:	d00b      	beq.n	800ac8e <SetLength+0x4c>
            output[i] = (byte)(BytePrecision(length) | ASN_LONG_LENGTH);
 800ac76:	6878      	ldr	r0, [r7, #4]
 800ac78:	f7ff ffc3 	bl	800ac02 <BytePrecision>
 800ac7c:	4603      	mov	r3, r0
 800ac7e:	b2da      	uxtb	r2, r3
 800ac80:	6839      	ldr	r1, [r7, #0]
 800ac82:	68fb      	ldr	r3, [r7, #12]
 800ac84:	440b      	add	r3, r1
 800ac86:	f062 027f 	orn	r2, r2, #127	; 0x7f
 800ac8a:	b2d2      	uxtb	r2, r2
 800ac8c:	701a      	strb	r2, [r3, #0]
        i++;
 800ac8e:	68fb      	ldr	r3, [r7, #12]
 800ac90:	3301      	adds	r3, #1
 800ac92:	60fb      	str	r3, [r7, #12]

        for (j = BytePrecision(length); j; --j) {
 800ac94:	6878      	ldr	r0, [r7, #4]
 800ac96:	f7ff ffb4 	bl	800ac02 <BytePrecision>
 800ac9a:	60b8      	str	r0, [r7, #8]
 800ac9c:	e015      	b.n	800acca <SetLength+0x88>
            if (output)
 800ac9e:	683b      	ldr	r3, [r7, #0]
 800aca0:	2b00      	cmp	r3, #0
 800aca2:	d00c      	beq.n	800acbe <SetLength+0x7c>
                output[i] = (byte)(length >> ((j - 1) * WOLFSSL_BIT_SIZE));
 800aca4:	68bb      	ldr	r3, [r7, #8]
 800aca6:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800acaa:	3b01      	subs	r3, #1
 800acac:	00db      	lsls	r3, r3, #3
 800acae:	687a      	ldr	r2, [r7, #4]
 800acb0:	fa22 f103 	lsr.w	r1, r2, r3
 800acb4:	683a      	ldr	r2, [r7, #0]
 800acb6:	68fb      	ldr	r3, [r7, #12]
 800acb8:	4413      	add	r3, r2
 800acba:	b2ca      	uxtb	r2, r1
 800acbc:	701a      	strb	r2, [r3, #0]
            i++;
 800acbe:	68fb      	ldr	r3, [r7, #12]
 800acc0:	3301      	adds	r3, #1
 800acc2:	60fb      	str	r3, [r7, #12]
        for (j = BytePrecision(length); j; --j) {
 800acc4:	68bb      	ldr	r3, [r7, #8]
 800acc6:	3b01      	subs	r3, #1
 800acc8:	60bb      	str	r3, [r7, #8]
 800acca:	68bb      	ldr	r3, [r7, #8]
 800accc:	2b00      	cmp	r3, #0
 800acce:	d1e6      	bne.n	800ac9e <SetLength+0x5c>
        }
    }

    return i;
 800acd0:	68fb      	ldr	r3, [r7, #12]
}
 800acd2:	4618      	mov	r0, r3
 800acd4:	3710      	adds	r7, #16
 800acd6:	46bd      	mov	sp, r7
 800acd8:	bd80      	pop	{r7, pc}

0800acda <SetSequence>:

word32 SetSequence(word32 len, byte* output)
{
 800acda:	b580      	push	{r7, lr}
 800acdc:	b082      	sub	sp, #8
 800acde:	af00      	add	r7, sp, #0
 800ace0:	6078      	str	r0, [r7, #4]
 800ace2:	6039      	str	r1, [r7, #0]
    if (output)
 800ace4:	683b      	ldr	r3, [r7, #0]
 800ace6:	2b00      	cmp	r3, #0
 800ace8:	d002      	beq.n	800acf0 <SetSequence+0x16>
        output[0] = ASN_SEQUENCE | ASN_CONSTRUCTED;
 800acea:	683b      	ldr	r3, [r7, #0]
 800acec:	2230      	movs	r2, #48	; 0x30
 800acee:	701a      	strb	r2, [r3, #0]
    return SetLength(len, output ? output + 1 : NULL) + 1;
 800acf0:	683b      	ldr	r3, [r7, #0]
 800acf2:	2b00      	cmp	r3, #0
 800acf4:	d002      	beq.n	800acfc <SetSequence+0x22>
 800acf6:	683b      	ldr	r3, [r7, #0]
 800acf8:	3301      	adds	r3, #1
 800acfa:	e000      	b.n	800acfe <SetSequence+0x24>
 800acfc:	2300      	movs	r3, #0
 800acfe:	4619      	mov	r1, r3
 800ad00:	6878      	ldr	r0, [r7, #4]
 800ad02:	f7ff ff9e 	bl	800ac42 <SetLength>
 800ad06:	4603      	mov	r3, r0
 800ad08:	3301      	adds	r3, #1
}
 800ad0a:	4618      	mov	r0, r3
 800ad0c:	3708      	adds	r7, #8
 800ad0e:	46bd      	mov	sp, r7
 800ad10:	bd80      	pop	{r7, pc}

0800ad12 <IsSigAlgoECDSA>:
#endif /* HAVE_ECC && HAVE_ECC_KEY_EXPORT */


#ifdef HAVE_ECC
static WC_INLINE int IsSigAlgoECDSA(int algoOID)
{
 800ad12:	b480      	push	{r7}
 800ad14:	b083      	sub	sp, #12
 800ad16:	af00      	add	r7, sp, #0
 800ad18:	6078      	str	r0, [r7, #4]
    /* ECDSA sigAlgo must not have ASN1 NULL parameters */
    if (algoOID == CTC_SHAwECDSA || algoOID == CTC_SHA256wECDSA ||
 800ad1a:	687b      	ldr	r3, [r7, #4]
 800ad1c:	f5b3 7f02 	cmp.w	r3, #520	; 0x208
 800ad20:	d00d      	beq.n	800ad3e <IsSigAlgoECDSA+0x2c>
 800ad22:	687b      	ldr	r3, [r7, #4]
 800ad24:	f5b3 7f03 	cmp.w	r3, #524	; 0x20c
 800ad28:	d009      	beq.n	800ad3e <IsSigAlgoECDSA+0x2c>
 800ad2a:	687b      	ldr	r3, [r7, #4]
 800ad2c:	f240 220d 	movw	r2, #525	; 0x20d
 800ad30:	4293      	cmp	r3, r2
 800ad32:	d004      	beq.n	800ad3e <IsSigAlgoECDSA+0x2c>
        algoOID == CTC_SHA384wECDSA || algoOID == CTC_SHA512wECDSA) {
 800ad34:	687b      	ldr	r3, [r7, #4]
 800ad36:	f240 220e 	movw	r2, #526	; 0x20e
 800ad3a:	4293      	cmp	r3, r2
 800ad3c:	d101      	bne.n	800ad42 <IsSigAlgoECDSA+0x30>
        return 1;
 800ad3e:	2301      	movs	r3, #1
 800ad40:	e000      	b.n	800ad44 <IsSigAlgoECDSA+0x32>
    }

    return 0;
 800ad42:	2300      	movs	r3, #0
}
 800ad44:	4618      	mov	r0, r3
 800ad46:	370c      	adds	r7, #12
 800ad48:	46bd      	mov	sp, r7
 800ad4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ad4e:	4770      	bx	lr

0800ad50 <SetAlgoID>:
#endif

word32 SetAlgoID(int algoOID, byte* output, int type, int curveSz)
{
 800ad50:	b580      	push	{r7, lr}
 800ad52:	b08e      	sub	sp, #56	; 0x38
 800ad54:	af00      	add	r7, sp, #0
 800ad56:	60f8      	str	r0, [r7, #12]
 800ad58:	60b9      	str	r1, [r7, #8]
 800ad5a:	607a      	str	r2, [r7, #4]
 800ad5c:	603b      	str	r3, [r7, #0]
    word32 tagSz, idSz, seqSz, algoSz = 0;
 800ad5e:	2300      	movs	r3, #0
 800ad60:	623b      	str	r3, [r7, #32]
    const  byte* algoName = 0;
 800ad62:	2300      	movs	r3, #0
 800ad64:	633b      	str	r3, [r7, #48]	; 0x30
    byte   ID_Length[1 + MAX_LENGTH_SZ];
    byte   seqArray[MAX_SEQ_SZ + 1];  /* add object_id to end */
    int    length = 0;
 800ad66:	2300      	movs	r3, #0
 800ad68:	637b      	str	r3, [r7, #52]	; 0x34
        #endif
        #ifdef HAVE_ED448
              && algoOID != ED448k
        #endif
              ) ||
             (type == oidKeyType && algoOID == RSAk)) ? 2 : 0;
 800ad6a:	687b      	ldr	r3, [r7, #4]
 800ad6c:	2b00      	cmp	r3, #0
 800ad6e:	d010      	beq.n	800ad92 <SetAlgoID+0x42>
    tagSz = (type == oidHashType ||
 800ad70:	687b      	ldr	r3, [r7, #4]
 800ad72:	2b01      	cmp	r3, #1
 800ad74:	d105      	bne.n	800ad82 <SetAlgoID+0x32>
              && !IsSigAlgoECDSA(algoOID)
 800ad76:	68f8      	ldr	r0, [r7, #12]
 800ad78:	f7ff ffcb 	bl	800ad12 <IsSigAlgoECDSA>
 800ad7c:	4603      	mov	r3, r0
 800ad7e:	2b00      	cmp	r3, #0
 800ad80:	d007      	beq.n	800ad92 <SetAlgoID+0x42>
              ) ||
 800ad82:	687b      	ldr	r3, [r7, #4]
 800ad84:	2b02      	cmp	r3, #2
 800ad86:	d106      	bne.n	800ad96 <SetAlgoID+0x46>
             (type == oidKeyType && algoOID == RSAk)) ? 2 : 0;
 800ad88:	68fb      	ldr	r3, [r7, #12]
 800ad8a:	f240 2285 	movw	r2, #645	; 0x285
 800ad8e:	4293      	cmp	r3, r2
 800ad90:	d101      	bne.n	800ad96 <SetAlgoID+0x46>
 800ad92:	2302      	movs	r3, #2
 800ad94:	e000      	b.n	800ad98 <SetAlgoID+0x48>
 800ad96:	2300      	movs	r3, #0
    tagSz = (type == oidHashType ||
 800ad98:	62fb      	str	r3, [r7, #44]	; 0x2c

    algoName = OidFromId(algoOID, type, &algoSz);
 800ad9a:	68fb      	ldr	r3, [r7, #12]
 800ad9c:	6879      	ldr	r1, [r7, #4]
 800ad9e:	f107 0220 	add.w	r2, r7, #32
 800ada2:	4618      	mov	r0, r3
 800ada4:	f7fe f88a 	bl	8008ebc <OidFromId>
 800ada8:	6338      	str	r0, [r7, #48]	; 0x30

    if (algoName == NULL) {
 800adaa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800adac:	2b00      	cmp	r3, #0
 800adae:	d101      	bne.n	800adb4 <SetAlgoID+0x64>
        WOLFSSL_MSG("Unknown Algorithm");
        return 0;
 800adb0:	2300      	movs	r3, #0
 800adb2:	e07b      	b.n	800aeac <SetAlgoID+0x15c>
    }

    idSz  = SetObjectId(algoSz, ID_Length);
 800adb4:	6a3b      	ldr	r3, [r7, #32]
 800adb6:	461a      	mov	r2, r3
 800adb8:	f107 0318 	add.w	r3, r7, #24
 800adbc:	4619      	mov	r1, r3
 800adbe:	4610      	mov	r0, r2
 800adc0:	f7fe fbe5 	bl	800958e <SetObjectId>
 800adc4:	4603      	mov	r3, r0
 800adc6:	62bb      	str	r3, [r7, #40]	; 0x28
    seqSz = SetSequence(idSz + algoSz + tagSz + curveSz, seqArray);
 800adc8:	6a3a      	ldr	r2, [r7, #32]
 800adca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800adcc:	441a      	add	r2, r3
 800adce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800add0:	441a      	add	r2, r3
 800add2:	683b      	ldr	r3, [r7, #0]
 800add4:	4413      	add	r3, r2
 800add6:	f107 0210 	add.w	r2, r7, #16
 800adda:	4611      	mov	r1, r2
 800addc:	4618      	mov	r0, r3
 800adde:	f7ff ff7c 	bl	800acda <SetSequence>
 800ade2:	6278      	str	r0, [r7, #36]	; 0x24

    /* Copy only algo to output for DSA keys */
    if (algoOID == DSAk && output) {
 800ade4:	68fb      	ldr	r3, [r7, #12]
 800ade6:	f240 2203 	movw	r2, #515	; 0x203
 800adea:	4293      	cmp	r3, r2
 800adec:	d11f      	bne.n	800ae2e <SetAlgoID+0xde>
 800adee:	68bb      	ldr	r3, [r7, #8]
 800adf0:	2b00      	cmp	r3, #0
 800adf2:	d01c      	beq.n	800ae2e <SetAlgoID+0xde>
        XMEMCPY(output, ID_Length, idSz);
 800adf4:	f107 0318 	add.w	r3, r7, #24
 800adf8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800adfa:	4619      	mov	r1, r3
 800adfc:	68b8      	ldr	r0, [r7, #8]
 800adfe:	f00e fafa 	bl	80193f6 <memcpy>
        XMEMCPY(output + idSz, algoName, algoSz);
 800ae02:	68ba      	ldr	r2, [r7, #8]
 800ae04:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ae06:	4413      	add	r3, r2
 800ae08:	6a3a      	ldr	r2, [r7, #32]
 800ae0a:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800ae0c:	4618      	mov	r0, r3
 800ae0e:	f00e faf2 	bl	80193f6 <memcpy>
        if (tagSz == 2)
 800ae12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae14:	2b02      	cmp	r3, #2
 800ae16:	d134      	bne.n	800ae82 <SetAlgoID+0x132>
            SetASNNull(&output[seqSz + idSz + algoSz]);
 800ae18:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800ae1a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ae1c:	441a      	add	r2, r3
 800ae1e:	6a3b      	ldr	r3, [r7, #32]
 800ae20:	4413      	add	r3, r2
 800ae22:	68ba      	ldr	r2, [r7, #8]
 800ae24:	4413      	add	r3, r2
 800ae26:	4618      	mov	r0, r3
 800ae28:	f7fd fe0d 	bl	8008a46 <SetASNNull>
        if (tagSz == 2)
 800ae2c:	e029      	b.n	800ae82 <SetAlgoID+0x132>
    }
    else if (output) {
 800ae2e:	68bb      	ldr	r3, [r7, #8]
 800ae30:	2b00      	cmp	r3, #0
 800ae32:	d026      	beq.n	800ae82 <SetAlgoID+0x132>
        XMEMCPY(output, seqArray, seqSz);
 800ae34:	f107 0310 	add.w	r3, r7, #16
 800ae38:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800ae3a:	4619      	mov	r1, r3
 800ae3c:	68b8      	ldr	r0, [r7, #8]
 800ae3e:	f00e fada 	bl	80193f6 <memcpy>
        XMEMCPY(output + seqSz, ID_Length, idSz);
 800ae42:	68ba      	ldr	r2, [r7, #8]
 800ae44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ae46:	4413      	add	r3, r2
 800ae48:	f107 0118 	add.w	r1, r7, #24
 800ae4c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800ae4e:	4618      	mov	r0, r3
 800ae50:	f00e fad1 	bl	80193f6 <memcpy>
        XMEMCPY(output + seqSz + idSz, algoName, algoSz);
 800ae54:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800ae56:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ae58:	4413      	add	r3, r2
 800ae5a:	68ba      	ldr	r2, [r7, #8]
 800ae5c:	4413      	add	r3, r2
 800ae5e:	6a3a      	ldr	r2, [r7, #32]
 800ae60:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800ae62:	4618      	mov	r0, r3
 800ae64:	f00e fac7 	bl	80193f6 <memcpy>
        if (tagSz == 2)
 800ae68:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae6a:	2b02      	cmp	r3, #2
 800ae6c:	d109      	bne.n	800ae82 <SetAlgoID+0x132>
            SetASNNull(&output[seqSz + idSz + algoSz]);
 800ae6e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800ae70:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ae72:	441a      	add	r2, r3
 800ae74:	6a3b      	ldr	r3, [r7, #32]
 800ae76:	4413      	add	r3, r2
 800ae78:	68ba      	ldr	r2, [r7, #8]
 800ae7a:	4413      	add	r3, r2
 800ae7c:	4618      	mov	r0, r3
 800ae7e:	f7fd fde2 	bl	8008a46 <SetASNNull>
    }

    if (algoOID == DSAk)
 800ae82:	68fb      	ldr	r3, [r7, #12]
 800ae84:	f240 2203 	movw	r2, #515	; 0x203
 800ae88:	4293      	cmp	r3, r2
 800ae8a:	d106      	bne.n	800ae9a <SetAlgoID+0x14a>
        length = idSz + algoSz + tagSz;
 800ae8c:	6a3a      	ldr	r2, [r7, #32]
 800ae8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ae90:	441a      	add	r2, r3
 800ae92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae94:	4413      	add	r3, r2
 800ae96:	637b      	str	r3, [r7, #52]	; 0x34
 800ae98:	e007      	b.n	800aeaa <SetAlgoID+0x15a>
    else
        length = seqSz + idSz + algoSz + tagSz;
 800ae9a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800ae9c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ae9e:	441a      	add	r2, r3
 800aea0:	6a3b      	ldr	r3, [r7, #32]
 800aea2:	441a      	add	r2, r3
 800aea4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800aea6:	4413      	add	r3, r2
 800aea8:	637b      	str	r3, [r7, #52]	; 0x34

    return length;
 800aeaa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 800aeac:	4618      	mov	r0, r3
 800aeae:	3738      	adds	r7, #56	; 0x38
 800aeb0:	46bd      	mov	sp, r7
 800aeb2:	bd80      	pop	{r7, pc}

0800aeb4 <wc_EncodeSignature>:


word32 wc_EncodeSignature(byte* out, const byte* digest, word32 digSz,
                          int hashOID)
{
 800aeb4:	b580      	push	{r7, lr}
 800aeb6:	b0a2      	sub	sp, #136	; 0x88
 800aeb8:	af00      	add	r7, sp, #0
 800aeba:	60f8      	str	r0, [r7, #12]
 800aebc:	60b9      	str	r1, [r7, #8]
 800aebe:	607a      	str	r2, [r7, #4]
 800aec0:	603b      	str	r3, [r7, #0]
    byte digArray[MAX_ENCODED_DIG_SZ];
    byte algoArray[MAX_ALGO_SZ];
    byte seqArray[MAX_SEQ_SZ];
    word32 encDigSz, algoSz, seqSz;

    encDigSz = SetDigest(digest, digSz, digArray);
 800aec2:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800aec6:	461a      	mov	r2, r3
 800aec8:	6879      	ldr	r1, [r7, #4]
 800aeca:	68b8      	ldr	r0, [r7, #8]
 800aecc:	f7ff fe7f 	bl	800abce <SetDigest>
 800aed0:	f8c7 0084 	str.w	r0, [r7, #132]	; 0x84
    algoSz   = SetAlgoID(hashOID, algoArray, oidHashType, 0);
 800aed4:	f107 011c 	add.w	r1, r7, #28
 800aed8:	2300      	movs	r3, #0
 800aeda:	2200      	movs	r2, #0
 800aedc:	6838      	ldr	r0, [r7, #0]
 800aede:	f7ff ff37 	bl	800ad50 <SetAlgoID>
 800aee2:	f8c7 0080 	str.w	r0, [r7, #128]	; 0x80
    seqSz    = SetSequence(encDigSz + algoSz, seqArray);
 800aee6:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800aeea:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800aeee:	4413      	add	r3, r2
 800aef0:	f107 0214 	add.w	r2, r7, #20
 800aef4:	4611      	mov	r1, r2
 800aef6:	4618      	mov	r0, r3
 800aef8:	f7ff feef 	bl	800acda <SetSequence>
 800aefc:	67f8      	str	r0, [r7, #124]	; 0x7c

    XMEMCPY(out, seqArray, seqSz);
 800aefe:	f107 0314 	add.w	r3, r7, #20
 800af02:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800af04:	4619      	mov	r1, r3
 800af06:	68f8      	ldr	r0, [r7, #12]
 800af08:	f00e fa75 	bl	80193f6 <memcpy>
    XMEMCPY(out + seqSz, algoArray, algoSz);
 800af0c:	68fa      	ldr	r2, [r7, #12]
 800af0e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800af10:	4413      	add	r3, r2
 800af12:	f107 011c 	add.w	r1, r7, #28
 800af16:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800af1a:	4618      	mov	r0, r3
 800af1c:	f00e fa6b 	bl	80193f6 <memcpy>
    XMEMCPY(out + seqSz + algoSz, digArray, encDigSz);
 800af20:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800af22:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800af26:	4413      	add	r3, r2
 800af28:	68fa      	ldr	r2, [r7, #12]
 800af2a:	4413      	add	r3, r2
 800af2c:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800af30:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800af34:	4618      	mov	r0, r3
 800af36:	f00e fa5e 	bl	80193f6 <memcpy>

    return encDigSz + algoSz + seqSz;
 800af3a:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800af3e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800af42:	441a      	add	r2, r3
 800af44:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800af46:	4413      	add	r3, r2
}
 800af48:	4618      	mov	r0, r3
 800af4a:	3788      	adds	r7, #136	; 0x88
 800af4c:	46bd      	mov	sp, r7
 800af4e:	bd80      	pop	{r7, pc}

0800af50 <InitSignatureCtx>:

    return ret;
}

void InitSignatureCtx(SignatureCtx* sigCtx, void* heap, int devId)
{
 800af50:	b580      	push	{r7, lr}
 800af52:	b084      	sub	sp, #16
 800af54:	af00      	add	r7, sp, #0
 800af56:	60f8      	str	r0, [r7, #12]
 800af58:	60b9      	str	r1, [r7, #8]
 800af5a:	607a      	str	r2, [r7, #4]
    if (sigCtx) {
 800af5c:	68fb      	ldr	r3, [r7, #12]
 800af5e:	2b00      	cmp	r3, #0
 800af60:	d00a      	beq.n	800af78 <InitSignatureCtx+0x28>
        XMEMSET(sigCtx, 0, sizeof(SignatureCtx));
 800af62:	222c      	movs	r2, #44	; 0x2c
 800af64:	2100      	movs	r1, #0
 800af66:	68f8      	ldr	r0, [r7, #12]
 800af68:	f00e fa69 	bl	801943e <memset>
        sigCtx->devId = devId;
 800af6c:	68fb      	ldr	r3, [r7, #12]
 800af6e:	687a      	ldr	r2, [r7, #4]
 800af70:	619a      	str	r2, [r3, #24]
        sigCtx->heap = heap;
 800af72:	68fb      	ldr	r3, [r7, #12]
 800af74:	68ba      	ldr	r2, [r7, #8]
 800af76:	601a      	str	r2, [r3, #0]
    }
}
 800af78:	bf00      	nop
 800af7a:	3710      	adds	r7, #16
 800af7c:	46bd      	mov	sp, r7
 800af7e:	bd80      	pop	{r7, pc}

0800af80 <FreeSignatureCtx>:

void FreeSignatureCtx(SignatureCtx* sigCtx)
{
 800af80:	b580      	push	{r7, lr}
 800af82:	b086      	sub	sp, #24
 800af84:	af00      	add	r7, sp, #0
 800af86:	6078      	str	r0, [r7, #4]
    if (sigCtx == NULL)
 800af88:	687b      	ldr	r3, [r7, #4]
 800af8a:	2b00      	cmp	r3, #0
 800af8c:	d056      	beq.n	800b03c <FreeSignatureCtx+0xbc>
        return;

    if (sigCtx->digest) {
 800af8e:	687b      	ldr	r3, [r7, #4]
 800af90:	685b      	ldr	r3, [r3, #4]
 800af92:	2b00      	cmp	r3, #0
 800af94:	d00b      	beq.n	800afae <FreeSignatureCtx+0x2e>
        XFREE(sigCtx->digest, sigCtx->heap, DYNAMIC_TYPE_DIGEST);
 800af96:	687b      	ldr	r3, [r7, #4]
 800af98:	685b      	ldr	r3, [r3, #4]
 800af9a:	617b      	str	r3, [r7, #20]
 800af9c:	697b      	ldr	r3, [r7, #20]
 800af9e:	2b00      	cmp	r3, #0
 800afa0:	d002      	beq.n	800afa8 <FreeSignatureCtx+0x28>
 800afa2:	6978      	ldr	r0, [r7, #20]
 800afa4:	f003 ffc4 	bl	800ef30 <wolfSSL_Free>
        sigCtx->digest = NULL;
 800afa8:	687b      	ldr	r3, [r7, #4]
 800afaa:	2200      	movs	r2, #0
 800afac:	605a      	str	r2, [r3, #4]
    }
#if !(defined(NO_RSA) && defined(NO_DSA))
    if (sigCtx->sigCpy) {
 800afae:	687b      	ldr	r3, [r7, #4]
 800afb0:	68db      	ldr	r3, [r3, #12]
 800afb2:	2b00      	cmp	r3, #0
 800afb4:	d00b      	beq.n	800afce <FreeSignatureCtx+0x4e>
        XFREE(sigCtx->sigCpy, sigCtx->heap, DYNAMIC_TYPE_SIGNATURE);
 800afb6:	687b      	ldr	r3, [r7, #4]
 800afb8:	68db      	ldr	r3, [r3, #12]
 800afba:	613b      	str	r3, [r7, #16]
 800afbc:	693b      	ldr	r3, [r7, #16]
 800afbe:	2b00      	cmp	r3, #0
 800afc0:	d002      	beq.n	800afc8 <FreeSignatureCtx+0x48>
 800afc2:	6938      	ldr	r0, [r7, #16]
 800afc4:	f003 ffb4 	bl	800ef30 <wolfSSL_Free>
        sigCtx->sigCpy = NULL;
 800afc8:	687b      	ldr	r3, [r7, #4]
 800afca:	2200      	movs	r2, #0
 800afcc:	60da      	str	r2, [r3, #12]
    }
#endif
#ifndef NO_ASN_CRYPT
    if (sigCtx->key.ptr) {
 800afce:	687b      	ldr	r3, [r7, #4]
 800afd0:	695b      	ldr	r3, [r3, #20]
 800afd2:	2b00      	cmp	r3, #0
 800afd4:	d02e      	beq.n	800b034 <FreeSignatureCtx+0xb4>
        switch (sigCtx->keyOID) {
 800afd6:	687b      	ldr	r3, [r7, #4]
 800afd8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800afda:	f240 2206 	movw	r2, #518	; 0x206
 800afde:	4293      	cmp	r3, r2
 800afe0:	d013      	beq.n	800b00a <FreeSignatureCtx+0x8a>
 800afe2:	f240 2285 	movw	r2, #645	; 0x285
 800afe6:	4293      	cmp	r3, r2
 800afe8:	d000      	beq.n	800afec <FreeSignatureCtx+0x6c>
                wc_ed448_free(sigCtx->key.ed448);
                XFREE(sigCtx->key.ed448, sigCtx->heap, DYNAMIC_TYPE_ED448);
                break;
        #endif /* HAVE_ED448 */
            default:
                break;
 800afea:	e020      	b.n	800b02e <FreeSignatureCtx+0xae>
                wc_FreeRsaKey(sigCtx->key.rsa);
 800afec:	687b      	ldr	r3, [r7, #4]
 800afee:	695b      	ldr	r3, [r3, #20]
 800aff0:	4618      	mov	r0, r3
 800aff2:	f004 fa00 	bl	800f3f6 <wc_FreeRsaKey>
                XFREE(sigCtx->key.ptr, sigCtx->heap, DYNAMIC_TYPE_RSA);
 800aff6:	687b      	ldr	r3, [r7, #4]
 800aff8:	695b      	ldr	r3, [r3, #20]
 800affa:	60fb      	str	r3, [r7, #12]
 800affc:	68fb      	ldr	r3, [r7, #12]
 800affe:	2b00      	cmp	r3, #0
 800b000:	d012      	beq.n	800b028 <FreeSignatureCtx+0xa8>
 800b002:	68f8      	ldr	r0, [r7, #12]
 800b004:	f003 ff94 	bl	800ef30 <wolfSSL_Free>
                break;
 800b008:	e00e      	b.n	800b028 <FreeSignatureCtx+0xa8>
                wc_ecc_free(sigCtx->key.ecc);
 800b00a:	687b      	ldr	r3, [r7, #4]
 800b00c:	695b      	ldr	r3, [r3, #20]
 800b00e:	4618      	mov	r0, r3
 800b010:	f003 fb4c 	bl	800e6ac <wc_ecc_free>
                XFREE(sigCtx->key.ecc, sigCtx->heap, DYNAMIC_TYPE_ECC);
 800b014:	687b      	ldr	r3, [r7, #4]
 800b016:	695b      	ldr	r3, [r3, #20]
 800b018:	60bb      	str	r3, [r7, #8]
 800b01a:	68bb      	ldr	r3, [r7, #8]
 800b01c:	2b00      	cmp	r3, #0
 800b01e:	d005      	beq.n	800b02c <FreeSignatureCtx+0xac>
 800b020:	68b8      	ldr	r0, [r7, #8]
 800b022:	f003 ff85 	bl	800ef30 <wolfSSL_Free>
                break;
 800b026:	e001      	b.n	800b02c <FreeSignatureCtx+0xac>
                break;
 800b028:	bf00      	nop
 800b02a:	e000      	b.n	800b02e <FreeSignatureCtx+0xae>
                break;
 800b02c:	bf00      	nop
        } /* switch (keyOID) */
        sigCtx->key.ptr = NULL;
 800b02e:	687b      	ldr	r3, [r7, #4]
 800b030:	2200      	movs	r2, #0
 800b032:	615a      	str	r2, [r3, #20]
    }
#endif

    /* reset state, we are done */
    sigCtx->state = SIG_STATE_BEGIN;
 800b034:	687b      	ldr	r3, [r7, #4]
 800b036:	2200      	movs	r2, #0
 800b038:	61da      	str	r2, [r3, #28]
 800b03a:	e000      	b.n	800b03e <FreeSignatureCtx+0xbe>
        return;
 800b03c:	bf00      	nop
}
 800b03e:	3718      	adds	r7, #24
 800b040:	46bd      	mov	sp, r7
 800b042:	bd80      	pop	{r7, pc}

0800b044 <HashForSignature>:

#ifndef NO_ASN_CRYPT
static int HashForSignature(const byte* buf, word32 bufSz, word32 sigOID,
                            byte* digest, int* typeH, int* digestSz, int verify)
{
 800b044:	b580      	push	{r7, lr}
 800b046:	b086      	sub	sp, #24
 800b048:	af00      	add	r7, sp, #0
 800b04a:	60f8      	str	r0, [r7, #12]
 800b04c:	60b9      	str	r1, [r7, #8]
 800b04e:	607a      	str	r2, [r7, #4]
 800b050:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800b052:	2300      	movs	r3, #0
 800b054:	617b      	str	r3, [r7, #20]

    (void)verify;

    switch (sigOID) {
 800b056:	687b      	ldr	r3, [r7, #4]
 800b058:	f5b3 7f03 	cmp.w	r3, #524	; 0x20c
 800b05c:	d006      	beq.n	800b06c <HashForSignature+0x28>
 800b05e:	f240 228f 	movw	r2, #655	; 0x28f
 800b062:	4293      	cmp	r3, r2
 800b064:	d002      	beq.n	800b06c <HashForSignature+0x28>
 800b066:	f5b3 7fd0 	cmp.w	r3, #416	; 0x1a0
 800b06a:	d110      	bne.n	800b08e <HashForSignature+0x4a>
    #endif
    #ifndef NO_SHA256
        case CTC_SHA256wRSA:
        case CTC_SHA256wECDSA:
        case CTC_SHA256wDSA:
            if ((ret = wc_Sha256Hash(buf, bufSz, digest)) == 0) {
 800b06c:	683a      	ldr	r2, [r7, #0]
 800b06e:	68b9      	ldr	r1, [r7, #8]
 800b070:	68f8      	ldr	r0, [r7, #12]
 800b072:	f003 ff05 	bl	800ee80 <wc_Sha256Hash>
 800b076:	6178      	str	r0, [r7, #20]
 800b078:	697b      	ldr	r3, [r7, #20]
 800b07a:	2b00      	cmp	r3, #0
 800b07c:	d10b      	bne.n	800b096 <HashForSignature+0x52>
                *typeH    = SHA256h;
 800b07e:	6a3b      	ldr	r3, [r7, #32]
 800b080:	f44f 72cf 	mov.w	r2, #414	; 0x19e
 800b084:	601a      	str	r2, [r3, #0]
                *digestSz = WC_SHA256_DIGEST_SIZE;
 800b086:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b088:	2220      	movs	r2, #32
 800b08a:	601a      	str	r2, [r3, #0]
            }
            break;
 800b08c:	e003      	b.n	800b096 <HashForSignature+0x52>
             * Two dependent hashes with prefixes performed.
             */
            break;
    #endif
        default:
            ret = HASH_TYPE_E;
 800b08e:	f06f 03e7 	mvn.w	r3, #231	; 0xe7
 800b092:	617b      	str	r3, [r7, #20]
 800b094:	e000      	b.n	800b098 <HashForSignature+0x54>
            break;
 800b096:	bf00      	nop
            WOLFSSL_MSG("Hash for Signature has unsupported type");
    }

    return ret;
 800b098:	697b      	ldr	r3, [r7, #20]
}
 800b09a:	4618      	mov	r0, r3
 800b09c:	3718      	adds	r7, #24
 800b09e:	46bd      	mov	sp, r7
 800b0a0:	bd80      	pop	{r7, pc}
	...

0800b0a4 <ConfirmSignature>:
/* Return codes: 0=Success, Negative (see error-crypt.h), ASN_SIG_CONFIRM_E */
static int ConfirmSignature(SignatureCtx* sigCtx,
    const byte* buf, word32 bufSz,
    const byte* key, word32 keySz, word32 keyOID,
    const byte* sig, word32 sigSz, word32 sigOID, byte* rsaKeyIdx)
{
 800b0a4:	b580      	push	{r7, lr}
 800b0a6:	b090      	sub	sp, #64	; 0x40
 800b0a8:	af04      	add	r7, sp, #16
 800b0aa:	60f8      	str	r0, [r7, #12]
 800b0ac:	60b9      	str	r1, [r7, #8]
 800b0ae:	607a      	str	r2, [r7, #4]
 800b0b0:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800b0b2:	2300      	movs	r3, #0
 800b0b4:	62fb      	str	r3, [r7, #44]	; 0x2c
#ifndef WOLFSSL_RENESAS_TSIP_TLS
    (void)rsaKeyIdx;
#endif
    if (sigCtx == NULL || buf == NULL || bufSz == 0 || key == NULL ||
 800b0b6:	68fb      	ldr	r3, [r7, #12]
 800b0b8:	2b00      	cmp	r3, #0
 800b0ba:	d011      	beq.n	800b0e0 <ConfirmSignature+0x3c>
 800b0bc:	68bb      	ldr	r3, [r7, #8]
 800b0be:	2b00      	cmp	r3, #0
 800b0c0:	d00e      	beq.n	800b0e0 <ConfirmSignature+0x3c>
 800b0c2:	687b      	ldr	r3, [r7, #4]
 800b0c4:	2b00      	cmp	r3, #0
 800b0c6:	d00b      	beq.n	800b0e0 <ConfirmSignature+0x3c>
 800b0c8:	683b      	ldr	r3, [r7, #0]
 800b0ca:	2b00      	cmp	r3, #0
 800b0cc:	d008      	beq.n	800b0e0 <ConfirmSignature+0x3c>
 800b0ce:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b0d0:	2b00      	cmp	r3, #0
 800b0d2:	d005      	beq.n	800b0e0 <ConfirmSignature+0x3c>
        keySz == 0 || sig == NULL || sigSz == 0) {
 800b0d4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b0d6:	2b00      	cmp	r3, #0
 800b0d8:	d002      	beq.n	800b0e0 <ConfirmSignature+0x3c>
 800b0da:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b0dc:	2b00      	cmp	r3, #0
 800b0de:	d102      	bne.n	800b0e6 <ConfirmSignature+0x42>
        return BAD_FUNC_ARG;
 800b0e0:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800b0e4:	e15e      	b.n	800b3a4 <ConfirmSignature+0x300>
    (void)sigSz;

    WOLFSSL_ENTER("ConfirmSignature");

#ifndef NO_ASN_CRYPT
    switch (sigCtx->state) {
 800b0e6:	68fb      	ldr	r3, [r7, #12]
 800b0e8:	69db      	ldr	r3, [r3, #28]
 800b0ea:	2b04      	cmp	r3, #4
 800b0ec:	f200 8156 	bhi.w	800b39c <ConfirmSignature+0x2f8>
 800b0f0:	a201      	add	r2, pc, #4	; (adr r2, 800b0f8 <ConfirmSignature+0x54>)
 800b0f2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b0f6:	bf00      	nop
 800b0f8:	0800b10d 	.word	0x0800b10d
 800b0fc:	0800b135 	.word	0x0800b135
 800b100:	0800b165 	.word	0x0800b165
 800b104:	0800b281 	.word	0x0800b281
 800b108:	0800b2e7 	.word	0x0800b2e7
        case SIG_STATE_BEGIN:
        {
            sigCtx->keyOID = keyOID; /* must set early for cleanup */
 800b10c:	68fb      	ldr	r3, [r7, #12]
 800b10e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800b110:	629a      	str	r2, [r3, #40]	; 0x28

            sigCtx->digest = (byte*)XMALLOC(WC_MAX_DIGEST_SIZE, sigCtx->heap,
 800b112:	2020      	movs	r0, #32
 800b114:	f003 fef0 	bl	800eef8 <wolfSSL_Malloc>
 800b118:	4602      	mov	r2, r0
 800b11a:	68fb      	ldr	r3, [r7, #12]
 800b11c:	605a      	str	r2, [r3, #4]
                                                    DYNAMIC_TYPE_DIGEST);
            if (sigCtx->digest == NULL) {
 800b11e:	68fb      	ldr	r3, [r7, #12]
 800b120:	685b      	ldr	r3, [r3, #4]
 800b122:	2b00      	cmp	r3, #0
 800b124:	d103      	bne.n	800b12e <ConfirmSignature+0x8a>
                ERROR_OUT(MEMORY_E, exit_cs);
 800b126:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800b12a:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b12c:	e136      	b.n	800b39c <ConfirmSignature+0x2f8>
            }

            sigCtx->state = SIG_STATE_HASH;
 800b12e:	68fb      	ldr	r3, [r7, #12]
 800b130:	2201      	movs	r2, #1
 800b132:	61da      	str	r2, [r3, #28]
        } /* SIG_STATE_BEGIN */
        FALL_THROUGH;

        case SIG_STATE_HASH:
        {
            ret = HashForSignature(buf, bufSz, sigOID, sigCtx->digest,
 800b134:	68fb      	ldr	r3, [r7, #12]
 800b136:	6858      	ldr	r0, [r3, #4]
 800b138:	68fb      	ldr	r3, [r7, #12]
 800b13a:	3320      	adds	r3, #32
 800b13c:	68fa      	ldr	r2, [r7, #12]
 800b13e:	3224      	adds	r2, #36	; 0x24
 800b140:	2101      	movs	r1, #1
 800b142:	9102      	str	r1, [sp, #8]
 800b144:	9201      	str	r2, [sp, #4]
 800b146:	9300      	str	r3, [sp, #0]
 800b148:	4603      	mov	r3, r0
 800b14a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b14c:	6879      	ldr	r1, [r7, #4]
 800b14e:	68b8      	ldr	r0, [r7, #8]
 800b150:	f7ff ff78 	bl	800b044 <HashForSignature>
 800b154:	62f8      	str	r0, [r7, #44]	; 0x2c
                                   &sigCtx->typeH, &sigCtx->digestSz, 1);
            if (ret != 0) {
 800b156:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b158:	2b00      	cmp	r3, #0
 800b15a:	f040 8116 	bne.w	800b38a <ConfirmSignature+0x2e6>
                goto exit_cs;
            }

            sigCtx->state = SIG_STATE_KEY;
 800b15e:	68fb      	ldr	r3, [r7, #12]
 800b160:	2202      	movs	r2, #2
 800b162:	61da      	str	r2, [r3, #28]
        } /* SIG_STATE_HASH */
        FALL_THROUGH;

        case SIG_STATE_KEY:
        {
            switch (keyOID) {
 800b164:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b166:	f240 2206 	movw	r2, #518	; 0x206
 800b16a:	4293      	cmp	r3, r2
 800b16c:	d04d      	beq.n	800b20a <ConfirmSignature+0x166>
 800b16e:	f240 2285 	movw	r2, #645	; 0x285
 800b172:	4293      	cmp	r3, r2
 800b174:	d178      	bne.n	800b268 <ConfirmSignature+0x1c4>
            #ifndef NO_RSA
                case RSAk:
                {
                    word32 idx = 0;
 800b176:	2300      	movs	r3, #0
 800b178:	61bb      	str	r3, [r7, #24]

                    sigCtx->key.rsa = (RsaKey*)XMALLOC(sizeof(RsaKey),
 800b17a:	f641 007c 	movw	r0, #6268	; 0x187c
 800b17e:	f003 febb 	bl	800eef8 <wolfSSL_Malloc>
 800b182:	4602      	mov	r2, r0
 800b184:	68fb      	ldr	r3, [r7, #12]
 800b186:	615a      	str	r2, [r3, #20]
                                                sigCtx->heap, DYNAMIC_TYPE_RSA);
                    sigCtx->sigCpy = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ,
 800b188:	f44f 7000 	mov.w	r0, #512	; 0x200
 800b18c:	f003 feb4 	bl	800eef8 <wolfSSL_Malloc>
 800b190:	4602      	mov	r2, r0
 800b192:	68fb      	ldr	r3, [r7, #12]
 800b194:	60da      	str	r2, [r3, #12]
                                         sigCtx->heap, DYNAMIC_TYPE_SIGNATURE);
                    if (sigCtx->key.rsa == NULL || sigCtx->sigCpy == NULL) {
 800b196:	68fb      	ldr	r3, [r7, #12]
 800b198:	695b      	ldr	r3, [r3, #20]
 800b19a:	2b00      	cmp	r3, #0
 800b19c:	d003      	beq.n	800b1a6 <ConfirmSignature+0x102>
 800b19e:	68fb      	ldr	r3, [r7, #12]
 800b1a0:	68db      	ldr	r3, [r3, #12]
 800b1a2:	2b00      	cmp	r3, #0
 800b1a4:	d103      	bne.n	800b1ae <ConfirmSignature+0x10a>
                        ERROR_OUT(MEMORY_E, exit_cs);
 800b1a6:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800b1aa:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b1ac:	e0f6      	b.n	800b39c <ConfirmSignature+0x2f8>
                    }
                    if ((ret = wc_InitRsaKey_ex(sigCtx->key.rsa, sigCtx->heap,
 800b1ae:	68fb      	ldr	r3, [r7, #12]
 800b1b0:	6958      	ldr	r0, [r3, #20]
 800b1b2:	68fb      	ldr	r3, [r7, #12]
 800b1b4:	6819      	ldr	r1, [r3, #0]
 800b1b6:	68fb      	ldr	r3, [r7, #12]
 800b1b8:	699b      	ldr	r3, [r3, #24]
 800b1ba:	461a      	mov	r2, r3
 800b1bc:	f004 f89c 	bl	800f2f8 <wc_InitRsaKey_ex>
 800b1c0:	62f8      	str	r0, [r7, #44]	; 0x2c
 800b1c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b1c4:	2b00      	cmp	r3, #0
 800b1c6:	f040 80e2 	bne.w	800b38e <ConfirmSignature+0x2ea>
                                                        sigCtx->devId)) != 0) {
                        goto exit_cs;
                    }
                    if (sigSz > MAX_ENCODED_SIG_SZ) {
 800b1ca:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b1cc:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800b1d0:	d903      	bls.n	800b1da <ConfirmSignature+0x136>
                        WOLFSSL_MSG("Verify Signature is too big");
                        ERROR_OUT(BUFFER_E, exit_cs);
 800b1d2:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800b1d6:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b1d8:	e0e0      	b.n	800b39c <ConfirmSignature+0x2f8>
                    }
                    if ((ret = wc_RsaPublicKeyDecode(key, &idx, sigCtx->key.rsa,
 800b1da:	68fb      	ldr	r3, [r7, #12]
 800b1dc:	695a      	ldr	r2, [r3, #20]
 800b1de:	f107 0118 	add.w	r1, r7, #24
 800b1e2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b1e4:	6838      	ldr	r0, [r7, #0]
 800b1e6:	f7fe fcf5 	bl	8009bd4 <wc_RsaPublicKeyDecode>
 800b1ea:	62f8      	str	r0, [r7, #44]	; 0x2c
 800b1ec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b1ee:	2b00      	cmp	r3, #0
 800b1f0:	f040 80cf 	bne.w	800b392 <ConfirmSignature+0x2ee>
                                                                 keySz)) != 0) {
                        WOLFSSL_MSG("ASN Key decode error RSA");
                        goto exit_cs;
                    }
                    XMEMCPY(sigCtx->sigCpy, sig, sigSz);
 800b1f4:	68fb      	ldr	r3, [r7, #12]
 800b1f6:	68db      	ldr	r3, [r3, #12]
 800b1f8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800b1fa:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800b1fc:	4618      	mov	r0, r3
 800b1fe:	f00e f8fa 	bl	80193f6 <memcpy>
                    sigCtx->out = NULL;
 800b202:	68fb      	ldr	r3, [r7, #12]
 800b204:	2200      	movs	r2, #0
 800b206:	609a      	str	r2, [r3, #8]
 800b208:	e033      	b.n	800b272 <ConfirmSignature+0x1ce>
                }
            #endif /* !NO_DSA && !HAVE_SELFTEST */
            #ifdef HAVE_ECC
                case ECDSAk:
                {
                    word32 idx = 0;
 800b20a:	2300      	movs	r3, #0
 800b20c:	617b      	str	r3, [r7, #20]

                    sigCtx->verify = 0;
 800b20e:	68fb      	ldr	r3, [r7, #12]
 800b210:	2200      	movs	r2, #0
 800b212:	611a      	str	r2, [r3, #16]
                    sigCtx->key.ecc = (ecc_key*)XMALLOC(sizeof(ecc_key),
 800b214:	f44f 6083 	mov.w	r0, #1048	; 0x418
 800b218:	f003 fe6e 	bl	800eef8 <wolfSSL_Malloc>
 800b21c:	4602      	mov	r2, r0
 800b21e:	68fb      	ldr	r3, [r7, #12]
 800b220:	615a      	str	r2, [r3, #20]
                                                sigCtx->heap, DYNAMIC_TYPE_ECC);
                    if (sigCtx->key.ecc == NULL) {
 800b222:	68fb      	ldr	r3, [r7, #12]
 800b224:	695b      	ldr	r3, [r3, #20]
 800b226:	2b00      	cmp	r3, #0
 800b228:	d103      	bne.n	800b232 <ConfirmSignature+0x18e>
                        ERROR_OUT(MEMORY_E, exit_cs);
 800b22a:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800b22e:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b230:	e0b4      	b.n	800b39c <ConfirmSignature+0x2f8>
                    }
                    if ((ret = wc_ecc_init_ex(sigCtx->key.ecc, sigCtx->heap,
 800b232:	68fb      	ldr	r3, [r7, #12]
 800b234:	6958      	ldr	r0, [r3, #20]
 800b236:	68fb      	ldr	r3, [r7, #12]
 800b238:	6819      	ldr	r1, [r3, #0]
 800b23a:	68fb      	ldr	r3, [r7, #12]
 800b23c:	699b      	ldr	r3, [r3, #24]
 800b23e:	461a      	mov	r2, r3
 800b240:	f003 f9ea 	bl	800e618 <wc_ecc_init_ex>
 800b244:	62f8      	str	r0, [r7, #44]	; 0x2c
 800b246:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b248:	2b00      	cmp	r3, #0
 800b24a:	f2c0 80a4 	blt.w	800b396 <ConfirmSignature+0x2f2>
                                                          sigCtx->devId)) < 0) {
                        goto exit_cs;
                    }
                    ret = wc_EccPublicKeyDecode(key, &idx, sigCtx->key.ecc,
 800b24e:	68fb      	ldr	r3, [r7, #12]
 800b250:	695a      	ldr	r2, [r3, #20]
 800b252:	f107 0114 	add.w	r1, r7, #20
 800b256:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b258:	6838      	ldr	r0, [r7, #0]
 800b25a:	f002 fb74 	bl	800d946 <wc_EccPublicKeyDecode>
 800b25e:	62f8      	str	r0, [r7, #44]	; 0x2c
                                                                         keySz);
                    if (ret < 0) {
 800b260:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b262:	2b00      	cmp	r3, #0
 800b264:	da04      	bge.n	800b270 <ConfirmSignature+0x1cc>
                        WOLFSSL_MSG("ASN Key import error ECC");
                        goto exit_cs;
 800b266:	e099      	b.n	800b39c <ConfirmSignature+0x2f8>
                    break;
                }
            #endif
                default:
                    WOLFSSL_MSG("Verify Key type unknown");
                    ret = ASN_UNKNOWN_OID_E;
 800b268:	f06f 0393 	mvn.w	r3, #147	; 0x93
 800b26c:	62fb      	str	r3, [r7, #44]	; 0x2c
                    break;
 800b26e:	e000      	b.n	800b272 <ConfirmSignature+0x1ce>
                    break;
 800b270:	bf00      	nop
            } /* switch (keyOID) */

            if (ret != 0) {
 800b272:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b274:	2b00      	cmp	r3, #0
 800b276:	f040 8090 	bne.w	800b39a <ConfirmSignature+0x2f6>
                goto exit_cs;
            }

            sigCtx->state = SIG_STATE_DO;
 800b27a:	68fb      	ldr	r3, [r7, #12]
 800b27c:	2203      	movs	r2, #3
 800b27e:	61da      	str	r2, [r3, #28]
        } /* SIG_STATE_KEY */
        FALL_THROUGH;

        case SIG_STATE_DO:
        {
            switch (keyOID) {
 800b280:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b282:	f240 2206 	movw	r2, #518	; 0x206
 800b286:	4293      	cmp	r3, r2
 800b288:	d010      	beq.n	800b2ac <ConfirmSignature+0x208>
 800b28a:	f240 2285 	movw	r2, #645	; 0x285
 800b28e:	4293      	cmp	r3, r2
 800b290:	d000      	beq.n	800b294 <ConfirmSignature+0x1f0>
                                             NULL, 0);
                    break;
                }
            #endif
                default:
                    break;
 800b292:	e01e      	b.n	800b2d2 <ConfirmSignature+0x22e>
                        ret = wc_RsaSSL_VerifyInline(sigCtx->sigCpy, sigSz,
 800b294:	68fb      	ldr	r3, [r7, #12]
 800b296:	68d8      	ldr	r0, [r3, #12]
 800b298:	68fb      	ldr	r3, [r7, #12]
 800b29a:	f103 0208 	add.w	r2, r3, #8
                                                 &sigCtx->out, sigCtx->key.rsa);
 800b29e:	68fb      	ldr	r3, [r7, #12]
 800b2a0:	695b      	ldr	r3, [r3, #20]
                        ret = wc_RsaSSL_VerifyInline(sigCtx->sigCpy, sigSz,
 800b2a2:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800b2a4:	f004 ffee 	bl	8010284 <wc_RsaSSL_VerifyInline>
 800b2a8:	62f8      	str	r0, [r7, #44]	; 0x2c
                    break;
 800b2aa:	e012      	b.n	800b2d2 <ConfirmSignature+0x22e>
                        ret = wc_ecc_verify_hash(sig, sigSz, sigCtx->digest,
 800b2ac:	68fb      	ldr	r3, [r7, #12]
 800b2ae:	6859      	ldr	r1, [r3, #4]
                                            sigCtx->digestSz, &sigCtx->verify,
 800b2b0:	68fb      	ldr	r3, [r7, #12]
 800b2b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                        ret = wc_ecc_verify_hash(sig, sigSz, sigCtx->digest,
 800b2b4:	4618      	mov	r0, r3
 800b2b6:	68fb      	ldr	r3, [r7, #12]
 800b2b8:	3310      	adds	r3, #16
                                            sigCtx->key.ecc);
 800b2ba:	68fa      	ldr	r2, [r7, #12]
 800b2bc:	6952      	ldr	r2, [r2, #20]
                        ret = wc_ecc_verify_hash(sig, sigSz, sigCtx->digest,
 800b2be:	9201      	str	r2, [sp, #4]
 800b2c0:	9300      	str	r3, [sp, #0]
 800b2c2:	4603      	mov	r3, r0
 800b2c4:	460a      	mov	r2, r1
 800b2c6:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800b2c8:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800b2ca:	f003 fa13 	bl	800e6f4 <wc_ecc_verify_hash>
 800b2ce:	62f8      	str	r0, [r7, #44]	; 0x2c
                    break;
 800b2d0:	bf00      	nop
            if (ret == WC_PENDING_E) {
                goto exit_cs;
            }
        #endif

            if (ret < 0) {
 800b2d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2d4:	2b00      	cmp	r3, #0
 800b2d6:	da03      	bge.n	800b2e0 <ConfirmSignature+0x23c>
                /* treat all RSA errors as ASN_SIG_CONFIRM_E */
                ret = ASN_SIG_CONFIRM_E;
 800b2d8:	f06f 039a 	mvn.w	r3, #154	; 0x9a
 800b2dc:	62fb      	str	r3, [r7, #44]	; 0x2c
                goto exit_cs;
 800b2de:	e05d      	b.n	800b39c <ConfirmSignature+0x2f8>
            }

            sigCtx->state = SIG_STATE_CHECK;
 800b2e0:	68fb      	ldr	r3, [r7, #12]
 800b2e2:	2204      	movs	r2, #4
 800b2e4:	61da      	str	r2, [r3, #28]
        } /* SIG_STATE_DO */
        FALL_THROUGH;

        case SIG_STATE_CHECK:
        {
            switch (keyOID) {
 800b2e6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b2e8:	f240 2206 	movw	r2, #518	; 0x206
 800b2ec:	4293      	cmp	r3, r2
 800b2ee:	d03f      	beq.n	800b370 <ConfirmSignature+0x2cc>
 800b2f0:	f240 2285 	movw	r2, #645	; 0x285
 800b2f4:	4293      	cmp	r3, r2
 800b2f6:	d000      	beq.n	800b2fa <ConfirmSignature+0x256>
                    }
                    break;
                }
            #endif /* HAVE_ED448 */
                default:
                    break;
 800b2f8:	e046      	b.n	800b388 <ConfirmSignature+0x2e4>
                    byte* encodedSig = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ,
 800b2fa:	f44f 7000 	mov.w	r0, #512	; 0x200
 800b2fe:	f003 fdfb 	bl	800eef8 <wolfSSL_Malloc>
 800b302:	62b8      	str	r0, [r7, #40]	; 0x28
                    if (encodedSig == NULL) {
 800b304:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b306:	2b00      	cmp	r3, #0
 800b308:	d103      	bne.n	800b312 <ConfirmSignature+0x26e>
                        ERROR_OUT(MEMORY_E, exit_cs);
 800b30a:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800b30e:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b310:	e044      	b.n	800b39c <ConfirmSignature+0x2f8>
                    verifySz = ret;
 800b312:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b314:	627b      	str	r3, [r7, #36]	; 0x24
                            sigCtx->digest, sigCtx->digestSz, sigCtx->typeH);
 800b316:	68fb      	ldr	r3, [r7, #12]
 800b318:	6859      	ldr	r1, [r3, #4]
 800b31a:	68fb      	ldr	r3, [r7, #12]
 800b31c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                    encodedSigSz = wc_EncodeSignature(encodedSig,
 800b31e:	461a      	mov	r2, r3
 800b320:	68fb      	ldr	r3, [r7, #12]
 800b322:	6a1b      	ldr	r3, [r3, #32]
 800b324:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800b326:	f7ff fdc5 	bl	800aeb4 <wc_EncodeSignature>
 800b32a:	4603      	mov	r3, r0
 800b32c:	623b      	str	r3, [r7, #32]
                    if (encodedSigSz == verifySz && sigCtx->out != NULL &&
 800b32e:	6a3a      	ldr	r2, [r7, #32]
 800b330:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b332:	429a      	cmp	r2, r3
 800b334:	d110      	bne.n	800b358 <ConfirmSignature+0x2b4>
 800b336:	68fb      	ldr	r3, [r7, #12]
 800b338:	689b      	ldr	r3, [r3, #8]
 800b33a:	2b00      	cmp	r3, #0
 800b33c:	d00c      	beq.n	800b358 <ConfirmSignature+0x2b4>
                        XMEMCMP(sigCtx->out, encodedSig, encodedSigSz) == 0) {
 800b33e:	68fb      	ldr	r3, [r7, #12]
 800b340:	689b      	ldr	r3, [r3, #8]
 800b342:	6a3a      	ldr	r2, [r7, #32]
 800b344:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800b346:	4618      	mov	r0, r3
 800b348:	f00e f846 	bl	80193d8 <memcmp>
 800b34c:	4603      	mov	r3, r0
                    if (encodedSigSz == verifySz && sigCtx->out != NULL &&
 800b34e:	2b00      	cmp	r3, #0
 800b350:	d102      	bne.n	800b358 <ConfirmSignature+0x2b4>
                        ret = 0;
 800b352:	2300      	movs	r3, #0
 800b354:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b356:	e002      	b.n	800b35e <ConfirmSignature+0x2ba>
                        ret = ASN_SIG_CONFIRM_E;
 800b358:	f06f 039a 	mvn.w	r3, #154	; 0x9a
 800b35c:	62fb      	str	r3, [r7, #44]	; 0x2c
                    XFREE(encodedSig, sigCtx->heap, DYNAMIC_TYPE_TMP_BUFFER);
 800b35e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b360:	61fb      	str	r3, [r7, #28]
 800b362:	69fb      	ldr	r3, [r7, #28]
 800b364:	2b00      	cmp	r3, #0
 800b366:	d00e      	beq.n	800b386 <ConfirmSignature+0x2e2>
 800b368:	69f8      	ldr	r0, [r7, #28]
 800b36a:	f003 fde1 	bl	800ef30 <wolfSSL_Free>
                    break;
 800b36e:	e00a      	b.n	800b386 <ConfirmSignature+0x2e2>
                    if (sigCtx->verify == 1) {
 800b370:	68fb      	ldr	r3, [r7, #12]
 800b372:	691b      	ldr	r3, [r3, #16]
 800b374:	2b01      	cmp	r3, #1
 800b376:	d102      	bne.n	800b37e <ConfirmSignature+0x2da>
                        ret = 0;
 800b378:	2300      	movs	r3, #0
 800b37a:	62fb      	str	r3, [r7, #44]	; 0x2c
                    break;
 800b37c:	e004      	b.n	800b388 <ConfirmSignature+0x2e4>
                        ret = ASN_SIG_CONFIRM_E;
 800b37e:	f06f 039a 	mvn.w	r3, #154	; 0x9a
 800b382:	62fb      	str	r3, [r7, #44]	; 0x2c
                    break;
 800b384:	e000      	b.n	800b388 <ConfirmSignature+0x2e4>
                    break;
 800b386:	bf00      	nop
            }  /* switch (keyOID) */

            break;
 800b388:	e008      	b.n	800b39c <ConfirmSignature+0x2f8>
                goto exit_cs;
 800b38a:	bf00      	nop
 800b38c:	e006      	b.n	800b39c <ConfirmSignature+0x2f8>
                        goto exit_cs;
 800b38e:	bf00      	nop
 800b390:	e004      	b.n	800b39c <ConfirmSignature+0x2f8>
                        goto exit_cs;
 800b392:	bf00      	nop
 800b394:	e002      	b.n	800b39c <ConfirmSignature+0x2f8>
                        goto exit_cs;
 800b396:	bf00      	nop
 800b398:	e000      	b.n	800b39c <ConfirmSignature+0x2f8>
                goto exit_cs;
 800b39a:	bf00      	nop
#ifdef WOLFSSL_ASYNC_CRYPT
    if (ret == WC_PENDING_E)
        return ret;
#endif

    FreeSignatureCtx(sigCtx);
 800b39c:	68f8      	ldr	r0, [r7, #12]
 800b39e:	f7ff fdef 	bl	800af80 <FreeSignatureCtx>

    return ret;
 800b3a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 800b3a4:	4618      	mov	r0, r3
 800b3a6:	3730      	adds	r7, #48	; 0x30
 800b3a8:	46bd      	mov	sp, r7
 800b3aa:	bd80      	pop	{r7, pc}

0800b3ac <MatchBaseName>:

#ifndef IGNORE_NAME_CONSTRAINTS

static int MatchBaseName(int type, const char* name, int nameSz,
                         const char* base, int baseSz)
{
 800b3ac:	b590      	push	{r4, r7, lr}
 800b3ae:	b089      	sub	sp, #36	; 0x24
 800b3b0:	af00      	add	r7, sp, #0
 800b3b2:	60f8      	str	r0, [r7, #12]
 800b3b4:	60b9      	str	r1, [r7, #8]
 800b3b6:	607a      	str	r2, [r7, #4]
 800b3b8:	603b      	str	r3, [r7, #0]
    if (base == NULL || baseSz <= 0 || name == NULL || nameSz <= 0 ||
 800b3ba:	683b      	ldr	r3, [r7, #0]
 800b3bc:	2b00      	cmp	r3, #0
 800b3be:	d016      	beq.n	800b3ee <MatchBaseName+0x42>
 800b3c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b3c2:	2b00      	cmp	r3, #0
 800b3c4:	dd13      	ble.n	800b3ee <MatchBaseName+0x42>
 800b3c6:	68bb      	ldr	r3, [r7, #8]
 800b3c8:	2b00      	cmp	r3, #0
 800b3ca:	d010      	beq.n	800b3ee <MatchBaseName+0x42>
 800b3cc:	687b      	ldr	r3, [r7, #4]
 800b3ce:	2b00      	cmp	r3, #0
 800b3d0:	dd0d      	ble.n	800b3ee <MatchBaseName+0x42>
            name[0] == '.' || nameSz < baseSz ||
 800b3d2:	68bb      	ldr	r3, [r7, #8]
 800b3d4:	781b      	ldrb	r3, [r3, #0]
    if (base == NULL || baseSz <= 0 || name == NULL || nameSz <= 0 ||
 800b3d6:	2b2e      	cmp	r3, #46	; 0x2e
 800b3d8:	d009      	beq.n	800b3ee <MatchBaseName+0x42>
            name[0] == '.' || nameSz < baseSz ||
 800b3da:	687a      	ldr	r2, [r7, #4]
 800b3dc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b3de:	429a      	cmp	r2, r3
 800b3e0:	db05      	blt.n	800b3ee <MatchBaseName+0x42>
 800b3e2:	68fb      	ldr	r3, [r7, #12]
 800b3e4:	2b01      	cmp	r3, #1
 800b3e6:	d004      	beq.n	800b3f2 <MatchBaseName+0x46>
            (type != ASN_RFC822_TYPE && type != ASN_DNS_TYPE))
 800b3e8:	68fb      	ldr	r3, [r7, #12]
 800b3ea:	2b02      	cmp	r3, #2
 800b3ec:	d001      	beq.n	800b3f2 <MatchBaseName+0x46>
        return 0;
 800b3ee:	2300      	movs	r3, #0
 800b3f0:	e094      	b.n	800b51c <MatchBaseName+0x170>

    /* If an email type, handle special cases where the base is only
     * a domain, or is an email address itself. */
    if (type == ASN_RFC822_TYPE) {
 800b3f2:	68fb      	ldr	r3, [r7, #12]
 800b3f4:	2b01      	cmp	r3, #1
 800b3f6:	d146      	bne.n	800b486 <MatchBaseName+0xda>
        const char* p = NULL;
 800b3f8:	2300      	movs	r3, #0
 800b3fa:	61fb      	str	r3, [r7, #28]
        int count = 0;
 800b3fc:	2300      	movs	r3, #0
 800b3fe:	61bb      	str	r3, [r7, #24]

        if (base[0] != '.') {
 800b400:	683b      	ldr	r3, [r7, #0]
 800b402:	781b      	ldrb	r3, [r3, #0]
 800b404:	2b2e      	cmp	r3, #46	; 0x2e
 800b406:	d018      	beq.n	800b43a <MatchBaseName+0x8e>
            p = base;
 800b408:	683b      	ldr	r3, [r7, #0]
 800b40a:	61fb      	str	r3, [r7, #28]
            count = 0;
 800b40c:	2300      	movs	r3, #0
 800b40e:	61bb      	str	r3, [r7, #24]

            /* find the '@' in the base */
            while (*p != '@' && count < baseSz) {
 800b410:	e005      	b.n	800b41e <MatchBaseName+0x72>
                count++;
 800b412:	69bb      	ldr	r3, [r7, #24]
 800b414:	3301      	adds	r3, #1
 800b416:	61bb      	str	r3, [r7, #24]
                p++;
 800b418:	69fb      	ldr	r3, [r7, #28]
 800b41a:	3301      	adds	r3, #1
 800b41c:	61fb      	str	r3, [r7, #28]
            while (*p != '@' && count < baseSz) {
 800b41e:	69fb      	ldr	r3, [r7, #28]
 800b420:	781b      	ldrb	r3, [r3, #0]
 800b422:	2b40      	cmp	r3, #64	; 0x40
 800b424:	d003      	beq.n	800b42e <MatchBaseName+0x82>
 800b426:	69ba      	ldr	r2, [r7, #24]
 800b428:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b42a:	429a      	cmp	r2, r3
 800b42c:	dbf1      	blt.n	800b412 <MatchBaseName+0x66>
            }

            /* No '@' in base, reset p to NULL */
            if (count >= baseSz)
 800b42e:	69ba      	ldr	r2, [r7, #24]
 800b430:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b432:	429a      	cmp	r2, r3
 800b434:	db01      	blt.n	800b43a <MatchBaseName+0x8e>
                p = NULL;
 800b436:	2300      	movs	r3, #0
 800b438:	61fb      	str	r3, [r7, #28]
        }

        if (p == NULL) {
 800b43a:	69fb      	ldr	r3, [r7, #28]
 800b43c:	2b00      	cmp	r3, #0
 800b43e:	d122      	bne.n	800b486 <MatchBaseName+0xda>
            /* Base isn't an email address, it is a domain name,
             * wind the name forward one character past its '@'. */
            p = name;
 800b440:	68bb      	ldr	r3, [r7, #8]
 800b442:	61fb      	str	r3, [r7, #28]
            count = 0;
 800b444:	2300      	movs	r3, #0
 800b446:	61bb      	str	r3, [r7, #24]
            while (*p != '@' && count < baseSz) {
 800b448:	e005      	b.n	800b456 <MatchBaseName+0xaa>
                count++;
 800b44a:	69bb      	ldr	r3, [r7, #24]
 800b44c:	3301      	adds	r3, #1
 800b44e:	61bb      	str	r3, [r7, #24]
                p++;
 800b450:	69fb      	ldr	r3, [r7, #28]
 800b452:	3301      	adds	r3, #1
 800b454:	61fb      	str	r3, [r7, #28]
            while (*p != '@' && count < baseSz) {
 800b456:	69fb      	ldr	r3, [r7, #28]
 800b458:	781b      	ldrb	r3, [r3, #0]
 800b45a:	2b40      	cmp	r3, #64	; 0x40
 800b45c:	d003      	beq.n	800b466 <MatchBaseName+0xba>
 800b45e:	69ba      	ldr	r2, [r7, #24]
 800b460:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b462:	429a      	cmp	r2, r3
 800b464:	dbf1      	blt.n	800b44a <MatchBaseName+0x9e>
            }

            if (count < baseSz && *p == '@') {
 800b466:	69ba      	ldr	r2, [r7, #24]
 800b468:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b46a:	429a      	cmp	r2, r3
 800b46c:	da0b      	bge.n	800b486 <MatchBaseName+0xda>
 800b46e:	69fb      	ldr	r3, [r7, #28]
 800b470:	781b      	ldrb	r3, [r3, #0]
 800b472:	2b40      	cmp	r3, #64	; 0x40
 800b474:	d107      	bne.n	800b486 <MatchBaseName+0xda>
                name = p + 1;
 800b476:	69fb      	ldr	r3, [r7, #28]
 800b478:	3301      	adds	r3, #1
 800b47a:	60bb      	str	r3, [r7, #8]
                nameSz -= count + 1;
 800b47c:	69bb      	ldr	r3, [r7, #24]
 800b47e:	3301      	adds	r3, #1
 800b480:	687a      	ldr	r2, [r7, #4]
 800b482:	1ad3      	subs	r3, r2, r3
 800b484:	607b      	str	r3, [r7, #4]
            }
        }
    }

    if ((type == ASN_DNS_TYPE || type == ASN_RFC822_TYPE) && base[0] == '.') {
 800b486:	68fb      	ldr	r3, [r7, #12]
 800b488:	2b02      	cmp	r3, #2
 800b48a:	d002      	beq.n	800b492 <MatchBaseName+0xe6>
 800b48c:	68fb      	ldr	r3, [r7, #12]
 800b48e:	2b01      	cmp	r3, #1
 800b490:	d140      	bne.n	800b514 <MatchBaseName+0x168>
 800b492:	683b      	ldr	r3, [r7, #0]
 800b494:	781b      	ldrb	r3, [r3, #0]
 800b496:	2b2e      	cmp	r3, #46	; 0x2e
 800b498:	d13c      	bne.n	800b514 <MatchBaseName+0x168>
        int szAdjust = nameSz - baseSz;
 800b49a:	687a      	ldr	r2, [r7, #4]
 800b49c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b49e:	1ad3      	subs	r3, r2, r3
 800b4a0:	617b      	str	r3, [r7, #20]
        name += szAdjust;
 800b4a2:	697b      	ldr	r3, [r7, #20]
 800b4a4:	68ba      	ldr	r2, [r7, #8]
 800b4a6:	4413      	add	r3, r2
 800b4a8:	60bb      	str	r3, [r7, #8]
        nameSz -= szAdjust;
 800b4aa:	687a      	ldr	r2, [r7, #4]
 800b4ac:	697b      	ldr	r3, [r7, #20]
 800b4ae:	1ad3      	subs	r3, r2, r3
 800b4b0:	607b      	str	r3, [r7, #4]
    }

    while (nameSz > 0) {
 800b4b2:	e02f      	b.n	800b514 <MatchBaseName+0x168>
        if (XTOLOWER((unsigned char)*name++) !=
 800b4b4:	68bb      	ldr	r3, [r7, #8]
 800b4b6:	1c5a      	adds	r2, r3, #1
 800b4b8:	60ba      	str	r2, [r7, #8]
 800b4ba:	781b      	ldrb	r3, [r3, #0]
 800b4bc:	74fb      	strb	r3, [r7, #19]
 800b4be:	f00d ff5b 	bl	8019378 <__locale_ctype_ptr>
 800b4c2:	4602      	mov	r2, r0
 800b4c4:	7cfb      	ldrb	r3, [r7, #19]
 800b4c6:	3301      	adds	r3, #1
 800b4c8:	4413      	add	r3, r2
 800b4ca:	781b      	ldrb	r3, [r3, #0]
 800b4cc:	f003 0303 	and.w	r3, r3, #3
 800b4d0:	2b01      	cmp	r3, #1
 800b4d2:	d103      	bne.n	800b4dc <MatchBaseName+0x130>
 800b4d4:	7cfb      	ldrb	r3, [r7, #19]
 800b4d6:	f103 0420 	add.w	r4, r3, #32
 800b4da:	e000      	b.n	800b4de <MatchBaseName+0x132>
 800b4dc:	7cfc      	ldrb	r4, [r7, #19]
                                               XTOLOWER((unsigned char)*base++))
 800b4de:	683b      	ldr	r3, [r7, #0]
 800b4e0:	1c5a      	adds	r2, r3, #1
 800b4e2:	603a      	str	r2, [r7, #0]
 800b4e4:	781b      	ldrb	r3, [r3, #0]
 800b4e6:	74bb      	strb	r3, [r7, #18]
 800b4e8:	f00d ff46 	bl	8019378 <__locale_ctype_ptr>
 800b4ec:	4602      	mov	r2, r0
 800b4ee:	7cbb      	ldrb	r3, [r7, #18]
 800b4f0:	3301      	adds	r3, #1
 800b4f2:	4413      	add	r3, r2
 800b4f4:	781b      	ldrb	r3, [r3, #0]
 800b4f6:	f003 0303 	and.w	r3, r3, #3
 800b4fa:	2b01      	cmp	r3, #1
 800b4fc:	d102      	bne.n	800b504 <MatchBaseName+0x158>
 800b4fe:	7cbb      	ldrb	r3, [r7, #18]
 800b500:	3320      	adds	r3, #32
 800b502:	e000      	b.n	800b506 <MatchBaseName+0x15a>
 800b504:	7cbb      	ldrb	r3, [r7, #18]
        if (XTOLOWER((unsigned char)*name++) !=
 800b506:	429c      	cmp	r4, r3
 800b508:	d001      	beq.n	800b50e <MatchBaseName+0x162>
            return 0;
 800b50a:	2300      	movs	r3, #0
 800b50c:	e006      	b.n	800b51c <MatchBaseName+0x170>
        nameSz--;
 800b50e:	687b      	ldr	r3, [r7, #4]
 800b510:	3b01      	subs	r3, #1
 800b512:	607b      	str	r3, [r7, #4]
    while (nameSz > 0) {
 800b514:	687b      	ldr	r3, [r7, #4]
 800b516:	2b00      	cmp	r3, #0
 800b518:	dccc      	bgt.n	800b4b4 <MatchBaseName+0x108>
    }

    return 1;
 800b51a:	2301      	movs	r3, #1
}
 800b51c:	4618      	mov	r0, r3
 800b51e:	3724      	adds	r7, #36	; 0x24
 800b520:	46bd      	mov	sp, r7
 800b522:	bd90      	pop	{r4, r7, pc}

0800b524 <ConfirmNameConstraints>:


static int ConfirmNameConstraints(Signer* signer, DecodedCert* cert)
{
 800b524:	b580      	push	{r7, lr}
 800b526:	b092      	sub	sp, #72	; 0x48
 800b528:	af02      	add	r7, sp, #8
 800b52a:	6078      	str	r0, [r7, #4]
 800b52c:	6039      	str	r1, [r7, #0]
    if (signer == NULL || cert == NULL)
 800b52e:	687b      	ldr	r3, [r7, #4]
 800b530:	2b00      	cmp	r3, #0
 800b532:	d002      	beq.n	800b53a <ConfirmNameConstraints+0x16>
 800b534:	683b      	ldr	r3, [r7, #0]
 800b536:	2b00      	cmp	r3, #0
 800b538:	d101      	bne.n	800b53e <ConfirmNameConstraints+0x1a>
        return 0;
 800b53a:	2300      	movs	r3, #0
 800b53c:	e133      	b.n	800b7a6 <ConfirmNameConstraints+0x282>

    /* Check against the excluded list */
    if (signer->excludedNames) {
 800b53e:	687b      	ldr	r3, [r7, #4]
 800b540:	6a1b      	ldr	r3, [r3, #32]
 800b542:	2b00      	cmp	r3, #0
 800b544:	d07f      	beq.n	800b646 <ConfirmNameConstraints+0x122>
        Base_entry* base = signer->excludedNames;
 800b546:	687b      	ldr	r3, [r7, #4]
 800b548:	6a1b      	ldr	r3, [r3, #32]
 800b54a:	63fb      	str	r3, [r7, #60]	; 0x3c

        while (base != NULL) {
 800b54c:	e078      	b.n	800b640 <ConfirmNameConstraints+0x11c>
            switch (base->type) {
 800b54e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b550:	7b1b      	ldrb	r3, [r3, #12]
 800b552:	2b02      	cmp	r3, #2
 800b554:	d004      	beq.n	800b560 <ConfirmNameConstraints+0x3c>
 800b556:	2b04      	cmp	r3, #4
 800b558:	d03c      	beq.n	800b5d4 <ConfirmNameConstraints+0xb0>
 800b55a:	2b01      	cmp	r3, #1
 800b55c:	d01d      	beq.n	800b59a <ConfirmNameConstraints+0x76>
 800b55e:	e06c      	b.n	800b63a <ConfirmNameConstraints+0x116>
                case ASN_DNS_TYPE:
                {
                    DNS_entry* name = cert->altNames;
 800b560:	683b      	ldr	r3, [r7, #0]
 800b562:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b564:	63bb      	str	r3, [r7, #56]	; 0x38
                    while (name != NULL) {
 800b566:	e014      	b.n	800b592 <ConfirmNameConstraints+0x6e>
                        if (MatchBaseName(ASN_DNS_TYPE,
                                          name->name, name->len,
 800b568:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b56a:	68d9      	ldr	r1, [r3, #12]
                        if (MatchBaseName(ASN_DNS_TYPE,
 800b56c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b56e:	689a      	ldr	r2, [r3, #8]
                                          base->name, base->nameSz)) {
 800b570:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b572:	6858      	ldr	r0, [r3, #4]
                        if (MatchBaseName(ASN_DNS_TYPE,
 800b574:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b576:	689b      	ldr	r3, [r3, #8]
 800b578:	9300      	str	r3, [sp, #0]
 800b57a:	4603      	mov	r3, r0
 800b57c:	2002      	movs	r0, #2
 800b57e:	f7ff ff15 	bl	800b3ac <MatchBaseName>
 800b582:	4603      	mov	r3, r0
 800b584:	2b00      	cmp	r3, #0
 800b586:	d001      	beq.n	800b58c <ConfirmNameConstraints+0x68>
                            return 0;
 800b588:	2300      	movs	r3, #0
 800b58a:	e10c      	b.n	800b7a6 <ConfirmNameConstraints+0x282>
                        }
                        name = name->next;
 800b58c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b58e:	681b      	ldr	r3, [r3, #0]
 800b590:	63bb      	str	r3, [r7, #56]	; 0x38
                    while (name != NULL) {
 800b592:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b594:	2b00      	cmp	r3, #0
 800b596:	d1e7      	bne.n	800b568 <ConfirmNameConstraints+0x44>
                    }
                    break;
 800b598:	e04f      	b.n	800b63a <ConfirmNameConstraints+0x116>
                }
                case ASN_RFC822_TYPE:
                {
                    DNS_entry* name = cert->altEmailNames;
 800b59a:	683b      	ldr	r3, [r7, #0]
 800b59c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b59e:	637b      	str	r3, [r7, #52]	; 0x34
                    while (name != NULL) {
 800b5a0:	e014      	b.n	800b5cc <ConfirmNameConstraints+0xa8>
                        if (MatchBaseName(ASN_RFC822_TYPE,
                                          name->name, name->len,
 800b5a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b5a4:	68d9      	ldr	r1, [r3, #12]
                        if (MatchBaseName(ASN_RFC822_TYPE,
 800b5a6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b5a8:	689a      	ldr	r2, [r3, #8]
                                          base->name, base->nameSz)) {
 800b5aa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b5ac:	6858      	ldr	r0, [r3, #4]
                        if (MatchBaseName(ASN_RFC822_TYPE,
 800b5ae:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b5b0:	689b      	ldr	r3, [r3, #8]
 800b5b2:	9300      	str	r3, [sp, #0]
 800b5b4:	4603      	mov	r3, r0
 800b5b6:	2001      	movs	r0, #1
 800b5b8:	f7ff fef8 	bl	800b3ac <MatchBaseName>
 800b5bc:	4603      	mov	r3, r0
 800b5be:	2b00      	cmp	r3, #0
 800b5c0:	d001      	beq.n	800b5c6 <ConfirmNameConstraints+0xa2>
                            return 0;
 800b5c2:	2300      	movs	r3, #0
 800b5c4:	e0ef      	b.n	800b7a6 <ConfirmNameConstraints+0x282>
                        }
                        name = name->next;
 800b5c6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b5c8:	681b      	ldr	r3, [r3, #0]
 800b5ca:	637b      	str	r3, [r7, #52]	; 0x34
                    while (name != NULL) {
 800b5cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b5ce:	2b00      	cmp	r3, #0
 800b5d0:	d1e7      	bne.n	800b5a2 <ConfirmNameConstraints+0x7e>
                    }
                    break;
 800b5d2:	e032      	b.n	800b63a <ConfirmNameConstraints+0x116>
                }
                case ASN_DIR_TYPE:
                {
                    /* allow permitted dirName smaller than actual subject */
                    if (cert->subjectRawLen >= base->nameSz &&
 800b5d4:	683b      	ldr	r3, [r7, #0]
 800b5d6:	f8d3 233c 	ldr.w	r2, [r3, #828]	; 0x33c
 800b5da:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b5dc:	689b      	ldr	r3, [r3, #8]
 800b5de:	429a      	cmp	r2, r3
 800b5e0:	db0e      	blt.n	800b600 <ConfirmNameConstraints+0xdc>
                        XMEMCMP(cert->subjectRaw, base->name,
 800b5e2:	683b      	ldr	r3, [r7, #0]
 800b5e4:	f8d3 0338 	ldr.w	r0, [r3, #824]	; 0x338
 800b5e8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b5ea:	6859      	ldr	r1, [r3, #4]
 800b5ec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b5ee:	689b      	ldr	r3, [r3, #8]
 800b5f0:	461a      	mov	r2, r3
 800b5f2:	f00d fef1 	bl	80193d8 <memcmp>
 800b5f6:	4603      	mov	r3, r0
                    if (cert->subjectRawLen >= base->nameSz &&
 800b5f8:	2b00      	cmp	r3, #0
 800b5fa:	d101      	bne.n	800b600 <ConfirmNameConstraints+0xdc>
                                                        base->nameSz) == 0) {
                        return 0;
 800b5fc:	2300      	movs	r3, #0
 800b5fe:	e0d2      	b.n	800b7a6 <ConfirmNameConstraints+0x282>
                       "Restrictions of the form directoryName MUST be
                        applied to the subject field .... and to any names
                        of type directoryName in the subjectAltName
                        extension"
                    */
                    if (cert->altDirNames != NULL) {
 800b600:	683b      	ldr	r3, [r7, #0]
 800b602:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b604:	2b00      	cmp	r3, #0
 800b606:	d017      	beq.n	800b638 <ConfirmNameConstraints+0x114>
                        DNS_entry* cur = cert->altDirNames;
 800b608:	683b      	ldr	r3, [r7, #0]
 800b60a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b60c:	633b      	str	r3, [r7, #48]	; 0x30
                        while (cur != NULL) {
 800b60e:	e010      	b.n	800b632 <ConfirmNameConstraints+0x10e>
                            if (XMEMCMP(cur->name, base->name, base->nameSz)
 800b610:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b612:	68d8      	ldr	r0, [r3, #12]
 800b614:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b616:	6859      	ldr	r1, [r3, #4]
 800b618:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b61a:	689b      	ldr	r3, [r3, #8]
 800b61c:	461a      	mov	r2, r3
 800b61e:	f00d fedb 	bl	80193d8 <memcmp>
 800b622:	4603      	mov	r3, r0
 800b624:	2b00      	cmp	r3, #0
 800b626:	d101      	bne.n	800b62c <ConfirmNameConstraints+0x108>
                                    == 0) {
                                WOLFSSL_MSG("DIR alt name constraint err");
                                return 0;
 800b628:	2300      	movs	r3, #0
 800b62a:	e0bc      	b.n	800b7a6 <ConfirmNameConstraints+0x282>
                            }
                            cur = cur->next;
 800b62c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b62e:	681b      	ldr	r3, [r3, #0]
 800b630:	633b      	str	r3, [r7, #48]	; 0x30
                        while (cur != NULL) {
 800b632:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b634:	2b00      	cmp	r3, #0
 800b636:	d1eb      	bne.n	800b610 <ConfirmNameConstraints+0xec>
                        }
                    }
                    #endif /* !WOLFSSL_NO_ASN_STRICT */
                    break;
 800b638:	bf00      	nop
                }
            }; /* switch */
            base = base->next;
 800b63a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b63c:	681b      	ldr	r3, [r3, #0]
 800b63e:	63fb      	str	r3, [r7, #60]	; 0x3c
        while (base != NULL) {
 800b640:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b642:	2b00      	cmp	r3, #0
 800b644:	d183      	bne.n	800b54e <ConfirmNameConstraints+0x2a>
        }
    }

    /* Check against the permitted list */
    if (signer->permittedNames != NULL) {
 800b646:	687b      	ldr	r3, [r7, #4]
 800b648:	69db      	ldr	r3, [r3, #28]
 800b64a:	2b00      	cmp	r3, #0
 800b64c:	f000 80aa 	beq.w	800b7a4 <ConfirmNameConstraints+0x280>
        int needDns = 0;
 800b650:	2300      	movs	r3, #0
 800b652:	62fb      	str	r3, [r7, #44]	; 0x2c
        int matchDns = 0;
 800b654:	2300      	movs	r3, #0
 800b656:	62bb      	str	r3, [r7, #40]	; 0x28
        int needEmail = 0;
 800b658:	2300      	movs	r3, #0
 800b65a:	627b      	str	r3, [r7, #36]	; 0x24
        int matchEmail = 0;
 800b65c:	2300      	movs	r3, #0
 800b65e:	623b      	str	r3, [r7, #32]
        int needDir = 0;
 800b660:	2300      	movs	r3, #0
 800b662:	61fb      	str	r3, [r7, #28]
        int matchDir = 0;
 800b664:	2300      	movs	r3, #0
 800b666:	61bb      	str	r3, [r7, #24]
        Base_entry* base = signer->permittedNames;
 800b668:	687b      	ldr	r3, [r7, #4]
 800b66a:	69db      	ldr	r3, [r3, #28]
 800b66c:	617b      	str	r3, [r7, #20]

        while (base != NULL) {
 800b66e:	e081      	b.n	800b774 <ConfirmNameConstraints+0x250>
            switch (base->type) {
 800b670:	697b      	ldr	r3, [r7, #20]
 800b672:	7b1b      	ldrb	r3, [r3, #12]
 800b674:	2b02      	cmp	r3, #2
 800b676:	d004      	beq.n	800b682 <ConfirmNameConstraints+0x15e>
 800b678:	2b04      	cmp	r3, #4
 800b67a:	d03e      	beq.n	800b6fa <ConfirmNameConstraints+0x1d6>
 800b67c:	2b01      	cmp	r3, #1
 800b67e:	d01e      	beq.n	800b6be <ConfirmNameConstraints+0x19a>
 800b680:	e075      	b.n	800b76e <ConfirmNameConstraints+0x24a>
                case ASN_DNS_TYPE:
                {
                    DNS_entry* name = cert->altNames;
 800b682:	683b      	ldr	r3, [r7, #0]
 800b684:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b686:	613b      	str	r3, [r7, #16]

                    if (name != NULL)
 800b688:	693b      	ldr	r3, [r7, #16]
 800b68a:	2b00      	cmp	r3, #0
 800b68c:	d013      	beq.n	800b6b6 <ConfirmNameConstraints+0x192>
                        needDns = 1;
 800b68e:	2301      	movs	r3, #1
 800b690:	62fb      	str	r3, [r7, #44]	; 0x2c

                    while (name != NULL) {
 800b692:	e010      	b.n	800b6b6 <ConfirmNameConstraints+0x192>
                        matchDns = MatchBaseName(ASN_DNS_TYPE,
                                          name->name, name->len,
 800b694:	693b      	ldr	r3, [r7, #16]
 800b696:	68d9      	ldr	r1, [r3, #12]
                        matchDns = MatchBaseName(ASN_DNS_TYPE,
 800b698:	693b      	ldr	r3, [r7, #16]
 800b69a:	689a      	ldr	r2, [r3, #8]
                                          base->name, base->nameSz);
 800b69c:	697b      	ldr	r3, [r7, #20]
 800b69e:	6858      	ldr	r0, [r3, #4]
                        matchDns = MatchBaseName(ASN_DNS_TYPE,
 800b6a0:	697b      	ldr	r3, [r7, #20]
 800b6a2:	689b      	ldr	r3, [r3, #8]
 800b6a4:	9300      	str	r3, [sp, #0]
 800b6a6:	4603      	mov	r3, r0
 800b6a8:	2002      	movs	r0, #2
 800b6aa:	f7ff fe7f 	bl	800b3ac <MatchBaseName>
 800b6ae:	62b8      	str	r0, [r7, #40]	; 0x28
                        name = name->next;
 800b6b0:	693b      	ldr	r3, [r7, #16]
 800b6b2:	681b      	ldr	r3, [r3, #0]
 800b6b4:	613b      	str	r3, [r7, #16]
                    while (name != NULL) {
 800b6b6:	693b      	ldr	r3, [r7, #16]
 800b6b8:	2b00      	cmp	r3, #0
 800b6ba:	d1eb      	bne.n	800b694 <ConfirmNameConstraints+0x170>
                    }
                    break;
 800b6bc:	e057      	b.n	800b76e <ConfirmNameConstraints+0x24a>
                }
                case ASN_RFC822_TYPE:
                {
                    DNS_entry* name = cert->altEmailNames;
 800b6be:	683b      	ldr	r3, [r7, #0]
 800b6c0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b6c2:	60fb      	str	r3, [r7, #12]

                    if (name != NULL)
 800b6c4:	68fb      	ldr	r3, [r7, #12]
 800b6c6:	2b00      	cmp	r3, #0
 800b6c8:	d013      	beq.n	800b6f2 <ConfirmNameConstraints+0x1ce>
                        needEmail = 1;
 800b6ca:	2301      	movs	r3, #1
 800b6cc:	627b      	str	r3, [r7, #36]	; 0x24

                    while (name != NULL) {
 800b6ce:	e010      	b.n	800b6f2 <ConfirmNameConstraints+0x1ce>
                        matchEmail = MatchBaseName(ASN_DNS_TYPE,
                                          name->name, name->len,
 800b6d0:	68fb      	ldr	r3, [r7, #12]
 800b6d2:	68d9      	ldr	r1, [r3, #12]
                        matchEmail = MatchBaseName(ASN_DNS_TYPE,
 800b6d4:	68fb      	ldr	r3, [r7, #12]
 800b6d6:	689a      	ldr	r2, [r3, #8]
                                          base->name, base->nameSz);
 800b6d8:	697b      	ldr	r3, [r7, #20]
 800b6da:	6858      	ldr	r0, [r3, #4]
                        matchEmail = MatchBaseName(ASN_DNS_TYPE,
 800b6dc:	697b      	ldr	r3, [r7, #20]
 800b6de:	689b      	ldr	r3, [r3, #8]
 800b6e0:	9300      	str	r3, [sp, #0]
 800b6e2:	4603      	mov	r3, r0
 800b6e4:	2002      	movs	r0, #2
 800b6e6:	f7ff fe61 	bl	800b3ac <MatchBaseName>
 800b6ea:	6238      	str	r0, [r7, #32]
                        name = name->next;
 800b6ec:	68fb      	ldr	r3, [r7, #12]
 800b6ee:	681b      	ldr	r3, [r3, #0]
 800b6f0:	60fb      	str	r3, [r7, #12]
                    while (name != NULL) {
 800b6f2:	68fb      	ldr	r3, [r7, #12]
 800b6f4:	2b00      	cmp	r3, #0
 800b6f6:	d1eb      	bne.n	800b6d0 <ConfirmNameConstraints+0x1ac>
                    }
                    break;
 800b6f8:	e039      	b.n	800b76e <ConfirmNameConstraints+0x24a>
                }
                case ASN_DIR_TYPE:
                {
                    /* allow permitted dirName smaller than actual subject */
                    needDir = 1;
 800b6fa:	2301      	movs	r3, #1
 800b6fc:	61fb      	str	r3, [r7, #28]
                    if (cert->subjectRaw != NULL &&
 800b6fe:	683b      	ldr	r3, [r7, #0]
 800b700:	f8d3 3338 	ldr.w	r3, [r3, #824]	; 0x338
 800b704:	2b00      	cmp	r3, #0
 800b706:	d031      	beq.n	800b76c <ConfirmNameConstraints+0x248>
                        cert->subjectRawLen >= base->nameSz &&
 800b708:	683b      	ldr	r3, [r7, #0]
 800b70a:	f8d3 233c 	ldr.w	r2, [r3, #828]	; 0x33c
 800b70e:	697b      	ldr	r3, [r7, #20]
 800b710:	689b      	ldr	r3, [r3, #8]
                    if (cert->subjectRaw != NULL &&
 800b712:	429a      	cmp	r2, r3
 800b714:	db2a      	blt.n	800b76c <ConfirmNameConstraints+0x248>
                        XMEMCMP(cert->subjectRaw, base->name,
 800b716:	683b      	ldr	r3, [r7, #0]
 800b718:	f8d3 0338 	ldr.w	r0, [r3, #824]	; 0x338
 800b71c:	697b      	ldr	r3, [r7, #20]
 800b71e:	6859      	ldr	r1, [r3, #4]
 800b720:	697b      	ldr	r3, [r7, #20]
 800b722:	689b      	ldr	r3, [r3, #8]
 800b724:	461a      	mov	r2, r3
 800b726:	f00d fe57 	bl	80193d8 <memcmp>
 800b72a:	4603      	mov	r3, r0
                        cert->subjectRawLen >= base->nameSz &&
 800b72c:	2b00      	cmp	r3, #0
 800b72e:	d11d      	bne.n	800b76c <ConfirmNameConstraints+0x248>
                                                        base->nameSz) == 0) {
                        matchDir = 1;
 800b730:	2301      	movs	r3, #1
 800b732:	61bb      	str	r3, [r7, #24]
                           "Restrictions of the form directoryName MUST be
                            applied to the subject field .... and to any names
                            of type directoryName in the subjectAltName
                            extension"
                        */
                        if (cert->altDirNames != NULL) {
 800b734:	683b      	ldr	r3, [r7, #0]
 800b736:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b738:	2b00      	cmp	r3, #0
 800b73a:	d017      	beq.n	800b76c <ConfirmNameConstraints+0x248>
                            DNS_entry* cur = cert->altDirNames;
 800b73c:	683b      	ldr	r3, [r7, #0]
 800b73e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b740:	60bb      	str	r3, [r7, #8]
                            while (cur != NULL) {
 800b742:	e010      	b.n	800b766 <ConfirmNameConstraints+0x242>
                                if (XMEMCMP(cur->name, base->name, base->nameSz)
 800b744:	68bb      	ldr	r3, [r7, #8]
 800b746:	68d8      	ldr	r0, [r3, #12]
 800b748:	697b      	ldr	r3, [r7, #20]
 800b74a:	6859      	ldr	r1, [r3, #4]
 800b74c:	697b      	ldr	r3, [r7, #20]
 800b74e:	689b      	ldr	r3, [r3, #8]
 800b750:	461a      	mov	r2, r3
 800b752:	f00d fe41 	bl	80193d8 <memcmp>
 800b756:	4603      	mov	r3, r0
 800b758:	2b00      	cmp	r3, #0
 800b75a:	d001      	beq.n	800b760 <ConfirmNameConstraints+0x23c>
                                        != 0) {
                                    WOLFSSL_MSG("DIR alt name constraint err");
                                    matchDir = 0; /* did not match */
 800b75c:	2300      	movs	r3, #0
 800b75e:	61bb      	str	r3, [r7, #24]
                                }
                                cur = cur->next;
 800b760:	68bb      	ldr	r3, [r7, #8]
 800b762:	681b      	ldr	r3, [r3, #0]
 800b764:	60bb      	str	r3, [r7, #8]
                            while (cur != NULL) {
 800b766:	68bb      	ldr	r3, [r7, #8]
 800b768:	2b00      	cmp	r3, #0
 800b76a:	d1eb      	bne.n	800b744 <ConfirmNameConstraints+0x220>
                            }
                        }
                        #endif /* !WOLFSSL_NO_ASN_STRICT */
                    }
                    break;
 800b76c:	bf00      	nop
                }
            } /* switch */
            base = base->next;
 800b76e:	697b      	ldr	r3, [r7, #20]
 800b770:	681b      	ldr	r3, [r3, #0]
 800b772:	617b      	str	r3, [r7, #20]
        while (base != NULL) {
 800b774:	697b      	ldr	r3, [r7, #20]
 800b776:	2b00      	cmp	r3, #0
 800b778:	f47f af7a 	bne.w	800b670 <ConfirmNameConstraints+0x14c>
        }

        if ((needDns   && !matchDns) ||
 800b77c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b77e:	2b00      	cmp	r3, #0
 800b780:	d002      	beq.n	800b788 <ConfirmNameConstraints+0x264>
 800b782:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b784:	2b00      	cmp	r3, #0
 800b786:	d00b      	beq.n	800b7a0 <ConfirmNameConstraints+0x27c>
 800b788:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b78a:	2b00      	cmp	r3, #0
 800b78c:	d002      	beq.n	800b794 <ConfirmNameConstraints+0x270>
            (needEmail && !matchEmail) ||
 800b78e:	6a3b      	ldr	r3, [r7, #32]
 800b790:	2b00      	cmp	r3, #0
 800b792:	d005      	beq.n	800b7a0 <ConfirmNameConstraints+0x27c>
 800b794:	69fb      	ldr	r3, [r7, #28]
 800b796:	2b00      	cmp	r3, #0
 800b798:	d004      	beq.n	800b7a4 <ConfirmNameConstraints+0x280>
            (needDir   && !matchDir)) {
 800b79a:	69bb      	ldr	r3, [r7, #24]
 800b79c:	2b00      	cmp	r3, #0
 800b79e:	d101      	bne.n	800b7a4 <ConfirmNameConstraints+0x280>
            return 0;
 800b7a0:	2300      	movs	r3, #0
 800b7a2:	e000      	b.n	800b7a6 <ConfirmNameConstraints+0x282>
        }
    }

    return 1;
 800b7a4:	2301      	movs	r3, #1
}
 800b7a6:	4618      	mov	r0, r3
 800b7a8:	3740      	adds	r7, #64	; 0x40
 800b7aa:	46bd      	mov	sp, r7
 800b7ac:	bd80      	pop	{r7, pc}

0800b7ae <DecodeAltNames>:

#endif /* IGNORE_NAME_CONSTRAINTS */

static int DecodeAltNames(const byte* input, int sz, DecodedCert* cert)
{
 800b7ae:	b580      	push	{r7, lr}
 800b7b0:	b09a      	sub	sp, #104	; 0x68
 800b7b2:	af00      	add	r7, sp, #0
 800b7b4:	60f8      	str	r0, [r7, #12]
 800b7b6:	60b9      	str	r1, [r7, #8]
 800b7b8:	607a      	str	r2, [r7, #4]
    word32 idx = 0;
 800b7ba:	2300      	movs	r3, #0
 800b7bc:	62bb      	str	r3, [r7, #40]	; 0x28
    int length = 0;
 800b7be:	2300      	movs	r3, #0
 800b7c0:	627b      	str	r3, [r7, #36]	; 0x24

    WOLFSSL_ENTER("DecodeAltNames");

    if (GetSequence(input, &idx, &length, sz) < 0) {
 800b7c2:	68bb      	ldr	r3, [r7, #8]
 800b7c4:	f107 0224 	add.w	r2, r7, #36	; 0x24
 800b7c8:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800b7cc:	68f8      	ldr	r0, [r7, #12]
 800b7ce:	f7fd f8df 	bl	8008990 <GetSequence>
 800b7d2:	4603      	mov	r3, r0
 800b7d4:	2b00      	cmp	r3, #0
 800b7d6:	da02      	bge.n	800b7de <DecodeAltNames+0x30>
        WOLFSSL_MSG("\tBad Sequence");
        return ASN_PARSE_E;
 800b7d8:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800b7dc:	e20a      	b.n	800bbf4 <DecodeAltNames+0x446>
    }

    if (length == 0) {
 800b7de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b7e0:	2b00      	cmp	r3, #0
 800b7e2:	d102      	bne.n	800b7ea <DecodeAltNames+0x3c>
        /* RFC 5280 4.2.1.6.  Subject Alternative Name
           If the subjectAltName extension is present, the sequence MUST
           contain at least one entry. */
        return ASN_PARSE_E;
 800b7e4:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800b7e8:	e204      	b.n	800bbf4 <DecodeAltNames+0x446>
    }

    cert->weOwnAltNames = 1;
 800b7ea:	687a      	ldr	r2, [r7, #4]
 800b7ec:	f892 3378 	ldrb.w	r3, [r2, #888]	; 0x378
 800b7f0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b7f4:	f882 3378 	strb.w	r3, [r2, #888]	; 0x378

    while (length > 0) {
 800b7f8:	e1f7      	b.n	800bbea <DecodeAltNames+0x43c>
        byte b = input[idx++];
 800b7fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b7fc:	1c5a      	adds	r2, r3, #1
 800b7fe:	62ba      	str	r2, [r7, #40]	; 0x28
 800b800:	68fa      	ldr	r2, [r7, #12]
 800b802:	4413      	add	r3, r2
 800b804:	781b      	ldrb	r3, [r3, #0]
 800b806:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63

        length--;
 800b80a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b80c:	3b01      	subs	r3, #1
 800b80e:	627b      	str	r3, [r7, #36]	; 0x24

        /* Save DNS Type names in the altNames list. */
        /* Save Other Type names in the cert's OidMap */
        if (b == (ASN_CONTEXT_SPECIFIC | ASN_DNS_TYPE)) {
 800b810:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 800b814:	2b82      	cmp	r3, #130	; 0x82
 800b816:	d15b      	bne.n	800b8d0 <DecodeAltNames+0x122>
            DNS_entry* dnsEntry;
            int strLen;
            word32 lenStartIdx = idx;
 800b818:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b81a:	637b      	str	r3, [r7, #52]	; 0x34

            if (GetLength(input, &idx, &strLen, sz) < 0) {
 800b81c:	68bb      	ldr	r3, [r7, #8]
 800b81e:	f107 0220 	add.w	r2, r7, #32
 800b822:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800b826:	68f8      	ldr	r0, [r7, #12]
 800b828:	f7fc ff7e 	bl	8008728 <GetLength>
 800b82c:	4603      	mov	r3, r0
 800b82e:	2b00      	cmp	r3, #0
 800b830:	da02      	bge.n	800b838 <DecodeAltNames+0x8a>
                WOLFSSL_MSG("\tfail: str length");
                return ASN_PARSE_E;
 800b832:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800b836:	e1dd      	b.n	800bbf4 <DecodeAltNames+0x446>
            }
            length -= (idx - lenStartIdx);
 800b838:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b83a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b83c:	1ad3      	subs	r3, r2, r3
 800b83e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b840:	4413      	add	r3, r2
 800b842:	627b      	str	r3, [r7, #36]	; 0x24

            dnsEntry = (DNS_entry*)XMALLOC(sizeof(DNS_entry), cert->heap,
 800b844:	2010      	movs	r0, #16
 800b846:	f003 fb57 	bl	800eef8 <wolfSSL_Malloc>
 800b84a:	6338      	str	r0, [r7, #48]	; 0x30
                                        DYNAMIC_TYPE_ALTNAME);
            if (dnsEntry == NULL) {
 800b84c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b84e:	2b00      	cmp	r3, #0
 800b850:	d102      	bne.n	800b858 <DecodeAltNames+0xaa>
                WOLFSSL_MSG("\tOut of Memory");
                return MEMORY_E;
 800b852:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800b856:	e1cd      	b.n	800bbf4 <DecodeAltNames+0x446>
            }

            dnsEntry->type = ASN_DNS_TYPE;
 800b858:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b85a:	2202      	movs	r2, #2
 800b85c:	605a      	str	r2, [r3, #4]
            dnsEntry->name = (char*)XMALLOC(strLen + 1, cert->heap,
 800b85e:	6a3b      	ldr	r3, [r7, #32]
 800b860:	3301      	adds	r3, #1
 800b862:	4618      	mov	r0, r3
 800b864:	f003 fb48 	bl	800eef8 <wolfSSL_Malloc>
 800b868:	4602      	mov	r2, r0
 800b86a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b86c:	60da      	str	r2, [r3, #12]
                                         DYNAMIC_TYPE_ALTNAME);
            if (dnsEntry->name == NULL) {
 800b86e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b870:	68db      	ldr	r3, [r3, #12]
 800b872:	2b00      	cmp	r3, #0
 800b874:	d10a      	bne.n	800b88c <DecodeAltNames+0xde>
                WOLFSSL_MSG("\tOut of Memory");
                XFREE(dnsEntry, cert->heap, DYNAMIC_TYPE_ALTNAME);
 800b876:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b878:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b87a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b87c:	2b00      	cmp	r3, #0
 800b87e:	d002      	beq.n	800b886 <DecodeAltNames+0xd8>
 800b880:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b882:	f003 fb55 	bl	800ef30 <wolfSSL_Free>
                return MEMORY_E;
 800b886:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800b88a:	e1b3      	b.n	800bbf4 <DecodeAltNames+0x446>
            }
            dnsEntry->len = strLen;
 800b88c:	6a3a      	ldr	r2, [r7, #32]
 800b88e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b890:	609a      	str	r2, [r3, #8]
            XMEMCPY(dnsEntry->name, &input[idx], strLen);
 800b892:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b894:	68d8      	ldr	r0, [r3, #12]
 800b896:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b898:	68fa      	ldr	r2, [r7, #12]
 800b89a:	4413      	add	r3, r2
 800b89c:	6a3a      	ldr	r2, [r7, #32]
 800b89e:	4619      	mov	r1, r3
 800b8a0:	f00d fda9 	bl	80193f6 <memcpy>
            dnsEntry->name[strLen] = '\0';
 800b8a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b8a6:	68db      	ldr	r3, [r3, #12]
 800b8a8:	6a3a      	ldr	r2, [r7, #32]
 800b8aa:	4413      	add	r3, r2
 800b8ac:	2200      	movs	r2, #0
 800b8ae:	701a      	strb	r2, [r3, #0]

            dnsEntry->next = cert->altNames;
 800b8b0:	687b      	ldr	r3, [r7, #4]
 800b8b2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b8b4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b8b6:	601a      	str	r2, [r3, #0]
            cert->altNames = dnsEntry;
 800b8b8:	687b      	ldr	r3, [r7, #4]
 800b8ba:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800b8bc:	625a      	str	r2, [r3, #36]	; 0x24

            length -= strLen;
 800b8be:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b8c0:	6a3b      	ldr	r3, [r7, #32]
 800b8c2:	1ad3      	subs	r3, r2, r3
 800b8c4:	627b      	str	r3, [r7, #36]	; 0x24
            idx    += strLen;
 800b8c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b8c8:	6a3a      	ldr	r2, [r7, #32]
 800b8ca:	4413      	add	r3, r2
 800b8cc:	62bb      	str	r3, [r7, #40]	; 0x28
 800b8ce:	e18c      	b.n	800bbea <DecodeAltNames+0x43c>
        }
    #ifndef IGNORE_NAME_CONSTRAINTS
        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | ASN_DIR_TYPE)) {
 800b8d0:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 800b8d4:	2ba4      	cmp	r3, #164	; 0xa4
 800b8d6:	d169      	bne.n	800b9ac <DecodeAltNames+0x1fe>
            DNS_entry* dirEntry;
            int strLen;
            word32 lenStartIdx = idx;
 800b8d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b8da:	643b      	str	r3, [r7, #64]	; 0x40

            if (GetLength(input, &idx, &strLen, sz) < 0) {
 800b8dc:	68bb      	ldr	r3, [r7, #8]
 800b8de:	f107 021c 	add.w	r2, r7, #28
 800b8e2:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800b8e6:	68f8      	ldr	r0, [r7, #12]
 800b8e8:	f7fc ff1e 	bl	8008728 <GetLength>
 800b8ec:	4603      	mov	r3, r0
 800b8ee:	2b00      	cmp	r3, #0
 800b8f0:	da02      	bge.n	800b8f8 <DecodeAltNames+0x14a>
                WOLFSSL_MSG("\tfail: str length");
                return ASN_PARSE_E;
 800b8f2:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800b8f6:	e17d      	b.n	800bbf4 <DecodeAltNames+0x446>
            }

            if (GetSequence(input, &idx, &strLen, sz) < 0) {
 800b8f8:	68bb      	ldr	r3, [r7, #8]
 800b8fa:	f107 021c 	add.w	r2, r7, #28
 800b8fe:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800b902:	68f8      	ldr	r0, [r7, #12]
 800b904:	f7fd f844 	bl	8008990 <GetSequence>
 800b908:	4603      	mov	r3, r0
 800b90a:	2b00      	cmp	r3, #0
 800b90c:	da02      	bge.n	800b914 <DecodeAltNames+0x166>
                WOLFSSL_MSG("\tfail: seq length");
                return ASN_PARSE_E;
 800b90e:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800b912:	e16f      	b.n	800bbf4 <DecodeAltNames+0x446>
            }
            length -= (idx - lenStartIdx);
 800b914:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b916:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800b918:	1ad3      	subs	r3, r2, r3
 800b91a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b91c:	4413      	add	r3, r2
 800b91e:	627b      	str	r3, [r7, #36]	; 0x24

            dirEntry = (DNS_entry*)XMALLOC(sizeof(DNS_entry), cert->heap,
 800b920:	2010      	movs	r0, #16
 800b922:	f003 fae9 	bl	800eef8 <wolfSSL_Malloc>
 800b926:	63f8      	str	r0, [r7, #60]	; 0x3c
                                        DYNAMIC_TYPE_ALTNAME);
            if (dirEntry == NULL) {
 800b928:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b92a:	2b00      	cmp	r3, #0
 800b92c:	d102      	bne.n	800b934 <DecodeAltNames+0x186>
                WOLFSSL_MSG("\tOut of Memory");
                return MEMORY_E;
 800b92e:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800b932:	e15f      	b.n	800bbf4 <DecodeAltNames+0x446>
            }

            dirEntry->type = ASN_DIR_TYPE;
 800b934:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b936:	2204      	movs	r2, #4
 800b938:	605a      	str	r2, [r3, #4]
            dirEntry->name = (char*)XMALLOC(strLen + 1, cert->heap,
 800b93a:	69fb      	ldr	r3, [r7, #28]
 800b93c:	3301      	adds	r3, #1
 800b93e:	4618      	mov	r0, r3
 800b940:	f003 fada 	bl	800eef8 <wolfSSL_Malloc>
 800b944:	4602      	mov	r2, r0
 800b946:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b948:	60da      	str	r2, [r3, #12]
                                         DYNAMIC_TYPE_ALTNAME);
            if (dirEntry->name == NULL) {
 800b94a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b94c:	68db      	ldr	r3, [r3, #12]
 800b94e:	2b00      	cmp	r3, #0
 800b950:	d10a      	bne.n	800b968 <DecodeAltNames+0x1ba>
                WOLFSSL_MSG("\tOut of Memory");
                XFREE(dirEntry, cert->heap, DYNAMIC_TYPE_ALTNAME);
 800b952:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b954:	63bb      	str	r3, [r7, #56]	; 0x38
 800b956:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b958:	2b00      	cmp	r3, #0
 800b95a:	d002      	beq.n	800b962 <DecodeAltNames+0x1b4>
 800b95c:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800b95e:	f003 fae7 	bl	800ef30 <wolfSSL_Free>
                return MEMORY_E;
 800b962:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800b966:	e145      	b.n	800bbf4 <DecodeAltNames+0x446>
            }
            dirEntry->len = strLen;
 800b968:	69fa      	ldr	r2, [r7, #28]
 800b96a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b96c:	609a      	str	r2, [r3, #8]
            XMEMCPY(dirEntry->name, &input[idx], strLen);
 800b96e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b970:	68d8      	ldr	r0, [r3, #12]
 800b972:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b974:	68fa      	ldr	r2, [r7, #12]
 800b976:	4413      	add	r3, r2
 800b978:	69fa      	ldr	r2, [r7, #28]
 800b97a:	4619      	mov	r1, r3
 800b97c:	f00d fd3b 	bl	80193f6 <memcpy>
            dirEntry->name[strLen] = '\0';
 800b980:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b982:	68db      	ldr	r3, [r3, #12]
 800b984:	69fa      	ldr	r2, [r7, #28]
 800b986:	4413      	add	r3, r2
 800b988:	2200      	movs	r2, #0
 800b98a:	701a      	strb	r2, [r3, #0]

            dirEntry->next = cert->altDirNames;
 800b98c:	687b      	ldr	r3, [r7, #4]
 800b98e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b990:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b992:	601a      	str	r2, [r3, #0]
            cert->altDirNames = dirEntry;
 800b994:	687b      	ldr	r3, [r7, #4]
 800b996:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800b998:	62da      	str	r2, [r3, #44]	; 0x2c

            length -= strLen;
 800b99a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b99c:	69fb      	ldr	r3, [r7, #28]
 800b99e:	1ad3      	subs	r3, r2, r3
 800b9a0:	627b      	str	r3, [r7, #36]	; 0x24
            idx    += strLen;
 800b9a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b9a4:	69fa      	ldr	r2, [r7, #28]
 800b9a6:	4413      	add	r3, r2
 800b9a8:	62bb      	str	r3, [r7, #40]	; 0x28
 800b9aa:	e11e      	b.n	800bbea <DecodeAltNames+0x43c>
        }
        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_RFC822_TYPE)) {
 800b9ac:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 800b9b0:	2b81      	cmp	r3, #129	; 0x81
 800b9b2:	d15b      	bne.n	800ba6c <DecodeAltNames+0x2be>
            DNS_entry* emailEntry;
            int strLen;
            word32 lenStartIdx = idx;
 800b9b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b9b6:	64fb      	str	r3, [r7, #76]	; 0x4c

            if (GetLength(input, &idx, &strLen, sz) < 0) {
 800b9b8:	68bb      	ldr	r3, [r7, #8]
 800b9ba:	f107 0218 	add.w	r2, r7, #24
 800b9be:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800b9c2:	68f8      	ldr	r0, [r7, #12]
 800b9c4:	f7fc feb0 	bl	8008728 <GetLength>
 800b9c8:	4603      	mov	r3, r0
 800b9ca:	2b00      	cmp	r3, #0
 800b9cc:	da02      	bge.n	800b9d4 <DecodeAltNames+0x226>
                WOLFSSL_MSG("\tfail: str length");
                return ASN_PARSE_E;
 800b9ce:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800b9d2:	e10f      	b.n	800bbf4 <DecodeAltNames+0x446>
            }
            length -= (idx - lenStartIdx);
 800b9d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b9d6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800b9d8:	1ad3      	subs	r3, r2, r3
 800b9da:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b9dc:	4413      	add	r3, r2
 800b9de:	627b      	str	r3, [r7, #36]	; 0x24

            emailEntry = (DNS_entry*)XMALLOC(sizeof(DNS_entry), cert->heap,
 800b9e0:	2010      	movs	r0, #16
 800b9e2:	f003 fa89 	bl	800eef8 <wolfSSL_Malloc>
 800b9e6:	64b8      	str	r0, [r7, #72]	; 0x48
                                        DYNAMIC_TYPE_ALTNAME);
            if (emailEntry == NULL) {
 800b9e8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b9ea:	2b00      	cmp	r3, #0
 800b9ec:	d102      	bne.n	800b9f4 <DecodeAltNames+0x246>
                WOLFSSL_MSG("\tOut of Memory");
                return MEMORY_E;
 800b9ee:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800b9f2:	e0ff      	b.n	800bbf4 <DecodeAltNames+0x446>
            }

            emailEntry->type = ASN_RFC822_TYPE;
 800b9f4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b9f6:	2201      	movs	r2, #1
 800b9f8:	605a      	str	r2, [r3, #4]
            emailEntry->name = (char*)XMALLOC(strLen + 1, cert->heap,
 800b9fa:	69bb      	ldr	r3, [r7, #24]
 800b9fc:	3301      	adds	r3, #1
 800b9fe:	4618      	mov	r0, r3
 800ba00:	f003 fa7a 	bl	800eef8 <wolfSSL_Malloc>
 800ba04:	4602      	mov	r2, r0
 800ba06:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ba08:	60da      	str	r2, [r3, #12]
                                         DYNAMIC_TYPE_ALTNAME);
            if (emailEntry->name == NULL) {
 800ba0a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ba0c:	68db      	ldr	r3, [r3, #12]
 800ba0e:	2b00      	cmp	r3, #0
 800ba10:	d10a      	bne.n	800ba28 <DecodeAltNames+0x27a>
                WOLFSSL_MSG("\tOut of Memory");
                XFREE(emailEntry, cert->heap, DYNAMIC_TYPE_ALTNAME);
 800ba12:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ba14:	647b      	str	r3, [r7, #68]	; 0x44
 800ba16:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ba18:	2b00      	cmp	r3, #0
 800ba1a:	d002      	beq.n	800ba22 <DecodeAltNames+0x274>
 800ba1c:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800ba1e:	f003 fa87 	bl	800ef30 <wolfSSL_Free>
                return MEMORY_E;
 800ba22:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800ba26:	e0e5      	b.n	800bbf4 <DecodeAltNames+0x446>
            }
            emailEntry->len = strLen;
 800ba28:	69ba      	ldr	r2, [r7, #24]
 800ba2a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ba2c:	609a      	str	r2, [r3, #8]
            XMEMCPY(emailEntry->name, &input[idx], strLen);
 800ba2e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ba30:	68d8      	ldr	r0, [r3, #12]
 800ba32:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ba34:	68fa      	ldr	r2, [r7, #12]
 800ba36:	4413      	add	r3, r2
 800ba38:	69ba      	ldr	r2, [r7, #24]
 800ba3a:	4619      	mov	r1, r3
 800ba3c:	f00d fcdb 	bl	80193f6 <memcpy>
            emailEntry->name[strLen] = '\0';
 800ba40:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ba42:	68db      	ldr	r3, [r3, #12]
 800ba44:	69ba      	ldr	r2, [r7, #24]
 800ba46:	4413      	add	r3, r2
 800ba48:	2200      	movs	r2, #0
 800ba4a:	701a      	strb	r2, [r3, #0]

            emailEntry->next = cert->altEmailNames;
 800ba4c:	687b      	ldr	r3, [r7, #4]
 800ba4e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800ba50:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ba52:	601a      	str	r2, [r3, #0]
            cert->altEmailNames = emailEntry;
 800ba54:	687b      	ldr	r3, [r7, #4]
 800ba56:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800ba58:	629a      	str	r2, [r3, #40]	; 0x28

            length -= strLen;
 800ba5a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800ba5c:	69bb      	ldr	r3, [r7, #24]
 800ba5e:	1ad3      	subs	r3, r2, r3
 800ba60:	627b      	str	r3, [r7, #36]	; 0x24
            idx    += strLen;
 800ba62:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ba64:	69ba      	ldr	r2, [r7, #24]
 800ba66:	4413      	add	r3, r2
 800ba68:	62bb      	str	r3, [r7, #40]	; 0x28
 800ba6a:	e0be      	b.n	800bbea <DecodeAltNames+0x43c>
        }
        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_URI_TYPE)) {
 800ba6c:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 800ba70:	2b86      	cmp	r3, #134	; 0x86
 800ba72:	f040 809d 	bne.w	800bbb0 <DecodeAltNames+0x402>
            DNS_entry* uriEntry;
            int strLen;
            word32 lenStartIdx = idx;
 800ba76:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ba78:	65bb      	str	r3, [r7, #88]	; 0x58

            WOLFSSL_MSG("\tPutting URI into list but not using");
            if (GetLength(input, &idx, &strLen, sz) < 0) {
 800ba7a:	68bb      	ldr	r3, [r7, #8]
 800ba7c:	f107 0214 	add.w	r2, r7, #20
 800ba80:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800ba84:	68f8      	ldr	r0, [r7, #12]
 800ba86:	f7fc fe4f 	bl	8008728 <GetLength>
 800ba8a:	4603      	mov	r3, r0
 800ba8c:	2b00      	cmp	r3, #0
 800ba8e:	da02      	bge.n	800ba96 <DecodeAltNames+0x2e8>
                WOLFSSL_MSG("\tfail: str length");
                return ASN_PARSE_E;
 800ba90:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800ba94:	e0ae      	b.n	800bbf4 <DecodeAltNames+0x446>
            }
            length -= (idx - lenStartIdx);
 800ba96:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ba98:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800ba9a:	1ad3      	subs	r3, r2, r3
 800ba9c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800ba9e:	4413      	add	r3, r2
 800baa0:	627b      	str	r3, [r7, #36]	; 0x24

            /* check that strLen at index is not past input buffer */
            if (strLen + (int)idx > sz) {
 800baa2:	697b      	ldr	r3, [r7, #20]
 800baa4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800baa6:	4413      	add	r3, r2
 800baa8:	68ba      	ldr	r2, [r7, #8]
 800baaa:	429a      	cmp	r2, r3
 800baac:	da02      	bge.n	800bab4 <DecodeAltNames+0x306>
                return BUFFER_E;
 800baae:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800bab2:	e09f      	b.n	800bbf4 <DecodeAltNames+0x446>

            {
                int i;

                /* skip past scheme (i.e http,ftp,...) finding first ':' char */
                for (i = 0; i < strLen; i++) {
 800bab4:	2300      	movs	r3, #0
 800bab6:	667b      	str	r3, [r7, #100]	; 0x64
 800bab8:	e014      	b.n	800bae4 <DecodeAltNames+0x336>
                    if (input[idx + i] == ':') {
 800baba:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800babc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800babe:	4413      	add	r3, r2
 800bac0:	68fa      	ldr	r2, [r7, #12]
 800bac2:	4413      	add	r3, r2
 800bac4:	781b      	ldrb	r3, [r3, #0]
 800bac6:	2b3a      	cmp	r3, #58	; 0x3a
 800bac8:	d011      	beq.n	800baee <DecodeAltNames+0x340>
                        break;
                    }
                    if (input[idx + i] == '/') {
 800baca:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800bacc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800bace:	4413      	add	r3, r2
 800bad0:	68fa      	ldr	r2, [r7, #12]
 800bad2:	4413      	add	r3, r2
 800bad4:	781b      	ldrb	r3, [r3, #0]
 800bad6:	2b2f      	cmp	r3, #47	; 0x2f
 800bad8:	d101      	bne.n	800bade <DecodeAltNames+0x330>
                        i = strLen; /* error, found relative path since '/' was
 800bada:	697b      	ldr	r3, [r7, #20]
 800badc:	667b      	str	r3, [r7, #100]	; 0x64
                for (i = 0; i < strLen; i++) {
 800bade:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800bae0:	3301      	adds	r3, #1
 800bae2:	667b      	str	r3, [r7, #100]	; 0x64
 800bae4:	697b      	ldr	r3, [r7, #20]
 800bae6:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800bae8:	429a      	cmp	r2, r3
 800baea:	dbe6      	blt.n	800baba <DecodeAltNames+0x30c>
 800baec:	e000      	b.n	800baf0 <DecodeAltNames+0x342>
                        break;
 800baee:	bf00      	nop
                    }
                }

                /* test if no ':' char was found and test that the next two
                 * chars are // to match the pattern "://" */
                if (i >= strLen - 2 || (input[idx + i + 1] != '/' ||
 800baf0:	697b      	ldr	r3, [r7, #20]
 800baf2:	3b02      	subs	r3, #2
 800baf4:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800baf6:	429a      	cmp	r2, r3
 800baf8:	da11      	bge.n	800bb1e <DecodeAltNames+0x370>
 800bafa:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800bafc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800bafe:	4413      	add	r3, r2
 800bb00:	3301      	adds	r3, #1
 800bb02:	68fa      	ldr	r2, [r7, #12]
 800bb04:	4413      	add	r3, r2
 800bb06:	781b      	ldrb	r3, [r3, #0]
 800bb08:	2b2f      	cmp	r3, #47	; 0x2f
 800bb0a:	d108      	bne.n	800bb1e <DecodeAltNames+0x370>
                                        input[idx + i + 2] != '/')) {
 800bb0c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800bb0e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800bb10:	4413      	add	r3, r2
 800bb12:	3302      	adds	r3, #2
 800bb14:	68fa      	ldr	r2, [r7, #12]
 800bb16:	4413      	add	r3, r2
 800bb18:	781b      	ldrb	r3, [r3, #0]
                if (i >= strLen - 2 || (input[idx + i + 1] != '/' ||
 800bb1a:	2b2f      	cmp	r3, #47	; 0x2f
 800bb1c:	d002      	beq.n	800bb24 <DecodeAltNames+0x376>
                    WOLFSSL_MSG("\tAlt Name must be absolute URI");
                    return ASN_ALT_NAME_E;
 800bb1e:	f06f 03a0 	mvn.w	r3, #160	; 0xa0
 800bb22:	e067      	b.n	800bbf4 <DecodeAltNames+0x446>
                }
            }
        #endif

            uriEntry = (DNS_entry*)XMALLOC(sizeof(DNS_entry), cert->heap,
 800bb24:	2010      	movs	r0, #16
 800bb26:	f003 f9e7 	bl	800eef8 <wolfSSL_Malloc>
 800bb2a:	6578      	str	r0, [r7, #84]	; 0x54
                                        DYNAMIC_TYPE_ALTNAME);
            if (uriEntry == NULL) {
 800bb2c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800bb2e:	2b00      	cmp	r3, #0
 800bb30:	d102      	bne.n	800bb38 <DecodeAltNames+0x38a>
                WOLFSSL_MSG("\tOut of Memory");
                return MEMORY_E;
 800bb32:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800bb36:	e05d      	b.n	800bbf4 <DecodeAltNames+0x446>
            }

            uriEntry->type = ASN_URI_TYPE;
 800bb38:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800bb3a:	2206      	movs	r2, #6
 800bb3c:	605a      	str	r2, [r3, #4]
            uriEntry->name = (char*)XMALLOC(strLen + 1, cert->heap,
 800bb3e:	697b      	ldr	r3, [r7, #20]
 800bb40:	3301      	adds	r3, #1
 800bb42:	4618      	mov	r0, r3
 800bb44:	f003 f9d8 	bl	800eef8 <wolfSSL_Malloc>
 800bb48:	4602      	mov	r2, r0
 800bb4a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800bb4c:	60da      	str	r2, [r3, #12]
                                         DYNAMIC_TYPE_ALTNAME);
            if (uriEntry->name == NULL) {
 800bb4e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800bb50:	68db      	ldr	r3, [r3, #12]
 800bb52:	2b00      	cmp	r3, #0
 800bb54:	d10a      	bne.n	800bb6c <DecodeAltNames+0x3be>
                WOLFSSL_MSG("\tOut of Memory");
                XFREE(uriEntry, cert->heap, DYNAMIC_TYPE_ALTNAME);
 800bb56:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800bb58:	653b      	str	r3, [r7, #80]	; 0x50
 800bb5a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800bb5c:	2b00      	cmp	r3, #0
 800bb5e:	d002      	beq.n	800bb66 <DecodeAltNames+0x3b8>
 800bb60:	6d38      	ldr	r0, [r7, #80]	; 0x50
 800bb62:	f003 f9e5 	bl	800ef30 <wolfSSL_Free>
                return MEMORY_E;
 800bb66:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800bb6a:	e043      	b.n	800bbf4 <DecodeAltNames+0x446>
            }
            uriEntry->len = strLen;
 800bb6c:	697a      	ldr	r2, [r7, #20]
 800bb6e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800bb70:	609a      	str	r2, [r3, #8]
            XMEMCPY(uriEntry->name, &input[idx], strLen);
 800bb72:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800bb74:	68d8      	ldr	r0, [r3, #12]
 800bb76:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bb78:	68fa      	ldr	r2, [r7, #12]
 800bb7a:	4413      	add	r3, r2
 800bb7c:	697a      	ldr	r2, [r7, #20]
 800bb7e:	4619      	mov	r1, r3
 800bb80:	f00d fc39 	bl	80193f6 <memcpy>
            uriEntry->name[strLen] = '\0';
 800bb84:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800bb86:	68db      	ldr	r3, [r3, #12]
 800bb88:	697a      	ldr	r2, [r7, #20]
 800bb8a:	4413      	add	r3, r2
 800bb8c:	2200      	movs	r2, #0
 800bb8e:	701a      	strb	r2, [r3, #0]

            uriEntry->next = cert->altNames;
 800bb90:	687b      	ldr	r3, [r7, #4]
 800bb92:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800bb94:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800bb96:	601a      	str	r2, [r3, #0]
            cert->altNames = uriEntry;
 800bb98:	687b      	ldr	r3, [r7, #4]
 800bb9a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800bb9c:	625a      	str	r2, [r3, #36]	; 0x24

            length -= strLen;
 800bb9e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800bba0:	697b      	ldr	r3, [r7, #20]
 800bba2:	1ad3      	subs	r3, r2, r3
 800bba4:	627b      	str	r3, [r7, #36]	; 0x24
            idx    += strLen;
 800bba6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bba8:	697a      	ldr	r2, [r7, #20]
 800bbaa:	4413      	add	r3, r2
 800bbac:	62bb      	str	r3, [r7, #40]	; 0x28
 800bbae:	e01c      	b.n	800bbea <DecodeAltNames+0x43c>
            idx += strLen;
        }
    #endif /* WOLFSSL_SEP */
        else {
            int strLen;
            word32 lenStartIdx = idx;
 800bbb0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bbb2:	65fb      	str	r3, [r7, #92]	; 0x5c

            WOLFSSL_MSG("\tUnsupported name type, skipping");

            if (GetLength(input, &idx, &strLen, sz) < 0) {
 800bbb4:	68bb      	ldr	r3, [r7, #8]
 800bbb6:	f107 0210 	add.w	r2, r7, #16
 800bbba:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800bbbe:	68f8      	ldr	r0, [r7, #12]
 800bbc0:	f7fc fdb2 	bl	8008728 <GetLength>
 800bbc4:	4603      	mov	r3, r0
 800bbc6:	2b00      	cmp	r3, #0
 800bbc8:	da02      	bge.n	800bbd0 <DecodeAltNames+0x422>
                WOLFSSL_MSG("\tfail: unsupported name length");
                return ASN_PARSE_E;
 800bbca:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800bbce:	e011      	b.n	800bbf4 <DecodeAltNames+0x446>
            }
            length -= (strLen + idx - lenStartIdx);
 800bbd0:	693b      	ldr	r3, [r7, #16]
 800bbd2:	461a      	mov	r2, r3
 800bbd4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bbd6:	4413      	add	r3, r2
 800bbd8:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800bbda:	1ad3      	subs	r3, r2, r3
 800bbdc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800bbde:	4413      	add	r3, r2
 800bbe0:	627b      	str	r3, [r7, #36]	; 0x24
            idx += strLen;
 800bbe2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bbe4:	693a      	ldr	r2, [r7, #16]
 800bbe6:	4413      	add	r3, r2
 800bbe8:	62bb      	str	r3, [r7, #40]	; 0x28
    while (length > 0) {
 800bbea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bbec:	2b00      	cmp	r3, #0
 800bbee:	f73f ae04 	bgt.w	800b7fa <DecodeAltNames+0x4c>
        }
    }
    return 0;
 800bbf2:	2300      	movs	r3, #0
}
 800bbf4:	4618      	mov	r0, r3
 800bbf6:	3768      	adds	r7, #104	; 0x68
 800bbf8:	46bd      	mov	sp, r7
 800bbfa:	bd80      	pop	{r7, pc}

0800bbfc <DecodeBasicCaConstraint>:

static int DecodeBasicCaConstraint(const byte* input, int sz, DecodedCert* cert)
{
 800bbfc:	b580      	push	{r7, lr}
 800bbfe:	b088      	sub	sp, #32
 800bc00:	af00      	add	r7, sp, #0
 800bc02:	60f8      	str	r0, [r7, #12]
 800bc04:	60b9      	str	r1, [r7, #8]
 800bc06:	607a      	str	r2, [r7, #4]
    word32 idx = 0;
 800bc08:	2300      	movs	r3, #0
 800bc0a:	61bb      	str	r3, [r7, #24]
    int length = 0;
 800bc0c:	2300      	movs	r3, #0
 800bc0e:	617b      	str	r3, [r7, #20]
    int ret;

    WOLFSSL_ENTER("DecodeBasicCaConstraint");

    if (GetSequence(input, &idx, &length, sz) < 0) {
 800bc10:	68bb      	ldr	r3, [r7, #8]
 800bc12:	f107 0214 	add.w	r2, r7, #20
 800bc16:	f107 0118 	add.w	r1, r7, #24
 800bc1a:	68f8      	ldr	r0, [r7, #12]
 800bc1c:	f7fc feb8 	bl	8008990 <GetSequence>
 800bc20:	4603      	mov	r3, r0
 800bc22:	2b00      	cmp	r3, #0
 800bc24:	da02      	bge.n	800bc2c <DecodeBasicCaConstraint+0x30>
        WOLFSSL_MSG("\tfail: bad SEQUENCE");
        return ASN_PARSE_E;
 800bc26:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800bc2a:	e03c      	b.n	800bca6 <DecodeBasicCaConstraint+0xaa>
    }

    if (length == 0)
 800bc2c:	697b      	ldr	r3, [r7, #20]
 800bc2e:	2b00      	cmp	r3, #0
 800bc30:	d101      	bne.n	800bc36 <DecodeBasicCaConstraint+0x3a>
        return 0;
 800bc32:	2300      	movs	r3, #0
 800bc34:	e037      	b.n	800bca6 <DecodeBasicCaConstraint+0xaa>

    /* If the basic ca constraint is false, this extension may be named, but
     * left empty. So, if the length is 0, just return. */

    ret = GetBoolean(input, &idx, sz);
 800bc36:	68ba      	ldr	r2, [r7, #8]
 800bc38:	f107 0318 	add.w	r3, r7, #24
 800bc3c:	4619      	mov	r1, r3
 800bc3e:	68f8      	ldr	r0, [r7, #12]
 800bc40:	f7fc ff13 	bl	8008a6a <GetBoolean>
 800bc44:	61f8      	str	r0, [r7, #28]

#ifndef WOLFSSL_X509_BASICCONS_INT
    if (ret < 0) {
 800bc46:	69fb      	ldr	r3, [r7, #28]
 800bc48:	2b00      	cmp	r3, #0
 800bc4a:	da01      	bge.n	800bc50 <DecodeBasicCaConstraint+0x54>
        WOLFSSL_MSG("\tfail: constraint not valid BOOLEAN");
        return ret;
 800bc4c:	69fb      	ldr	r3, [r7, #28]
 800bc4e:	e02a      	b.n	800bca6 <DecodeBasicCaConstraint+0xaa>
    }

    cert->isCA = (byte)ret;
 800bc50:	69fb      	ldr	r3, [r7, #28]
 800bc52:	f003 0301 	and.w	r3, r3, #1
 800bc56:	b2d9      	uxtb	r1, r3
 800bc58:	687a      	ldr	r2, [r7, #4]
 800bc5a:	f892 3378 	ldrb.w	r3, [r2, #888]	; 0x378
 800bc5e:	f361 1304 	bfi	r3, r1, #4, #1
 800bc62:	f882 3378 	strb.w	r3, [r2, #888]	; 0x378
    } else
        cert->isCA = (byte)ret;
#endif

    /* If there isn't any more data, return. */
    if (idx >= (word32)sz) {
 800bc66:	69ba      	ldr	r2, [r7, #24]
 800bc68:	68bb      	ldr	r3, [r7, #8]
 800bc6a:	429a      	cmp	r2, r3
 800bc6c:	d301      	bcc.n	800bc72 <DecodeBasicCaConstraint+0x76>
        return 0;
 800bc6e:	2300      	movs	r3, #0
 800bc70:	e019      	b.n	800bca6 <DecodeBasicCaConstraint+0xaa>
    }

    ret = GetInteger7Bit(input, &idx, sz);
 800bc72:	68ba      	ldr	r2, [r7, #8]
 800bc74:	f107 0318 	add.w	r3, r7, #24
 800bc78:	4619      	mov	r1, r3
 800bc7a:	68f8      	ldr	r0, [r7, #12]
 800bc7c:	f7fc ffa1 	bl	8008bc2 <GetInteger7Bit>
 800bc80:	61f8      	str	r0, [r7, #28]
    if (ret < 0)
 800bc82:	69fb      	ldr	r3, [r7, #28]
 800bc84:	2b00      	cmp	r3, #0
 800bc86:	da01      	bge.n	800bc8c <DecodeBasicCaConstraint+0x90>
        return ret;
 800bc88:	69fb      	ldr	r3, [r7, #28]
 800bc8a:	e00c      	b.n	800bca6 <DecodeBasicCaConstraint+0xaa>
    cert->pathLength = (byte)ret;
 800bc8c:	69fb      	ldr	r3, [r7, #28]
 800bc8e:	b2da      	uxtb	r2, r3
 800bc90:	687b      	ldr	r3, [r7, #4]
 800bc92:	f883 231c 	strb.w	r2, [r3, #796]	; 0x31c
    cert->pathLengthSet = 1;
 800bc96:	687a      	ldr	r2, [r7, #4]
 800bc98:	f892 3378 	ldrb.w	r3, [r2, #888]	; 0x378
 800bc9c:	f043 0320 	orr.w	r3, r3, #32
 800bca0:	f882 3378 	strb.w	r3, [r2, #888]	; 0x378

    return 0;
 800bca4:	2300      	movs	r3, #0
}
 800bca6:	4618      	mov	r0, r3
 800bca8:	3720      	adds	r7, #32
 800bcaa:	46bd      	mov	sp, r7
 800bcac:	bd80      	pop	{r7, pc}

0800bcae <DecodeCrlDist>:
    /* From RFC3280 SS4.2.1.14, Distribution Point Name*/
#define GENERALNAME_URI 6
    /* From RFC3280 SS4.2.1.7, GeneralName */

static int DecodeCrlDist(const byte* input, int sz, DecodedCert* cert)
{
 800bcae:	b580      	push	{r7, lr}
 800bcb0:	b088      	sub	sp, #32
 800bcb2:	af00      	add	r7, sp, #0
 800bcb4:	60f8      	str	r0, [r7, #12]
 800bcb6:	60b9      	str	r1, [r7, #8]
 800bcb8:	607a      	str	r2, [r7, #4]
    word32 idx = 0, localIdx;
 800bcba:	2300      	movs	r3, #0
 800bcbc:	61fb      	str	r3, [r7, #28]
    int length = 0;
 800bcbe:	2300      	movs	r3, #0
 800bcc0:	617b      	str	r3, [r7, #20]
    byte tag   = 0;
 800bcc2:	2300      	movs	r3, #0
 800bcc4:	74fb      	strb	r3, [r7, #19]

    WOLFSSL_ENTER("DecodeCrlDist");

    /* Unwrap the list of Distribution Points*/
    if (GetSequence(input, &idx, &length, sz) < 0)
 800bcc6:	68bb      	ldr	r3, [r7, #8]
 800bcc8:	f107 0214 	add.w	r2, r7, #20
 800bccc:	f107 011c 	add.w	r1, r7, #28
 800bcd0:	68f8      	ldr	r0, [r7, #12]
 800bcd2:	f7fc fe5d 	bl	8008990 <GetSequence>
 800bcd6:	4603      	mov	r3, r0
 800bcd8:	2b00      	cmp	r3, #0
 800bcda:	da02      	bge.n	800bce2 <DecodeCrlDist+0x34>
        return ASN_PARSE_E;
 800bcdc:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800bce0:	e0db      	b.n	800be9a <DecodeCrlDist+0x1ec>

    /* Unwrap a single Distribution Point */
    if (GetSequence(input, &idx, &length, sz) < 0)
 800bce2:	68bb      	ldr	r3, [r7, #8]
 800bce4:	f107 0214 	add.w	r2, r7, #20
 800bce8:	f107 011c 	add.w	r1, r7, #28
 800bcec:	68f8      	ldr	r0, [r7, #12]
 800bcee:	f7fc fe4f 	bl	8008990 <GetSequence>
 800bcf2:	4603      	mov	r3, r0
 800bcf4:	2b00      	cmp	r3, #0
 800bcf6:	da02      	bge.n	800bcfe <DecodeCrlDist+0x50>
        return ASN_PARSE_E;
 800bcf8:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800bcfc:	e0cd      	b.n	800be9a <DecodeCrlDist+0x1ec>

    /* The Distribution Point has three explicit optional members
     *  First check for a DistributionPointName
     */
    localIdx = idx;
 800bcfe:	69fb      	ldr	r3, [r7, #28]
 800bd00:	61bb      	str	r3, [r7, #24]
    if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&
 800bd02:	68bb      	ldr	r3, [r7, #8]
 800bd04:	f107 0213 	add.w	r2, r7, #19
 800bd08:	f107 0118 	add.w	r1, r7, #24
 800bd0c:	68f8      	ldr	r0, [r7, #12]
 800bd0e:	f7fc fd89 	bl	8008824 <GetASNTag>
 800bd12:	4603      	mov	r3, r0
 800bd14:	2b00      	cmp	r3, #0
 800bd16:	d16d      	bne.n	800bdf4 <DecodeCrlDist+0x146>
            tag == (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 0))
 800bd18:	7cfb      	ldrb	r3, [r7, #19]
    if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&
 800bd1a:	2ba0      	cmp	r3, #160	; 0xa0
 800bd1c:	d16a      	bne.n	800bdf4 <DecodeCrlDist+0x146>
    {
        idx++;
 800bd1e:	69fb      	ldr	r3, [r7, #28]
 800bd20:	3301      	adds	r3, #1
 800bd22:	61fb      	str	r3, [r7, #28]
        if (GetLength(input, &idx, &length, sz) < 0)
 800bd24:	68bb      	ldr	r3, [r7, #8]
 800bd26:	f107 0214 	add.w	r2, r7, #20
 800bd2a:	f107 011c 	add.w	r1, r7, #28
 800bd2e:	68f8      	ldr	r0, [r7, #12]
 800bd30:	f7fc fcfa 	bl	8008728 <GetLength>
 800bd34:	4603      	mov	r3, r0
 800bd36:	2b00      	cmp	r3, #0
 800bd38:	da02      	bge.n	800bd40 <DecodeCrlDist+0x92>
            return ASN_PARSE_E;
 800bd3a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800bd3e:	e0ac      	b.n	800be9a <DecodeCrlDist+0x1ec>

        localIdx = idx;
 800bd40:	69fb      	ldr	r3, [r7, #28]
 800bd42:	61bb      	str	r3, [r7, #24]
        if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&
 800bd44:	68bb      	ldr	r3, [r7, #8]
 800bd46:	f107 0213 	add.w	r2, r7, #19
 800bd4a:	f107 0118 	add.w	r1, r7, #24
 800bd4e:	68f8      	ldr	r0, [r7, #12]
 800bd50:	f7fc fd68 	bl	8008824 <GetASNTag>
 800bd54:	4603      	mov	r3, r0
 800bd56:	2b00      	cmp	r3, #0
 800bd58:	d148      	bne.n	800bdec <DecodeCrlDist+0x13e>
                tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED |
 800bd5a:	7cfb      	ldrb	r3, [r7, #19]
        if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&
 800bd5c:	2ba0      	cmp	r3, #160	; 0xa0
 800bd5e:	d145      	bne.n	800bdec <DecodeCrlDist+0x13e>
                    CRLDP_FULL_NAME))
        {
            idx++;
 800bd60:	69fb      	ldr	r3, [r7, #28]
 800bd62:	3301      	adds	r3, #1
 800bd64:	61fb      	str	r3, [r7, #28]
            if (GetLength(input, &idx, &length, sz) < 0)
 800bd66:	68bb      	ldr	r3, [r7, #8]
 800bd68:	f107 0214 	add.w	r2, r7, #20
 800bd6c:	f107 011c 	add.w	r1, r7, #28
 800bd70:	68f8      	ldr	r0, [r7, #12]
 800bd72:	f7fc fcd9 	bl	8008728 <GetLength>
 800bd76:	4603      	mov	r3, r0
 800bd78:	2b00      	cmp	r3, #0
 800bd7a:	da02      	bge.n	800bd82 <DecodeCrlDist+0xd4>
                return ASN_PARSE_E;
 800bd7c:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800bd80:	e08b      	b.n	800be9a <DecodeCrlDist+0x1ec>

            localIdx = idx;
 800bd82:	69fb      	ldr	r3, [r7, #28]
 800bd84:	61bb      	str	r3, [r7, #24]
            if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&
 800bd86:	68bb      	ldr	r3, [r7, #8]
 800bd88:	f107 0213 	add.w	r2, r7, #19
 800bd8c:	f107 0118 	add.w	r1, r7, #24
 800bd90:	68f8      	ldr	r0, [r7, #12]
 800bd92:	f7fc fd47 	bl	8008824 <GetASNTag>
 800bd96:	4603      	mov	r3, r0
 800bd98:	2b00      	cmp	r3, #0
 800bd9a:	d122      	bne.n	800bde2 <DecodeCrlDist+0x134>
                    tag == (ASN_CONTEXT_SPECIFIC | GENERALNAME_URI))
 800bd9c:	7cfb      	ldrb	r3, [r7, #19]
            if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&
 800bd9e:	2b86      	cmp	r3, #134	; 0x86
 800bda0:	d11f      	bne.n	800bde2 <DecodeCrlDist+0x134>
            {
                idx++;
 800bda2:	69fb      	ldr	r3, [r7, #28]
 800bda4:	3301      	adds	r3, #1
 800bda6:	61fb      	str	r3, [r7, #28]
                if (GetLength(input, &idx, &length, sz) < 0)
 800bda8:	68bb      	ldr	r3, [r7, #8]
 800bdaa:	f107 0214 	add.w	r2, r7, #20
 800bdae:	f107 011c 	add.w	r1, r7, #28
 800bdb2:	68f8      	ldr	r0, [r7, #12]
 800bdb4:	f7fc fcb8 	bl	8008728 <GetLength>
 800bdb8:	4603      	mov	r3, r0
 800bdba:	2b00      	cmp	r3, #0
 800bdbc:	da02      	bge.n	800bdc4 <DecodeCrlDist+0x116>
                    return ASN_PARSE_E;
 800bdbe:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800bdc2:	e06a      	b.n	800be9a <DecodeCrlDist+0x1ec>

                cert->extCrlInfoSz = length;
 800bdc4:	697a      	ldr	r2, [r7, #20]
 800bdc6:	687b      	ldr	r3, [r7, #4]
 800bdc8:	f8c3 22d8 	str.w	r2, [r3, #728]	; 0x2d8
                cert->extCrlInfo = input + idx;
 800bdcc:	69fb      	ldr	r3, [r7, #28]
 800bdce:	68fa      	ldr	r2, [r7, #12]
 800bdd0:	441a      	add	r2, r3
 800bdd2:	687b      	ldr	r3, [r7, #4]
 800bdd4:	f8c3 22d4 	str.w	r2, [r3, #724]	; 0x2d4
                idx += length;
 800bdd8:	69fb      	ldr	r3, [r7, #28]
 800bdda:	697a      	ldr	r2, [r7, #20]
 800bddc:	4413      	add	r3, r2
 800bdde:	61fb      	str	r3, [r7, #28]
            if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&
 800bde0:	e008      	b.n	800bdf4 <DecodeCrlDist+0x146>
            }
            else
                /* This isn't a URI, skip it. */
                idx += length;
 800bde2:	69fb      	ldr	r3, [r7, #28]
 800bde4:	697a      	ldr	r2, [r7, #20]
 800bde6:	4413      	add	r3, r2
 800bde8:	61fb      	str	r3, [r7, #28]
            if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&
 800bdea:	e003      	b.n	800bdf4 <DecodeCrlDist+0x146>
        }
        else {
            /* This isn't a FULLNAME, skip it. */
            idx += length;
 800bdec:	69fb      	ldr	r3, [r7, #28]
 800bdee:	697a      	ldr	r2, [r7, #20]
 800bdf0:	4413      	add	r3, r2
 800bdf2:	61fb      	str	r3, [r7, #28]
        }
    }

    /* Check for reasonFlags */
    localIdx = idx;
 800bdf4:	69fb      	ldr	r3, [r7, #28]
 800bdf6:	61bb      	str	r3, [r7, #24]
    if (idx < (word32)sz &&
 800bdf8:	69fa      	ldr	r2, [r7, #28]
 800bdfa:	68bb      	ldr	r3, [r7, #8]
 800bdfc:	429a      	cmp	r2, r3
 800bdfe:	d222      	bcs.n	800be46 <DecodeCrlDist+0x198>
        GetASNTag(input, &localIdx, &tag, sz) == 0 &&
 800be00:	68bb      	ldr	r3, [r7, #8]
 800be02:	f107 0213 	add.w	r2, r7, #19
 800be06:	f107 0118 	add.w	r1, r7, #24
 800be0a:	68f8      	ldr	r0, [r7, #12]
 800be0c:	f7fc fd0a 	bl	8008824 <GetASNTag>
 800be10:	4603      	mov	r3, r0
    if (idx < (word32)sz &&
 800be12:	2b00      	cmp	r3, #0
 800be14:	d117      	bne.n	800be46 <DecodeCrlDist+0x198>
        tag == (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 1))
 800be16:	7cfb      	ldrb	r3, [r7, #19]
        GetASNTag(input, &localIdx, &tag, sz) == 0 &&
 800be18:	2ba1      	cmp	r3, #161	; 0xa1
 800be1a:	d114      	bne.n	800be46 <DecodeCrlDist+0x198>
    {
        idx++;
 800be1c:	69fb      	ldr	r3, [r7, #28]
 800be1e:	3301      	adds	r3, #1
 800be20:	61fb      	str	r3, [r7, #28]
        if (GetLength(input, &idx, &length, sz) < 0)
 800be22:	68bb      	ldr	r3, [r7, #8]
 800be24:	f107 0214 	add.w	r2, r7, #20
 800be28:	f107 011c 	add.w	r1, r7, #28
 800be2c:	68f8      	ldr	r0, [r7, #12]
 800be2e:	f7fc fc7b 	bl	8008728 <GetLength>
 800be32:	4603      	mov	r3, r0
 800be34:	2b00      	cmp	r3, #0
 800be36:	da02      	bge.n	800be3e <DecodeCrlDist+0x190>
            return ASN_PARSE_E;
 800be38:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800be3c:	e02d      	b.n	800be9a <DecodeCrlDist+0x1ec>
        idx += length;
 800be3e:	69fb      	ldr	r3, [r7, #28]
 800be40:	697a      	ldr	r2, [r7, #20]
 800be42:	4413      	add	r3, r2
 800be44:	61fb      	str	r3, [r7, #28]
    }

    /* Check for cRLIssuer */
    localIdx = idx;
 800be46:	69fb      	ldr	r3, [r7, #28]
 800be48:	61bb      	str	r3, [r7, #24]
    if (idx < (word32)sz &&
 800be4a:	69fa      	ldr	r2, [r7, #28]
 800be4c:	68bb      	ldr	r3, [r7, #8]
 800be4e:	429a      	cmp	r2, r3
 800be50:	d222      	bcs.n	800be98 <DecodeCrlDist+0x1ea>
        GetASNTag(input, &localIdx, &tag, sz) == 0 &&
 800be52:	68bb      	ldr	r3, [r7, #8]
 800be54:	f107 0213 	add.w	r2, r7, #19
 800be58:	f107 0118 	add.w	r1, r7, #24
 800be5c:	68f8      	ldr	r0, [r7, #12]
 800be5e:	f7fc fce1 	bl	8008824 <GetASNTag>
 800be62:	4603      	mov	r3, r0
    if (idx < (word32)sz &&
 800be64:	2b00      	cmp	r3, #0
 800be66:	d117      	bne.n	800be98 <DecodeCrlDist+0x1ea>
        tag == (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 2))
 800be68:	7cfb      	ldrb	r3, [r7, #19]
        GetASNTag(input, &localIdx, &tag, sz) == 0 &&
 800be6a:	2ba2      	cmp	r3, #162	; 0xa2
 800be6c:	d114      	bne.n	800be98 <DecodeCrlDist+0x1ea>
    {
        idx++;
 800be6e:	69fb      	ldr	r3, [r7, #28]
 800be70:	3301      	adds	r3, #1
 800be72:	61fb      	str	r3, [r7, #28]
        if (GetLength(input, &idx, &length, sz) < 0)
 800be74:	68bb      	ldr	r3, [r7, #8]
 800be76:	f107 0214 	add.w	r2, r7, #20
 800be7a:	f107 011c 	add.w	r1, r7, #28
 800be7e:	68f8      	ldr	r0, [r7, #12]
 800be80:	f7fc fc52 	bl	8008728 <GetLength>
 800be84:	4603      	mov	r3, r0
 800be86:	2b00      	cmp	r3, #0
 800be88:	da02      	bge.n	800be90 <DecodeCrlDist+0x1e2>
            return ASN_PARSE_E;
 800be8a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800be8e:	e004      	b.n	800be9a <DecodeCrlDist+0x1ec>
        idx += length;
 800be90:	69fb      	ldr	r3, [r7, #28]
 800be92:	697a      	ldr	r2, [r7, #20]
 800be94:	4413      	add	r3, r2
 800be96:	61fb      	str	r3, [r7, #28]
    {
        WOLFSSL_MSG("\tThere are more CRL Distribution Point records, "
                   "but we only use the first one.");
    }

    return 0;
 800be98:	2300      	movs	r3, #0
}
 800be9a:	4618      	mov	r0, r3
 800be9c:	3720      	adds	r7, #32
 800be9e:	46bd      	mov	sp, r7
 800bea0:	bd80      	pop	{r7, pc}

0800bea2 <DecodeAuthInfo>:
static int DecodeAuthInfo(const byte* input, int sz, DecodedCert* cert)
/*
 *  Read Authority Information Access records. If there are
 *  any issues, return without saving the record.
 */
{
 800bea2:	b580      	push	{r7, lr}
 800bea4:	b08c      	sub	sp, #48	; 0x30
 800bea6:	af02      	add	r7, sp, #8
 800bea8:	60f8      	str	r0, [r7, #12]
 800beaa:	60b9      	str	r1, [r7, #8]
 800beac:	607a      	str	r2, [r7, #4]
    word32 idx = 0;
 800beae:	2300      	movs	r3, #0
 800beb0:	623b      	str	r3, [r7, #32]
    int length = 0;
 800beb2:	2300      	movs	r3, #0
 800beb4:	61fb      	str	r3, [r7, #28]
    int count  = 0;
 800beb6:	2300      	movs	r3, #0
 800beb8:	627b      	str	r3, [r7, #36]	; 0x24
    byte b = 0;
 800beba:	2300      	movs	r3, #0
 800bebc:	76fb      	strb	r3, [r7, #27]
    word32 oid;

    WOLFSSL_ENTER("DecodeAuthInfo");

    /* Unwrap the list of AIAs */
    if (GetSequence(input, &idx, &length, sz) < 0)
 800bebe:	68bb      	ldr	r3, [r7, #8]
 800bec0:	f107 021c 	add.w	r2, r7, #28
 800bec4:	f107 0120 	add.w	r1, r7, #32
 800bec8:	68f8      	ldr	r0, [r7, #12]
 800beca:	f7fc fd61 	bl	8008990 <GetSequence>
 800bece:	4603      	mov	r3, r0
 800bed0:	2b00      	cmp	r3, #0
 800bed2:	da56      	bge.n	800bf82 <DecodeAuthInfo+0xe0>
        return ASN_PARSE_E;
 800bed4:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800bed8:	e05b      	b.n	800bf92 <DecodeAuthInfo+0xf0>

    while ((idx < (word32)sz) && (count < MAX_AIA_SZ)) {
        /* Unwrap a single AIA */
        if (GetSequence(input, &idx, &length, sz) < 0)
 800beda:	68bb      	ldr	r3, [r7, #8]
 800bedc:	f107 021c 	add.w	r2, r7, #28
 800bee0:	f107 0120 	add.w	r1, r7, #32
 800bee4:	68f8      	ldr	r0, [r7, #12]
 800bee6:	f7fc fd53 	bl	8008990 <GetSequence>
 800beea:	4603      	mov	r3, r0
 800beec:	2b00      	cmp	r3, #0
 800beee:	da02      	bge.n	800bef6 <DecodeAuthInfo+0x54>
            return ASN_PARSE_E;
 800bef0:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800bef4:	e04d      	b.n	800bf92 <DecodeAuthInfo+0xf0>

        oid = 0;
 800bef6:	2300      	movs	r3, #0
 800bef8:	617b      	str	r3, [r7, #20]
        if (GetObjectId(input, &idx, &oid, oidCertAuthInfoType, sz) < 0)
 800befa:	68bb      	ldr	r3, [r7, #8]
 800befc:	f107 0214 	add.w	r2, r7, #20
 800bf00:	f107 0120 	add.w	r1, r7, #32
 800bf04:	9300      	str	r3, [sp, #0]
 800bf06:	2307      	movs	r3, #7
 800bf08:	68f8      	ldr	r0, [r7, #12]
 800bf0a:	f7fd fb6b 	bl	80095e4 <GetObjectId>
 800bf0e:	4603      	mov	r3, r0
 800bf10:	2b00      	cmp	r3, #0
 800bf12:	da02      	bge.n	800bf1a <DecodeAuthInfo+0x78>
            return ASN_PARSE_E;
 800bf14:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800bf18:	e03b      	b.n	800bf92 <DecodeAuthInfo+0xf0>

        /* Only supporting URIs right now. */
        if (GetASNTag(input, &idx, &b, sz) < 0)
 800bf1a:	68bb      	ldr	r3, [r7, #8]
 800bf1c:	f107 021b 	add.w	r2, r7, #27
 800bf20:	f107 0120 	add.w	r1, r7, #32
 800bf24:	68f8      	ldr	r0, [r7, #12]
 800bf26:	f7fc fc7d 	bl	8008824 <GetASNTag>
 800bf2a:	4603      	mov	r3, r0
 800bf2c:	2b00      	cmp	r3, #0
 800bf2e:	da02      	bge.n	800bf36 <DecodeAuthInfo+0x94>
            return ASN_PARSE_E;
 800bf30:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800bf34:	e02d      	b.n	800bf92 <DecodeAuthInfo+0xf0>

        if (GetLength(input, &idx, &length, sz) < 0)
 800bf36:	68bb      	ldr	r3, [r7, #8]
 800bf38:	f107 021c 	add.w	r2, r7, #28
 800bf3c:	f107 0120 	add.w	r1, r7, #32
 800bf40:	68f8      	ldr	r0, [r7, #12]
 800bf42:	f7fc fbf1 	bl	8008728 <GetLength>
 800bf46:	4603      	mov	r3, r0
 800bf48:	2b00      	cmp	r3, #0
 800bf4a:	da02      	bge.n	800bf52 <DecodeAuthInfo+0xb0>
            return ASN_PARSE_E;
 800bf4c:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800bf50:	e01f      	b.n	800bf92 <DecodeAuthInfo+0xf0>

        /* Set ocsp entry */
        if (b == (ASN_CONTEXT_SPECIFIC | GENERALNAME_URI) &&
 800bf52:	7efb      	ldrb	r3, [r7, #27]
 800bf54:	2b86      	cmp	r3, #134	; 0x86
 800bf56:	d110      	bne.n	800bf7a <DecodeAuthInfo+0xd8>
            oid == AIA_OCSP_OID)
 800bf58:	697b      	ldr	r3, [r7, #20]
        if (b == (ASN_CONTEXT_SPECIFIC | GENERALNAME_URI) &&
 800bf5a:	2b74      	cmp	r3, #116	; 0x74
 800bf5c:	d10d      	bne.n	800bf7a <DecodeAuthInfo+0xd8>
        {
            cert->extAuthInfoSz = length;
 800bf5e:	69fa      	ldr	r2, [r7, #28]
 800bf60:	687b      	ldr	r3, [r7, #4]
 800bf62:	f8c3 22d0 	str.w	r2, [r3, #720]	; 0x2d0
            cert->extAuthInfo = input + idx;
 800bf66:	6a3b      	ldr	r3, [r7, #32]
 800bf68:	68fa      	ldr	r2, [r7, #12]
 800bf6a:	441a      	add	r2, r3
 800bf6c:	687b      	ldr	r3, [r7, #4]
 800bf6e:	f8c3 22cc 	str.w	r2, [r3, #716]	; 0x2cc
            count++;
 800bf72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bf74:	3301      	adds	r3, #1
 800bf76:	627b      	str	r3, [r7, #36]	; 0x24
        #if !defined(OPENSSL_ALL) || !defined(WOLFSSL_QT)
            break;
 800bf78:	e00a      	b.n	800bf90 <DecodeAuthInfo+0xee>
            cert->extAuthInfoCaIssuerSz = length;
            cert->extAuthInfoCaIssuer = input + idx;
            count++;
        }
        #endif
        idx += length;
 800bf7a:	6a3b      	ldr	r3, [r7, #32]
 800bf7c:	69fa      	ldr	r2, [r7, #28]
 800bf7e:	4413      	add	r3, r2
 800bf80:	623b      	str	r3, [r7, #32]
    while ((idx < (word32)sz) && (count < MAX_AIA_SZ)) {
 800bf82:	6a3a      	ldr	r2, [r7, #32]
 800bf84:	68bb      	ldr	r3, [r7, #8]
 800bf86:	429a      	cmp	r2, r3
 800bf88:	d202      	bcs.n	800bf90 <DecodeAuthInfo+0xee>
 800bf8a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bf8c:	2b01      	cmp	r3, #1
 800bf8e:	dda4      	ble.n	800beda <DecodeAuthInfo+0x38>
    }

    return 0;
 800bf90:	2300      	movs	r3, #0
}
 800bf92:	4618      	mov	r0, r3
 800bf94:	3728      	adds	r7, #40	; 0x28
 800bf96:	46bd      	mov	sp, r7
 800bf98:	bd80      	pop	{r7, pc}

0800bf9a <DecodeAuthKeyId>:


static int DecodeAuthKeyId(const byte* input, int sz, DecodedCert* cert)
{
 800bf9a:	b580      	push	{r7, lr}
 800bf9c:	b088      	sub	sp, #32
 800bf9e:	af00      	add	r7, sp, #0
 800bfa0:	60f8      	str	r0, [r7, #12]
 800bfa2:	60b9      	str	r1, [r7, #8]
 800bfa4:	607a      	str	r2, [r7, #4]
    word32 idx = 0;
 800bfa6:	2300      	movs	r3, #0
 800bfa8:	61bb      	str	r3, [r7, #24]
    int length = 0, ret = 0;
 800bfaa:	2300      	movs	r3, #0
 800bfac:	617b      	str	r3, [r7, #20]
 800bfae:	2300      	movs	r3, #0
 800bfb0:	61fb      	str	r3, [r7, #28]
    byte tag;

    WOLFSSL_ENTER("DecodeAuthKeyId");

    if (GetSequence(input, &idx, &length, sz) < 0) {
 800bfb2:	68bb      	ldr	r3, [r7, #8]
 800bfb4:	f107 0214 	add.w	r2, r7, #20
 800bfb8:	f107 0118 	add.w	r1, r7, #24
 800bfbc:	68f8      	ldr	r0, [r7, #12]
 800bfbe:	f7fc fce7 	bl	8008990 <GetSequence>
 800bfc2:	4603      	mov	r3, r0
 800bfc4:	2b00      	cmp	r3, #0
 800bfc6:	da02      	bge.n	800bfce <DecodeAuthKeyId+0x34>
        WOLFSSL_MSG("\tfail: should be a SEQUENCE\n");
        return ASN_PARSE_E;
 800bfc8:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800bfcc:	e042      	b.n	800c054 <DecodeAuthKeyId+0xba>
    }

    if (GetASNTag(input, &idx, &tag, sz) < 0) {
 800bfce:	68bb      	ldr	r3, [r7, #8]
 800bfd0:	f107 0213 	add.w	r2, r7, #19
 800bfd4:	f107 0118 	add.w	r1, r7, #24
 800bfd8:	68f8      	ldr	r0, [r7, #12]
 800bfda:	f7fc fc23 	bl	8008824 <GetASNTag>
 800bfde:	4603      	mov	r3, r0
 800bfe0:	2b00      	cmp	r3, #0
 800bfe2:	da02      	bge.n	800bfea <DecodeAuthKeyId+0x50>
        return ASN_PARSE_E;
 800bfe4:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800bfe8:	e034      	b.n	800c054 <DecodeAuthKeyId+0xba>
    }

    if (tag != (ASN_CONTEXT_SPECIFIC | 0)) {
 800bfea:	7cfb      	ldrb	r3, [r7, #19]
 800bfec:	2b80      	cmp	r3, #128	; 0x80
 800bfee:	d008      	beq.n	800c002 <DecodeAuthKeyId+0x68>
        WOLFSSL_MSG("\tinfo: OPTIONAL item 0, not available\n");
        cert->extAuthKeyIdSet = 0;
 800bff0:	687a      	ldr	r2, [r7, #4]
 800bff2:	f892 3378 	ldrb.w	r3, [r2, #888]	; 0x378
 800bff6:	f36f 0382 	bfc	r3, #2, #1
 800bffa:	f882 3378 	strb.w	r3, [r2, #888]	; 0x378
        return 0;
 800bffe:	2300      	movs	r3, #0
 800c000:	e028      	b.n	800c054 <DecodeAuthKeyId+0xba>
    }

    if (GetLength(input, &idx, &length, sz) <= 0) {
 800c002:	68bb      	ldr	r3, [r7, #8]
 800c004:	f107 0214 	add.w	r2, r7, #20
 800c008:	f107 0118 	add.w	r1, r7, #24
 800c00c:	68f8      	ldr	r0, [r7, #12]
 800c00e:	f7fc fb8b 	bl	8008728 <GetLength>
 800c012:	4603      	mov	r3, r0
 800c014:	2b00      	cmp	r3, #0
 800c016:	dc02      	bgt.n	800c01e <DecodeAuthKeyId+0x84>
        WOLFSSL_MSG("\tfail: extension data length");
        return ASN_PARSE_E;
 800c018:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c01c:	e01a      	b.n	800c054 <DecodeAuthKeyId+0xba>
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    cert->extAuthKeyIdSrc = &input[idx];
    cert->extAuthKeyIdSz = length;
#endif /* OPENSSL_EXTRA */

    if (length == KEYID_SIZE) {
 800c01e:	697b      	ldr	r3, [r7, #20]
 800c020:	2b20      	cmp	r3, #32
 800c022:	d10a      	bne.n	800c03a <DecodeAuthKeyId+0xa0>
        XMEMCPY(cert->extAuthKeyId, input + idx, length);
 800c024:	687b      	ldr	r3, [r7, #4]
 800c026:	f503 703f 	add.w	r0, r3, #764	; 0x2fc
 800c02a:	69bb      	ldr	r3, [r7, #24]
 800c02c:	68fa      	ldr	r2, [r7, #12]
 800c02e:	4413      	add	r3, r2
 800c030:	697a      	ldr	r2, [r7, #20]
 800c032:	4619      	mov	r1, r3
 800c034:	f00d f9df 	bl	80193f6 <memcpy>
 800c038:	e00b      	b.n	800c052 <DecodeAuthKeyId+0xb8>
    }
    else
        ret = CalcHashId(input + idx, length, cert->extAuthKeyId);
 800c03a:	69bb      	ldr	r3, [r7, #24]
 800c03c:	68fa      	ldr	r2, [r7, #12]
 800c03e:	18d0      	adds	r0, r2, r3
 800c040:	697b      	ldr	r3, [r7, #20]
 800c042:	4619      	mov	r1, r3
 800c044:	687b      	ldr	r3, [r7, #4]
 800c046:	f503 733f 	add.w	r3, r3, #764	; 0x2fc
 800c04a:	461a      	mov	r2, r3
 800c04c:	f7fe f923 	bl	800a296 <CalcHashId>
 800c050:	61f8      	str	r0, [r7, #28]

    return ret;
 800c052:	69fb      	ldr	r3, [r7, #28]
}
 800c054:	4618      	mov	r0, r3
 800c056:	3720      	adds	r7, #32
 800c058:	46bd      	mov	sp, r7
 800c05a:	bd80      	pop	{r7, pc}

0800c05c <DecodeSubjKeyId>:


static int DecodeSubjKeyId(const byte* input, int sz, DecodedCert* cert)
{
 800c05c:	b580      	push	{r7, lr}
 800c05e:	b088      	sub	sp, #32
 800c060:	af00      	add	r7, sp, #0
 800c062:	60f8      	str	r0, [r7, #12]
 800c064:	60b9      	str	r1, [r7, #8]
 800c066:	607a      	str	r2, [r7, #4]
    word32 idx = 0;
 800c068:	2300      	movs	r3, #0
 800c06a:	61bb      	str	r3, [r7, #24]
    int length = 0, ret = 0;
 800c06c:	2300      	movs	r3, #0
 800c06e:	617b      	str	r3, [r7, #20]
 800c070:	2300      	movs	r3, #0
 800c072:	61fb      	str	r3, [r7, #28]

    WOLFSSL_ENTER("DecodeSubjKeyId");

    if (sz <= 0)
 800c074:	68bb      	ldr	r3, [r7, #8]
 800c076:	2b00      	cmp	r3, #0
 800c078:	dc02      	bgt.n	800c080 <DecodeSubjKeyId+0x24>
        return ASN_PARSE_E;
 800c07a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c07e:	e028      	b.n	800c0d2 <DecodeSubjKeyId+0x76>

    ret = GetOctetString(input, &idx, &length, sz);
 800c080:	68bb      	ldr	r3, [r7, #8]
 800c082:	f107 0214 	add.w	r2, r7, #20
 800c086:	f107 0118 	add.w	r1, r7, #24
 800c08a:	68f8      	ldr	r0, [r7, #12]
 800c08c:	f7fc fd2c 	bl	8008ae8 <GetOctetString>
 800c090:	61f8      	str	r0, [r7, #28]
    if (ret < 0)
 800c092:	69fb      	ldr	r3, [r7, #28]
 800c094:	2b00      	cmp	r3, #0
 800c096:	da01      	bge.n	800c09c <DecodeSubjKeyId+0x40>
        return ret;
 800c098:	69fb      	ldr	r3, [r7, #28]
 800c09a:	e01a      	b.n	800c0d2 <DecodeSubjKeyId+0x76>
    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        cert->extSubjKeyIdSrc = &input[idx];
        cert->extSubjKeyIdSz = length;
    #endif /* OPENSSL_EXTRA */

    if (length == KEYID_SIZE) {
 800c09c:	697b      	ldr	r3, [r7, #20]
 800c09e:	2b20      	cmp	r3, #32
 800c0a0:	d10a      	bne.n	800c0b8 <DecodeSubjKeyId+0x5c>
        XMEMCPY(cert->extSubjKeyId, input + idx, length);
 800c0a2:	687b      	ldr	r3, [r7, #4]
 800c0a4:	f503 7037 	add.w	r0, r3, #732	; 0x2dc
 800c0a8:	69bb      	ldr	r3, [r7, #24]
 800c0aa:	68fa      	ldr	r2, [r7, #12]
 800c0ac:	4413      	add	r3, r2
 800c0ae:	697a      	ldr	r2, [r7, #20]
 800c0b0:	4619      	mov	r1, r3
 800c0b2:	f00d f9a0 	bl	80193f6 <memcpy>
 800c0b6:	e00b      	b.n	800c0d0 <DecodeSubjKeyId+0x74>
    }
    else
        ret = CalcHashId(input + idx, length, cert->extSubjKeyId);
 800c0b8:	69bb      	ldr	r3, [r7, #24]
 800c0ba:	68fa      	ldr	r2, [r7, #12]
 800c0bc:	18d0      	adds	r0, r2, r3
 800c0be:	697b      	ldr	r3, [r7, #20]
 800c0c0:	4619      	mov	r1, r3
 800c0c2:	687b      	ldr	r3, [r7, #4]
 800c0c4:	f503 7337 	add.w	r3, r3, #732	; 0x2dc
 800c0c8:	461a      	mov	r2, r3
 800c0ca:	f7fe f8e4 	bl	800a296 <CalcHashId>
 800c0ce:	61f8      	str	r0, [r7, #28]

    return ret;
 800c0d0:	69fb      	ldr	r3, [r7, #28]
}
 800c0d2:	4618      	mov	r0, r3
 800c0d4:	3720      	adds	r7, #32
 800c0d6:	46bd      	mov	sp, r7
 800c0d8:	bd80      	pop	{r7, pc}

0800c0da <DecodeKeyUsage>:


static int DecodeKeyUsage(const byte* input, int sz, DecodedCert* cert)
{
 800c0da:	b580      	push	{r7, lr}
 800c0dc:	b08a      	sub	sp, #40	; 0x28
 800c0de:	af02      	add	r7, sp, #8
 800c0e0:	60f8      	str	r0, [r7, #12]
 800c0e2:	60b9      	str	r1, [r7, #8]
 800c0e4:	607a      	str	r2, [r7, #4]
    word32 idx = 0;
 800c0e6:	2300      	movs	r3, #0
 800c0e8:	61bb      	str	r3, [r7, #24]
    int length;
    int ret;
    WOLFSSL_ENTER("DecodeKeyUsage");

    ret = CheckBitString(input, &idx, &length, sz, 0, NULL);
 800c0ea:	68b8      	ldr	r0, [r7, #8]
 800c0ec:	f107 0214 	add.w	r2, r7, #20
 800c0f0:	f107 0118 	add.w	r1, r7, #24
 800c0f4:	2300      	movs	r3, #0
 800c0f6:	9301      	str	r3, [sp, #4]
 800c0f8:	2300      	movs	r3, #0
 800c0fa:	9300      	str	r3, [sp, #0]
 800c0fc:	4603      	mov	r3, r0
 800c0fe:	68f8      	ldr	r0, [r7, #12]
 800c100:	f7fc fe5d 	bl	8008dbe <CheckBitString>
 800c104:	61f8      	str	r0, [r7, #28]
    if (ret != 0)
 800c106:	69fb      	ldr	r3, [r7, #28]
 800c108:	2b00      	cmp	r3, #0
 800c10a:	d001      	beq.n	800c110 <DecodeKeyUsage+0x36>
        return ret;
 800c10c:	69fb      	ldr	r3, [r7, #28]
 800c10e:	e01b      	b.n	800c148 <DecodeKeyUsage+0x6e>

    cert->extKeyUsage = (word16)(input[idx]);
 800c110:	69bb      	ldr	r3, [r7, #24]
 800c112:	68fa      	ldr	r2, [r7, #12]
 800c114:	4413      	add	r3, r2
 800c116:	781b      	ldrb	r3, [r3, #0]
 800c118:	b29a      	uxth	r2, r3
 800c11a:	687b      	ldr	r3, [r7, #4]
 800c11c:	f8a3 231e 	strh.w	r2, [r3, #798]	; 0x31e
    if (length == 2)
 800c120:	697b      	ldr	r3, [r7, #20]
 800c122:	2b02      	cmp	r3, #2
 800c124:	d10f      	bne.n	800c146 <DecodeKeyUsage+0x6c>
        cert->extKeyUsage |= (word16)(input[idx+1] << 8);
 800c126:	687b      	ldr	r3, [r7, #4]
 800c128:	f8b3 231e 	ldrh.w	r2, [r3, #798]	; 0x31e
 800c12c:	69bb      	ldr	r3, [r7, #24]
 800c12e:	3301      	adds	r3, #1
 800c130:	68f9      	ldr	r1, [r7, #12]
 800c132:	440b      	add	r3, r1
 800c134:	781b      	ldrb	r3, [r3, #0]
 800c136:	b29b      	uxth	r3, r3
 800c138:	021b      	lsls	r3, r3, #8
 800c13a:	b29b      	uxth	r3, r3
 800c13c:	4313      	orrs	r3, r2
 800c13e:	b29a      	uxth	r2, r3
 800c140:	687b      	ldr	r3, [r7, #4]
 800c142:	f8a3 231e 	strh.w	r2, [r3, #798]	; 0x31e

    return 0;
 800c146:	2300      	movs	r3, #0
}
 800c148:	4618      	mov	r0, r3
 800c14a:	3720      	adds	r7, #32
 800c14c:	46bd      	mov	sp, r7
 800c14e:	bd80      	pop	{r7, pc}

0800c150 <DecodeExtKeyUsage>:


static int DecodeExtKeyUsage(const byte* input, int sz, DecodedCert* cert)
{
 800c150:	b580      	push	{r7, lr}
 800c152:	b08a      	sub	sp, #40	; 0x28
 800c154:	af02      	add	r7, sp, #8
 800c156:	60f8      	str	r0, [r7, #12]
 800c158:	60b9      	str	r1, [r7, #8]
 800c15a:	607a      	str	r2, [r7, #4]
    word32 idx = 0, oid;
 800c15c:	2300      	movs	r3, #0
 800c15e:	61bb      	str	r3, [r7, #24]
    int length, ret;

    WOLFSSL_MSG("DecodeExtKeyUsage");

    if (GetSequence(input, &idx, &length, sz) < 0) {
 800c160:	68bb      	ldr	r3, [r7, #8]
 800c162:	f107 0210 	add.w	r2, r7, #16
 800c166:	f107 0118 	add.w	r1, r7, #24
 800c16a:	68f8      	ldr	r0, [r7, #12]
 800c16c:	f7fc fc10 	bl	8008990 <GetSequence>
 800c170:	4603      	mov	r3, r0
 800c172:	2b00      	cmp	r3, #0
 800c174:	da70      	bge.n	800c258 <DecodeExtKeyUsage+0x108>
        WOLFSSL_MSG("\tfail: should be a SEQUENCE");
        return ASN_PARSE_E;
 800c176:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c17a:	e072      	b.n	800c262 <DecodeExtKeyUsage+0x112>
    cert->extExtKeyUsageSrc = input + idx;
    cert->extExtKeyUsageSz = length;
#endif

    while (idx < (word32)sz) {
        ret = GetObjectId(input, &idx, &oid, oidCertKeyUseType, sz);
 800c17c:	68bb      	ldr	r3, [r7, #8]
 800c17e:	f107 0214 	add.w	r2, r7, #20
 800c182:	f107 0118 	add.w	r1, r7, #24
 800c186:	9300      	str	r3, [sp, #0]
 800c188:	230a      	movs	r3, #10
 800c18a:	68f8      	ldr	r0, [r7, #12]
 800c18c:	f7fd fa2a 	bl	80095e4 <GetObjectId>
 800c190:	61f8      	str	r0, [r7, #28]
        if (ret == ASN_UNKNOWN_OID_E)
 800c192:	69fb      	ldr	r3, [r7, #28]
 800c194:	f113 0f94 	cmn.w	r3, #148	; 0x94
 800c198:	d100      	bne.n	800c19c <DecodeExtKeyUsage+0x4c>
            continue;
 800c19a:	e05d      	b.n	800c258 <DecodeExtKeyUsage+0x108>
        else if (ret < 0)
 800c19c:	69fb      	ldr	r3, [r7, #28]
 800c19e:	2b00      	cmp	r3, #0
 800c1a0:	da01      	bge.n	800c1a6 <DecodeExtKeyUsage+0x56>
            return ret;
 800c1a2:	69fb      	ldr	r3, [r7, #28]
 800c1a4:	e05d      	b.n	800c262 <DecodeExtKeyUsage+0x112>

        switch (oid) {
 800c1a6:	697b      	ldr	r3, [r7, #20]
 800c1a8:	2b4a      	cmp	r3, #74	; 0x4a
 800c1aa:	d037      	beq.n	800c21c <DecodeExtKeyUsage+0xcc>
 800c1ac:	2b4a      	cmp	r3, #74	; 0x4a
 800c1ae:	d806      	bhi.n	800c1be <DecodeExtKeyUsage+0x6e>
 800c1b0:	2b48      	cmp	r3, #72	; 0x48
 800c1b2:	d01f      	beq.n	800c1f4 <DecodeExtKeyUsage+0xa4>
 800c1b4:	2b48      	cmp	r3, #72	; 0x48
 800c1b6:	d827      	bhi.n	800c208 <DecodeExtKeyUsage+0xb8>
 800c1b8:	2b47      	cmp	r3, #71	; 0x47
 800c1ba:	d011      	beq.n	800c1e0 <DecodeExtKeyUsage+0x90>
 800c1bc:	e04c      	b.n	800c258 <DecodeExtKeyUsage+0x108>
 800c1be:	2b4f      	cmp	r3, #79	; 0x4f
 800c1c0:	d040      	beq.n	800c244 <DecodeExtKeyUsage+0xf4>
 800c1c2:	2b97      	cmp	r3, #151	; 0x97
 800c1c4:	d002      	beq.n	800c1cc <DecodeExtKeyUsage+0x7c>
 800c1c6:	2b4e      	cmp	r3, #78	; 0x4e
 800c1c8:	d032      	beq.n	800c230 <DecodeExtKeyUsage+0xe0>
 800c1ca:	e045      	b.n	800c258 <DecodeExtKeyUsage+0x108>
            case EKU_ANY_OID:
                cert->extExtKeyUsage |= EXTKEYUSE_ANY;
 800c1cc:	687b      	ldr	r3, [r7, #4]
 800c1ce:	f893 3320 	ldrb.w	r3, [r3, #800]	; 0x320
 800c1d2:	f043 0301 	orr.w	r3, r3, #1
 800c1d6:	b2da      	uxtb	r2, r3
 800c1d8:	687b      	ldr	r3, [r7, #4]
 800c1da:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
                break;
 800c1de:	e03b      	b.n	800c258 <DecodeExtKeyUsage+0x108>
            case EKU_SERVER_AUTH_OID:
                cert->extExtKeyUsage |= EXTKEYUSE_SERVER_AUTH;
 800c1e0:	687b      	ldr	r3, [r7, #4]
 800c1e2:	f893 3320 	ldrb.w	r3, [r3, #800]	; 0x320
 800c1e6:	f043 0302 	orr.w	r3, r3, #2
 800c1ea:	b2da      	uxtb	r2, r3
 800c1ec:	687b      	ldr	r3, [r7, #4]
 800c1ee:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
                break;
 800c1f2:	e031      	b.n	800c258 <DecodeExtKeyUsage+0x108>
            case EKU_CLIENT_AUTH_OID:
                cert->extExtKeyUsage |= EXTKEYUSE_CLIENT_AUTH;
 800c1f4:	687b      	ldr	r3, [r7, #4]
 800c1f6:	f893 3320 	ldrb.w	r3, [r3, #800]	; 0x320
 800c1fa:	f043 0304 	orr.w	r3, r3, #4
 800c1fe:	b2da      	uxtb	r2, r3
 800c200:	687b      	ldr	r3, [r7, #4]
 800c202:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
                break;
 800c206:	e027      	b.n	800c258 <DecodeExtKeyUsage+0x108>
            case EKU_CODESIGNING_OID:
                cert->extExtKeyUsage |= EXTKEYUSE_CODESIGN;
 800c208:	687b      	ldr	r3, [r7, #4]
 800c20a:	f893 3320 	ldrb.w	r3, [r3, #800]	; 0x320
 800c20e:	f043 0308 	orr.w	r3, r3, #8
 800c212:	b2da      	uxtb	r2, r3
 800c214:	687b      	ldr	r3, [r7, #4]
 800c216:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
                break;
 800c21a:	e01d      	b.n	800c258 <DecodeExtKeyUsage+0x108>
            case EKU_EMAILPROTECT_OID:
                cert->extExtKeyUsage |= EXTKEYUSE_EMAILPROT;
 800c21c:	687b      	ldr	r3, [r7, #4]
 800c21e:	f893 3320 	ldrb.w	r3, [r3, #800]	; 0x320
 800c222:	f043 0310 	orr.w	r3, r3, #16
 800c226:	b2da      	uxtb	r2, r3
 800c228:	687b      	ldr	r3, [r7, #4]
 800c22a:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
                break;
 800c22e:	e013      	b.n	800c258 <DecodeExtKeyUsage+0x108>
            case EKU_TIMESTAMP_OID:
                cert->extExtKeyUsage |= EXTKEYUSE_TIMESTAMP;
 800c230:	687b      	ldr	r3, [r7, #4]
 800c232:	f893 3320 	ldrb.w	r3, [r3, #800]	; 0x320
 800c236:	f043 0320 	orr.w	r3, r3, #32
 800c23a:	b2da      	uxtb	r2, r3
 800c23c:	687b      	ldr	r3, [r7, #4]
 800c23e:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
                break;
 800c242:	e009      	b.n	800c258 <DecodeExtKeyUsage+0x108>
            case EKU_OCSP_SIGN_OID:
                cert->extExtKeyUsage |= EXTKEYUSE_OCSP_SIGN;
 800c244:	687b      	ldr	r3, [r7, #4]
 800c246:	f893 3320 	ldrb.w	r3, [r3, #800]	; 0x320
 800c24a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800c24e:	b2da      	uxtb	r2, r3
 800c250:	687b      	ldr	r3, [r7, #4]
 800c252:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
                break;
 800c256:	bf00      	nop
    while (idx < (word32)sz) {
 800c258:	69ba      	ldr	r2, [r7, #24]
 800c25a:	68bb      	ldr	r3, [r7, #8]
 800c25c:	429a      	cmp	r2, r3
 800c25e:	d38d      	bcc.n	800c17c <DecodeExtKeyUsage+0x2c>
    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        cert->extExtKeyUsageCount++;
    #endif
    }

    return 0;
 800c260:	2300      	movs	r3, #0
}
 800c262:	4618      	mov	r0, r3
 800c264:	3720      	adds	r7, #32
 800c266:	46bd      	mov	sp, r7
 800c268:	bd80      	pop	{r7, pc}

0800c26a <DecodeSubtree>:

#ifndef IGNORE_NAME_CONSTRAINTS
#define ASN_TYPE_MASK 0xF
static int DecodeSubtree(const byte* input, int sz,
                         Base_entry** head, void* heap)
{
 800c26a:	b580      	push	{r7, lr}
 800c26c:	b08c      	sub	sp, #48	; 0x30
 800c26e:	af00      	add	r7, sp, #0
 800c270:	60f8      	str	r0, [r7, #12]
 800c272:	60b9      	str	r1, [r7, #8]
 800c274:	607a      	str	r2, [r7, #4]
 800c276:	603b      	str	r3, [r7, #0]
    word32 idx = 0;
 800c278:	2300      	movs	r3, #0
 800c27a:	623b      	str	r3, [r7, #32]

    (void)heap;

    while (idx < (word32)sz) {
 800c27c:	e086      	b.n	800c38c <DecodeSubtree+0x122>
        int seqLength, strLength;
        word32 nameIdx;
        byte b, bType;

        if (GetSequence(input, &idx, &seqLength, sz) < 0) {
 800c27e:	68bb      	ldr	r3, [r7, #8]
 800c280:	f107 021c 	add.w	r2, r7, #28
 800c284:	f107 0120 	add.w	r1, r7, #32
 800c288:	68f8      	ldr	r0, [r7, #12]
 800c28a:	f7fc fb81 	bl	8008990 <GetSequence>
 800c28e:	4603      	mov	r3, r0
 800c290:	2b00      	cmp	r3, #0
 800c292:	da02      	bge.n	800c29a <DecodeSubtree+0x30>
            WOLFSSL_MSG("\tfail: should be a SEQUENCE");
            return ASN_PARSE_E;
 800c294:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c298:	e07e      	b.n	800c398 <DecodeSubtree+0x12e>
        }
        nameIdx = idx;
 800c29a:	6a3b      	ldr	r3, [r7, #32]
 800c29c:	617b      	str	r3, [r7, #20]
        b = input[nameIdx++];
 800c29e:	697b      	ldr	r3, [r7, #20]
 800c2a0:	1c5a      	adds	r2, r3, #1
 800c2a2:	617a      	str	r2, [r7, #20]
 800c2a4:	68fa      	ldr	r2, [r7, #12]
 800c2a6:	4413      	add	r3, r2
 800c2a8:	781b      	ldrb	r3, [r3, #0]
 800c2aa:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

        if (GetLength(input, &nameIdx, &strLength, sz) <= 0) {
 800c2ae:	68bb      	ldr	r3, [r7, #8]
 800c2b0:	f107 0218 	add.w	r2, r7, #24
 800c2b4:	f107 0114 	add.w	r1, r7, #20
 800c2b8:	68f8      	ldr	r0, [r7, #12]
 800c2ba:	f7fc fa35 	bl	8008728 <GetLength>
 800c2be:	4603      	mov	r3, r0
 800c2c0:	2b00      	cmp	r3, #0
 800c2c2:	dc02      	bgt.n	800c2ca <DecodeSubtree+0x60>
            WOLFSSL_MSG("\tinvalid length");
            return ASN_PARSE_E;
 800c2c4:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c2c8:	e066      	b.n	800c398 <DecodeSubtree+0x12e>
        }

        /* Get type, LSB 4-bits */
        bType = (b & ASN_TYPE_MASK);
 800c2ca:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800c2ce:	f003 030f 	and.w	r3, r3, #15
 800c2d2:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e

        if (bType == ASN_DNS_TYPE || bType == ASN_RFC822_TYPE ||
 800c2d6:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 800c2da:	2b02      	cmp	r3, #2
 800c2dc:	d007      	beq.n	800c2ee <DecodeSubtree+0x84>
 800c2de:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 800c2e2:	2b01      	cmp	r3, #1
 800c2e4:	d003      	beq.n	800c2ee <DecodeSubtree+0x84>
 800c2e6:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 800c2ea:	2b04      	cmp	r3, #4
 800c2ec:	d14a      	bne.n	800c384 <DecodeSubtree+0x11a>
                                                        bType == ASN_DIR_TYPE) {
            Base_entry* entry;

            /* if constructed has leading sequence */
            if (b & ASN_CONSTRUCTED) {
 800c2ee:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800c2f2:	f003 0320 	and.w	r3, r3, #32
 800c2f6:	2b00      	cmp	r3, #0
 800c2f8:	d00d      	beq.n	800c316 <DecodeSubtree+0xac>
                if (GetSequence(input, &nameIdx, &strLength, sz) < 0) {
 800c2fa:	68bb      	ldr	r3, [r7, #8]
 800c2fc:	f107 0218 	add.w	r2, r7, #24
 800c300:	f107 0114 	add.w	r1, r7, #20
 800c304:	68f8      	ldr	r0, [r7, #12]
 800c306:	f7fc fb43 	bl	8008990 <GetSequence>
 800c30a:	4603      	mov	r3, r0
 800c30c:	2b00      	cmp	r3, #0
 800c30e:	da02      	bge.n	800c316 <DecodeSubtree+0xac>
                    WOLFSSL_MSG("\tfail: constructed be a SEQUENCE");
                    return ASN_PARSE_E;
 800c310:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c314:	e040      	b.n	800c398 <DecodeSubtree+0x12e>
                }
            }

            entry = (Base_entry*)XMALLOC(sizeof(Base_entry), heap,
 800c316:	2010      	movs	r0, #16
 800c318:	f002 fdee 	bl	800eef8 <wolfSSL_Malloc>
 800c31c:	62b8      	str	r0, [r7, #40]	; 0x28
                                                          DYNAMIC_TYPE_ALTNAME);
            if (entry == NULL) {
 800c31e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c320:	2b00      	cmp	r3, #0
 800c322:	d102      	bne.n	800c32a <DecodeSubtree+0xc0>
                WOLFSSL_MSG("allocate error");
                return MEMORY_E;
 800c324:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800c328:	e036      	b.n	800c398 <DecodeSubtree+0x12e>
            }

            entry->name = (char*)XMALLOC(strLength, heap, DYNAMIC_TYPE_ALTNAME);
 800c32a:	69bb      	ldr	r3, [r7, #24]
 800c32c:	4618      	mov	r0, r3
 800c32e:	f002 fde3 	bl	800eef8 <wolfSSL_Malloc>
 800c332:	4602      	mov	r2, r0
 800c334:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c336:	605a      	str	r2, [r3, #4]
            if (entry->name == NULL) {
 800c338:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c33a:	685b      	ldr	r3, [r3, #4]
 800c33c:	2b00      	cmp	r3, #0
 800c33e:	d10a      	bne.n	800c356 <DecodeSubtree+0xec>
                WOLFSSL_MSG("allocate error");
                XFREE(entry, heap, DYNAMIC_TYPE_ALTNAME);
 800c340:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c342:	627b      	str	r3, [r7, #36]	; 0x24
 800c344:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c346:	2b00      	cmp	r3, #0
 800c348:	d002      	beq.n	800c350 <DecodeSubtree+0xe6>
 800c34a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800c34c:	f002 fdf0 	bl	800ef30 <wolfSSL_Free>
                return MEMORY_E;
 800c350:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800c354:	e020      	b.n	800c398 <DecodeSubtree+0x12e>
            }

            XMEMCPY(entry->name, &input[nameIdx], strLength);
 800c356:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c358:	6858      	ldr	r0, [r3, #4]
 800c35a:	697b      	ldr	r3, [r7, #20]
 800c35c:	68fa      	ldr	r2, [r7, #12]
 800c35e:	4413      	add	r3, r2
 800c360:	69ba      	ldr	r2, [r7, #24]
 800c362:	4619      	mov	r1, r3
 800c364:	f00d f847 	bl	80193f6 <memcpy>
            entry->nameSz = strLength;
 800c368:	69ba      	ldr	r2, [r7, #24]
 800c36a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c36c:	609a      	str	r2, [r3, #8]
            entry->type = bType;
 800c36e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c370:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 800c374:	731a      	strb	r2, [r3, #12]

            entry->next = *head;
 800c376:	687b      	ldr	r3, [r7, #4]
 800c378:	681a      	ldr	r2, [r3, #0]
 800c37a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c37c:	601a      	str	r2, [r3, #0]
            *head = entry;
 800c37e:	687b      	ldr	r3, [r7, #4]
 800c380:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800c382:	601a      	str	r2, [r3, #0]
        }

        idx += seqLength;
 800c384:	6a3b      	ldr	r3, [r7, #32]
 800c386:	69fa      	ldr	r2, [r7, #28]
 800c388:	4413      	add	r3, r2
 800c38a:	623b      	str	r3, [r7, #32]
    while (idx < (word32)sz) {
 800c38c:	6a3a      	ldr	r2, [r7, #32]
 800c38e:	68bb      	ldr	r3, [r7, #8]
 800c390:	429a      	cmp	r2, r3
 800c392:	f4ff af74 	bcc.w	800c27e <DecodeSubtree+0x14>
    }

    return 0;
 800c396:	2300      	movs	r3, #0
}
 800c398:	4618      	mov	r0, r3
 800c39a:	3730      	adds	r7, #48	; 0x30
 800c39c:	46bd      	mov	sp, r7
 800c39e:	bd80      	pop	{r7, pc}

0800c3a0 <DecodeNameConstraints>:


static int DecodeNameConstraints(const byte* input, int sz, DecodedCert* cert)
{
 800c3a0:	b580      	push	{r7, lr}
 800c3a2:	b088      	sub	sp, #32
 800c3a4:	af00      	add	r7, sp, #0
 800c3a6:	60f8      	str	r0, [r7, #12]
 800c3a8:	60b9      	str	r1, [r7, #8]
 800c3aa:	607a      	str	r2, [r7, #4]
    word32 idx = 0;
 800c3ac:	2300      	movs	r3, #0
 800c3ae:	617b      	str	r3, [r7, #20]
    int length = 0;
 800c3b0:	2300      	movs	r3, #0
 800c3b2:	613b      	str	r3, [r7, #16]

    WOLFSSL_ENTER("DecodeNameConstraints");

    if (GetSequence(input, &idx, &length, sz) < 0) {
 800c3b4:	68bb      	ldr	r3, [r7, #8]
 800c3b6:	f107 0210 	add.w	r2, r7, #16
 800c3ba:	f107 0114 	add.w	r1, r7, #20
 800c3be:	68f8      	ldr	r0, [r7, #12]
 800c3c0:	f7fc fae6 	bl	8008990 <GetSequence>
 800c3c4:	4603      	mov	r3, r0
 800c3c6:	2b00      	cmp	r3, #0
 800c3c8:	da3e      	bge.n	800c448 <DecodeNameConstraints+0xa8>
        WOLFSSL_MSG("\tfail: should be a SEQUENCE");
        return ASN_PARSE_E;
 800c3ca:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c3ce:	e040      	b.n	800c452 <DecodeNameConstraints+0xb2>
    }

    while (idx < (word32)sz) {
        byte b = input[idx++];
 800c3d0:	697b      	ldr	r3, [r7, #20]
 800c3d2:	1c5a      	adds	r2, r3, #1
 800c3d4:	617a      	str	r2, [r7, #20]
 800c3d6:	68fa      	ldr	r2, [r7, #12]
 800c3d8:	4413      	add	r3, r2
 800c3da:	781b      	ldrb	r3, [r3, #0]
 800c3dc:	76fb      	strb	r3, [r7, #27]
        Base_entry** subtree = NULL;
 800c3de:	2300      	movs	r3, #0
 800c3e0:	61fb      	str	r3, [r7, #28]

        if (GetLength(input, &idx, &length, sz) <= 0) {
 800c3e2:	68bb      	ldr	r3, [r7, #8]
 800c3e4:	f107 0210 	add.w	r2, r7, #16
 800c3e8:	f107 0114 	add.w	r1, r7, #20
 800c3ec:	68f8      	ldr	r0, [r7, #12]
 800c3ee:	f7fc f99b 	bl	8008728 <GetLength>
 800c3f2:	4603      	mov	r3, r0
 800c3f4:	2b00      	cmp	r3, #0
 800c3f6:	dc02      	bgt.n	800c3fe <DecodeNameConstraints+0x5e>
            WOLFSSL_MSG("\tinvalid length");
            return ASN_PARSE_E;
 800c3f8:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c3fc:	e029      	b.n	800c452 <DecodeNameConstraints+0xb2>
        }

        if (b == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
 800c3fe:	7efb      	ldrb	r3, [r7, #27]
 800c400:	2ba0      	cmp	r3, #160	; 0xa0
 800c402:	d103      	bne.n	800c40c <DecodeNameConstraints+0x6c>
            subtree = &cert->permittedNames;
 800c404:	687b      	ldr	r3, [r7, #4]
 800c406:	3330      	adds	r3, #48	; 0x30
 800c408:	61fb      	str	r3, [r7, #28]
 800c40a:	e009      	b.n	800c420 <DecodeNameConstraints+0x80>
        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1))
 800c40c:	7efb      	ldrb	r3, [r7, #27]
 800c40e:	2ba1      	cmp	r3, #161	; 0xa1
 800c410:	d103      	bne.n	800c41a <DecodeNameConstraints+0x7a>
            subtree = &cert->excludedNames;
 800c412:	687b      	ldr	r3, [r7, #4]
 800c414:	3334      	adds	r3, #52	; 0x34
 800c416:	61fb      	str	r3, [r7, #28]
 800c418:	e002      	b.n	800c420 <DecodeNameConstraints+0x80>
        else {
            WOLFSSL_MSG("\tinvalid subtree");
            return ASN_PARSE_E;
 800c41a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c41e:	e018      	b.n	800c452 <DecodeNameConstraints+0xb2>
        }

        if (DecodeSubtree(input + idx, length, subtree, cert->heap) < 0) {
 800c420:	697b      	ldr	r3, [r7, #20]
 800c422:	68fa      	ldr	r2, [r7, #12]
 800c424:	18d0      	adds	r0, r2, r3
 800c426:	6939      	ldr	r1, [r7, #16]
 800c428:	687b      	ldr	r3, [r7, #4]
 800c42a:	f8d3 3298 	ldr.w	r3, [r3, #664]	; 0x298
 800c42e:	69fa      	ldr	r2, [r7, #28]
 800c430:	f7ff ff1b 	bl	800c26a <DecodeSubtree>
 800c434:	4603      	mov	r3, r0
 800c436:	2b00      	cmp	r3, #0
 800c438:	da02      	bge.n	800c440 <DecodeNameConstraints+0xa0>
            WOLFSSL_MSG("\terror parsing subtree");
            return ASN_PARSE_E;
 800c43a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c43e:	e008      	b.n	800c452 <DecodeNameConstraints+0xb2>
        }

        idx += length;
 800c440:	697b      	ldr	r3, [r7, #20]
 800c442:	693a      	ldr	r2, [r7, #16]
 800c444:	4413      	add	r3, r2
 800c446:	617b      	str	r3, [r7, #20]
    while (idx < (word32)sz) {
 800c448:	697a      	ldr	r2, [r7, #20]
 800c44a:	68bb      	ldr	r3, [r7, #8]
 800c44c:	429a      	cmp	r2, r3
 800c44e:	d3bf      	bcc.n	800c3d0 <DecodeNameConstraints+0x30>
    }

    return 0;
 800c450:	2300      	movs	r3, #0
}
 800c452:	4618      	mov	r0, r3
 800c454:	3720      	adds	r7, #32
 800c456:	46bd      	mov	sp, r7
 800c458:	bd80      	pop	{r7, pc}

0800c45a <DecodeCertExtensions>:
static int DecodeCertExtensions(DecodedCert* cert)
/*
 *  Processing the Certificate Extensions. This does not modify the current
 *  index. It is works starting with the recorded extensions pointer.
 */
{
 800c45a:	b580      	push	{r7, lr}
 800c45c:	b08e      	sub	sp, #56	; 0x38
 800c45e:	af02      	add	r7, sp, #8
 800c460:	6078      	str	r0, [r7, #4]
    int ret = 0;
 800c462:	2300      	movs	r3, #0
 800c464:	62bb      	str	r3, [r7, #40]	; 0x28
    word32 idx = 0;
 800c466:	2300      	movs	r3, #0
 800c468:	61fb      	str	r3, [r7, #28]
    int sz = cert->extensionsSz;
 800c46a:	687b      	ldr	r3, [r7, #4]
 800c46c:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 800c470:	627b      	str	r3, [r7, #36]	; 0x24
    const byte* input = cert->extensions;
 800c472:	687b      	ldr	r3, [r7, #4]
 800c474:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 800c478:	623b      	str	r3, [r7, #32]
    int length;
    word32 oid;
    byte critical = 0;
 800c47a:	2300      	movs	r3, #0
 800c47c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    byte criticalFail = 0;
 800c480:	2300      	movs	r3, #0
 800c482:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
    byte tag = 0;
 800c486:	2300      	movs	r3, #0
 800c488:	74fb      	strb	r3, [r7, #19]

    WOLFSSL_ENTER("DecodeCertExtensions");

    if (input == NULL || sz == 0)
 800c48a:	6a3b      	ldr	r3, [r7, #32]
 800c48c:	2b00      	cmp	r3, #0
 800c48e:	d002      	beq.n	800c496 <DecodeCertExtensions+0x3c>
 800c490:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c492:	2b00      	cmp	r3, #0
 800c494:	d102      	bne.n	800c49c <DecodeCertExtensions+0x42>
        return BAD_FUNC_ARG;
 800c496:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800c49a:	e257      	b.n	800c94c <DecodeCertExtensions+0x4f2>

#ifdef WOLFSSL_CERT_REQ
    if (!cert->isCSR)
#endif
    { /* Not included in CSR */
        if (GetASNTag(input, &idx, &tag, sz) < 0) {
 800c49c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c49e:	f107 0213 	add.w	r2, r7, #19
 800c4a2:	f107 011c 	add.w	r1, r7, #28
 800c4a6:	6a38      	ldr	r0, [r7, #32]
 800c4a8:	f7fc f9bc 	bl	8008824 <GetASNTag>
 800c4ac:	4603      	mov	r3, r0
 800c4ae:	2b00      	cmp	r3, #0
 800c4b0:	da02      	bge.n	800c4b8 <DecodeCertExtensions+0x5e>
            return ASN_PARSE_E;
 800c4b2:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c4b6:	e249      	b.n	800c94c <DecodeCertExtensions+0x4f2>
        }

        if (tag != ASN_EXTENSIONS) {
 800c4b8:	7cfb      	ldrb	r3, [r7, #19]
 800c4ba:	2ba3      	cmp	r3, #163	; 0xa3
 800c4bc:	d002      	beq.n	800c4c4 <DecodeCertExtensions+0x6a>
            WOLFSSL_MSG("\tfail: should be an EXTENSIONS");
            return ASN_PARSE_E;
 800c4be:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c4c2:	e243      	b.n	800c94c <DecodeCertExtensions+0x4f2>
        }

        if (GetLength(input, &idx, &length, sz) < 0) {
 800c4c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c4c6:	f107 0218 	add.w	r2, r7, #24
 800c4ca:	f107 011c 	add.w	r1, r7, #28
 800c4ce:	6a38      	ldr	r0, [r7, #32]
 800c4d0:	f7fc f92a 	bl	8008728 <GetLength>
 800c4d4:	4603      	mov	r3, r0
 800c4d6:	2b00      	cmp	r3, #0
 800c4d8:	da02      	bge.n	800c4e0 <DecodeCertExtensions+0x86>
            WOLFSSL_MSG("\tfail: invalid length");
            return ASN_PARSE_E;
 800c4da:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c4de:	e235      	b.n	800c94c <DecodeCertExtensions+0x4f2>
        }
    }

    if (GetSequence(input, &idx, &length, sz) < 0) {
 800c4e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c4e2:	f107 0218 	add.w	r2, r7, #24
 800c4e6:	f107 011c 	add.w	r1, r7, #28
 800c4ea:	6a38      	ldr	r0, [r7, #32]
 800c4ec:	f7fc fa50 	bl	8008990 <GetSequence>
 800c4f0:	4603      	mov	r3, r0
 800c4f2:	2b00      	cmp	r3, #0
 800c4f4:	f280 821d 	bge.w	800c932 <DecodeCertExtensions+0x4d8>
        WOLFSSL_MSG("\tfail: should be a SEQUENCE (1)");
        return ASN_PARSE_E;
 800c4f8:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c4fc:	e226      	b.n	800c94c <DecodeCertExtensions+0x4f2>
    }

    while (idx < (word32)sz) {
        word32 localIdx;

        if (GetSequence(input, &idx, &length, sz) < 0) {
 800c4fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c500:	f107 0218 	add.w	r2, r7, #24
 800c504:	f107 011c 	add.w	r1, r7, #28
 800c508:	6a38      	ldr	r0, [r7, #32]
 800c50a:	f7fc fa41 	bl	8008990 <GetSequence>
 800c50e:	4603      	mov	r3, r0
 800c510:	2b00      	cmp	r3, #0
 800c512:	da02      	bge.n	800c51a <DecodeCertExtensions+0xc0>
            WOLFSSL_MSG("\tfail: should be a SEQUENCE");
            return ASN_PARSE_E;
 800c514:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c518:	e218      	b.n	800c94c <DecodeCertExtensions+0x4f2>
        }

        oid = 0;
 800c51a:	2300      	movs	r3, #0
 800c51c:	617b      	str	r3, [r7, #20]
        if ((ret = GetObjectId(input, &idx, &oid, oidCertExtType, sz)) < 0) {
 800c51e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c520:	f107 0214 	add.w	r2, r7, #20
 800c524:	f107 011c 	add.w	r1, r7, #28
 800c528:	9300      	str	r3, [sp, #0]
 800c52a:	2306      	movs	r3, #6
 800c52c:	6a38      	ldr	r0, [r7, #32]
 800c52e:	f7fd f859 	bl	80095e4 <GetObjectId>
 800c532:	62b8      	str	r0, [r7, #40]	; 0x28
 800c534:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c536:	2b00      	cmp	r3, #0
 800c538:	da01      	bge.n	800c53e <DecodeCertExtensions+0xe4>
            WOLFSSL_MSG("\tfail: OBJECT ID");
            return ret;
 800c53a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c53c:	e206      	b.n	800c94c <DecodeCertExtensions+0x4f2>
        }

        /* check for critical flag */
        critical = 0;
 800c53e:	2300      	movs	r3, #0
 800c540:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        if ((idx + 1) > (word32)sz) {
 800c544:	69fb      	ldr	r3, [r7, #28]
 800c546:	1c5a      	adds	r2, r3, #1
 800c548:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c54a:	429a      	cmp	r2, r3
 800c54c:	d902      	bls.n	800c554 <DecodeCertExtensions+0xfa>
            WOLFSSL_MSG("\tfail: malformed buffer");
            return BUFFER_E;
 800c54e:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800c552:	e1fb      	b.n	800c94c <DecodeCertExtensions+0x4f2>
        }

        localIdx = idx;
 800c554:	69fb      	ldr	r3, [r7, #28]
 800c556:	60fb      	str	r3, [r7, #12]
        if (GetASNTag(input, &localIdx, &tag, sz) == 0) {
 800c558:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c55a:	f107 0213 	add.w	r2, r7, #19
 800c55e:	f107 010c 	add.w	r1, r7, #12
 800c562:	6a38      	ldr	r0, [r7, #32]
 800c564:	f7fc f95e 	bl	8008824 <GetASNTag>
 800c568:	4603      	mov	r3, r0
 800c56a:	2b00      	cmp	r3, #0
 800c56c:	d112      	bne.n	800c594 <DecodeCertExtensions+0x13a>
            if (tag == ASN_BOOLEAN) {
 800c56e:	7cfb      	ldrb	r3, [r7, #19]
 800c570:	2b01      	cmp	r3, #1
 800c572:	d10f      	bne.n	800c594 <DecodeCertExtensions+0x13a>
                ret = GetBoolean(input, &idx, sz);
 800c574:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800c576:	f107 031c 	add.w	r3, r7, #28
 800c57a:	4619      	mov	r1, r3
 800c57c:	6a38      	ldr	r0, [r7, #32]
 800c57e:	f7fc fa74 	bl	8008a6a <GetBoolean>
 800c582:	62b8      	str	r0, [r7, #40]	; 0x28
                if (ret < 0) {
 800c584:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c586:	2b00      	cmp	r3, #0
 800c588:	da01      	bge.n	800c58e <DecodeCertExtensions+0x134>
                    WOLFSSL_MSG("\tfail: critical boolean");
                    return ret;
 800c58a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c58c:	e1de      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                }

                critical = (byte)ret;
 800c58e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c590:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            }
        }

        /* process the extension based on the OID */
        ret = GetOctetString(input, &idx, &length, sz);
 800c594:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c596:	f107 0218 	add.w	r2, r7, #24
 800c59a:	f107 011c 	add.w	r1, r7, #28
 800c59e:	6a38      	ldr	r0, [r7, #32]
 800c5a0:	f7fc faa2 	bl	8008ae8 <GetOctetString>
 800c5a4:	62b8      	str	r0, [r7, #40]	; 0x28
        if (ret < 0) {
 800c5a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c5a8:	2b00      	cmp	r3, #0
 800c5aa:	da01      	bge.n	800c5b0 <DecodeCertExtensions+0x156>
            WOLFSSL_MSG("\tfail: bad OCTET STRING");
            return ret;
 800c5ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c5ae:	e1cd      	b.n	800c94c <DecodeCertExtensions+0x4f2>
        }

        switch (oid) {
 800c5b0:	697b      	ldr	r3, [r7, #20]
 800c5b2:	2b90      	cmp	r3, #144	; 0x90
 800c5b4:	f000 8146 	beq.w	800c844 <DecodeCertExtensions+0x3ea>
 800c5b8:	2b90      	cmp	r3, #144	; 0x90
 800c5ba:	d80f      	bhi.n	800c5dc <DecodeCertExtensions+0x182>
 800c5bc:	2b81      	cmp	r3, #129	; 0x81
 800c5be:	f000 80fe 	beq.w	800c7be <DecodeCertExtensions+0x364>
 800c5c2:	2b81      	cmp	r3, #129	; 0x81
 800c5c4:	d805      	bhi.n	800c5d2 <DecodeCertExtensions+0x178>
 800c5c6:	2b45      	cmp	r3, #69	; 0x45
 800c5c8:	d063      	beq.n	800c692 <DecodeCertExtensions+0x238>
 800c5ca:	2b80      	cmp	r3, #128	; 0x80
 800c5cc:	f000 80ce 	beq.w	800c76c <DecodeCertExtensions+0x312>
 800c5d0:	e18c      	b.n	800c8ec <DecodeCertExtensions+0x492>
 800c5d2:	2b83      	cmp	r3, #131	; 0x83
 800c5d4:	d07f      	beq.n	800c6d6 <DecodeCertExtensions+0x27c>
 800c5d6:	2b85      	cmp	r3, #133	; 0x85
 800c5d8:	d017      	beq.n	800c60a <DecodeCertExtensions+0x1b0>
 800c5da:	e187      	b.n	800c8ec <DecodeCertExtensions+0x492>
 800c5dc:	2b95      	cmp	r3, #149	; 0x95
 800c5de:	f000 809c 	beq.w	800c71a <DecodeCertExtensions+0x2c0>
 800c5e2:	2b95      	cmp	r3, #149	; 0x95
 800c5e4:	d805      	bhi.n	800c5f2 <DecodeCertExtensions+0x198>
 800c5e6:	2b91      	cmp	r3, #145	; 0x91
 800c5e8:	d031      	beq.n	800c64e <DecodeCertExtensions+0x1f4>
 800c5ea:	2b92      	cmp	r3, #146	; 0x92
 800c5ec:	f000 8186 	beq.w	800c8fc <DecodeCertExtensions+0x4a2>
 800c5f0:	e17c      	b.n	800c8ec <DecodeCertExtensions+0x492>
 800c5f2:	2ba8      	cmp	r3, #168	; 0xa8
 800c5f4:	f000 8152 	beq.w	800c89c <DecodeCertExtensions+0x442>
 800c5f8:	f240 22f1 	movw	r2, #753	; 0x2f1
 800c5fc:	4293      	cmp	r3, r2
 800c5fe:	f000 8160 	beq.w	800c8c2 <DecodeCertExtensions+0x468>
 800c602:	2b97      	cmp	r3, #151	; 0x97
 800c604:	f000 80fd 	beq.w	800c802 <DecodeCertExtensions+0x3a8>
 800c608:	e170      	b.n	800c8ec <DecodeCertExtensions+0x492>
            case BASIC_CA_OID:
                VERIFY_AND_SET_OID(cert->extBasicConstSet);
 800c60a:	687b      	ldr	r3, [r7, #4]
 800c60c:	f893 3379 	ldrb.w	r3, [r3, #889]	; 0x379
 800c610:	f003 0308 	and.w	r3, r3, #8
 800c614:	b2db      	uxtb	r3, r3
 800c616:	2b00      	cmp	r3, #0
 800c618:	d113      	bne.n	800c642 <DecodeCertExtensions+0x1e8>
 800c61a:	687a      	ldr	r2, [r7, #4]
 800c61c:	f892 3379 	ldrb.w	r3, [r2, #889]	; 0x379
 800c620:	f043 0308 	orr.w	r3, r3, #8
 800c624:	f882 3379 	strb.w	r3, [r2, #889]	; 0x379
                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                    cert->extBasicConstCrit = critical;
                #endif
                if (DecodeBasicCaConstraint(&input[idx], length, cert) < 0)
 800c628:	69fb      	ldr	r3, [r7, #28]
 800c62a:	6a3a      	ldr	r2, [r7, #32]
 800c62c:	4413      	add	r3, r2
 800c62e:	69b9      	ldr	r1, [r7, #24]
 800c630:	687a      	ldr	r2, [r7, #4]
 800c632:	4618      	mov	r0, r3
 800c634:	f7ff fae2 	bl	800bbfc <DecodeBasicCaConstraint>
 800c638:	4603      	mov	r3, r0
 800c63a:	2b00      	cmp	r3, #0
 800c63c:	f280 8160 	bge.w	800c900 <DecodeCertExtensions+0x4a6>
 800c640:	e002      	b.n	800c648 <DecodeCertExtensions+0x1ee>
                VERIFY_AND_SET_OID(cert->extBasicConstSet);
 800c642:	f06f 038f 	mvn.w	r3, #143	; 0x8f
 800c646:	e181      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                    return ASN_PARSE_E;
 800c648:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c64c:	e17e      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                break;

            case CRL_DIST_OID:
                VERIFY_AND_SET_OID(cert->extCRLdistSet);
 800c64e:	687b      	ldr	r3, [r7, #4]
 800c650:	f893 3379 	ldrb.w	r3, [r3, #889]	; 0x379
 800c654:	f003 0302 	and.w	r3, r3, #2
 800c658:	b2db      	uxtb	r3, r3
 800c65a:	2b00      	cmp	r3, #0
 800c65c:	d113      	bne.n	800c686 <DecodeCertExtensions+0x22c>
 800c65e:	687a      	ldr	r2, [r7, #4]
 800c660:	f892 3379 	ldrb.w	r3, [r2, #889]	; 0x379
 800c664:	f043 0302 	orr.w	r3, r3, #2
 800c668:	f882 3379 	strb.w	r3, [r2, #889]	; 0x379
                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                    cert->extCRLdistCrit = critical;
                #endif
                if (DecodeCrlDist(&input[idx], length, cert) < 0)
 800c66c:	69fb      	ldr	r3, [r7, #28]
 800c66e:	6a3a      	ldr	r2, [r7, #32]
 800c670:	4413      	add	r3, r2
 800c672:	69b9      	ldr	r1, [r7, #24]
 800c674:	687a      	ldr	r2, [r7, #4]
 800c676:	4618      	mov	r0, r3
 800c678:	f7ff fb19 	bl	800bcae <DecodeCrlDist>
 800c67c:	4603      	mov	r3, r0
 800c67e:	2b00      	cmp	r3, #0
 800c680:	f280 8140 	bge.w	800c904 <DecodeCertExtensions+0x4aa>
 800c684:	e002      	b.n	800c68c <DecodeCertExtensions+0x232>
                VERIFY_AND_SET_OID(cert->extCRLdistSet);
 800c686:	f06f 038f 	mvn.w	r3, #143	; 0x8f
 800c68a:	e15f      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                    return ASN_PARSE_E;
 800c68c:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c690:	e15c      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                break;

            case AUTH_INFO_OID:
                VERIFY_AND_SET_OID(cert->extAuthInfoSet);
 800c692:	687b      	ldr	r3, [r7, #4]
 800c694:	f893 3379 	ldrb.w	r3, [r3, #889]	; 0x379
 800c698:	f003 0304 	and.w	r3, r3, #4
 800c69c:	b2db      	uxtb	r3, r3
 800c69e:	2b00      	cmp	r3, #0
 800c6a0:	d113      	bne.n	800c6ca <DecodeCertExtensions+0x270>
 800c6a2:	687a      	ldr	r2, [r7, #4]
 800c6a4:	f892 3379 	ldrb.w	r3, [r2, #889]	; 0x379
 800c6a8:	f043 0304 	orr.w	r3, r3, #4
 800c6ac:	f882 3379 	strb.w	r3, [r2, #889]	; 0x379
                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                    cert->extAuthInfoCrit = critical;
                #endif
                if (DecodeAuthInfo(&input[idx], length, cert) < 0)
 800c6b0:	69fb      	ldr	r3, [r7, #28]
 800c6b2:	6a3a      	ldr	r2, [r7, #32]
 800c6b4:	4413      	add	r3, r2
 800c6b6:	69b9      	ldr	r1, [r7, #24]
 800c6b8:	687a      	ldr	r2, [r7, #4]
 800c6ba:	4618      	mov	r0, r3
 800c6bc:	f7ff fbf1 	bl	800bea2 <DecodeAuthInfo>
 800c6c0:	4603      	mov	r3, r0
 800c6c2:	2b00      	cmp	r3, #0
 800c6c4:	f280 8120 	bge.w	800c908 <DecodeCertExtensions+0x4ae>
 800c6c8:	e002      	b.n	800c6d0 <DecodeCertExtensions+0x276>
                VERIFY_AND_SET_OID(cert->extAuthInfoSet);
 800c6ca:	f06f 038f 	mvn.w	r3, #143	; 0x8f
 800c6ce:	e13d      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                    return ASN_PARSE_E;
 800c6d0:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c6d4:	e13a      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                break;

            case ALT_NAMES_OID:
                VERIFY_AND_SET_OID(cert->extSubjAltNameSet);
 800c6d6:	687b      	ldr	r3, [r7, #4]
 800c6d8:	f893 3379 	ldrb.w	r3, [r3, #889]	; 0x379
 800c6dc:	f003 0310 	and.w	r3, r3, #16
 800c6e0:	b2db      	uxtb	r3, r3
 800c6e2:	2b00      	cmp	r3, #0
 800c6e4:	d114      	bne.n	800c710 <DecodeCertExtensions+0x2b6>
 800c6e6:	687a      	ldr	r2, [r7, #4]
 800c6e8:	f892 3379 	ldrb.w	r3, [r2, #889]	; 0x379
 800c6ec:	f043 0310 	orr.w	r3, r3, #16
 800c6f0:	f882 3379 	strb.w	r3, [r2, #889]	; 0x379
                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                    cert->extSubjAltNameCrit = critical;
                #endif
                ret = DecodeAltNames(&input[idx], length, cert);
 800c6f4:	69fb      	ldr	r3, [r7, #28]
 800c6f6:	6a3a      	ldr	r2, [r7, #32]
 800c6f8:	4413      	add	r3, r2
 800c6fa:	69b9      	ldr	r1, [r7, #24]
 800c6fc:	687a      	ldr	r2, [r7, #4]
 800c6fe:	4618      	mov	r0, r3
 800c700:	f7ff f855 	bl	800b7ae <DecodeAltNames>
 800c704:	62b8      	str	r0, [r7, #40]	; 0x28
                if (ret < 0)
 800c706:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c708:	2b00      	cmp	r3, #0
 800c70a:	f280 80ff 	bge.w	800c90c <DecodeCertExtensions+0x4b2>
 800c70e:	e002      	b.n	800c716 <DecodeCertExtensions+0x2bc>
                VERIFY_AND_SET_OID(cert->extSubjAltNameSet);
 800c710:	f06f 038f 	mvn.w	r3, #143	; 0x8f
 800c714:	e11a      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                    return ret;
 800c716:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c718:	e118      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                break;

            case AUTH_KEY_OID:
                VERIFY_AND_SET_OID(cert->extAuthKeyIdSet);
 800c71a:	687b      	ldr	r3, [r7, #4]
 800c71c:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 800c720:	f003 0304 	and.w	r3, r3, #4
 800c724:	b2db      	uxtb	r3, r3
 800c726:	2b00      	cmp	r3, #0
 800c728:	d10b      	bne.n	800c742 <DecodeCertExtensions+0x2e8>
 800c72a:	687a      	ldr	r2, [r7, #4]
 800c72c:	f892 3378 	ldrb.w	r3, [r2, #888]	; 0x378
 800c730:	f043 0304 	orr.w	r3, r3, #4
 800c734:	f882 3378 	strb.w	r3, [r2, #888]	; 0x378
                #ifndef WOLFSSL_ALLOW_CRIT_SKID
                    /* This check is added due to RFC 5280 section 4.2.1.1
                     * stating that conforming CA's must mark this extension
                     * as non-critical. When parsing extensions check that
                     * certificate was made in compliance with this. */
                    if (critical) {
 800c738:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800c73c:	2b00      	cmp	r3, #0
 800c73e:	d006      	beq.n	800c74e <DecodeCertExtensions+0x2f4>
 800c740:	e002      	b.n	800c748 <DecodeCertExtensions+0x2ee>
                VERIFY_AND_SET_OID(cert->extAuthKeyIdSet);
 800c742:	f06f 038f 	mvn.w	r3, #143	; 0x8f
 800c746:	e101      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                        WOLFSSL_MSG("Critical Auth Key ID is not allowed");
                        WOLFSSL_MSG("Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted");
                        return ASN_CRIT_EXT_E;
 800c748:	f06f 039f 	mvn.w	r3, #159	; 0x9f
 800c74c:	e0fe      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                    }
                #endif
                if (DecodeAuthKeyId(&input[idx], length, cert) < 0)
 800c74e:	69fb      	ldr	r3, [r7, #28]
 800c750:	6a3a      	ldr	r2, [r7, #32]
 800c752:	4413      	add	r3, r2
 800c754:	69b9      	ldr	r1, [r7, #24]
 800c756:	687a      	ldr	r2, [r7, #4]
 800c758:	4618      	mov	r0, r3
 800c75a:	f7ff fc1e 	bl	800bf9a <DecodeAuthKeyId>
 800c75e:	4603      	mov	r3, r0
 800c760:	2b00      	cmp	r3, #0
 800c762:	f280 80d5 	bge.w	800c910 <DecodeCertExtensions+0x4b6>
                    return ASN_PARSE_E;
 800c766:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c76a:	e0ef      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                break;

            case SUBJ_KEY_OID:
                VERIFY_AND_SET_OID(cert->extSubjKeyIdSet);
 800c76c:	687b      	ldr	r3, [r7, #4]
 800c76e:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 800c772:	f003 0302 	and.w	r3, r3, #2
 800c776:	b2db      	uxtb	r3, r3
 800c778:	2b00      	cmp	r3, #0
 800c77a:	d10b      	bne.n	800c794 <DecodeCertExtensions+0x33a>
 800c77c:	687a      	ldr	r2, [r7, #4]
 800c77e:	f892 3378 	ldrb.w	r3, [r2, #888]	; 0x378
 800c782:	f043 0302 	orr.w	r3, r3, #2
 800c786:	f882 3378 	strb.w	r3, [r2, #888]	; 0x378
                #ifndef WOLFSSL_ALLOW_CRIT_SKID
                    /* This check is added due to RFC 5280 section 4.2.1.2
                     * stating that conforming CA's must mark this extension
                     * as non-critical. When parsing extensions check that
                     * certificate was made in compliance with this. */
                    if (critical) {
 800c78a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800c78e:	2b00      	cmp	r3, #0
 800c790:	d006      	beq.n	800c7a0 <DecodeCertExtensions+0x346>
 800c792:	e002      	b.n	800c79a <DecodeCertExtensions+0x340>
                VERIFY_AND_SET_OID(cert->extSubjKeyIdSet);
 800c794:	f06f 038f 	mvn.w	r3, #143	; 0x8f
 800c798:	e0d8      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                        WOLFSSL_MSG("Critical Subject Key ID is not allowed");
                        WOLFSSL_MSG("Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted");
                        return ASN_CRIT_EXT_E;
 800c79a:	f06f 039f 	mvn.w	r3, #159	; 0x9f
 800c79e:	e0d5      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                    }
                #endif

                if (DecodeSubjKeyId(&input[idx], length, cert) < 0)
 800c7a0:	69fb      	ldr	r3, [r7, #28]
 800c7a2:	6a3a      	ldr	r2, [r7, #32]
 800c7a4:	4413      	add	r3, r2
 800c7a6:	69b9      	ldr	r1, [r7, #24]
 800c7a8:	687a      	ldr	r2, [r7, #4]
 800c7aa:	4618      	mov	r0, r3
 800c7ac:	f7ff fc56 	bl	800c05c <DecodeSubjKeyId>
 800c7b0:	4603      	mov	r3, r0
 800c7b2:	2b00      	cmp	r3, #0
 800c7b4:	f280 80ae 	bge.w	800c914 <DecodeCertExtensions+0x4ba>
                    return ASN_PARSE_E;
 800c7b8:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c7bc:	e0c6      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                    WOLFSSL_MSG("Certificate Policy extension not supported yet.");
                #endif
                break;

            case KEY_USAGE_OID:
                VERIFY_AND_SET_OID(cert->extKeyUsageSet);
 800c7be:	687b      	ldr	r3, [r7, #4]
 800c7c0:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 800c7c4:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800c7c8:	b2db      	uxtb	r3, r3
 800c7ca:	2b00      	cmp	r3, #0
 800c7cc:	d113      	bne.n	800c7f6 <DecodeCertExtensions+0x39c>
 800c7ce:	687a      	ldr	r2, [r7, #4]
 800c7d0:	f892 3378 	ldrb.w	r3, [r2, #888]	; 0x378
 800c7d4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800c7d8:	f882 3378 	strb.w	r3, [r2, #888]	; 0x378
                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                    cert->extKeyUsageCrit = critical;
                #endif
                if (DecodeKeyUsage(&input[idx], length, cert) < 0)
 800c7dc:	69fb      	ldr	r3, [r7, #28]
 800c7de:	6a3a      	ldr	r2, [r7, #32]
 800c7e0:	4413      	add	r3, r2
 800c7e2:	69b9      	ldr	r1, [r7, #24]
 800c7e4:	687a      	ldr	r2, [r7, #4]
 800c7e6:	4618      	mov	r0, r3
 800c7e8:	f7ff fc77 	bl	800c0da <DecodeKeyUsage>
 800c7ec:	4603      	mov	r3, r0
 800c7ee:	2b00      	cmp	r3, #0
 800c7f0:	f280 8092 	bge.w	800c918 <DecodeCertExtensions+0x4be>
 800c7f4:	e002      	b.n	800c7fc <DecodeCertExtensions+0x3a2>
                VERIFY_AND_SET_OID(cert->extKeyUsageSet);
 800c7f6:	f06f 038f 	mvn.w	r3, #143	; 0x8f
 800c7fa:	e0a7      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                    return ASN_PARSE_E;
 800c7fc:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c800:	e0a4      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                break;

            case EXT_KEY_USAGE_OID:
                VERIFY_AND_SET_OID(cert->extExtKeyUsageSet);
 800c802:	687b      	ldr	r3, [r7, #4]
 800c804:	f893 3379 	ldrb.w	r3, [r3, #889]	; 0x379
 800c808:	f003 0301 	and.w	r3, r3, #1
 800c80c:	b2db      	uxtb	r3, r3
 800c80e:	2b00      	cmp	r3, #0
 800c810:	d112      	bne.n	800c838 <DecodeCertExtensions+0x3de>
 800c812:	687a      	ldr	r2, [r7, #4]
 800c814:	f892 3379 	ldrb.w	r3, [r2, #889]	; 0x379
 800c818:	f043 0301 	orr.w	r3, r3, #1
 800c81c:	f882 3379 	strb.w	r3, [r2, #889]	; 0x379
                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                    cert->extExtKeyUsageCrit = critical;
                #endif
                if (DecodeExtKeyUsage(&input[idx], length, cert) < 0)
 800c820:	69fb      	ldr	r3, [r7, #28]
 800c822:	6a3a      	ldr	r2, [r7, #32]
 800c824:	4413      	add	r3, r2
 800c826:	69b9      	ldr	r1, [r7, #24]
 800c828:	687a      	ldr	r2, [r7, #4]
 800c82a:	4618      	mov	r0, r3
 800c82c:	f7ff fc90 	bl	800c150 <DecodeExtKeyUsage>
 800c830:	4603      	mov	r3, r0
 800c832:	2b00      	cmp	r3, #0
 800c834:	da72      	bge.n	800c91c <DecodeCertExtensions+0x4c2>
 800c836:	e002      	b.n	800c83e <DecodeCertExtensions+0x3e4>
                VERIFY_AND_SET_OID(cert->extExtKeyUsageSet);
 800c838:	f06f 038f 	mvn.w	r3, #143	; 0x8f
 800c83c:	e086      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                    return ASN_PARSE_E;
 800c83e:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c842:	e083      	b.n	800c94c <DecodeCertExtensions+0x4f2>
            case NAME_CONS_OID:
            #ifndef WOLFSSL_NO_ASN_STRICT
                /* Verify RFC 5280 Sec 4.2.1.10 rule:
                    "The name constraints extension,
                    which MUST be used only in a CA certificate" */
                if (!cert->isCA) {
 800c844:	687b      	ldr	r3, [r7, #4]
 800c846:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 800c84a:	f003 0310 	and.w	r3, r3, #16
 800c84e:	b2db      	uxtb	r3, r3
 800c850:	2b00      	cmp	r3, #0
 800c852:	d102      	bne.n	800c85a <DecodeCertExtensions+0x400>
                    WOLFSSL_MSG("Name constraints allowed only for CA certs");
                    return ASN_NAME_INVALID_E;
 800c854:	f06f 03c5 	mvn.w	r3, #197	; 0xc5
 800c858:	e078      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                }
            #endif
                VERIFY_AND_SET_OID(cert->extNameConstraintSet);
 800c85a:	687b      	ldr	r3, [r7, #4]
 800c85c:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 800c860:	f003 0308 	and.w	r3, r3, #8
 800c864:	b2db      	uxtb	r3, r3
 800c866:	2b00      	cmp	r3, #0
 800c868:	d112      	bne.n	800c890 <DecodeCertExtensions+0x436>
 800c86a:	687a      	ldr	r2, [r7, #4]
 800c86c:	f892 3378 	ldrb.w	r3, [r2, #888]	; 0x378
 800c870:	f043 0308 	orr.w	r3, r3, #8
 800c874:	f882 3378 	strb.w	r3, [r2, #888]	; 0x378
                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                    cert->extNameConstraintCrit = critical;
                #endif
                if (DecodeNameConstraints(&input[idx], length, cert) < 0)
 800c878:	69fb      	ldr	r3, [r7, #28]
 800c87a:	6a3a      	ldr	r2, [r7, #32]
 800c87c:	4413      	add	r3, r2
 800c87e:	69b9      	ldr	r1, [r7, #24]
 800c880:	687a      	ldr	r2, [r7, #4]
 800c882:	4618      	mov	r0, r3
 800c884:	f7ff fd8c 	bl	800c3a0 <DecodeNameConstraints>
 800c888:	4603      	mov	r3, r0
 800c88a:	2b00      	cmp	r3, #0
 800c88c:	da48      	bge.n	800c920 <DecodeCertExtensions+0x4c6>
 800c88e:	e002      	b.n	800c896 <DecodeCertExtensions+0x43c>
                VERIFY_AND_SET_OID(cert->extNameConstraintSet);
 800c890:	f06f 038f 	mvn.w	r3, #143	; 0x8f
 800c894:	e05a      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                    return ASN_PARSE_E;
 800c896:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c89a:	e057      	b.n	800c94c <DecodeCertExtensions+0x4f2>
                break;
            #endif /* IGNORE_NAME_CONSTRAINTS */

            case INHIBIT_ANY_OID:
                VERIFY_AND_SET_OID(cert->inhibitAnyOidSet);
 800c89c:	687b      	ldr	r3, [r7, #4]
 800c89e:	f893 3379 	ldrb.w	r3, [r3, #889]	; 0x379
 800c8a2:	f003 0320 	and.w	r3, r3, #32
 800c8a6:	b2db      	uxtb	r3, r3
 800c8a8:	2b00      	cmp	r3, #0
 800c8aa:	d107      	bne.n	800c8bc <DecodeCertExtensions+0x462>
 800c8ac:	687a      	ldr	r2, [r7, #4]
 800c8ae:	f892 3379 	ldrb.w	r3, [r2, #889]	; 0x379
 800c8b2:	f043 0320 	orr.w	r3, r3, #32
 800c8b6:	f882 3379 	strb.w	r3, [r2, #889]	; 0x379
                WOLFSSL_MSG("Inhibit anyPolicy extension not supported yet.");
                break;
 800c8ba:	e036      	b.n	800c92a <DecodeCertExtensions+0x4d0>
                VERIFY_AND_SET_OID(cert->inhibitAnyOidSet);
 800c8bc:	f06f 038f 	mvn.w	r3, #143	; 0x8f
 800c8c0:	e044      	b.n	800c94c <DecodeCertExtensions+0x4f2>

       #ifndef IGNORE_NETSCAPE_CERT_TYPE
            case NETSCAPE_CT_OID:
                WOLFSSL_MSG("Netscape certificate type extension not supported "
                            "yet.");
                if (CheckBitString(input, &idx, &length, idx + length, 0,
 800c8c2:	69fb      	ldr	r3, [r7, #28]
 800c8c4:	69ba      	ldr	r2, [r7, #24]
 800c8c6:	1898      	adds	r0, r3, r2
 800c8c8:	f107 0218 	add.w	r2, r7, #24
 800c8cc:	f107 011c 	add.w	r1, r7, #28
 800c8d0:	2300      	movs	r3, #0
 800c8d2:	9301      	str	r3, [sp, #4]
 800c8d4:	2300      	movs	r3, #0
 800c8d6:	9300      	str	r3, [sp, #0]
 800c8d8:	4603      	mov	r3, r0
 800c8da:	6a38      	ldr	r0, [r7, #32]
 800c8dc:	f7fc fa6f 	bl	8008dbe <CheckBitString>
 800c8e0:	4603      	mov	r3, r0
 800c8e2:	2b00      	cmp	r3, #0
 800c8e4:	da1e      	bge.n	800c924 <DecodeCertExtensions+0x4ca>
                                                                    NULL) < 0) {
                    return ASN_PARSE_E;
 800c8e6:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800c8ea:	e02f      	b.n	800c94c <DecodeCertExtensions+0x4f2>
            #ifndef WOLFSSL_NO_ASN_STRICT
                /* While it is a failure to not support critical extensions,
                 * still parse the certificate ignoring the unsupported
                 * extension to allow caller to accept it with the verify
                 * callback. */
                if (critical)
 800c8ec:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800c8f0:	2b00      	cmp	r3, #0
 800c8f2:	d019      	beq.n	800c928 <DecodeCertExtensions+0x4ce>
                    criticalFail = 1;
 800c8f4:	2301      	movs	r3, #1
 800c8f6:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
            #endif
            break;
 800c8fa:	e015      	b.n	800c928 <DecodeCertExtensions+0x4ce>
                break;
 800c8fc:	bf00      	nop
 800c8fe:	e014      	b.n	800c92a <DecodeCertExtensions+0x4d0>
                break;
 800c900:	bf00      	nop
 800c902:	e012      	b.n	800c92a <DecodeCertExtensions+0x4d0>
                break;
 800c904:	bf00      	nop
 800c906:	e010      	b.n	800c92a <DecodeCertExtensions+0x4d0>
                break;
 800c908:	bf00      	nop
 800c90a:	e00e      	b.n	800c92a <DecodeCertExtensions+0x4d0>
                break;
 800c90c:	bf00      	nop
 800c90e:	e00c      	b.n	800c92a <DecodeCertExtensions+0x4d0>
                break;
 800c910:	bf00      	nop
 800c912:	e00a      	b.n	800c92a <DecodeCertExtensions+0x4d0>
                break;
 800c914:	bf00      	nop
 800c916:	e008      	b.n	800c92a <DecodeCertExtensions+0x4d0>
                break;
 800c918:	bf00      	nop
 800c91a:	e006      	b.n	800c92a <DecodeCertExtensions+0x4d0>
                break;
 800c91c:	bf00      	nop
 800c91e:	e004      	b.n	800c92a <DecodeCertExtensions+0x4d0>
                break;
 800c920:	bf00      	nop
 800c922:	e002      	b.n	800c92a <DecodeCertExtensions+0x4d0>
                break;
 800c924:	bf00      	nop
 800c926:	e000      	b.n	800c92a <DecodeCertExtensions+0x4d0>
            break;
 800c928:	bf00      	nop
        }
        idx += length;
 800c92a:	69fb      	ldr	r3, [r7, #28]
 800c92c:	69ba      	ldr	r2, [r7, #24]
 800c92e:	4413      	add	r3, r2
 800c930:	61fb      	str	r3, [r7, #28]
    while (idx < (word32)sz) {
 800c932:	69fa      	ldr	r2, [r7, #28]
 800c934:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c936:	429a      	cmp	r2, r3
 800c938:	f4ff ade1 	bcc.w	800c4fe <DecodeCertExtensions+0xa4>
    }

    return criticalFail ? ASN_CRIT_EXT_E : 0;
 800c93c:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 800c940:	2b00      	cmp	r3, #0
 800c942:	d002      	beq.n	800c94a <DecodeCertExtensions+0x4f0>
 800c944:	f06f 039f 	mvn.w	r3, #159	; 0x9f
 800c948:	e000      	b.n	800c94c <DecodeCertExtensions+0x4f2>
 800c94a:	2300      	movs	r3, #0
}
 800c94c:	4618      	mov	r0, r3
 800c94e:	3730      	adds	r7, #48	; 0x30
 800c950:	46bd      	mov	sp, r7
 800c952:	bd80      	pop	{r7, pc}

0800c954 <ParseCert>:

int ParseCert(DecodedCert* cert, int type, int verify, void* cm)
{
 800c954:	b580      	push	{r7, lr}
 800c956:	b086      	sub	sp, #24
 800c958:	af00      	add	r7, sp, #0
 800c95a:	60f8      	str	r0, [r7, #12]
 800c95c:	60b9      	str	r1, [r7, #8]
 800c95e:	607a      	str	r2, [r7, #4]
 800c960:	603b      	str	r3, [r7, #0]
    int   ret;
    char* ptr;

    ret = ParseCertRelative(cert, type, verify, cm);
 800c962:	683b      	ldr	r3, [r7, #0]
 800c964:	687a      	ldr	r2, [r7, #4]
 800c966:	68b9      	ldr	r1, [r7, #8]
 800c968:	68f8      	ldr	r0, [r7, #12]
 800c96a:	f000 f861 	bl	800ca30 <ParseCertRelative>
 800c96e:	6178      	str	r0, [r7, #20]
    if (ret < 0)
 800c970:	697b      	ldr	r3, [r7, #20]
 800c972:	2b00      	cmp	r3, #0
 800c974:	da01      	bge.n	800c97a <ParseCert+0x26>
        return ret;
 800c976:	697b      	ldr	r3, [r7, #20]
 800c978:	e056      	b.n	800ca28 <ParseCert+0xd4>

    if (cert->subjectCNLen > 0) {
 800c97a:	68fb      	ldr	r3, [r7, #12]
 800c97c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800c980:	2b00      	cmp	r3, #0
 800c982:	dd28      	ble.n	800c9d6 <ParseCert+0x82>
        ptr = (char*) XMALLOC(cert->subjectCNLen + 1, cert->heap,
 800c984:	68fb      	ldr	r3, [r7, #12]
 800c986:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800c98a:	3301      	adds	r3, #1
 800c98c:	4618      	mov	r0, r3
 800c98e:	f002 fab3 	bl	800eef8 <wolfSSL_Malloc>
 800c992:	6138      	str	r0, [r7, #16]
                              DYNAMIC_TYPE_SUBJECT_CN);
        if (ptr == NULL)
 800c994:	693b      	ldr	r3, [r7, #16]
 800c996:	2b00      	cmp	r3, #0
 800c998:	d102      	bne.n	800c9a0 <ParseCert+0x4c>
            return MEMORY_E;
 800c99a:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800c99e:	e043      	b.n	800ca28 <ParseCert+0xd4>
        XMEMCPY(ptr, cert->subjectCN, cert->subjectCNLen);
 800c9a0:	68fb      	ldr	r3, [r7, #12]
 800c9a2:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
 800c9a4:	68fb      	ldr	r3, [r7, #12]
 800c9a6:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800c9aa:	461a      	mov	r2, r3
 800c9ac:	6938      	ldr	r0, [r7, #16]
 800c9ae:	f00c fd22 	bl	80193f6 <memcpy>
        ptr[cert->subjectCNLen] = '\0';
 800c9b2:	68fb      	ldr	r3, [r7, #12]
 800c9b4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800c9b8:	461a      	mov	r2, r3
 800c9ba:	693b      	ldr	r3, [r7, #16]
 800c9bc:	4413      	add	r3, r2
 800c9be:	2200      	movs	r2, #0
 800c9c0:	701a      	strb	r2, [r3, #0]
        cert->subjectCN = ptr;
 800c9c2:	68fb      	ldr	r3, [r7, #12]
 800c9c4:	693a      	ldr	r2, [r7, #16]
 800c9c6:	67da      	str	r2, [r3, #124]	; 0x7c
        cert->subjectCNStored = 1;
 800c9c8:	68fa      	ldr	r2, [r7, #12]
 800c9ca:	f892 3378 	ldrb.w	r3, [r2, #888]	; 0x378
 800c9ce:	f043 0301 	orr.w	r3, r3, #1
 800c9d2:	f882 3378 	strb.w	r3, [r2, #888]	; 0x378
    }

    if (cert->keyOID == RSAk &&
 800c9d6:	68fb      	ldr	r3, [r7, #12]
 800c9d8:	69db      	ldr	r3, [r3, #28]
 800c9da:	f240 2285 	movw	r2, #645	; 0x285
 800c9de:	4293      	cmp	r3, r2
 800c9e0:	d121      	bne.n	800ca26 <ParseCert+0xd2>
                          cert->publicKey != NULL  && cert->pubKeySize > 0) {
 800c9e2:	68fb      	ldr	r3, [r7, #12]
 800c9e4:	681b      	ldr	r3, [r3, #0]
    if (cert->keyOID == RSAk &&
 800c9e6:	2b00      	cmp	r3, #0
 800c9e8:	d01d      	beq.n	800ca26 <ParseCert+0xd2>
                          cert->publicKey != NULL  && cert->pubKeySize > 0) {
 800c9ea:	68fb      	ldr	r3, [r7, #12]
 800c9ec:	685b      	ldr	r3, [r3, #4]
 800c9ee:	2b00      	cmp	r3, #0
 800c9f0:	d019      	beq.n	800ca26 <ParseCert+0xd2>
        ptr = (char*) XMALLOC(cert->pubKeySize, cert->heap,
 800c9f2:	68fb      	ldr	r3, [r7, #12]
 800c9f4:	685b      	ldr	r3, [r3, #4]
 800c9f6:	4618      	mov	r0, r3
 800c9f8:	f002 fa7e 	bl	800eef8 <wolfSSL_Malloc>
 800c9fc:	6138      	str	r0, [r7, #16]
                              DYNAMIC_TYPE_PUBLIC_KEY);
        if (ptr == NULL)
 800c9fe:	693b      	ldr	r3, [r7, #16]
 800ca00:	2b00      	cmp	r3, #0
 800ca02:	d102      	bne.n	800ca0a <ParseCert+0xb6>
            return MEMORY_E;
 800ca04:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800ca08:	e00e      	b.n	800ca28 <ParseCert+0xd4>
        XMEMCPY(ptr, cert->publicKey, cert->pubKeySize);
 800ca0a:	68fb      	ldr	r3, [r7, #12]
 800ca0c:	6819      	ldr	r1, [r3, #0]
 800ca0e:	68fb      	ldr	r3, [r7, #12]
 800ca10:	685b      	ldr	r3, [r3, #4]
 800ca12:	461a      	mov	r2, r3
 800ca14:	6938      	ldr	r0, [r7, #16]
 800ca16:	f00c fcee 	bl	80193f6 <memcpy>
        cert->publicKey = (byte *)ptr;
 800ca1a:	68fb      	ldr	r3, [r7, #12]
 800ca1c:	693a      	ldr	r2, [r7, #16]
 800ca1e:	601a      	str	r2, [r3, #0]
        cert->pubKeyStored = 1;
 800ca20:	68fb      	ldr	r3, [r7, #12]
 800ca22:	2201      	movs	r2, #1
 800ca24:	609a      	str	r2, [r3, #8]
    }

    return ret;
 800ca26:	697b      	ldr	r3, [r7, #20]
}
 800ca28:	4618      	mov	r0, r3
 800ca2a:	3718      	adds	r7, #24
 800ca2c:	46bd      	mov	sp, r7
 800ca2e:	bd80      	pop	{r7, pc}

0800ca30 <ParseCertRelative>:
}
#endif /* WOLFSSL_SMALL_CERT_VERIFY */
#endif /* WOLFSSL_SMALL_CERT_VERIFY || OPENSSL_EXTRA */

int ParseCertRelative(DecodedCert* cert, int type, int verify, void* cm)
{
 800ca30:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ca32:	b093      	sub	sp, #76	; 0x4c
 800ca34:	af06      	add	r7, sp, #24
 800ca36:	6178      	str	r0, [r7, #20]
 800ca38:	6139      	str	r1, [r7, #16]
 800ca3a:	60fa      	str	r2, [r7, #12]
 800ca3c:	60bb      	str	r3, [r7, #8]
    int    ret = 0;
 800ca3e:	2300      	movs	r3, #0
 800ca40:	62fb      	str	r3, [r7, #44]	; 0x2c
    int    checkPathLen = 0;
 800ca42:	2300      	movs	r3, #0
 800ca44:	62bb      	str	r3, [r7, #40]	; 0x28
    int    decrementMaxPathLen = 0;
 800ca46:	2300      	movs	r3, #0
 800ca48:	627b      	str	r3, [r7, #36]	; 0x24
    word32 confirmOID = 0;
 800ca4a:	2300      	movs	r3, #0
 800ca4c:	61fb      	str	r3, [r7, #28]
    byte*  tsip_encRsaKeyIdx;
#ifdef WOLFSSL_CERT_REQ
    int    len = 0;
#endif

    if (cert == NULL) {
 800ca4e:	697b      	ldr	r3, [r7, #20]
 800ca50:	2b00      	cmp	r3, #0
 800ca52:	d102      	bne.n	800ca5a <ParseCertRelative+0x2a>
        return BAD_FUNC_ARG;
 800ca54:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800ca58:	e25b      	b.n	800cf12 <ParseCertRelative+0x4e2>
#ifdef WOLFSSL_CERT_REQ
    if (type == CERTREQ_TYPE)
        cert->isCSR = 1;
#endif

    if (cert->sigCtx.state == SIG_STATE_BEGIN) {
 800ca5a:	697b      	ldr	r3, [r7, #20]
 800ca5c:	f8d3 3360 	ldr.w	r3, [r3, #864]	; 0x360
 800ca60:	2b00      	cmp	r3, #0
 800ca62:	f040 81d5 	bne.w	800ce10 <ParseCertRelative+0x3e0>
        cert->badDate = 0;
 800ca66:	697b      	ldr	r3, [r7, #20]
 800ca68:	2200      	movs	r2, #0
 800ca6a:	f8c3 2370 	str.w	r2, [r3, #880]	; 0x370
        cert->criticalExt = 0;
 800ca6e:	697b      	ldr	r3, [r7, #20]
 800ca70:	2200      	movs	r2, #0
 800ca72:	f8c3 2374 	str.w	r2, [r3, #884]	; 0x374
        if ((ret = DecodeToKey(cert, verify)) < 0) {
 800ca76:	68f9      	ldr	r1, [r7, #12]
 800ca78:	6978      	ldr	r0, [r7, #20]
 800ca7a:	f7fe f815 	bl	800aaa8 <DecodeToKey>
 800ca7e:	62f8      	str	r0, [r7, #44]	; 0x2c
 800ca80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ca82:	2b00      	cmp	r3, #0
 800ca84:	da0e      	bge.n	800caa4 <ParseCertRelative+0x74>
            if (ret == ASN_BEFORE_DATE_E || ret == ASN_AFTER_DATE_E)
 800ca86:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ca88:	f113 0f96 	cmn.w	r3, #150	; 0x96
 800ca8c:	d003      	beq.n	800ca96 <ParseCertRelative+0x66>
 800ca8e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ca90:	f113 0f97 	cmn.w	r3, #151	; 0x97
 800ca94:	d104      	bne.n	800caa0 <ParseCertRelative+0x70>
                cert->badDate = ret;
 800ca96:	697b      	ldr	r3, [r7, #20]
 800ca98:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800ca9a:	f8c3 2370 	str.w	r2, [r3, #880]	; 0x370
 800ca9e:	e001      	b.n	800caa4 <ParseCertRelative+0x74>
            else
                return ret;
 800caa0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800caa2:	e236      	b.n	800cf12 <ParseCertRelative+0x4e2>
                }
            }
        }
#endif

        if (cert->srcIdx < cert->sigIndex) {
 800caa4:	697b      	ldr	r3, [r7, #20]
 800caa6:	f8d3 2290 	ldr.w	r2, [r3, #656]	; 0x290
 800caaa:	697b      	ldr	r3, [r7, #20]
 800caac:	691b      	ldr	r3, [r3, #16]
 800caae:	429a      	cmp	r2, r3
 800cab0:	d237      	bcs.n	800cb22 <ParseCertRelative+0xf2>
        #ifndef ALLOW_V1_EXTENSIONS
            if (cert->version < 2) {
 800cab2:	697b      	ldr	r3, [r7, #20]
 800cab4:	6a1b      	ldr	r3, [r3, #32]
 800cab6:	2b01      	cmp	r3, #1
 800cab8:	dc02      	bgt.n	800cac0 <ParseCertRelative+0x90>
                WOLFSSL_MSG("\tv1 and v2 certs not allowed extensions");
                return ASN_VERSION_E;
 800caba:	f06f 038c 	mvn.w	r3, #140	; 0x8c
 800cabe:	e228      	b.n	800cf12 <ParseCertRelative+0x4e2>
            }
        #endif

            /* save extensions */
            cert->extensions    = &cert->source[cert->srcIdx];
 800cac0:	697b      	ldr	r3, [r7, #20]
 800cac2:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 800cac6:	697b      	ldr	r3, [r7, #20]
 800cac8:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800cacc:	441a      	add	r2, r3
 800cace:	697b      	ldr	r3, [r7, #20]
 800cad0:	f8c3 22c0 	str.w	r2, [r3, #704]	; 0x2c0
            cert->extensionsSz  = cert->sigIndex - cert->srcIdx;
 800cad4:	697b      	ldr	r3, [r7, #20]
 800cad6:	691a      	ldr	r2, [r3, #16]
 800cad8:	697b      	ldr	r3, [r7, #20]
 800cada:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
 800cade:	1ad3      	subs	r3, r2, r3
 800cae0:	461a      	mov	r2, r3
 800cae2:	697b      	ldr	r3, [r7, #20]
 800cae4:	f8c3 22c4 	str.w	r2, [r3, #708]	; 0x2c4
            cert->extensionsIdx = cert->srcIdx;   /* for potential later use */
 800cae8:	697b      	ldr	r3, [r7, #20]
 800caea:	f8d3 2290 	ldr.w	r2, [r3, #656]	; 0x290
 800caee:	697b      	ldr	r3, [r7, #20]
 800caf0:	f8c3 22c8 	str.w	r2, [r3, #712]	; 0x2c8

            if ((ret = DecodeCertExtensions(cert)) < 0) {
 800caf4:	6978      	ldr	r0, [r7, #20]
 800caf6:	f7ff fcb0 	bl	800c45a <DecodeCertExtensions>
 800cafa:	62f8      	str	r0, [r7, #44]	; 0x2c
 800cafc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cafe:	2b00      	cmp	r3, #0
 800cb00:	da0a      	bge.n	800cb18 <ParseCertRelative+0xe8>
                if (ret == ASN_CRIT_EXT_E)
 800cb02:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cb04:	f113 0fa0 	cmn.w	r3, #160	; 0xa0
 800cb08:	d104      	bne.n	800cb14 <ParseCertRelative+0xe4>
                    cert->criticalExt = ret;
 800cb0a:	697b      	ldr	r3, [r7, #20]
 800cb0c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800cb0e:	f8c3 2374 	str.w	r2, [r3, #884]	; 0x374
 800cb12:	e001      	b.n	800cb18 <ParseCertRelative+0xe8>
                else
                    return ret;
 800cb14:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cb16:	e1fc      	b.n	800cf12 <ParseCertRelative+0x4e2>
            /* trust for the lifetime of the responder's cert*/
            if (cert->ocspNoCheckSet && verify == VERIFY_OCSP)
                verify = NO_VERIFY;
        #endif
            /* advance past extensions */
            cert->srcIdx = cert->sigIndex;
 800cb18:	697b      	ldr	r3, [r7, #20]
 800cb1a:	691a      	ldr	r2, [r3, #16]
 800cb1c:	697b      	ldr	r3, [r7, #20]
 800cb1e:	f8c3 2290 	str.w	r2, [r3, #656]	; 0x290
        }

        if ((ret = GetAlgoId(cert->source, &cert->srcIdx,
 800cb22:	697b      	ldr	r3, [r7, #20]
 800cb24:	f8d3 028c 	ldr.w	r0, [r3, #652]	; 0x28c
 800cb28:	697b      	ldr	r3, [r7, #20]
 800cb2a:	f503 7124 	add.w	r1, r3, #656	; 0x290
 800cb2e:	697b      	ldr	r3, [r7, #20]
 800cb30:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 800cb34:	f107 021c 	add.w	r2, r7, #28
 800cb38:	9300      	str	r3, [sp, #0]
 800cb3a:	2301      	movs	r3, #1
 800cb3c:	f7fc fdd8 	bl	80096f0 <GetAlgoId>
 800cb40:	62f8      	str	r0, [r7, #44]	; 0x2c
 800cb42:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cb44:	2b00      	cmp	r3, #0
 800cb46:	da01      	bge.n	800cb4c <ParseCertRelative+0x11c>
                !cert->isCSR ? &confirmOID : &cert->signatureOID,
#else
                &confirmOID,
#endif
                oidSigType, cert->maxIdx)) < 0)
            return ret;
 800cb48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cb4a:	e1e2      	b.n	800cf12 <ParseCertRelative+0x4e2>

        if ((ret = GetSignature(cert)) < 0)
 800cb4c:	6978      	ldr	r0, [r7, #20]
 800cb4e:	f7fd ffe8 	bl	800ab22 <GetSignature>
 800cb52:	62f8      	str	r0, [r7, #44]	; 0x2c
 800cb54:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cb56:	2b00      	cmp	r3, #0
 800cb58:	da01      	bge.n	800cb5e <ParseCertRelative+0x12e>
            return ret;
 800cb5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cb5c:	e1d9      	b.n	800cf12 <ParseCertRelative+0x4e2>

        if (confirmOID != cert->signatureOID
 800cb5e:	697b      	ldr	r3, [r7, #20]
 800cb60:	699a      	ldr	r2, [r3, #24]
 800cb62:	69fb      	ldr	r3, [r7, #28]
 800cb64:	429a      	cmp	r2, r3
 800cb66:	d002      	beq.n	800cb6e <ParseCertRelative+0x13e>
#ifdef WOLFSSL_CERT_REQ
                && !cert->isCSR
#endif
                )
            return ASN_SIG_OID_E;
 800cb68:	f06f 0397 	mvn.w	r3, #151	; 0x97
 800cb6c:	e1d1      	b.n	800cf12 <ParseCertRelative+0x4e2>

    #ifndef NO_SKID
        if (cert->extSubjKeyIdSet == 0 && cert->publicKey != NULL &&
 800cb6e:	697b      	ldr	r3, [r7, #20]
 800cb70:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 800cb74:	f003 0302 	and.w	r3, r3, #2
 800cb78:	b2db      	uxtb	r3, r3
 800cb7a:	2b00      	cmp	r3, #0
 800cb7c:	d117      	bne.n	800cbae <ParseCertRelative+0x17e>
 800cb7e:	697b      	ldr	r3, [r7, #20]
 800cb80:	681b      	ldr	r3, [r3, #0]
 800cb82:	2b00      	cmp	r3, #0
 800cb84:	d013      	beq.n	800cbae <ParseCertRelative+0x17e>
                                                         cert->pubKeySize > 0) {
 800cb86:	697b      	ldr	r3, [r7, #20]
 800cb88:	685b      	ldr	r3, [r3, #4]
        if (cert->extSubjKeyIdSet == 0 && cert->publicKey != NULL &&
 800cb8a:	2b00      	cmp	r3, #0
 800cb8c:	d00f      	beq.n	800cbae <ParseCertRelative+0x17e>
            ret = CalcHashId(cert->publicKey, cert->pubKeySize,
 800cb8e:	697b      	ldr	r3, [r7, #20]
 800cb90:	6818      	ldr	r0, [r3, #0]
 800cb92:	697b      	ldr	r3, [r7, #20]
 800cb94:	6859      	ldr	r1, [r3, #4]
                                                            cert->extSubjKeyId);
 800cb96:	697b      	ldr	r3, [r7, #20]
 800cb98:	f503 7337 	add.w	r3, r3, #732	; 0x2dc
            ret = CalcHashId(cert->publicKey, cert->pubKeySize,
 800cb9c:	461a      	mov	r2, r3
 800cb9e:	f7fd fb7a 	bl	800a296 <CalcHashId>
 800cba2:	62f8      	str	r0, [r7, #44]	; 0x2c
            if (ret != 0)
 800cba4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cba6:	2b00      	cmp	r3, #0
 800cba8:	d001      	beq.n	800cbae <ParseCertRelative+0x17e>
                return ret;
 800cbaa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cbac:	e1b1      	b.n	800cf12 <ParseCertRelative+0x4e2>
        }
    #endif /* !NO_SKID */

        if (!cert->selfSigned || (verify != NO_VERIFY && type != CA_TYPE &&
 800cbae:	697b      	ldr	r3, [r7, #20]
 800cbb0:	f893 3379 	ldrb.w	r3, [r3, #889]	; 0x379
 800cbb4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800cbb8:	b2db      	uxtb	r3, r3
 800cbba:	2b00      	cmp	r3, #0
 800cbbc:	d008      	beq.n	800cbd0 <ParseCertRelative+0x1a0>
 800cbbe:	68fb      	ldr	r3, [r7, #12]
 800cbc0:	2b00      	cmp	r3, #0
 800cbc2:	d06e      	beq.n	800cca2 <ParseCertRelative+0x272>
 800cbc4:	693b      	ldr	r3, [r7, #16]
 800cbc6:	2b05      	cmp	r3, #5
 800cbc8:	d06b      	beq.n	800cca2 <ParseCertRelative+0x272>
 800cbca:	693b      	ldr	r3, [r7, #16]
 800cbcc:	2b0f      	cmp	r3, #15
 800cbce:	d068      	beq.n	800cca2 <ParseCertRelative+0x272>
                                                   type != TRUSTED_PEER_TYPE)) {
            cert->ca = NULL;
 800cbd0:	697b      	ldr	r3, [r7, #20]
 800cbd2:	2200      	movs	r2, #0
 800cbd4:	f8c3 2340 	str.w	r2, [r3, #832]	; 0x340
    #ifndef NO_SKID
            if (cert->extAuthKeyIdSet) {
 800cbd8:	697b      	ldr	r3, [r7, #20]
 800cbda:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 800cbde:	f003 0304 	and.w	r3, r3, #4
 800cbe2:	b2db      	uxtb	r3, r3
 800cbe4:	2b00      	cmp	r3, #0
 800cbe6:	d00a      	beq.n	800cbfe <ParseCertRelative+0x1ce>
                cert->ca = GetCA(cm, cert->extAuthKeyId);
 800cbe8:	697b      	ldr	r3, [r7, #20]
 800cbea:	f503 733f 	add.w	r3, r3, #764	; 0x2fc
 800cbee:	4619      	mov	r1, r3
 800cbf0:	68b8      	ldr	r0, [r7, #8]
 800cbf2:	f7fa fa24 	bl	800703e <GetCA>
 800cbf6:	4602      	mov	r2, r0
 800cbf8:	697b      	ldr	r3, [r7, #20]
 800cbfa:	f8c3 2340 	str.w	r2, [r3, #832]	; 0x340
            }
            if (cert->ca == NULL && cert->extSubjKeyIdSet
 800cbfe:	697b      	ldr	r3, [r7, #20]
 800cc00:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
 800cc04:	2b00      	cmp	r3, #0
 800cc06:	d115      	bne.n	800cc34 <ParseCertRelative+0x204>
 800cc08:	697b      	ldr	r3, [r7, #20]
 800cc0a:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 800cc0e:	f003 0302 	and.w	r3, r3, #2
 800cc12:	b2db      	uxtb	r3, r3
 800cc14:	2b00      	cmp	r3, #0
 800cc16:	d00d      	beq.n	800cc34 <ParseCertRelative+0x204>
                                 && verify != VERIFY_OCSP) {
 800cc18:	68fb      	ldr	r3, [r7, #12]
 800cc1a:	2b03      	cmp	r3, #3
 800cc1c:	d00a      	beq.n	800cc34 <ParseCertRelative+0x204>
                cert->ca = GetCA(cm, cert->extSubjKeyId);
 800cc1e:	697b      	ldr	r3, [r7, #20]
 800cc20:	f503 7337 	add.w	r3, r3, #732	; 0x2dc
 800cc24:	4619      	mov	r1, r3
 800cc26:	68b8      	ldr	r0, [r7, #8]
 800cc28:	f7fa fa09 	bl	800703e <GetCA>
 800cc2c:	4602      	mov	r2, r0
 800cc2e:	697b      	ldr	r3, [r7, #20]
 800cc30:	f8c3 2340 	str.w	r2, [r3, #832]	; 0x340
            }
            if (cert->ca != NULL && XMEMCMP(cert->issuerHash,
 800cc34:	697b      	ldr	r3, [r7, #20]
 800cc36:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
 800cc3a:	2b00      	cmp	r3, #0
 800cc3c:	d011      	beq.n	800cc62 <ParseCertRelative+0x232>
 800cc3e:	697b      	ldr	r3, [r7, #20]
 800cc40:	f103 0058 	add.w	r0, r3, #88	; 0x58
 800cc44:	697b      	ldr	r3, [r7, #20]
 800cc46:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
 800cc4a:	3324      	adds	r3, #36	; 0x24
 800cc4c:	2220      	movs	r2, #32
 800cc4e:	4619      	mov	r1, r3
 800cc50:	f00c fbc2 	bl	80193d8 <memcmp>
 800cc54:	4603      	mov	r3, r0
 800cc56:	2b00      	cmp	r3, #0
 800cc58:	d003      	beq.n	800cc62 <ParseCertRelative+0x232>
                                  cert->ca->subjectNameHash, KEYID_SIZE) != 0) {
                cert->ca = NULL;
 800cc5a:	697b      	ldr	r3, [r7, #20]
 800cc5c:	2200      	movs	r2, #0
 800cc5e:	f8c3 2340 	str.w	r2, [r3, #832]	; 0x340
            }
            if (cert->ca == NULL) {
 800cc62:	697b      	ldr	r3, [r7, #20]
 800cc64:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
 800cc68:	2b00      	cmp	r3, #0
 800cc6a:	d11a      	bne.n	800cca2 <ParseCertRelative+0x272>
                cert->ca = GetCAByName(cm, cert->issuerHash);
 800cc6c:	697b      	ldr	r3, [r7, #20]
 800cc6e:	3358      	adds	r3, #88	; 0x58
 800cc70:	4619      	mov	r1, r3
 800cc72:	68b8      	ldr	r0, [r7, #8]
 800cc74:	f7fa fa28 	bl	80070c8 <GetCAByName>
 800cc78:	4602      	mov	r2, r0
 800cc7a:	697b      	ldr	r3, [r7, #20]
 800cc7c:	f8c3 2340 	str.w	r2, [r3, #832]	; 0x340
                /* If AKID is available then this CA doesn't have the public
                 * key required */
                if (cert->ca && cert->extAuthKeyIdSet) {
 800cc80:	697b      	ldr	r3, [r7, #20]
 800cc82:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
 800cc86:	2b00      	cmp	r3, #0
 800cc88:	d00b      	beq.n	800cca2 <ParseCertRelative+0x272>
 800cc8a:	697b      	ldr	r3, [r7, #20]
 800cc8c:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 800cc90:	f003 0304 	and.w	r3, r3, #4
 800cc94:	b2db      	uxtb	r3, r3
 800cc96:	2b00      	cmp	r3, #0
 800cc98:	d003      	beq.n	800cca2 <ParseCertRelative+0x272>
                    WOLFSSL_MSG("CA SKID doesn't match AKID");
                    cert->ca = NULL;
 800cc9a:	697b      	ldr	r3, [r7, #20]
 800cc9c:	2200      	movs	r2, #0
 800cc9e:	f8c3 2340 	str.w	r2, [r3, #832]	; 0x340
            if (cert->ca) {
                WOLFSSL_MSG("CA found");
            }
        }

        if (cert->selfSigned) {
 800cca2:	697b      	ldr	r3, [r7, #20]
 800cca4:	f893 3379 	ldrb.w	r3, [r3, #889]	; 0x379
 800cca8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ccac:	b2db      	uxtb	r3, r3
 800ccae:	2b00      	cmp	r3, #0
 800ccb0:	d004      	beq.n	800ccbc <ParseCertRelative+0x28c>
            cert->maxPathLen = WOLFSSL_MAX_PATH_LEN;
 800ccb2:	697b      	ldr	r3, [r7, #20]
 800ccb4:	227f      	movs	r2, #127	; 0x7f
 800ccb6:	f883 231d 	strb.w	r2, [r3, #797]	; 0x31d
 800ccba:	e0a9      	b.n	800ce10 <ParseCertRelative+0x3e0>
             * 4) Is maxPathLen > 0?
             *      Yes - Reduce by 1
             *      No  - ERROR
             */

            if (cert->ca && cert->pathLengthSet) {
 800ccbc:	697b      	ldr	r3, [r7, #20]
 800ccbe:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
 800ccc2:	2b00      	cmp	r3, #0
 800ccc4:	d076      	beq.n	800cdb4 <ParseCertRelative+0x384>
 800ccc6:	697b      	ldr	r3, [r7, #20]
 800ccc8:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 800cccc:	f003 0320 	and.w	r3, r3, #32
 800ccd0:	b2db      	uxtb	r3, r3
 800ccd2:	2b00      	cmp	r3, #0
 800ccd4:	d06e      	beq.n	800cdb4 <ParseCertRelative+0x384>
                cert->maxPathLen = cert->pathLength;
 800ccd6:	697b      	ldr	r3, [r7, #20]
 800ccd8:	f893 231c 	ldrb.w	r2, [r3, #796]	; 0x31c
 800ccdc:	697b      	ldr	r3, [r7, #20]
 800ccde:	f883 231d 	strb.w	r2, [r3, #797]	; 0x31d
                if (cert->isCA) {
 800cce2:	697b      	ldr	r3, [r7, #20]
 800cce4:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 800cce8:	f003 0310 	and.w	r3, r3, #16
 800ccec:	b2db      	uxtb	r3, r3
 800ccee:	2b00      	cmp	r3, #0
 800ccf0:	d016      	beq.n	800cd20 <ParseCertRelative+0x2f0>
                    WOLFSSL_MSG("\tCA boolean set");
                    if (cert->extKeyUsageSet) {
 800ccf2:	697b      	ldr	r3, [r7, #20]
 800ccf4:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 800ccf8:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800ccfc:	b2db      	uxtb	r3, r3
 800ccfe:	2b00      	cmp	r3, #0
 800cd00:	d00c      	beq.n	800cd1c <ParseCertRelative+0x2ec>
                         WOLFSSL_MSG("\tExtension Key Usage Set");
                         if ((cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) != 0) {
 800cd02:	697b      	ldr	r3, [r7, #20]
 800cd04:	f8b3 331e 	ldrh.w	r3, [r3, #798]	; 0x31e
 800cd08:	f003 0304 	and.w	r3, r3, #4
 800cd0c:	2b00      	cmp	r3, #0
 800cd0e:	d002      	beq.n	800cd16 <ParseCertRelative+0x2e6>
                            checkPathLen = 1;
 800cd10:	2301      	movs	r3, #1
 800cd12:	62bb      	str	r3, [r7, #40]	; 0x28
 800cd14:	e004      	b.n	800cd20 <ParseCertRelative+0x2f0>
                         } else {
                            decrementMaxPathLen = 1;
 800cd16:	2301      	movs	r3, #1
 800cd18:	627b      	str	r3, [r7, #36]	; 0x24
 800cd1a:	e001      	b.n	800cd20 <ParseCertRelative+0x2f0>
                         }
                    } else {
                        checkPathLen = 1;
 800cd1c:	2301      	movs	r3, #1
 800cd1e:	62bb      	str	r3, [r7, #40]	; 0x28
                    } /* !cert->ca check */
                } /* cert is not a CA (assuming entity cert) */

                if (checkPathLen && cert->pathLengthSet) {
 800cd20:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cd22:	2b00      	cmp	r3, #0
 800cd24:	d019      	beq.n	800cd5a <ParseCertRelative+0x32a>
 800cd26:	697b      	ldr	r3, [r7, #20]
 800cd28:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 800cd2c:	f003 0320 	and.w	r3, r3, #32
 800cd30:	b2db      	uxtb	r3, r3
 800cd32:	2b00      	cmp	r3, #0
 800cd34:	d011      	beq.n	800cd5a <ParseCertRelative+0x32a>
                    if (cert->pathLength < cert->ca->maxPathLen) {
 800cd36:	697b      	ldr	r3, [r7, #20]
 800cd38:	f893 231c 	ldrb.w	r2, [r3, #796]	; 0x31c
 800cd3c:	697b      	ldr	r3, [r7, #20]
 800cd3e:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
 800cd42:	7a9b      	ldrb	r3, [r3, #10]
 800cd44:	429a      	cmp	r2, r3
 800cd46:	d206      	bcs.n	800cd56 <ParseCertRelative+0x326>
                        WOLFSSL_MSG("\tmaxPathLen status: set to pathLength");
                        cert->maxPathLen = cert->pathLength;
 800cd48:	697b      	ldr	r3, [r7, #20]
 800cd4a:	f893 231c 	ldrb.w	r2, [r3, #796]	; 0x31c
 800cd4e:	697b      	ldr	r3, [r7, #20]
 800cd50:	f883 231d 	strb.w	r2, [r3, #797]	; 0x31d
 800cd54:	e001      	b.n	800cd5a <ParseCertRelative+0x32a>
                    } else {
                        decrementMaxPathLen = 1;
 800cd56:	2301      	movs	r3, #1
 800cd58:	627b      	str	r3, [r7, #36]	; 0x24
                    }
                }

                if (decrementMaxPathLen && cert->ca->maxPathLen > 0) {
 800cd5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cd5c:	2b00      	cmp	r3, #0
 800cd5e:	d010      	beq.n	800cd82 <ParseCertRelative+0x352>
 800cd60:	697b      	ldr	r3, [r7, #20]
 800cd62:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
 800cd66:	7a9b      	ldrb	r3, [r3, #10]
 800cd68:	2b00      	cmp	r3, #0
 800cd6a:	d00a      	beq.n	800cd82 <ParseCertRelative+0x352>
                    WOLFSSL_MSG("\tmaxPathLen status: reduce by 1");
                    cert->maxPathLen = cert->ca->maxPathLen - 1;
 800cd6c:	697b      	ldr	r3, [r7, #20]
 800cd6e:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
 800cd72:	7a9b      	ldrb	r3, [r3, #10]
 800cd74:	3b01      	subs	r3, #1
 800cd76:	b2da      	uxtb	r2, r3
 800cd78:	697b      	ldr	r3, [r7, #20]
 800cd7a:	f883 231d 	strb.w	r2, [r3, #797]	; 0x31d
                    if (verify != NO_VERIFY && type != CA_TYPE &&
 800cd7e:	bf00      	nop
                if (decrementMaxPathLen && cert->ca->maxPathLen > 0) {
 800cd80:	e045      	b.n	800ce0e <ParseCertRelative+0x3de>
                                                    type != TRUSTED_PEER_TYPE) {
                        WOLFSSL_MSG("\tmaxPathLen status: OK");
                    }
                } else if (decrementMaxPathLen && cert->ca->maxPathLen == 0) {
 800cd82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cd84:	2b00      	cmp	r3, #0
 800cd86:	d042      	beq.n	800ce0e <ParseCertRelative+0x3de>
 800cd88:	697b      	ldr	r3, [r7, #20]
 800cd8a:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
 800cd8e:	7a9b      	ldrb	r3, [r3, #10]
 800cd90:	2b00      	cmp	r3, #0
 800cd92:	d13c      	bne.n	800ce0e <ParseCertRelative+0x3de>
                    cert->maxPathLen = 0;
 800cd94:	697b      	ldr	r3, [r7, #20]
 800cd96:	2200      	movs	r2, #0
 800cd98:	f883 231d 	strb.w	r2, [r3, #797]	; 0x31d
                    if (verify != NO_VERIFY && type != CA_TYPE &&
 800cd9c:	68fb      	ldr	r3, [r7, #12]
 800cd9e:	2b00      	cmp	r3, #0
 800cda0:	d035      	beq.n	800ce0e <ParseCertRelative+0x3de>
 800cda2:	693b      	ldr	r3, [r7, #16]
 800cda4:	2b05      	cmp	r3, #5
 800cda6:	d032      	beq.n	800ce0e <ParseCertRelative+0x3de>
 800cda8:	693b      	ldr	r3, [r7, #16]
 800cdaa:	2b0f      	cmp	r3, #15
 800cdac:	d02f      	beq.n	800ce0e <ParseCertRelative+0x3de>
                                                    type != TRUSTED_PEER_TYPE) {
                        WOLFSSL_MSG("\tNon-entity cert, maxPathLen is 0");
                        WOLFSSL_MSG("\tmaxPathLen status: ERROR");
                        return ASN_PATHLEN_INV_E;
 800cdae:	f06f 03ed 	mvn.w	r3, #237	; 0xed
 800cdb2:	e0ae      	b.n	800cf12 <ParseCertRelative+0x4e2>
                    }
                }
            } else if (cert->ca && cert->isCA) {
 800cdb4:	697b      	ldr	r3, [r7, #20]
 800cdb6:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
 800cdba:	2b00      	cmp	r3, #0
 800cdbc:	d028      	beq.n	800ce10 <ParseCertRelative+0x3e0>
 800cdbe:	697b      	ldr	r3, [r7, #20]
 800cdc0:	f893 3378 	ldrb.w	r3, [r3, #888]	; 0x378
 800cdc4:	f003 0310 	and.w	r3, r3, #16
 800cdc8:	b2db      	uxtb	r3, r3
 800cdca:	2b00      	cmp	r3, #0
 800cdcc:	d020      	beq.n	800ce10 <ParseCertRelative+0x3e0>
                /* case where cert->pathLength extension is not set */
                if (cert->ca->maxPathLen > 0) {
 800cdce:	697b      	ldr	r3, [r7, #20]
 800cdd0:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
 800cdd4:	7a9b      	ldrb	r3, [r3, #10]
 800cdd6:	2b00      	cmp	r3, #0
 800cdd8:	d009      	beq.n	800cdee <ParseCertRelative+0x3be>
                    cert->maxPathLen = cert->ca->maxPathLen - 1;
 800cdda:	697b      	ldr	r3, [r7, #20]
 800cddc:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
 800cde0:	7a9b      	ldrb	r3, [r3, #10]
 800cde2:	3b01      	subs	r3, #1
 800cde4:	b2da      	uxtb	r2, r3
 800cde6:	697b      	ldr	r3, [r7, #20]
 800cde8:	f883 231d 	strb.w	r2, [r3, #797]	; 0x31d
 800cdec:	e010      	b.n	800ce10 <ParseCertRelative+0x3e0>
                } else {
                    cert->maxPathLen = 0;
 800cdee:	697b      	ldr	r3, [r7, #20]
 800cdf0:	2200      	movs	r2, #0
 800cdf2:	f883 231d 	strb.w	r2, [r3, #797]	; 0x31d
                    if (verify != NO_VERIFY && type != CA_TYPE &&
 800cdf6:	68fb      	ldr	r3, [r7, #12]
 800cdf8:	2b00      	cmp	r3, #0
 800cdfa:	d009      	beq.n	800ce10 <ParseCertRelative+0x3e0>
 800cdfc:	693b      	ldr	r3, [r7, #16]
 800cdfe:	2b05      	cmp	r3, #5
 800ce00:	d006      	beq.n	800ce10 <ParseCertRelative+0x3e0>
 800ce02:	693b      	ldr	r3, [r7, #16]
 800ce04:	2b0f      	cmp	r3, #15
 800ce06:	d003      	beq.n	800ce10 <ParseCertRelative+0x3e0>
                                                    type != TRUSTED_PEER_TYPE) {
                        WOLFSSL_MSG("\tNon-entity cert, maxPathLen is 0");
                        WOLFSSL_MSG("\tmaxPathLen status: ERROR");
                        return ASN_PATHLEN_INV_E;
 800ce08:	f06f 03ed 	mvn.w	r3, #237	; 0xed
 800ce0c:	e081      	b.n	800cf12 <ParseCertRelative+0x4e2>
                if (decrementMaxPathLen && cert->ca->maxPathLen > 0) {
 800ce0e:	bf00      	nop
        cert->tsip_encRsaKeyIdx = NULL;
    }

    tsip_encRsaKeyIdx = cert->tsip_encRsaKeyIdx;
#else
    tsip_encRsaKeyIdx = NULL;
 800ce10:	2300      	movs	r3, #0
 800ce12:	623b      	str	r3, [r7, #32]
#endif

    if (verify != NO_VERIFY && type != CA_TYPE && type != TRUSTED_PEER_TYPE) {
 800ce14:	68fb      	ldr	r3, [r7, #12]
 800ce16:	2b00      	cmp	r3, #0
 800ce18:	d065      	beq.n	800cee6 <ParseCertRelative+0x4b6>
 800ce1a:	693b      	ldr	r3, [r7, #16]
 800ce1c:	2b05      	cmp	r3, #5
 800ce1e:	d062      	beq.n	800cee6 <ParseCertRelative+0x4b6>
 800ce20:	693b      	ldr	r3, [r7, #16]
 800ce22:	2b0f      	cmp	r3, #15
 800ce24:	d05f      	beq.n	800cee6 <ParseCertRelative+0x4b6>
        if (cert->ca) {
 800ce26:	697b      	ldr	r3, [r7, #20]
 800ce28:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
 800ce2c:	2b00      	cmp	r3, #0
 800ce2e:	d057      	beq.n	800cee0 <ParseCertRelative+0x4b0>
            if (verify == VERIFY || verify == VERIFY_OCSP ||
 800ce30:	68fb      	ldr	r3, [r7, #12]
 800ce32:	2b01      	cmp	r3, #1
 800ce34:	d005      	beq.n	800ce42 <ParseCertRelative+0x412>
 800ce36:	68fb      	ldr	r3, [r7, #12]
 800ce38:	2b03      	cmp	r3, #3
 800ce3a:	d002      	beq.n	800ce42 <ParseCertRelative+0x412>
 800ce3c:	68fb      	ldr	r3, [r7, #12]
 800ce3e:	2b05      	cmp	r3, #5
 800ce40:	d135      	bne.n	800ceae <ParseCertRelative+0x47e>
                                                 verify == VERIFY_SKIP_DATE) {
                /* try to confirm/verify signature */
                if ((ret = ConfirmSignature(&cert->sigCtx,
 800ce42:	697b      	ldr	r3, [r7, #20]
 800ce44:	f503 7651 	add.w	r6, r3, #836	; 0x344
                        cert->source + cert->certBegin,
 800ce48:	697b      	ldr	r3, [r7, #20]
 800ce4a:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 800ce4e:	697b      	ldr	r3, [r7, #20]
 800ce50:	68db      	ldr	r3, [r3, #12]
                if ((ret = ConfirmSignature(&cert->sigCtx,
 800ce52:	eb02 0c03 	add.w	ip, r2, r3
                        cert->sigIndex - cert->certBegin,
 800ce56:	697b      	ldr	r3, [r7, #20]
 800ce58:	691a      	ldr	r2, [r3, #16]
 800ce5a:	697b      	ldr	r3, [r7, #20]
 800ce5c:	68db      	ldr	r3, [r3, #12]
                if ((ret = ConfirmSignature(&cert->sigCtx,
 800ce5e:	eba2 0e03 	sub.w	lr, r2, r3
                        cert->ca->publicKey, cert->ca->pubKeySize,
 800ce62:	697b      	ldr	r3, [r7, #20]
 800ce64:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
                if ((ret = ConfirmSignature(&cert->sigCtx,
 800ce68:	691b      	ldr	r3, [r3, #16]
 800ce6a:	607b      	str	r3, [r7, #4]
                        cert->ca->publicKey, cert->ca->pubKeySize,
 800ce6c:	697b      	ldr	r3, [r7, #20]
 800ce6e:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
                if ((ret = ConfirmSignature(&cert->sigCtx,
 800ce72:	681b      	ldr	r3, [r3, #0]
                        cert->ca->keyOID, cert->signature,
 800ce74:	697a      	ldr	r2, [r7, #20]
 800ce76:	f8d2 2340 	ldr.w	r2, [r2, #832]	; 0x340
                if ((ret = ConfirmSignature(&cert->sigCtx,
 800ce7a:	6852      	ldr	r2, [r2, #4]
 800ce7c:	6979      	ldr	r1, [r7, #20]
 800ce7e:	6f89      	ldr	r1, [r1, #120]	; 0x78
 800ce80:	6978      	ldr	r0, [r7, #20]
 800ce82:	6940      	ldr	r0, [r0, #20]
 800ce84:	697c      	ldr	r4, [r7, #20]
 800ce86:	69a4      	ldr	r4, [r4, #24]
 800ce88:	6a3d      	ldr	r5, [r7, #32]
 800ce8a:	9505      	str	r5, [sp, #20]
 800ce8c:	9404      	str	r4, [sp, #16]
 800ce8e:	9003      	str	r0, [sp, #12]
 800ce90:	9102      	str	r1, [sp, #8]
 800ce92:	9201      	str	r2, [sp, #4]
 800ce94:	9300      	str	r3, [sp, #0]
 800ce96:	687b      	ldr	r3, [r7, #4]
 800ce98:	4672      	mov	r2, lr
 800ce9a:	4661      	mov	r1, ip
 800ce9c:	4630      	mov	r0, r6
 800ce9e:	f7fe f901 	bl	800b0a4 <ConfirmSignature>
 800cea2:	62f8      	str	r0, [r7, #44]	; 0x2c
 800cea4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cea6:	2b00      	cmp	r3, #0
 800cea8:	d001      	beq.n	800ceae <ParseCertRelative+0x47e>
                        cert->sigLength, cert->signatureOID,
                        tsip_encRsaKeyIdx)) != 0) {
                    if (ret != 0 && ret != WC_PENDING_E) {
                        WOLFSSL_MSG("Confirm signature failed");
                    }
                    return ret;
 800ceaa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ceac:	e031      	b.n	800cf12 <ParseCertRelative+0x4e2>
                }
            }
        #ifndef IGNORE_NAME_CONSTRAINTS
            if (verify == VERIFY || verify == VERIFY_OCSP ||
 800ceae:	68fb      	ldr	r3, [r7, #12]
 800ceb0:	2b01      	cmp	r3, #1
 800ceb2:	d008      	beq.n	800cec6 <ParseCertRelative+0x496>
 800ceb4:	68fb      	ldr	r3, [r7, #12]
 800ceb6:	2b03      	cmp	r3, #3
 800ceb8:	d005      	beq.n	800cec6 <ParseCertRelative+0x496>
 800ceba:	68fb      	ldr	r3, [r7, #12]
 800cebc:	2b04      	cmp	r3, #4
 800cebe:	d002      	beq.n	800cec6 <ParseCertRelative+0x496>
                        verify == VERIFY_NAME || verify == VERIFY_SKIP_DATE) {
 800cec0:	68fb      	ldr	r3, [r7, #12]
 800cec2:	2b05      	cmp	r3, #5
 800cec4:	d10f      	bne.n	800cee6 <ParseCertRelative+0x4b6>
                /* check that this cert's name is permitted by the signer's
                 * name constraints */
                if (!ConfirmNameConstraints(cert->ca, cert)) {
 800cec6:	697b      	ldr	r3, [r7, #20]
 800cec8:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
 800cecc:	6979      	ldr	r1, [r7, #20]
 800cece:	4618      	mov	r0, r3
 800ced0:	f7fe fb28 	bl	800b524 <ConfirmNameConstraints>
 800ced4:	4603      	mov	r3, r0
 800ced6:	2b00      	cmp	r3, #0
 800ced8:	d105      	bne.n	800cee6 <ParseCertRelative+0x4b6>
                    WOLFSSL_MSG("Confirm name constraint failed");
                    return ASN_NAME_INVALID_E;
 800ceda:	f06f 03c5 	mvn.w	r3, #197	; 0xc5
 800cede:	e018      	b.n	800cf12 <ParseCertRelative+0x4e2>
        #endif /* IGNORE_NAME_CONSTRAINTS */
        }
        else {
            /* no signer */
            WOLFSSL_MSG("No CA signer to verify with");
            return ASN_NO_SIGNER_E;
 800cee0:	f06f 03bb 	mvn.w	r3, #187	; 0xbb
 800cee4:	e015      	b.n	800cf12 <ParseCertRelative+0x4e2>

#if defined(WOLFSSL_NO_TRUSTED_CERTS_VERIFY) && !defined(NO_SKID)
exit_pcr:
#endif

    if (cert->badDate != 0) {
 800cee6:	697b      	ldr	r3, [r7, #20]
 800cee8:	f8d3 3370 	ldr.w	r3, [r3, #880]	; 0x370
 800ceec:	2b00      	cmp	r3, #0
 800ceee:	d006      	beq.n	800cefe <ParseCertRelative+0x4ce>
        if (verify != VERIFY_SKIP_DATE) {
 800cef0:	68fb      	ldr	r3, [r7, #12]
 800cef2:	2b05      	cmp	r3, #5
 800cef4:	d003      	beq.n	800cefe <ParseCertRelative+0x4ce>
            return cert->badDate;
 800cef6:	697b      	ldr	r3, [r7, #20]
 800cef8:	f8d3 3370 	ldr.w	r3, [r3, #880]	; 0x370
 800cefc:	e009      	b.n	800cf12 <ParseCertRelative+0x4e2>
        }
        WOLFSSL_MSG("Date error: Verify option is skipping");
    }

    if (cert->criticalExt != 0)
 800cefe:	697b      	ldr	r3, [r7, #20]
 800cf00:	f8d3 3374 	ldr.w	r3, [r3, #884]	; 0x374
 800cf04:	2b00      	cmp	r3, #0
 800cf06:	d003      	beq.n	800cf10 <ParseCertRelative+0x4e0>
        return cert->criticalExt;
 800cf08:	697b      	ldr	r3, [r7, #20]
 800cf0a:	f8d3 3374 	ldr.w	r3, [r3, #884]	; 0x374
 800cf0e:	e000      	b.n	800cf12 <ParseCertRelative+0x4e2>

    return ret;
 800cf10:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 800cf12:	4618      	mov	r0, r3
 800cf14:	3734      	adds	r7, #52	; 0x34
 800cf16:	46bd      	mov	sp, r7
 800cf18:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800cf1a <MakeSigner>:

/* Create and init an new signer */
Signer* MakeSigner(void* heap)
{
 800cf1a:	b580      	push	{r7, lr}
 800cf1c:	b084      	sub	sp, #16
 800cf1e:	af00      	add	r7, sp, #0
 800cf20:	6078      	str	r0, [r7, #4]
    Signer* signer = (Signer*) XMALLOC(sizeof(Signer), heap,
 800cf22:	2068      	movs	r0, #104	; 0x68
 800cf24:	f001 ffe8 	bl	800eef8 <wolfSSL_Malloc>
 800cf28:	60f8      	str	r0, [r7, #12]
                                       DYNAMIC_TYPE_SIGNER);
    if (signer) {
 800cf2a:	68fb      	ldr	r3, [r7, #12]
 800cf2c:	2b00      	cmp	r3, #0
 800cf2e:	d004      	beq.n	800cf3a <MakeSigner+0x20>
        XMEMSET(signer, 0, sizeof(Signer));
 800cf30:	2268      	movs	r2, #104	; 0x68
 800cf32:	2100      	movs	r1, #0
 800cf34:	68f8      	ldr	r0, [r7, #12]
 800cf36:	f00c fa82 	bl	801943e <memset>
    }
    (void)heap;

    return signer;
 800cf3a:	68fb      	ldr	r3, [r7, #12]
}
 800cf3c:	4618      	mov	r0, r3
 800cf3e:	3710      	adds	r7, #16
 800cf40:	46bd      	mov	sp, r7
 800cf42:	bd80      	pop	{r7, pc}

0800cf44 <FreeSigner>:


/* Free an individual signer */
void FreeSigner(Signer* signer, void* heap)
{
 800cf44:	b580      	push	{r7, lr}
 800cf46:	b086      	sub	sp, #24
 800cf48:	af00      	add	r7, sp, #0
 800cf4a:	6078      	str	r0, [r7, #4]
 800cf4c:	6039      	str	r1, [r7, #0]
    XFREE(signer->name, heap, DYNAMIC_TYPE_SUBJECT_CN);
 800cf4e:	687b      	ldr	r3, [r7, #4]
 800cf50:	699b      	ldr	r3, [r3, #24]
 800cf52:	617b      	str	r3, [r7, #20]
 800cf54:	697b      	ldr	r3, [r7, #20]
 800cf56:	2b00      	cmp	r3, #0
 800cf58:	d002      	beq.n	800cf60 <FreeSigner+0x1c>
 800cf5a:	6978      	ldr	r0, [r7, #20]
 800cf5c:	f001 ffe8 	bl	800ef30 <wolfSSL_Free>
    XFREE((void*)signer->publicKey, heap, DYNAMIC_TYPE_PUBLIC_KEY);
 800cf60:	687b      	ldr	r3, [r7, #4]
 800cf62:	691b      	ldr	r3, [r3, #16]
 800cf64:	613b      	str	r3, [r7, #16]
 800cf66:	693b      	ldr	r3, [r7, #16]
 800cf68:	2b00      	cmp	r3, #0
 800cf6a:	d002      	beq.n	800cf72 <FreeSigner+0x2e>
 800cf6c:	6938      	ldr	r0, [r7, #16]
 800cf6e:	f001 ffdf 	bl	800ef30 <wolfSSL_Free>
#ifndef IGNORE_NAME_CONSTRAINTS
    if (signer->permittedNames)
 800cf72:	687b      	ldr	r3, [r7, #4]
 800cf74:	69db      	ldr	r3, [r3, #28]
 800cf76:	2b00      	cmp	r3, #0
 800cf78:	d005      	beq.n	800cf86 <FreeSigner+0x42>
        FreeNameSubtrees(signer->permittedNames, heap);
 800cf7a:	687b      	ldr	r3, [r7, #4]
 800cf7c:	69db      	ldr	r3, [r3, #28]
 800cf7e:	6839      	ldr	r1, [r7, #0]
 800cf80:	4618      	mov	r0, r3
 800cf82:	f7fc ff1c 	bl	8009dbe <FreeNameSubtrees>
    if (signer->excludedNames)
 800cf86:	687b      	ldr	r3, [r7, #4]
 800cf88:	6a1b      	ldr	r3, [r3, #32]
 800cf8a:	2b00      	cmp	r3, #0
 800cf8c:	d005      	beq.n	800cf9a <FreeSigner+0x56>
        FreeNameSubtrees(signer->excludedNames, heap);
 800cf8e:	687b      	ldr	r3, [r7, #4]
 800cf90:	6a1b      	ldr	r3, [r3, #32]
 800cf92:	6839      	ldr	r1, [r7, #0]
 800cf94:	4618      	mov	r0, r3
 800cf96:	f7fc ff12 	bl	8009dbe <FreeNameSubtrees>
#endif
#ifdef WOLFSSL_SIGNER_DER_CERT
    FreeDer(&signer->derCert);
#endif
    XFREE(signer, heap, DYNAMIC_TYPE_SIGNER);
 800cf9a:	687b      	ldr	r3, [r7, #4]
 800cf9c:	60fb      	str	r3, [r7, #12]
 800cf9e:	68fb      	ldr	r3, [r7, #12]
 800cfa0:	2b00      	cmp	r3, #0
 800cfa2:	d002      	beq.n	800cfaa <FreeSigner+0x66>
 800cfa4:	68f8      	ldr	r0, [r7, #12]
 800cfa6:	f001 ffc3 	bl	800ef30 <wolfSSL_Free>

    (void)heap;
}
 800cfaa:	bf00      	nop
 800cfac:	3718      	adds	r7, #24
 800cfae:	46bd      	mov	sp, r7
 800cfb0:	bd80      	pop	{r7, pc}

0800cfb2 <FreeSignerTable>:


/* Free the whole singer table with number of rows */
void FreeSignerTable(Signer** table, int rows, void* heap)
{
 800cfb2:	b580      	push	{r7, lr}
 800cfb4:	b088      	sub	sp, #32
 800cfb6:	af00      	add	r7, sp, #0
 800cfb8:	60f8      	str	r0, [r7, #12]
 800cfba:	60b9      	str	r1, [r7, #8]
 800cfbc:	607a      	str	r2, [r7, #4]
    int i;

    for (i = 0; i < rows; i++) {
 800cfbe:	2300      	movs	r3, #0
 800cfc0:	61fb      	str	r3, [r7, #28]
 800cfc2:	e01b      	b.n	800cffc <FreeSignerTable+0x4a>
        Signer* signer = table[i];
 800cfc4:	69fb      	ldr	r3, [r7, #28]
 800cfc6:	009b      	lsls	r3, r3, #2
 800cfc8:	68fa      	ldr	r2, [r7, #12]
 800cfca:	4413      	add	r3, r2
 800cfcc:	681b      	ldr	r3, [r3, #0]
 800cfce:	61bb      	str	r3, [r7, #24]
        while (signer) {
 800cfd0:	e008      	b.n	800cfe4 <FreeSignerTable+0x32>
            Signer* next = signer->next;
 800cfd2:	69bb      	ldr	r3, [r7, #24]
 800cfd4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800cfd6:	617b      	str	r3, [r7, #20]
            FreeSigner(signer, heap);
 800cfd8:	6879      	ldr	r1, [r7, #4]
 800cfda:	69b8      	ldr	r0, [r7, #24]
 800cfdc:	f7ff ffb2 	bl	800cf44 <FreeSigner>
            signer = next;
 800cfe0:	697b      	ldr	r3, [r7, #20]
 800cfe2:	61bb      	str	r3, [r7, #24]
        while (signer) {
 800cfe4:	69bb      	ldr	r3, [r7, #24]
 800cfe6:	2b00      	cmp	r3, #0
 800cfe8:	d1f3      	bne.n	800cfd2 <FreeSignerTable+0x20>
        }
        table[i] = NULL;
 800cfea:	69fb      	ldr	r3, [r7, #28]
 800cfec:	009b      	lsls	r3, r3, #2
 800cfee:	68fa      	ldr	r2, [r7, #12]
 800cff0:	4413      	add	r3, r2
 800cff2:	2200      	movs	r2, #0
 800cff4:	601a      	str	r2, [r3, #0]
    for (i = 0; i < rows; i++) {
 800cff6:	69fb      	ldr	r3, [r7, #28]
 800cff8:	3301      	adds	r3, #1
 800cffa:	61fb      	str	r3, [r7, #28]
 800cffc:	69fa      	ldr	r2, [r7, #28]
 800cffe:	68bb      	ldr	r3, [r7, #8]
 800d000:	429a      	cmp	r2, r3
 800d002:	dbdf      	blt.n	800cfc4 <FreeSignerTable+0x12>
    }
}
 800d004:	bf00      	nop
 800d006:	3720      	adds	r7, #32
 800d008:	46bd      	mov	sp, r7
 800d00a:	bd80      	pop	{r7, pc}

0800d00c <GetSerialNumber>:

#endif /* !NO_CERTS */

int GetSerialNumber(const byte* input, word32* inOutIdx,
    byte* serial, int* serialSz, word32 maxIdx)
{
 800d00c:	b580      	push	{r7, lr}
 800d00e:	b086      	sub	sp, #24
 800d010:	af00      	add	r7, sp, #0
 800d012:	60f8      	str	r0, [r7, #12]
 800d014:	60b9      	str	r1, [r7, #8]
 800d016:	607a      	str	r2, [r7, #4]
 800d018:	603b      	str	r3, [r7, #0]
    int result = 0;
 800d01a:	2300      	movs	r3, #0
 800d01c:	617b      	str	r3, [r7, #20]
    int ret;

    WOLFSSL_ENTER("GetSerialNumber");

    if (serial == NULL || input == NULL || serialSz == NULL) {
 800d01e:	687b      	ldr	r3, [r7, #4]
 800d020:	2b00      	cmp	r3, #0
 800d022:	d005      	beq.n	800d030 <GetSerialNumber+0x24>
 800d024:	68fb      	ldr	r3, [r7, #12]
 800d026:	2b00      	cmp	r3, #0
 800d028:	d002      	beq.n	800d030 <GetSerialNumber+0x24>
 800d02a:	683b      	ldr	r3, [r7, #0]
 800d02c:	2b00      	cmp	r3, #0
 800d02e:	d102      	bne.n	800d036 <GetSerialNumber+0x2a>
        return BAD_FUNC_ARG;
 800d030:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800d034:	e02d      	b.n	800d092 <GetSerialNumber+0x86>
    }

    /* First byte is ASN type */
    if ((*inOutIdx+1) > maxIdx) {
 800d036:	68bb      	ldr	r3, [r7, #8]
 800d038:	681b      	ldr	r3, [r3, #0]
 800d03a:	3301      	adds	r3, #1
 800d03c:	6a3a      	ldr	r2, [r7, #32]
 800d03e:	429a      	cmp	r2, r3
 800d040:	d202      	bcs.n	800d048 <GetSerialNumber+0x3c>
        WOLFSSL_MSG("Bad idx first");
        return BUFFER_E;
 800d042:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800d046:	e024      	b.n	800d092 <GetSerialNumber+0x86>
    }

    ret = GetASNInt(input, inOutIdx, serialSz, maxIdx);
 800d048:	6a3b      	ldr	r3, [r7, #32]
 800d04a:	683a      	ldr	r2, [r7, #0]
 800d04c:	68b9      	ldr	r1, [r7, #8]
 800d04e:	68f8      	ldr	r0, [r7, #12]
 800d050:	f7fb fd5e 	bl	8008b10 <GetASNInt>
 800d054:	6138      	str	r0, [r7, #16]
    if (ret != 0)
 800d056:	693b      	ldr	r3, [r7, #16]
 800d058:	2b00      	cmp	r3, #0
 800d05a:	d001      	beq.n	800d060 <GetSerialNumber+0x54>
        return ret;
 800d05c:	693b      	ldr	r3, [r7, #16]
 800d05e:	e018      	b.n	800d092 <GetSerialNumber+0x86>

    if (*serialSz > EXTERNAL_SERIAL_SIZE) {
 800d060:	683b      	ldr	r3, [r7, #0]
 800d062:	681b      	ldr	r3, [r3, #0]
 800d064:	2b20      	cmp	r3, #32
 800d066:	dd02      	ble.n	800d06e <GetSerialNumber+0x62>
        WOLFSSL_MSG("Serial size bad");
        return ASN_PARSE_E;
 800d068:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800d06c:	e011      	b.n	800d092 <GetSerialNumber+0x86>
    }

    /* return serial */
    XMEMCPY(serial, &input[*inOutIdx], *serialSz);
 800d06e:	68bb      	ldr	r3, [r7, #8]
 800d070:	681b      	ldr	r3, [r3, #0]
 800d072:	68fa      	ldr	r2, [r7, #12]
 800d074:	18d1      	adds	r1, r2, r3
 800d076:	683b      	ldr	r3, [r7, #0]
 800d078:	681b      	ldr	r3, [r3, #0]
 800d07a:	461a      	mov	r2, r3
 800d07c:	6878      	ldr	r0, [r7, #4]
 800d07e:	f00c f9ba 	bl	80193f6 <memcpy>
    *inOutIdx += *serialSz;
 800d082:	68bb      	ldr	r3, [r7, #8]
 800d084:	681b      	ldr	r3, [r3, #0]
 800d086:	683a      	ldr	r2, [r7, #0]
 800d088:	6812      	ldr	r2, [r2, #0]
 800d08a:	441a      	add	r2, r3
 800d08c:	68bb      	ldr	r3, [r7, #8]
 800d08e:	601a      	str	r2, [r3, #0]

    return result;
 800d090:	697b      	ldr	r3, [r7, #20]
}
 800d092:	4618      	mov	r0, r3
 800d094:	3718      	adds	r7, #24
 800d096:	46bd      	mov	sp, r7
 800d098:	bd80      	pop	{r7, pc}
	...

0800d09c <AllocDer>:

#ifndef NO_CERTS

int AllocDer(DerBuffer** pDer, word32 length, int type, void* heap)
{
 800d09c:	b580      	push	{r7, lr}
 800d09e:	b088      	sub	sp, #32
 800d0a0:	af00      	add	r7, sp, #0
 800d0a2:	60f8      	str	r0, [r7, #12]
 800d0a4:	60b9      	str	r1, [r7, #8]
 800d0a6:	607a      	str	r2, [r7, #4]
 800d0a8:	603b      	str	r3, [r7, #0]
    int ret = BAD_FUNC_ARG;
 800d0aa:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800d0ae:	61fb      	str	r3, [r7, #28]
    if (pDer) {
 800d0b0:	68fb      	ldr	r3, [r7, #12]
 800d0b2:	2b00      	cmp	r3, #0
 800d0b4:	d062      	beq.n	800d17c <AllocDer+0xe0>
        int dynType = 0;
 800d0b6:	2300      	movs	r3, #0
 800d0b8:	61bb      	str	r3, [r7, #24]
        DerBuffer* der;

        /* Determine dynamic type */
        switch (type) {
 800d0ba:	687b      	ldr	r3, [r7, #4]
 800d0bc:	2b0b      	cmp	r3, #11
 800d0be:	d82d      	bhi.n	800d11c <AllocDer+0x80>
 800d0c0:	a201      	add	r2, pc, #4	; (adr r2, 800d0c8 <AllocDer+0x2c>)
 800d0c2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800d0c6:	bf00      	nop
 800d0c8:	0800d0ff 	.word	0x0800d0ff
 800d0cc:	0800d11d 	.word	0x0800d11d
 800d0d0:	0800d11d 	.word	0x0800d11d
 800d0d4:	0800d11d 	.word	0x0800d11d
 800d0d8:	0800d105 	.word	0x0800d105
 800d0dc:	0800d0f9 	.word	0x0800d0f9
 800d0e0:	0800d11d 	.word	0x0800d11d
 800d0e4:	0800d11d 	.word	0x0800d11d
 800d0e8:	0800d11d 	.word	0x0800d11d
 800d0ec:	0800d10b 	.word	0x0800d10b
 800d0f0:	0800d111 	.word	0x0800d111
 800d0f4:	0800d117 	.word	0x0800d117
            case CA_TYPE:   dynType = DYNAMIC_TYPE_CA;   break;
 800d0f8:	2301      	movs	r3, #1
 800d0fa:	61bb      	str	r3, [r7, #24]
 800d0fc:	e011      	b.n	800d122 <AllocDer+0x86>
            case CERT_TYPE: dynType = DYNAMIC_TYPE_CERT; break;
 800d0fe:	2302      	movs	r3, #2
 800d100:	61bb      	str	r3, [r7, #24]
 800d102:	e00e      	b.n	800d122 <AllocDer+0x86>
            case CRL_TYPE:  dynType = DYNAMIC_TYPE_CRL;  break;
 800d104:	2316      	movs	r3, #22
 800d106:	61bb      	str	r3, [r7, #24]
 800d108:	e00b      	b.n	800d122 <AllocDer+0x86>
            case DSA_TYPE:  dynType = DYNAMIC_TYPE_DSA;  break;
 800d10a:	2315      	movs	r3, #21
 800d10c:	61bb      	str	r3, [r7, #24]
 800d10e:	e008      	b.n	800d122 <AllocDer+0x86>
            case ECC_TYPE:  dynType = DYNAMIC_TYPE_ECC;  break;
 800d110:	2325      	movs	r3, #37	; 0x25
 800d112:	61bb      	str	r3, [r7, #24]
 800d114:	e005      	b.n	800d122 <AllocDer+0x86>
            case RSA_TYPE:  dynType = DYNAMIC_TYPE_RSA;  break;
 800d116:	230a      	movs	r3, #10
 800d118:	61bb      	str	r3, [r7, #24]
 800d11a:	e002      	b.n	800d122 <AllocDer+0x86>
            default:        dynType = DYNAMIC_TYPE_KEY;  break;
 800d11c:	2303      	movs	r3, #3
 800d11e:	61bb      	str	r3, [r7, #24]
 800d120:	bf00      	nop
        }

        /* Setup new buffer */
        *pDer = (DerBuffer*)XMALLOC(sizeof(DerBuffer) + length, heap, dynType);
 800d122:	68bb      	ldr	r3, [r7, #8]
 800d124:	3314      	adds	r3, #20
 800d126:	4618      	mov	r0, r3
 800d128:	f001 fee6 	bl	800eef8 <wolfSSL_Malloc>
 800d12c:	4602      	mov	r2, r0
 800d12e:	68fb      	ldr	r3, [r7, #12]
 800d130:	601a      	str	r2, [r3, #0]
        if (*pDer == NULL) {
 800d132:	68fb      	ldr	r3, [r7, #12]
 800d134:	681b      	ldr	r3, [r3, #0]
 800d136:	2b00      	cmp	r3, #0
 800d138:	d102      	bne.n	800d140 <AllocDer+0xa4>
            return MEMORY_E;
 800d13a:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800d13e:	e01e      	b.n	800d17e <AllocDer+0xe2>
        }
        XMEMSET(*pDer, 0, sizeof(DerBuffer) + length);
 800d140:	68fb      	ldr	r3, [r7, #12]
 800d142:	6818      	ldr	r0, [r3, #0]
 800d144:	68bb      	ldr	r3, [r7, #8]
 800d146:	3314      	adds	r3, #20
 800d148:	461a      	mov	r2, r3
 800d14a:	2100      	movs	r1, #0
 800d14c:	f00c f977 	bl	801943e <memset>

        der = *pDer;
 800d150:	68fb      	ldr	r3, [r7, #12]
 800d152:	681b      	ldr	r3, [r3, #0]
 800d154:	617b      	str	r3, [r7, #20]
        der->type = type;
 800d156:	697b      	ldr	r3, [r7, #20]
 800d158:	687a      	ldr	r2, [r7, #4]
 800d15a:	60da      	str	r2, [r3, #12]
        der->dynType = dynType; /* Cache this for FreeDer */
 800d15c:	697b      	ldr	r3, [r7, #20]
 800d15e:	69ba      	ldr	r2, [r7, #24]
 800d160:	611a      	str	r2, [r3, #16]
        der->heap = heap;
 800d162:	697b      	ldr	r3, [r7, #20]
 800d164:	683a      	ldr	r2, [r7, #0]
 800d166:	605a      	str	r2, [r3, #4]
        der->buffer = (byte*)der + sizeof(DerBuffer);
 800d168:	697b      	ldr	r3, [r7, #20]
 800d16a:	f103 0214 	add.w	r2, r3, #20
 800d16e:	697b      	ldr	r3, [r7, #20]
 800d170:	601a      	str	r2, [r3, #0]
        der->length = length;
 800d172:	697b      	ldr	r3, [r7, #20]
 800d174:	68ba      	ldr	r2, [r7, #8]
 800d176:	609a      	str	r2, [r3, #8]
        ret = 0; /* Success */
 800d178:	2300      	movs	r3, #0
 800d17a:	61fb      	str	r3, [r7, #28]
    }
    return ret;
 800d17c:	69fb      	ldr	r3, [r7, #28]
}
 800d17e:	4618      	mov	r0, r3
 800d180:	3720      	adds	r7, #32
 800d182:	46bd      	mov	sp, r7
 800d184:	bd80      	pop	{r7, pc}
 800d186:	bf00      	nop

0800d188 <FreeDer>:

void FreeDer(DerBuffer** pDer)
{
 800d188:	b580      	push	{r7, lr}
 800d18a:	b084      	sub	sp, #16
 800d18c:	af00      	add	r7, sp, #0
 800d18e:	6078      	str	r0, [r7, #4]
    if (pDer && *pDer)
 800d190:	687b      	ldr	r3, [r7, #4]
 800d192:	2b00      	cmp	r3, #0
 800d194:	d023      	beq.n	800d1de <FreeDer+0x56>
 800d196:	687b      	ldr	r3, [r7, #4]
 800d198:	681b      	ldr	r3, [r3, #0]
 800d19a:	2b00      	cmp	r3, #0
 800d19c:	d01f      	beq.n	800d1de <FreeDer+0x56>
    {
        DerBuffer* der = (DerBuffer*)*pDer;
 800d19e:	687b      	ldr	r3, [r7, #4]
 800d1a0:	681b      	ldr	r3, [r3, #0]
 800d1a2:	60fb      	str	r3, [r7, #12]

        /* ForceZero private keys */
        if (der->type == PRIVATEKEY_TYPE) {
 800d1a4:	68fb      	ldr	r3, [r7, #12]
 800d1a6:	68db      	ldr	r3, [r3, #12]
 800d1a8:	2b01      	cmp	r3, #1
 800d1aa:	d107      	bne.n	800d1bc <FreeDer+0x34>
            ForceZero(der->buffer, der->length);
 800d1ac:	68fb      	ldr	r3, [r7, #12]
 800d1ae:	681a      	ldr	r2, [r3, #0]
 800d1b0:	68fb      	ldr	r3, [r7, #12]
 800d1b2:	689b      	ldr	r3, [r3, #8]
 800d1b4:	4619      	mov	r1, r3
 800d1b6:	4610      	mov	r0, r2
 800d1b8:	f7fb fa9e 	bl	80086f8 <ForceZero>
        }
        der->buffer = NULL;
 800d1bc:	68fb      	ldr	r3, [r7, #12]
 800d1be:	2200      	movs	r2, #0
 800d1c0:	601a      	str	r2, [r3, #0]
        der->length = 0;
 800d1c2:	68fb      	ldr	r3, [r7, #12]
 800d1c4:	2200      	movs	r2, #0
 800d1c6:	609a      	str	r2, [r3, #8]
        XFREE(der, der->heap, der->dynType);
 800d1c8:	68fb      	ldr	r3, [r7, #12]
 800d1ca:	60bb      	str	r3, [r7, #8]
 800d1cc:	68bb      	ldr	r3, [r7, #8]
 800d1ce:	2b00      	cmp	r3, #0
 800d1d0:	d002      	beq.n	800d1d8 <FreeDer+0x50>
 800d1d2:	68b8      	ldr	r0, [r7, #8]
 800d1d4:	f001 feac 	bl	800ef30 <wolfSSL_Free>

        *pDer = NULL;
 800d1d8:	687b      	ldr	r3, [r7, #4]
 800d1da:	2200      	movs	r2, #0
 800d1dc:	601a      	str	r2, [r3, #0]
    }
}
 800d1de:	bf00      	nop
 800d1e0:	3710      	adds	r7, #16
 800d1e2:	46bd      	mov	sp, r7
 800d1e4:	bd80      	pop	{r7, pc}

0800d1e6 <SkipEndOfLineChars>:

const int pem_struct_min_sz = XSTR_SIZEOF("-----BEGIN X509 CRL-----"
                                             "-----END X509 CRL-----");

static WC_INLINE char* SkipEndOfLineChars(char* line, const char* endOfLine)
{
 800d1e6:	b480      	push	{r7}
 800d1e8:	b083      	sub	sp, #12
 800d1ea:	af00      	add	r7, sp, #0
 800d1ec:	6078      	str	r0, [r7, #4]
 800d1ee:	6039      	str	r1, [r7, #0]
    /* eat end of line characters */
    while (line < endOfLine &&
 800d1f0:	e002      	b.n	800d1f8 <SkipEndOfLineChars+0x12>
              (line[0] == '\r' || line[0] == '\n')) {
        line++;
 800d1f2:	687b      	ldr	r3, [r7, #4]
 800d1f4:	3301      	adds	r3, #1
 800d1f6:	607b      	str	r3, [r7, #4]
    while (line < endOfLine &&
 800d1f8:	687a      	ldr	r2, [r7, #4]
 800d1fa:	683b      	ldr	r3, [r7, #0]
 800d1fc:	429a      	cmp	r2, r3
 800d1fe:	d207      	bcs.n	800d210 <SkipEndOfLineChars+0x2a>
              (line[0] == '\r' || line[0] == '\n')) {
 800d200:	687b      	ldr	r3, [r7, #4]
 800d202:	781b      	ldrb	r3, [r3, #0]
    while (line < endOfLine &&
 800d204:	2b0d      	cmp	r3, #13
 800d206:	d0f4      	beq.n	800d1f2 <SkipEndOfLineChars+0xc>
              (line[0] == '\r' || line[0] == '\n')) {
 800d208:	687b      	ldr	r3, [r7, #4]
 800d20a:	781b      	ldrb	r3, [r3, #0]
 800d20c:	2b0a      	cmp	r3, #10
 800d20e:	d0f0      	beq.n	800d1f2 <SkipEndOfLineChars+0xc>
    }
    return line;
 800d210:	687b      	ldr	r3, [r7, #4]
}
 800d212:	4618      	mov	r0, r3
 800d214:	370c      	adds	r7, #12
 800d216:	46bd      	mov	sp, r7
 800d218:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d21c:	4770      	bx	lr
	...

0800d220 <wc_PemGetHeaderFooter>:

int wc_PemGetHeaderFooter(int type, const char** header, const char** footer)
{
 800d220:	b480      	push	{r7}
 800d222:	b087      	sub	sp, #28
 800d224:	af00      	add	r7, sp, #0
 800d226:	60f8      	str	r0, [r7, #12]
 800d228:	60b9      	str	r1, [r7, #8]
 800d22a:	607a      	str	r2, [r7, #4]
    int ret = BAD_FUNC_ARG;
 800d22c:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800d230:	617b      	str	r3, [r7, #20]

    switch (type) {
 800d232:	68fb      	ldr	r3, [r7, #12]
 800d234:	2b17      	cmp	r3, #23
 800d236:	f200 80ab 	bhi.w	800d390 <wc_PemGetHeaderFooter+0x170>
 800d23a:	a201      	add	r2, pc, #4	; (adr r2, 800d240 <wc_PemGetHeaderFooter+0x20>)
 800d23c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800d240:	0800d2a1 	.word	0x0800d2a1
 800d244:	0800d319 	.word	0x0800d319
 800d248:	0800d2dd 	.word	0x0800d2dd
 800d24c:	0800d391 	.word	0x0800d391
 800d250:	0800d2bf 	.word	0x0800d2bf
 800d254:	0800d2a1 	.word	0x0800d2a1
 800d258:	0800d2fb 	.word	0x0800d2fb
 800d25c:	0800d391 	.word	0x0800d391
 800d260:	0800d391 	.word	0x0800d391
 800d264:	0800d391 	.word	0x0800d391
 800d268:	0800d2fb 	.word	0x0800d2fb
 800d26c:	0800d319 	.word	0x0800d319
 800d270:	0800d337 	.word	0x0800d337
 800d274:	0800d391 	.word	0x0800d391
 800d278:	0800d337 	.word	0x0800d337
 800d27c:	0800d2a1 	.word	0x0800d2a1
 800d280:	0800d391 	.word	0x0800d391
 800d284:	0800d391 	.word	0x0800d391
 800d288:	0800d391 	.word	0x0800d391
 800d28c:	0800d391 	.word	0x0800d391
 800d290:	0800d355 	.word	0x0800d355
 800d294:	0800d373 	.word	0x0800d373
 800d298:	0800d391 	.word	0x0800d391
 800d29c:	0800d355 	.word	0x0800d355
        case CA_TYPE:       /* same as below */
        case TRUSTED_PEER_TYPE:
        case CERT_TYPE:
            if (header) *header = BEGIN_CERT;
 800d2a0:	68bb      	ldr	r3, [r7, #8]
 800d2a2:	2b00      	cmp	r3, #0
 800d2a4:	d002      	beq.n	800d2ac <wc_PemGetHeaderFooter+0x8c>
 800d2a6:	4a3e      	ldr	r2, [pc, #248]	; (800d3a0 <wc_PemGetHeaderFooter+0x180>)
 800d2a8:	68bb      	ldr	r3, [r7, #8]
 800d2aa:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_CERT;
 800d2ac:	687b      	ldr	r3, [r7, #4]
 800d2ae:	2b00      	cmp	r3, #0
 800d2b0:	d002      	beq.n	800d2b8 <wc_PemGetHeaderFooter+0x98>
 800d2b2:	4a3c      	ldr	r2, [pc, #240]	; (800d3a4 <wc_PemGetHeaderFooter+0x184>)
 800d2b4:	687b      	ldr	r3, [r7, #4]
 800d2b6:	601a      	str	r2, [r3, #0]
            ret = 0;
 800d2b8:	2300      	movs	r3, #0
 800d2ba:	617b      	str	r3, [r7, #20]
            break;
 800d2bc:	e069      	b.n	800d392 <wc_PemGetHeaderFooter+0x172>

        case CRL_TYPE:
            if (header) *header = BEGIN_X509_CRL;
 800d2be:	68bb      	ldr	r3, [r7, #8]
 800d2c0:	2b00      	cmp	r3, #0
 800d2c2:	d002      	beq.n	800d2ca <wc_PemGetHeaderFooter+0xaa>
 800d2c4:	4a38      	ldr	r2, [pc, #224]	; (800d3a8 <wc_PemGetHeaderFooter+0x188>)
 800d2c6:	68bb      	ldr	r3, [r7, #8]
 800d2c8:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_X509_CRL;
 800d2ca:	687b      	ldr	r3, [r7, #4]
 800d2cc:	2b00      	cmp	r3, #0
 800d2ce:	d002      	beq.n	800d2d6 <wc_PemGetHeaderFooter+0xb6>
 800d2d0:	4a36      	ldr	r2, [pc, #216]	; (800d3ac <wc_PemGetHeaderFooter+0x18c>)
 800d2d2:	687b      	ldr	r3, [r7, #4]
 800d2d4:	601a      	str	r2, [r3, #0]
            ret = 0;
 800d2d6:	2300      	movs	r3, #0
 800d2d8:	617b      	str	r3, [r7, #20]
            break;
 800d2da:	e05a      	b.n	800d392 <wc_PemGetHeaderFooter+0x172>
    #ifndef NO_DH
        case DH_PARAM_TYPE:
            if (header) *header = BEGIN_DH_PARAM;
 800d2dc:	68bb      	ldr	r3, [r7, #8]
 800d2de:	2b00      	cmp	r3, #0
 800d2e0:	d002      	beq.n	800d2e8 <wc_PemGetHeaderFooter+0xc8>
 800d2e2:	4a33      	ldr	r2, [pc, #204]	; (800d3b0 <wc_PemGetHeaderFooter+0x190>)
 800d2e4:	68bb      	ldr	r3, [r7, #8]
 800d2e6:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_DH_PARAM;
 800d2e8:	687b      	ldr	r3, [r7, #4]
 800d2ea:	2b00      	cmp	r3, #0
 800d2ec:	d002      	beq.n	800d2f4 <wc_PemGetHeaderFooter+0xd4>
 800d2ee:	4a31      	ldr	r2, [pc, #196]	; (800d3b4 <wc_PemGetHeaderFooter+0x194>)
 800d2f0:	687b      	ldr	r3, [r7, #4]
 800d2f2:	601a      	str	r2, [r3, #0]
            ret = 0;
 800d2f4:	2300      	movs	r3, #0
 800d2f6:	617b      	str	r3, [r7, #20]
            break;
 800d2f8:	e04b      	b.n	800d392 <wc_PemGetHeaderFooter+0x172>
            break;
    #endif
    #ifdef HAVE_ECC
        case ECC_TYPE:
        case ECC_PRIVATEKEY_TYPE:
            if (header) *header = BEGIN_EC_PRIV;
 800d2fa:	68bb      	ldr	r3, [r7, #8]
 800d2fc:	2b00      	cmp	r3, #0
 800d2fe:	d002      	beq.n	800d306 <wc_PemGetHeaderFooter+0xe6>
 800d300:	4a2d      	ldr	r2, [pc, #180]	; (800d3b8 <wc_PemGetHeaderFooter+0x198>)
 800d302:	68bb      	ldr	r3, [r7, #8]
 800d304:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_EC_PRIV;
 800d306:	687b      	ldr	r3, [r7, #4]
 800d308:	2b00      	cmp	r3, #0
 800d30a:	d002      	beq.n	800d312 <wc_PemGetHeaderFooter+0xf2>
 800d30c:	4a2b      	ldr	r2, [pc, #172]	; (800d3bc <wc_PemGetHeaderFooter+0x19c>)
 800d30e:	687b      	ldr	r3, [r7, #4]
 800d310:	601a      	str	r2, [r3, #0]
            ret = 0;
 800d312:	2300      	movs	r3, #0
 800d314:	617b      	str	r3, [r7, #20]
            break;
 800d316:	e03c      	b.n	800d392 <wc_PemGetHeaderFooter+0x172>
    #endif
        case RSA_TYPE:
        case PRIVATEKEY_TYPE:
            if (header) *header = BEGIN_RSA_PRIV;
 800d318:	68bb      	ldr	r3, [r7, #8]
 800d31a:	2b00      	cmp	r3, #0
 800d31c:	d002      	beq.n	800d324 <wc_PemGetHeaderFooter+0x104>
 800d31e:	4a28      	ldr	r2, [pc, #160]	; (800d3c0 <wc_PemGetHeaderFooter+0x1a0>)
 800d320:	68bb      	ldr	r3, [r7, #8]
 800d322:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_RSA_PRIV;
 800d324:	687b      	ldr	r3, [r7, #4]
 800d326:	2b00      	cmp	r3, #0
 800d328:	d002      	beq.n	800d330 <wc_PemGetHeaderFooter+0x110>
 800d32a:	4a26      	ldr	r2, [pc, #152]	; (800d3c4 <wc_PemGetHeaderFooter+0x1a4>)
 800d32c:	687b      	ldr	r3, [r7, #4]
 800d32e:	601a      	str	r2, [r3, #0]
            ret = 0;
 800d330:	2300      	movs	r3, #0
 800d332:	617b      	str	r3, [r7, #20]
            break;
 800d334:	e02d      	b.n	800d392 <wc_PemGetHeaderFooter+0x172>
            ret = 0;
            break;
    #endif
        case PUBLICKEY_TYPE:
        case ECC_PUBLICKEY_TYPE:
            if (header) *header = BEGIN_PUB_KEY;
 800d336:	68bb      	ldr	r3, [r7, #8]
 800d338:	2b00      	cmp	r3, #0
 800d33a:	d002      	beq.n	800d342 <wc_PemGetHeaderFooter+0x122>
 800d33c:	4a22      	ldr	r2, [pc, #136]	; (800d3c8 <wc_PemGetHeaderFooter+0x1a8>)
 800d33e:	68bb      	ldr	r3, [r7, #8]
 800d340:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_PUB_KEY;
 800d342:	687b      	ldr	r3, [r7, #4]
 800d344:	2b00      	cmp	r3, #0
 800d346:	d002      	beq.n	800d34e <wc_PemGetHeaderFooter+0x12e>
 800d348:	4a20      	ldr	r2, [pc, #128]	; (800d3cc <wc_PemGetHeaderFooter+0x1ac>)
 800d34a:	687b      	ldr	r3, [r7, #4]
 800d34c:	601a      	str	r2, [r3, #0]
            ret = 0;
 800d34e:	2300      	movs	r3, #0
 800d350:	617b      	str	r3, [r7, #20]
            break;
 800d352:	e01e      	b.n	800d392 <wc_PemGetHeaderFooter+0x172>
    #ifndef NO_DH
        case DH_PRIVATEKEY_TYPE:
    #endif
        case PKCS8_PRIVATEKEY_TYPE:
            if (header) *header = BEGIN_PRIV_KEY;
 800d354:	68bb      	ldr	r3, [r7, #8]
 800d356:	2b00      	cmp	r3, #0
 800d358:	d002      	beq.n	800d360 <wc_PemGetHeaderFooter+0x140>
 800d35a:	4a1d      	ldr	r2, [pc, #116]	; (800d3d0 <wc_PemGetHeaderFooter+0x1b0>)
 800d35c:	68bb      	ldr	r3, [r7, #8]
 800d35e:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_PRIV_KEY;
 800d360:	687b      	ldr	r3, [r7, #4]
 800d362:	2b00      	cmp	r3, #0
 800d364:	d002      	beq.n	800d36c <wc_PemGetHeaderFooter+0x14c>
 800d366:	4a1b      	ldr	r2, [pc, #108]	; (800d3d4 <wc_PemGetHeaderFooter+0x1b4>)
 800d368:	687b      	ldr	r3, [r7, #4]
 800d36a:	601a      	str	r2, [r3, #0]
            ret = 0;
 800d36c:	2300      	movs	r3, #0
 800d36e:	617b      	str	r3, [r7, #20]
            break;
 800d370:	e00f      	b.n	800d392 <wc_PemGetHeaderFooter+0x172>
        case PKCS8_ENC_PRIVATEKEY_TYPE:
            if (header) *header = BEGIN_ENC_PRIV_KEY;
 800d372:	68bb      	ldr	r3, [r7, #8]
 800d374:	2b00      	cmp	r3, #0
 800d376:	d002      	beq.n	800d37e <wc_PemGetHeaderFooter+0x15e>
 800d378:	4a17      	ldr	r2, [pc, #92]	; (800d3d8 <wc_PemGetHeaderFooter+0x1b8>)
 800d37a:	68bb      	ldr	r3, [r7, #8]
 800d37c:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_ENC_PRIV_KEY;
 800d37e:	687b      	ldr	r3, [r7, #4]
 800d380:	2b00      	cmp	r3, #0
 800d382:	d002      	beq.n	800d38a <wc_PemGetHeaderFooter+0x16a>
 800d384:	4a15      	ldr	r2, [pc, #84]	; (800d3dc <wc_PemGetHeaderFooter+0x1bc>)
 800d386:	687b      	ldr	r3, [r7, #4]
 800d388:	601a      	str	r2, [r3, #0]
            ret = 0;
 800d38a:	2300      	movs	r3, #0
 800d38c:	617b      	str	r3, [r7, #20]
            break;
 800d38e:	e000      	b.n	800d392 <wc_PemGetHeaderFooter+0x172>
        default:
            break;
 800d390:	bf00      	nop
    }
    return ret;
 800d392:	697b      	ldr	r3, [r7, #20]
}
 800d394:	4618      	mov	r0, r3
 800d396:	371c      	adds	r7, #28
 800d398:	46bd      	mov	sp, r7
 800d39a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d39e:	4770      	bx	lr
 800d3a0:	0801a468 	.word	0x0801a468
 800d3a4:	0801a484 	.word	0x0801a484
 800d3a8:	0801a4dc 	.word	0x0801a4dc
 800d3ac:	0801a4f8 	.word	0x0801a4f8
 800d3b0:	0801a4a0 	.word	0x0801a4a0
 800d3b4:	0801a4c0 	.word	0x0801a4c0
 800d3b8:	0801a5d4 	.word	0x0801a5d4
 800d3bc:	0801a5f4 	.word	0x0801a5f4
 800d3c0:	0801a510 	.word	0x0801a510
 800d3c4:	0801a530 	.word	0x0801a530
 800d3c8:	0801a654 	.word	0x0801a654
 800d3cc:	0801a670 	.word	0x0801a670
 800d3d0:	0801a550 	.word	0x0801a550
 800d3d4:	0801a56c 	.word	0x0801a56c
 800d3d8:	0801a588 	.word	0x0801a588
 800d3dc:	0801a5b0 	.word	0x0801a5b0

0800d3e0 <PemToDer>:

/* Remove PEM header/footer, convert to ASN1, store any encrypted data
   info->consumed tracks of PEM bytes consumed in case multiple parts */
int PemToDer(const unsigned char* buff, long longSz, int type,
              DerBuffer** pDer, void* heap, EncryptedInfo* info, int* keyFormat)
{
 800d3e0:	b580      	push	{r7, lr}
 800d3e2:	b090      	sub	sp, #64	; 0x40
 800d3e4:	af00      	add	r7, sp, #0
 800d3e6:	60f8      	str	r0, [r7, #12]
 800d3e8:	60b9      	str	r1, [r7, #8]
 800d3ea:	607a      	str	r2, [r7, #4]
 800d3ec:	603b      	str	r3, [r7, #0]
    const char* header      = NULL;
 800d3ee:	2300      	movs	r3, #0
 800d3f0:	61bb      	str	r3, [r7, #24]
    const char* footer      = NULL;
 800d3f2:	2300      	movs	r3, #0
 800d3f4:	617b      	str	r3, [r7, #20]
    char*       headerEnd;
    char*       footerEnd;
    char*       consumedEnd;
    char*       bufferEnd   = (char*)(buff + longSz);
 800d3f6:	68bb      	ldr	r3, [r7, #8]
 800d3f8:	68fa      	ldr	r2, [r7, #12]
 800d3fa:	4413      	add	r3, r2
 800d3fc:	63bb      	str	r3, [r7, #56]	; 0x38
    long        neededSz;
    int         ret         = 0;
 800d3fe:	2300      	movs	r3, #0
 800d400:	637b      	str	r3, [r7, #52]	; 0x34
    int         sz          = (int)longSz;
 800d402:	68bb      	ldr	r3, [r7, #8]
 800d404:	633b      	str	r3, [r7, #48]	; 0x30
    int         encrypted_key = 0;
 800d406:	2300      	movs	r3, #0
 800d408:	62fb      	str	r3, [r7, #44]	; 0x2c
    DerBuffer*  der;
#if defined(HAVE_PKCS8) || defined(WOLFSSL_ENCRYPTED_KEYS)
    word32      algId = 0;
 800d40a:	2300      	movs	r3, #0
 800d40c:	613b      	str	r3, [r7, #16]
#endif

    WOLFSSL_ENTER("PemToDer");

    /* get PEM header and footer based on type */
    ret = wc_PemGetHeaderFooter(type, &header, &footer);
 800d40e:	f107 0214 	add.w	r2, r7, #20
 800d412:	f107 0318 	add.w	r3, r7, #24
 800d416:	4619      	mov	r1, r3
 800d418:	6878      	ldr	r0, [r7, #4]
 800d41a:	f7ff ff01 	bl	800d220 <wc_PemGetHeaderFooter>
 800d41e:	6378      	str	r0, [r7, #52]	; 0x34
    if (ret != 0)
 800d420:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d422:	2b00      	cmp	r3, #0
 800d424:	d001      	beq.n	800d42a <PemToDer+0x4a>
        return ret;
 800d426:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d428:	e0e2      	b.n	800d5f0 <PemToDer+0x210>

    /* map header if not found for type */
    for (;;) {
        headerEnd = XSTRNSTR((char*)buff, header, sz);
 800d42a:	69bb      	ldr	r3, [r7, #24]
 800d42c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800d42e:	4619      	mov	r1, r3
 800d430:	68f8      	ldr	r0, [r7, #12]
 800d432:	f00b ff45 	bl	80192c0 <mystrnstr>
 800d436:	62b8      	str	r0, [r7, #40]	; 0x28

        if (headerEnd) {
 800d438:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d43a:	2b00      	cmp	r3, #0
 800d43c:	d126      	bne.n	800d48c <PemToDer+0xac>
            break;
        } else
        if (type == PRIVATEKEY_TYPE) {
 800d43e:	687b      	ldr	r3, [r7, #4]
 800d440:	2b01      	cmp	r3, #1
 800d442:	d125      	bne.n	800d490 <PemToDer+0xb0>
            if (header == BEGIN_RSA_PRIV) {
 800d444:	69bb      	ldr	r3, [r7, #24]
 800d446:	4a6c      	ldr	r2, [pc, #432]	; (800d5f8 <PemToDer+0x218>)
 800d448:	4293      	cmp	r3, r2
 800d44a:	d104      	bne.n	800d456 <PemToDer+0x76>
                header =  BEGIN_PRIV_KEY;       footer = END_PRIV_KEY;
 800d44c:	4b6b      	ldr	r3, [pc, #428]	; (800d5fc <PemToDer+0x21c>)
 800d44e:	61bb      	str	r3, [r7, #24]
 800d450:	4b6b      	ldr	r3, [pc, #428]	; (800d600 <PemToDer+0x220>)
 800d452:	617b      	str	r3, [r7, #20]
 800d454:	e7e9      	b.n	800d42a <PemToDer+0x4a>
            } else
            if (header == BEGIN_PRIV_KEY) {
 800d456:	69bb      	ldr	r3, [r7, #24]
 800d458:	4a68      	ldr	r2, [pc, #416]	; (800d5fc <PemToDer+0x21c>)
 800d45a:	4293      	cmp	r3, r2
 800d45c:	d104      	bne.n	800d468 <PemToDer+0x88>
                header =  BEGIN_ENC_PRIV_KEY;   footer = END_ENC_PRIV_KEY;
 800d45e:	4b69      	ldr	r3, [pc, #420]	; (800d604 <PemToDer+0x224>)
 800d460:	61bb      	str	r3, [r7, #24]
 800d462:	4b69      	ldr	r3, [pc, #420]	; (800d608 <PemToDer+0x228>)
 800d464:	617b      	str	r3, [r7, #20]
 800d466:	e7e0      	b.n	800d42a <PemToDer+0x4a>
            } else
    #ifdef HAVE_ECC
            if (header == BEGIN_ENC_PRIV_KEY) {
 800d468:	69bb      	ldr	r3, [r7, #24]
 800d46a:	4a66      	ldr	r2, [pc, #408]	; (800d604 <PemToDer+0x224>)
 800d46c:	4293      	cmp	r3, r2
 800d46e:	d104      	bne.n	800d47a <PemToDer+0x9a>
                header =  BEGIN_EC_PRIV;        footer = END_EC_PRIV;
 800d470:	4b66      	ldr	r3, [pc, #408]	; (800d60c <PemToDer+0x22c>)
 800d472:	61bb      	str	r3, [r7, #24]
 800d474:	4b66      	ldr	r3, [pc, #408]	; (800d610 <PemToDer+0x230>)
 800d476:	617b      	str	r3, [r7, #20]
 800d478:	e7d7      	b.n	800d42a <PemToDer+0x4a>
            } else
            if (header == BEGIN_EC_PRIV) {
 800d47a:	69bb      	ldr	r3, [r7, #24]
 800d47c:	4a63      	ldr	r2, [pc, #396]	; (800d60c <PemToDer+0x22c>)
 800d47e:	4293      	cmp	r3, r2
 800d480:	d108      	bne.n	800d494 <PemToDer+0xb4>
                header =  BEGIN_DSA_PRIV;       footer = END_DSA_PRIV;
 800d482:	4b64      	ldr	r3, [pc, #400]	; (800d614 <PemToDer+0x234>)
 800d484:	61bb      	str	r3, [r7, #24]
 800d486:	4b64      	ldr	r3, [pc, #400]	; (800d618 <PemToDer+0x238>)
 800d488:	617b      	str	r3, [r7, #20]
        headerEnd = XSTRNSTR((char*)buff, header, sz);
 800d48a:	e7ce      	b.n	800d42a <PemToDer+0x4a>
            break;
 800d48c:	bf00      	nop
 800d48e:	e002      	b.n	800d496 <PemToDer+0xb6>
        if ((type == CRL_TYPE) && (header != BEGIN_X509_CRL)) {
            header =  BEGIN_X509_CRL;           footer = END_X509_CRL;
        } else
#endif
        {
            break;
 800d490:	bf00      	nop
 800d492:	e000      	b.n	800d496 <PemToDer+0xb6>
                break;
 800d494:	bf00      	nop
        }
    }

    if (!headerEnd) {
 800d496:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d498:	2b00      	cmp	r3, #0
 800d49a:	d102      	bne.n	800d4a2 <PemToDer+0xc2>
            WOLFSSL_MSG("Couldn't find PEM header");
            return ASN_NO_PEM_HEADER;
        }
#else
        WOLFSSL_MSG("Couldn't find PEM header");
        return ASN_NO_PEM_HEADER;
 800d49c:	f06f 03a1 	mvn.w	r3, #161	; 0xa1
 800d4a0:	e0a6      	b.n	800d5f0 <PemToDer+0x210>
#endif
    } else {
        headerEnd += XSTRLEN(header);
 800d4a2:	69bb      	ldr	r3, [r7, #24]
 800d4a4:	4618      	mov	r0, r3
 800d4a6:	f7f2 feab 	bl	8000200 <strlen>
 800d4aa:	4602      	mov	r2, r0
 800d4ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d4ae:	4413      	add	r3, r2
 800d4b0:	62bb      	str	r3, [r7, #40]	; 0x28
    }

    /* eat end of line characters */
    headerEnd = SkipEndOfLineChars(headerEnd, bufferEnd);
 800d4b2:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800d4b4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d4b6:	f7ff fe96 	bl	800d1e6 <SkipEndOfLineChars>
 800d4ba:	62b8      	str	r0, [r7, #40]	; 0x28

    if (type == PRIVATEKEY_TYPE) {
 800d4bc:	687b      	ldr	r3, [r7, #4]
 800d4be:	2b01      	cmp	r3, #1
 800d4c0:	d10a      	bne.n	800d4d8 <PemToDer+0xf8>
        /* keyFormat is Key_Sum enum */
        if (keyFormat) {
 800d4c2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d4c4:	2b00      	cmp	r3, #0
 800d4c6:	d007      	beq.n	800d4d8 <PemToDer+0xf8>
        #ifdef HAVE_ECC
            if (header == BEGIN_EC_PRIV)
 800d4c8:	69bb      	ldr	r3, [r7, #24]
 800d4ca:	4a50      	ldr	r2, [pc, #320]	; (800d60c <PemToDer+0x22c>)
 800d4cc:	4293      	cmp	r3, r2
 800d4ce:	d103      	bne.n	800d4d8 <PemToDer+0xf8>
                *keyFormat = ECDSAk;
 800d4d0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d4d2:	f240 2206 	movw	r2, #518	; 0x206
 800d4d6:	601a      	str	r2, [r3, #0]
            encrypted_key = 1;
    }
#endif /* WOLFSSL_ENCRYPTED_KEYS */

    /* find footer */
    footerEnd = XSTRNSTR(headerEnd, footer, (unsigned int)((char*)buff + sz - headerEnd));
 800d4d8:	6979      	ldr	r1, [r7, #20]
 800d4da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d4dc:	68fa      	ldr	r2, [r7, #12]
 800d4de:	4413      	add	r3, r2
 800d4e0:	461a      	mov	r2, r3
 800d4e2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d4e4:	1ad3      	subs	r3, r2, r3
 800d4e6:	461a      	mov	r2, r3
 800d4e8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d4ea:	f00b fee9 	bl	80192c0 <mystrnstr>
 800d4ee:	6278      	str	r0, [r7, #36]	; 0x24
    if (!footerEnd) {
 800d4f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d4f2:	2b00      	cmp	r3, #0
 800d4f4:	d108      	bne.n	800d508 <PemToDer+0x128>
        if (info)
 800d4f6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d4f8:	2b00      	cmp	r3, #0
 800d4fa:	d002      	beq.n	800d502 <PemToDer+0x122>
            info->consumed = longSz; /* No more certs if no footer */
 800d4fc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d4fe:	68ba      	ldr	r2, [r7, #8]
 800d500:	609a      	str	r2, [r3, #8]
        return BUFFER_E;
 800d502:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800d506:	e073      	b.n	800d5f0 <PemToDer+0x210>
    }

    consumedEnd = footerEnd + XSTRLEN(footer);
 800d508:	697b      	ldr	r3, [r7, #20]
 800d50a:	4618      	mov	r0, r3
 800d50c:	f7f2 fe78 	bl	8000200 <strlen>
 800d510:	4602      	mov	r2, r0
 800d512:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d514:	4413      	add	r3, r2
 800d516:	63fb      	str	r3, [r7, #60]	; 0x3c

    if (consumedEnd < bufferEnd) { /* handle no end of line on last line */
 800d518:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800d51a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d51c:	429a      	cmp	r2, r3
 800d51e:	d20f      	bcs.n	800d540 <PemToDer+0x160>
        /* eat end of line characters */
        consumedEnd = SkipEndOfLineChars(consumedEnd, bufferEnd);
 800d520:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800d522:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800d524:	f7ff fe5f 	bl	800d1e6 <SkipEndOfLineChars>
 800d528:	63f8      	str	r0, [r7, #60]	; 0x3c
        /* skip possible null term */
        if (consumedEnd < bufferEnd && consumedEnd[0] == '\0')
 800d52a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800d52c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d52e:	429a      	cmp	r2, r3
 800d530:	d206      	bcs.n	800d540 <PemToDer+0x160>
 800d532:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d534:	781b      	ldrb	r3, [r3, #0]
 800d536:	2b00      	cmp	r3, #0
 800d538:	d102      	bne.n	800d540 <PemToDer+0x160>
            consumedEnd++;
 800d53a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d53c:	3301      	adds	r3, #1
 800d53e:	63fb      	str	r3, [r7, #60]	; 0x3c
    }

    if (info)
 800d540:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d542:	2b00      	cmp	r3, #0
 800d544:	d004      	beq.n	800d550 <PemToDer+0x170>
        info->consumed = (long)(consumedEnd - (char*)buff);
 800d546:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800d548:	68fb      	ldr	r3, [r7, #12]
 800d54a:	1ad2      	subs	r2, r2, r3
 800d54c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d54e:	609a      	str	r2, [r3, #8]

    /* set up der buffer */
    neededSz = (long)(footerEnd - headerEnd);
 800d550:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d552:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d554:	1ad3      	subs	r3, r2, r3
 800d556:	623b      	str	r3, [r7, #32]
    if (neededSz > sz || neededSz <= 0)
 800d558:	6a3a      	ldr	r2, [r7, #32]
 800d55a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d55c:	429a      	cmp	r2, r3
 800d55e:	dc02      	bgt.n	800d566 <PemToDer+0x186>
 800d560:	6a3b      	ldr	r3, [r7, #32]
 800d562:	2b00      	cmp	r3, #0
 800d564:	dc02      	bgt.n	800d56c <PemToDer+0x18c>
        return BUFFER_E;
 800d566:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800d56a:	e041      	b.n	800d5f0 <PemToDer+0x210>

    ret = AllocDer(pDer, (word32)neededSz, type, heap);
 800d56c:	6a39      	ldr	r1, [r7, #32]
 800d56e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800d570:	687a      	ldr	r2, [r7, #4]
 800d572:	6838      	ldr	r0, [r7, #0]
 800d574:	f7ff fd92 	bl	800d09c <AllocDer>
 800d578:	6378      	str	r0, [r7, #52]	; 0x34
    if (ret < 0) {
 800d57a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d57c:	2b00      	cmp	r3, #0
 800d57e:	da01      	bge.n	800d584 <PemToDer+0x1a4>
        return ret;
 800d580:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d582:	e035      	b.n	800d5f0 <PemToDer+0x210>
    }
    der = *pDer;
 800d584:	683b      	ldr	r3, [r7, #0]
 800d586:	681b      	ldr	r3, [r3, #0]
 800d588:	61fb      	str	r3, [r7, #28]

    if (Base64_Decode((byte*)headerEnd, (word32)neededSz,
 800d58a:	6a39      	ldr	r1, [r7, #32]
 800d58c:	69fb      	ldr	r3, [r7, #28]
 800d58e:	681a      	ldr	r2, [r3, #0]
 800d590:	69fb      	ldr	r3, [r7, #28]
 800d592:	3308      	adds	r3, #8
 800d594:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d596:	f000 fbb8 	bl	800dd0a <Base64_Decode>
 800d59a:	4603      	mov	r3, r0
 800d59c:	2b00      	cmp	r3, #0
 800d59e:	da02      	bge.n	800d5a6 <PemToDer+0x1c6>
                      der->buffer, &der->length) < 0)
        return BUFFER_E;
 800d5a0:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800d5a4:	e024      	b.n	800d5f0 <PemToDer+0x210>

    if ((header == BEGIN_PRIV_KEY
 800d5a6:	69bb      	ldr	r3, [r7, #24]
 800d5a8:	4a14      	ldr	r2, [pc, #80]	; (800d5fc <PemToDer+0x21c>)
 800d5aa:	4293      	cmp	r3, r2
 800d5ac:	d003      	beq.n	800d5b6 <PemToDer+0x1d6>
#ifdef OPENSSL_EXTRA
         || header == beginBuf
#endif
#ifdef HAVE_ECC
         || header == BEGIN_EC_PRIV
 800d5ae:	69bb      	ldr	r3, [r7, #24]
 800d5b0:	4a16      	ldr	r2, [pc, #88]	; (800d60c <PemToDer+0x22c>)
 800d5b2:	4293      	cmp	r3, r2
 800d5b4:	d11b      	bne.n	800d5ee <PemToDer+0x20e>
#endif
        ) && !encrypted_key)
 800d5b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d5b8:	2b00      	cmp	r3, #0
 800d5ba:	d118      	bne.n	800d5ee <PemToDer+0x20e>
    {
    #ifdef HAVE_PKCS8
        /* pkcs8 key, convert and adjust length */
        if ((ret = ToTraditional_ex(der->buffer, der->length, &algId)) > 0) {
 800d5bc:	69fb      	ldr	r3, [r7, #28]
 800d5be:	6818      	ldr	r0, [r3, #0]
 800d5c0:	69fb      	ldr	r3, [r7, #28]
 800d5c2:	689b      	ldr	r3, [r3, #8]
 800d5c4:	f107 0210 	add.w	r2, r7, #16
 800d5c8:	4619      	mov	r1, r3
 800d5ca:	f7fc f9f4 	bl	80099b6 <ToTraditional_ex>
 800d5ce:	6378      	str	r0, [r7, #52]	; 0x34
 800d5d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d5d2:	2b00      	cmp	r3, #0
 800d5d4:	dd09      	ble.n	800d5ea <PemToDer+0x20a>
            der->length = ret;
 800d5d6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d5d8:	69fb      	ldr	r3, [r7, #28]
 800d5da:	609a      	str	r2, [r3, #8]
            if (keyFormat) {
 800d5dc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d5de:	2b00      	cmp	r3, #0
 800d5e0:	d003      	beq.n	800d5ea <PemToDer+0x20a>
                *keyFormat = algId;
 800d5e2:	693b      	ldr	r3, [r7, #16]
 800d5e4:	461a      	mov	r2, r3
 800d5e6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d5e8:	601a      	str	r2, [r3, #0]
        else {
            /* ignore failure here and assume key is not pkcs8 wrapped */
        }
    #endif

        return 0;
 800d5ea:	2300      	movs	r3, #0
 800d5ec:	e000      	b.n	800d5f0 <PemToDer+0x210>
        XFREE(password, heap, DYNAMIC_TYPE_STRING);
    #endif
    }
#endif /* WOLFSSL_ENCRYPTED_KEYS */

    return ret;
 800d5ee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 800d5f0:	4618      	mov	r0, r3
 800d5f2:	3740      	adds	r7, #64	; 0x40
 800d5f4:	46bd      	mov	sp, r7
 800d5f6:	bd80      	pop	{r7, pc}
 800d5f8:	0801a510 	.word	0x0801a510
 800d5fc:	0801a550 	.word	0x0801a550
 800d600:	0801a56c 	.word	0x0801a56c
 800d604:	0801a588 	.word	0x0801a588
 800d608:	0801a5b0 	.word	0x0801a5b0
 800d60c:	0801a5d4 	.word	0x0801a5d4
 800d610:	0801a5f4 	.word	0x0801a5f4
 800d614:	0801a614 	.word	0x0801a614
 800d618:	0801a634 	.word	0x0801a634

0800d61c <DecodeECC_DSA_Sig>:
    return ret;
}


int DecodeECC_DSA_Sig(const byte* sig, word32 sigLen, mp_int* r, mp_int* s)
{
 800d61c:	b580      	push	{r7, lr}
 800d61e:	b086      	sub	sp, #24
 800d620:	af00      	add	r7, sp, #0
 800d622:	60f8      	str	r0, [r7, #12]
 800d624:	60b9      	str	r1, [r7, #8]
 800d626:	607a      	str	r2, [r7, #4]
 800d628:	603b      	str	r3, [r7, #0]
    word32 idx = 0;
 800d62a:	2300      	movs	r3, #0
 800d62c:	617b      	str	r3, [r7, #20]
    int    len = 0;
 800d62e:	2300      	movs	r3, #0
 800d630:	613b      	str	r3, [r7, #16]

    if (GetSequence(sig, &idx, &len, sigLen) < 0) {
 800d632:	f107 0210 	add.w	r2, r7, #16
 800d636:	f107 0114 	add.w	r1, r7, #20
 800d63a:	68bb      	ldr	r3, [r7, #8]
 800d63c:	68f8      	ldr	r0, [r7, #12]
 800d63e:	f7fb f9a7 	bl	8008990 <GetSequence>
 800d642:	4603      	mov	r3, r0
 800d644:	2b00      	cmp	r3, #0
 800d646:	da02      	bge.n	800d64e <DecodeECC_DSA_Sig+0x32>
        return ASN_ECC_KEY_E;
 800d648:	f06f 03aa 	mvn.w	r3, #170	; 0xaa
 800d64c:	e026      	b.n	800d69c <DecodeECC_DSA_Sig+0x80>
    }

#ifndef NO_STRICT_ECDSA_LEN
    /* enable strict length checking for signature */
    if (sigLen != idx + (word32)len) {
 800d64e:	697b      	ldr	r3, [r7, #20]
 800d650:	693a      	ldr	r2, [r7, #16]
 800d652:	4413      	add	r3, r2
 800d654:	68ba      	ldr	r2, [r7, #8]
 800d656:	429a      	cmp	r2, r3
 800d658:	d002      	beq.n	800d660 <DecodeECC_DSA_Sig+0x44>
        return ASN_ECC_KEY_E;
 800d65a:	f06f 03aa 	mvn.w	r3, #170	; 0xaa
 800d65e:	e01d      	b.n	800d69c <DecodeECC_DSA_Sig+0x80>
    if ((word32)len > (sigLen - idx)) {
        return ASN_ECC_KEY_E;
    }
#endif

    if (GetInt(r, sig, &idx, sigLen) < 0) {
 800d660:	f107 0214 	add.w	r2, r7, #20
 800d664:	68bb      	ldr	r3, [r7, #8]
 800d666:	68f9      	ldr	r1, [r7, #12]
 800d668:	6878      	ldr	r0, [r7, #4]
 800d66a:	f7fb fb6c 	bl	8008d46 <GetInt>
 800d66e:	4603      	mov	r3, r0
 800d670:	2b00      	cmp	r3, #0
 800d672:	da02      	bge.n	800d67a <DecodeECC_DSA_Sig+0x5e>
        return ASN_ECC_KEY_E;
 800d674:	f06f 03aa 	mvn.w	r3, #170	; 0xaa
 800d678:	e010      	b.n	800d69c <DecodeECC_DSA_Sig+0x80>
    }

    if (GetInt(s, sig, &idx, sigLen) < 0) {
 800d67a:	f107 0214 	add.w	r2, r7, #20
 800d67e:	68bb      	ldr	r3, [r7, #8]
 800d680:	68f9      	ldr	r1, [r7, #12]
 800d682:	6838      	ldr	r0, [r7, #0]
 800d684:	f7fb fb5f 	bl	8008d46 <GetInt>
 800d688:	4603      	mov	r3, r0
 800d68a:	2b00      	cmp	r3, #0
 800d68c:	da05      	bge.n	800d69a <DecodeECC_DSA_Sig+0x7e>
        mp_clear(r);
 800d68e:	6878      	ldr	r0, [r7, #4]
 800d690:	f00b f9ed 	bl	8018a6e <sp_clear>
        return ASN_ECC_KEY_E;
 800d694:	f06f 03aa 	mvn.w	r3, #170	; 0xaa
 800d698:	e000      	b.n	800d69c <DecodeECC_DSA_Sig+0x80>
    }

    return 0;
 800d69a:	2300      	movs	r3, #0
}
 800d69c:	4618      	mov	r0, r3
 800d69e:	3718      	adds	r7, #24
 800d6a0:	46bd      	mov	sp, r7
 800d6a2:	bd80      	pop	{r7, pc}

0800d6a4 <wc_EccPrivateKeyDecode>:


int wc_EccPrivateKeyDecode(const byte* input, word32* inOutIdx, ecc_key* key,
                        word32 inSz)
{
 800d6a4:	b580      	push	{r7, lr}
 800d6a6:	b094      	sub	sp, #80	; 0x50
 800d6a8:	af02      	add	r7, sp, #8
 800d6aa:	60f8      	str	r0, [r7, #12]
 800d6ac:	60b9      	str	r1, [r7, #8]
 800d6ae:	607a      	str	r2, [r7, #4]
 800d6b0:	603b      	str	r3, [r7, #0]
    word32 oidSum;
    int    version, length;
    int    privSz, pubSz = 0;
 800d6b2:	2300      	movs	r3, #0
 800d6b4:	647b      	str	r3, [r7, #68]	; 0x44
    byte   b;
    int    ret = 0;
 800d6b6:	2300      	movs	r3, #0
 800d6b8:	643b      	str	r3, [r7, #64]	; 0x40
    int    curve_id = ECC_CURVE_DEF;
 800d6ba:	2300      	movs	r3, #0
 800d6bc:	63fb      	str	r3, [r7, #60]	; 0x3c
#ifdef WOLFSSL_SMALL_STACK
    byte* priv;
    byte* pub = NULL;
 800d6be:	2300      	movs	r3, #0
 800d6c0:	63bb      	str	r3, [r7, #56]	; 0x38
#else
    byte priv[ECC_MAXSIZE+1];
    byte pub[2*(ECC_MAXSIZE+1)]; /* public key has two parts plus header */
#endif
    byte* pubData = NULL;
 800d6c2:	2300      	movs	r3, #0
 800d6c4:	637b      	str	r3, [r7, #52]	; 0x34

    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)
 800d6c6:	68fb      	ldr	r3, [r7, #12]
 800d6c8:	2b00      	cmp	r3, #0
 800d6ca:	d008      	beq.n	800d6de <wc_EccPrivateKeyDecode+0x3a>
 800d6cc:	68bb      	ldr	r3, [r7, #8]
 800d6ce:	2b00      	cmp	r3, #0
 800d6d0:	d005      	beq.n	800d6de <wc_EccPrivateKeyDecode+0x3a>
 800d6d2:	687b      	ldr	r3, [r7, #4]
 800d6d4:	2b00      	cmp	r3, #0
 800d6d6:	d002      	beq.n	800d6de <wc_EccPrivateKeyDecode+0x3a>
 800d6d8:	683b      	ldr	r3, [r7, #0]
 800d6da:	2b00      	cmp	r3, #0
 800d6dc:	d102      	bne.n	800d6e4 <wc_EccPrivateKeyDecode+0x40>
        return BAD_FUNC_ARG;
 800d6de:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800d6e2:	e12c      	b.n	800d93e <wc_EccPrivateKeyDecode+0x29a>

    if (GetSequence(input, inOutIdx, &length, inSz) < 0)
 800d6e4:	f107 0214 	add.w	r2, r7, #20
 800d6e8:	683b      	ldr	r3, [r7, #0]
 800d6ea:	68b9      	ldr	r1, [r7, #8]
 800d6ec:	68f8      	ldr	r0, [r7, #12]
 800d6ee:	f7fb f94f 	bl	8008990 <GetSequence>
 800d6f2:	4603      	mov	r3, r0
 800d6f4:	2b00      	cmp	r3, #0
 800d6f6:	da02      	bge.n	800d6fe <wc_EccPrivateKeyDecode+0x5a>
        return ASN_PARSE_E;
 800d6f8:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800d6fc:	e11f      	b.n	800d93e <wc_EccPrivateKeyDecode+0x29a>

    if (GetMyVersion(input, inOutIdx, &version, inSz) < 0)
 800d6fe:	f107 0218 	add.w	r2, r7, #24
 800d702:	683b      	ldr	r3, [r7, #0]
 800d704:	68b9      	ldr	r1, [r7, #8]
 800d706:	68f8      	ldr	r0, [r7, #12]
 800d708:	f7fb fa9a 	bl	8008c40 <GetMyVersion>
 800d70c:	4603      	mov	r3, r0
 800d70e:	2b00      	cmp	r3, #0
 800d710:	da02      	bge.n	800d718 <wc_EccPrivateKeyDecode+0x74>
        return ASN_PARSE_E;
 800d712:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800d716:	e112      	b.n	800d93e <wc_EccPrivateKeyDecode+0x29a>

    if (*inOutIdx >= inSz)
 800d718:	68bb      	ldr	r3, [r7, #8]
 800d71a:	681b      	ldr	r3, [r3, #0]
 800d71c:	683a      	ldr	r2, [r7, #0]
 800d71e:	429a      	cmp	r2, r3
 800d720:	d802      	bhi.n	800d728 <wc_EccPrivateKeyDecode+0x84>
        return ASN_PARSE_E;
 800d722:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800d726:	e10a      	b.n	800d93e <wc_EccPrivateKeyDecode+0x29a>

    b = input[*inOutIdx];
 800d728:	68bb      	ldr	r3, [r7, #8]
 800d72a:	681b      	ldr	r3, [r3, #0]
 800d72c:	68fa      	ldr	r2, [r7, #12]
 800d72e:	4413      	add	r3, r2
 800d730:	781b      	ldrb	r3, [r3, #0]
 800d732:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    *inOutIdx += 1;
 800d736:	68bb      	ldr	r3, [r7, #8]
 800d738:	681b      	ldr	r3, [r3, #0]
 800d73a:	1c5a      	adds	r2, r3, #1
 800d73c:	68bb      	ldr	r3, [r7, #8]
 800d73e:	601a      	str	r2, [r3, #0]

    /* priv type */
    if (b != 4 && b != 6 && b != 7)
 800d740:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800d744:	2b04      	cmp	r3, #4
 800d746:	d00a      	beq.n	800d75e <wc_EccPrivateKeyDecode+0xba>
 800d748:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800d74c:	2b06      	cmp	r3, #6
 800d74e:	d006      	beq.n	800d75e <wc_EccPrivateKeyDecode+0xba>
 800d750:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800d754:	2b07      	cmp	r3, #7
 800d756:	d002      	beq.n	800d75e <wc_EccPrivateKeyDecode+0xba>
        return ASN_PARSE_E;
 800d758:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800d75c:	e0ef      	b.n	800d93e <wc_EccPrivateKeyDecode+0x29a>

    if (GetLength(input, inOutIdx, &length, inSz) < 0)
 800d75e:	f107 0214 	add.w	r2, r7, #20
 800d762:	683b      	ldr	r3, [r7, #0]
 800d764:	68b9      	ldr	r1, [r7, #8]
 800d766:	68f8      	ldr	r0, [r7, #12]
 800d768:	f7fa ffde 	bl	8008728 <GetLength>
 800d76c:	4603      	mov	r3, r0
 800d76e:	2b00      	cmp	r3, #0
 800d770:	da02      	bge.n	800d778 <wc_EccPrivateKeyDecode+0xd4>
        return ASN_PARSE_E;
 800d772:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800d776:	e0e2      	b.n	800d93e <wc_EccPrivateKeyDecode+0x29a>
    privSz = length;
 800d778:	697b      	ldr	r3, [r7, #20]
 800d77a:	62fb      	str	r3, [r7, #44]	; 0x2c

    if (privSz > ECC_MAXSIZE)
 800d77c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d77e:	2b42      	cmp	r3, #66	; 0x42
 800d780:	dd02      	ble.n	800d788 <wc_EccPrivateKeyDecode+0xe4>
        return BUFFER_E;
 800d782:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800d786:	e0da      	b.n	800d93e <wc_EccPrivateKeyDecode+0x29a>

#ifdef WOLFSSL_SMALL_STACK
    priv = (byte*)XMALLOC(privSz, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 800d788:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d78a:	4618      	mov	r0, r3
 800d78c:	f001 fbb4 	bl	800eef8 <wolfSSL_Malloc>
 800d790:	62b8      	str	r0, [r7, #40]	; 0x28
    if (priv == NULL)
 800d792:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d794:	2b00      	cmp	r3, #0
 800d796:	d102      	bne.n	800d79e <wc_EccPrivateKeyDecode+0xfa>
        return MEMORY_E;
 800d798:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800d79c:	e0cf      	b.n	800d93e <wc_EccPrivateKeyDecode+0x29a>
#endif

    /* priv key */
    XMEMCPY(priv, &input[*inOutIdx], privSz);
 800d79e:	68bb      	ldr	r3, [r7, #8]
 800d7a0:	681b      	ldr	r3, [r3, #0]
 800d7a2:	68fa      	ldr	r2, [r7, #12]
 800d7a4:	4413      	add	r3, r2
 800d7a6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d7a8:	4619      	mov	r1, r3
 800d7aa:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d7ac:	f00b fe23 	bl	80193f6 <memcpy>
    *inOutIdx += length;
 800d7b0:	68bb      	ldr	r3, [r7, #8]
 800d7b2:	681b      	ldr	r3, [r3, #0]
 800d7b4:	697a      	ldr	r2, [r7, #20]
 800d7b6:	441a      	add	r2, r3
 800d7b8:	68bb      	ldr	r3, [r7, #8]
 800d7ba:	601a      	str	r2, [r3, #0]

    if ((*inOutIdx + 1) < inSz) {
 800d7bc:	68bb      	ldr	r3, [r7, #8]
 800d7be:	681b      	ldr	r3, [r3, #0]
 800d7c0:	3301      	adds	r3, #1
 800d7c2:	683a      	ldr	r2, [r7, #0]
 800d7c4:	429a      	cmp	r2, r3
 800d7c6:	d93a      	bls.n	800d83e <wc_EccPrivateKeyDecode+0x19a>
        /* prefix 0, may have */
        b = input[*inOutIdx];
 800d7c8:	68bb      	ldr	r3, [r7, #8]
 800d7ca:	681b      	ldr	r3, [r3, #0]
 800d7cc:	68fa      	ldr	r2, [r7, #12]
 800d7ce:	4413      	add	r3, r2
 800d7d0:	781b      	ldrb	r3, [r3, #0]
 800d7d2:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
        if (b == ECC_PREFIX_0) {
 800d7d6:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800d7da:	2ba0      	cmp	r3, #160	; 0xa0
 800d7dc:	d12f      	bne.n	800d83e <wc_EccPrivateKeyDecode+0x19a>
            *inOutIdx += 1;
 800d7de:	68bb      	ldr	r3, [r7, #8]
 800d7e0:	681b      	ldr	r3, [r3, #0]
 800d7e2:	1c5a      	adds	r2, r3, #1
 800d7e4:	68bb      	ldr	r3, [r7, #8]
 800d7e6:	601a      	str	r2, [r3, #0]

            if (GetLength(input, inOutIdx, &length, inSz) <= 0)
 800d7e8:	f107 0214 	add.w	r2, r7, #20
 800d7ec:	683b      	ldr	r3, [r7, #0]
 800d7ee:	68b9      	ldr	r1, [r7, #8]
 800d7f0:	68f8      	ldr	r0, [r7, #12]
 800d7f2:	f7fa ff99 	bl	8008728 <GetLength>
 800d7f6:	4603      	mov	r3, r0
 800d7f8:	2b00      	cmp	r3, #0
 800d7fa:	dc03      	bgt.n	800d804 <wc_EccPrivateKeyDecode+0x160>
                ret = ASN_PARSE_E;
 800d7fc:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800d800:	643b      	str	r3, [r7, #64]	; 0x40
 800d802:	e01c      	b.n	800d83e <wc_EccPrivateKeyDecode+0x19a>
            else {
                ret = GetObjectId(input, inOutIdx, &oidSum, oidIgnoreType,
 800d804:	f107 021c 	add.w	r2, r7, #28
 800d808:	683b      	ldr	r3, [r7, #0]
 800d80a:	9300      	str	r3, [sp, #0]
 800d80c:	2315      	movs	r3, #21
 800d80e:	68b9      	ldr	r1, [r7, #8]
 800d810:	68f8      	ldr	r0, [r7, #12]
 800d812:	f7fb fee7 	bl	80095e4 <GetObjectId>
 800d816:	6438      	str	r0, [r7, #64]	; 0x40
                                  inSz);
                if (ret == 0) {
 800d818:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d81a:	2b00      	cmp	r3, #0
 800d81c:	d10f      	bne.n	800d83e <wc_EccPrivateKeyDecode+0x19a>
                    if ((ret = CheckCurve(oidSum)) < 0)
 800d81e:	69fb      	ldr	r3, [r7, #28]
 800d820:	4618      	mov	r0, r3
 800d822:	f7fc fc2e 	bl	800a082 <CheckCurve>
 800d826:	6438      	str	r0, [r7, #64]	; 0x40
 800d828:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d82a:	2b00      	cmp	r3, #0
 800d82c:	da03      	bge.n	800d836 <wc_EccPrivateKeyDecode+0x192>
                        ret = ECC_CURVE_OID_E;
 800d82e:	f06f 03ab 	mvn.w	r3, #171	; 0xab
 800d832:	643b      	str	r3, [r7, #64]	; 0x40
 800d834:	e003      	b.n	800d83e <wc_EccPrivateKeyDecode+0x19a>
                    else {
                        curve_id = ret;
 800d836:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d838:	63fb      	str	r3, [r7, #60]	; 0x3c
                        ret = 0;
 800d83a:	2300      	movs	r3, #0
 800d83c:	643b      	str	r3, [r7, #64]	; 0x40
                }
            }
        }
    }

    if (ret == 0 && (*inOutIdx + 1) < inSz) {
 800d83e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d840:	2b00      	cmp	r3, #0
 800d842:	d15c      	bne.n	800d8fe <wc_EccPrivateKeyDecode+0x25a>
 800d844:	68bb      	ldr	r3, [r7, #8]
 800d846:	681b      	ldr	r3, [r3, #0]
 800d848:	3301      	adds	r3, #1
 800d84a:	683a      	ldr	r2, [r7, #0]
 800d84c:	429a      	cmp	r2, r3
 800d84e:	d956      	bls.n	800d8fe <wc_EccPrivateKeyDecode+0x25a>
        /* prefix 1 */
        b = input[*inOutIdx];
 800d850:	68bb      	ldr	r3, [r7, #8]
 800d852:	681b      	ldr	r3, [r3, #0]
 800d854:	68fa      	ldr	r2, [r7, #12]
 800d856:	4413      	add	r3, r2
 800d858:	781b      	ldrb	r3, [r3, #0]
 800d85a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
        *inOutIdx += 1;
 800d85e:	68bb      	ldr	r3, [r7, #8]
 800d860:	681b      	ldr	r3, [r3, #0]
 800d862:	1c5a      	adds	r2, r3, #1
 800d864:	68bb      	ldr	r3, [r7, #8]
 800d866:	601a      	str	r2, [r3, #0]

        if (b != ECC_PREFIX_1) {
 800d868:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800d86c:	2ba1      	cmp	r3, #161	; 0xa1
 800d86e:	d003      	beq.n	800d878 <wc_EccPrivateKeyDecode+0x1d4>
            ret = ASN_ECC_KEY_E;
 800d870:	f06f 03aa 	mvn.w	r3, #170	; 0xaa
 800d874:	643b      	str	r3, [r7, #64]	; 0x40
 800d876:	e042      	b.n	800d8fe <wc_EccPrivateKeyDecode+0x25a>
        }
        else if (GetLength(input, inOutIdx, &length, inSz) <= 0) {
 800d878:	f107 0214 	add.w	r2, r7, #20
 800d87c:	683b      	ldr	r3, [r7, #0]
 800d87e:	68b9      	ldr	r1, [r7, #8]
 800d880:	68f8      	ldr	r0, [r7, #12]
 800d882:	f7fa ff51 	bl	8008728 <GetLength>
 800d886:	4603      	mov	r3, r0
 800d888:	2b00      	cmp	r3, #0
 800d88a:	dc03      	bgt.n	800d894 <wc_EccPrivateKeyDecode+0x1f0>
            ret = ASN_PARSE_E;
 800d88c:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800d890:	643b      	str	r3, [r7, #64]	; 0x40
 800d892:	e034      	b.n	800d8fe <wc_EccPrivateKeyDecode+0x25a>
        }
        else {
            /* key header */
            ret = CheckBitString(input, inOutIdx, &length, inSz, 0, NULL);
 800d894:	f107 0214 	add.w	r2, r7, #20
 800d898:	2300      	movs	r3, #0
 800d89a:	9301      	str	r3, [sp, #4]
 800d89c:	2300      	movs	r3, #0
 800d89e:	9300      	str	r3, [sp, #0]
 800d8a0:	683b      	ldr	r3, [r7, #0]
 800d8a2:	68b9      	ldr	r1, [r7, #8]
 800d8a4:	68f8      	ldr	r0, [r7, #12]
 800d8a6:	f7fb fa8a 	bl	8008dbe <CheckBitString>
 800d8aa:	6438      	str	r0, [r7, #64]	; 0x40
            if (ret == 0) {
 800d8ac:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d8ae:	2b00      	cmp	r3, #0
 800d8b0:	d125      	bne.n	800d8fe <wc_EccPrivateKeyDecode+0x25a>
                /* pub key */
                pubSz = length;
 800d8b2:	697b      	ldr	r3, [r7, #20]
 800d8b4:	647b      	str	r3, [r7, #68]	; 0x44
                if (pubSz > 2*(ECC_MAXSIZE+1))
 800d8b6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d8b8:	2b86      	cmp	r3, #134	; 0x86
 800d8ba:	dd03      	ble.n	800d8c4 <wc_EccPrivateKeyDecode+0x220>
                    ret = BUFFER_E;
 800d8bc:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800d8c0:	643b      	str	r3, [r7, #64]	; 0x40
 800d8c2:	e01c      	b.n	800d8fe <wc_EccPrivateKeyDecode+0x25a>
                else {
            #ifdef WOLFSSL_SMALL_STACK
                    pub = (byte*)XMALLOC(pubSz, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 800d8c4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d8c6:	4618      	mov	r0, r3
 800d8c8:	f001 fb16 	bl	800eef8 <wolfSSL_Malloc>
 800d8cc:	63b8      	str	r0, [r7, #56]	; 0x38
                    if (pub == NULL)
 800d8ce:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d8d0:	2b00      	cmp	r3, #0
 800d8d2:	d103      	bne.n	800d8dc <wc_EccPrivateKeyDecode+0x238>
                        ret = MEMORY_E;
 800d8d4:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800d8d8:	643b      	str	r3, [r7, #64]	; 0x40
 800d8da:	e010      	b.n	800d8fe <wc_EccPrivateKeyDecode+0x25a>
                    else
            #endif
                    {
                        XMEMCPY(pub, &input[*inOutIdx], pubSz);
 800d8dc:	68bb      	ldr	r3, [r7, #8]
 800d8de:	681b      	ldr	r3, [r3, #0]
 800d8e0:	68fa      	ldr	r2, [r7, #12]
 800d8e2:	4413      	add	r3, r2
 800d8e4:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800d8e6:	4619      	mov	r1, r3
 800d8e8:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800d8ea:	f00b fd84 	bl	80193f6 <memcpy>
                        *inOutIdx += length;
 800d8ee:	68bb      	ldr	r3, [r7, #8]
 800d8f0:	681b      	ldr	r3, [r3, #0]
 800d8f2:	697a      	ldr	r2, [r7, #20]
 800d8f4:	441a      	add	r2, r3
 800d8f6:	68bb      	ldr	r3, [r7, #8]
 800d8f8:	601a      	str	r2, [r3, #0]
                        pubData = pub;
 800d8fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d8fc:	637b      	str	r3, [r7, #52]	; 0x34
                }
            }
        }
    }

    if (ret == 0) {
 800d8fe:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d900:	2b00      	cmp	r3, #0
 800d902:	d10b      	bne.n	800d91c <wc_EccPrivateKeyDecode+0x278>
        ret = wc_ecc_import_private_key_ex(priv, privSz, pubData, pubSz, key,
 800d904:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800d906:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800d908:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d90a:	9301      	str	r3, [sp, #4]
 800d90c:	687b      	ldr	r3, [r7, #4]
 800d90e:	9300      	str	r3, [sp, #0]
 800d910:	4613      	mov	r3, r2
 800d912:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d914:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d916:	f001 f979 	bl	800ec0c <wc_ecc_import_private_key_ex>
 800d91a:	6438      	str	r0, [r7, #64]	; 0x40
                                                                      curve_id);
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(priv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 800d91c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d91e:	627b      	str	r3, [r7, #36]	; 0x24
 800d920:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d922:	2b00      	cmp	r3, #0
 800d924:	d002      	beq.n	800d92c <wc_EccPrivateKeyDecode+0x288>
 800d926:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800d928:	f001 fb02 	bl	800ef30 <wolfSSL_Free>
    XFREE(pub,  key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 800d92c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d92e:	623b      	str	r3, [r7, #32]
 800d930:	6a3b      	ldr	r3, [r7, #32]
 800d932:	2b00      	cmp	r3, #0
 800d934:	d002      	beq.n	800d93c <wc_EccPrivateKeyDecode+0x298>
 800d936:	6a38      	ldr	r0, [r7, #32]
 800d938:	f001 fafa 	bl	800ef30 <wolfSSL_Free>
#endif

    return ret;
 800d93c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
}
 800d93e:	4618      	mov	r0, r3
 800d940:	3748      	adds	r7, #72	; 0x48
 800d942:	46bd      	mov	sp, r7
 800d944:	bd80      	pop	{r7, pc}

0800d946 <wc_EccPublicKeyDecode>:
}
#endif /* WOLFSSL_CUSTOM_CURVES */

int wc_EccPublicKeyDecode(const byte* input, word32* inOutIdx,
                          ecc_key* key, word32 inSz)
{
 800d946:	b580      	push	{r7, lr}
 800d948:	b08e      	sub	sp, #56	; 0x38
 800d94a:	af02      	add	r7, sp, #8
 800d94c:	60f8      	str	r0, [r7, #12]
 800d94e:	60b9      	str	r1, [r7, #8]
 800d950:	607a      	str	r2, [r7, #4]
 800d952:	603b      	str	r3, [r7, #0]
    int    ret;
    int    version, length;
    int    curve_id = ECC_CURVE_DEF;
 800d954:	2300      	movs	r3, #0
 800d956:	62bb      	str	r3, [r7, #40]	; 0x28
    word32 oidSum, localIdx;
    byte   tag, isPrivFormat = 0;
 800d958:	2300      	movs	r3, #0
 800d95a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)
 800d95e:	68fb      	ldr	r3, [r7, #12]
 800d960:	2b00      	cmp	r3, #0
 800d962:	d008      	beq.n	800d976 <wc_EccPublicKeyDecode+0x30>
 800d964:	68bb      	ldr	r3, [r7, #8]
 800d966:	2b00      	cmp	r3, #0
 800d968:	d005      	beq.n	800d976 <wc_EccPublicKeyDecode+0x30>
 800d96a:	687b      	ldr	r3, [r7, #4]
 800d96c:	2b00      	cmp	r3, #0
 800d96e:	d002      	beq.n	800d976 <wc_EccPublicKeyDecode+0x30>
 800d970:	683b      	ldr	r3, [r7, #0]
 800d972:	2b00      	cmp	r3, #0
 800d974:	d102      	bne.n	800d97c <wc_EccPublicKeyDecode+0x36>
        return BAD_FUNC_ARG;
 800d976:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800d97a:	e119      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>

    if (GetSequence(input, inOutIdx, &length, inSz) < 0)
 800d97c:	f107 021c 	add.w	r2, r7, #28
 800d980:	683b      	ldr	r3, [r7, #0]
 800d982:	68b9      	ldr	r1, [r7, #8]
 800d984:	68f8      	ldr	r0, [r7, #12]
 800d986:	f7fb f803 	bl	8008990 <GetSequence>
 800d98a:	4603      	mov	r3, r0
 800d98c:	2b00      	cmp	r3, #0
 800d98e:	da02      	bge.n	800d996 <wc_EccPublicKeyDecode+0x50>
        return ASN_PARSE_E;
 800d990:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800d994:	e10c      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>

    /* Check if ECC private key is being used and skip private portion */
    if (GetMyVersion(input, inOutIdx, &version, inSz) >= 0) {
 800d996:	f107 0220 	add.w	r2, r7, #32
 800d99a:	683b      	ldr	r3, [r7, #0]
 800d99c:	68b9      	ldr	r1, [r7, #8]
 800d99e:	68f8      	ldr	r0, [r7, #12]
 800d9a0:	f7fb f94e 	bl	8008c40 <GetMyVersion>
 800d9a4:	4603      	mov	r3, r0
 800d9a6:	2b00      	cmp	r3, #0
 800d9a8:	db60      	blt.n	800da6c <wc_EccPublicKeyDecode+0x126>
        isPrivFormat = 1;
 800d9aa:	2301      	movs	r3, #1
 800d9ac:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

        /* Type private key */
        if (*inOutIdx >= inSz)
 800d9b0:	68bb      	ldr	r3, [r7, #8]
 800d9b2:	681b      	ldr	r3, [r3, #0]
 800d9b4:	683a      	ldr	r2, [r7, #0]
 800d9b6:	429a      	cmp	r2, r3
 800d9b8:	d802      	bhi.n	800d9c0 <wc_EccPublicKeyDecode+0x7a>
            return ASN_PARSE_E;
 800d9ba:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800d9be:	e0f7      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>
        tag = input[*inOutIdx];
 800d9c0:	68bb      	ldr	r3, [r7, #8]
 800d9c2:	681b      	ldr	r3, [r3, #0]
 800d9c4:	68fa      	ldr	r2, [r7, #12]
 800d9c6:	4413      	add	r3, r2
 800d9c8:	781b      	ldrb	r3, [r3, #0]
 800d9ca:	74fb      	strb	r3, [r7, #19]
        *inOutIdx += 1;
 800d9cc:	68bb      	ldr	r3, [r7, #8]
 800d9ce:	681b      	ldr	r3, [r3, #0]
 800d9d0:	1c5a      	adds	r2, r3, #1
 800d9d2:	68bb      	ldr	r3, [r7, #8]
 800d9d4:	601a      	str	r2, [r3, #0]
        if (tag != 4 && tag != 6 && tag != 7)
 800d9d6:	7cfb      	ldrb	r3, [r7, #19]
 800d9d8:	2b04      	cmp	r3, #4
 800d9da:	d008      	beq.n	800d9ee <wc_EccPublicKeyDecode+0xa8>
 800d9dc:	7cfb      	ldrb	r3, [r7, #19]
 800d9de:	2b06      	cmp	r3, #6
 800d9e0:	d005      	beq.n	800d9ee <wc_EccPublicKeyDecode+0xa8>
 800d9e2:	7cfb      	ldrb	r3, [r7, #19]
 800d9e4:	2b07      	cmp	r3, #7
 800d9e6:	d002      	beq.n	800d9ee <wc_EccPublicKeyDecode+0xa8>
            return ASN_PARSE_E;
 800d9e8:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800d9ec:	e0e0      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>

        /* Skip Private Key */
        if (GetLength(input, inOutIdx, &length, inSz) < 0)
 800d9ee:	f107 021c 	add.w	r2, r7, #28
 800d9f2:	683b      	ldr	r3, [r7, #0]
 800d9f4:	68b9      	ldr	r1, [r7, #8]
 800d9f6:	68f8      	ldr	r0, [r7, #12]
 800d9f8:	f7fa fe96 	bl	8008728 <GetLength>
 800d9fc:	4603      	mov	r3, r0
 800d9fe:	2b00      	cmp	r3, #0
 800da00:	da02      	bge.n	800da08 <wc_EccPublicKeyDecode+0xc2>
            return ASN_PARSE_E;
 800da02:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800da06:	e0d3      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>
        if (length > ECC_MAXSIZE)
 800da08:	69fb      	ldr	r3, [r7, #28]
 800da0a:	2b42      	cmp	r3, #66	; 0x42
 800da0c:	dd02      	ble.n	800da14 <wc_EccPublicKeyDecode+0xce>
            return BUFFER_E;
 800da0e:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800da12:	e0cd      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>
        *inOutIdx += length;
 800da14:	68bb      	ldr	r3, [r7, #8]
 800da16:	681b      	ldr	r3, [r3, #0]
 800da18:	69fa      	ldr	r2, [r7, #28]
 800da1a:	441a      	add	r2, r3
 800da1c:	68bb      	ldr	r3, [r7, #8]
 800da1e:	601a      	str	r2, [r3, #0]

        /* Private Curve Header */
        if (*inOutIdx >= inSz)
 800da20:	68bb      	ldr	r3, [r7, #8]
 800da22:	681b      	ldr	r3, [r3, #0]
 800da24:	683a      	ldr	r2, [r7, #0]
 800da26:	429a      	cmp	r2, r3
 800da28:	d802      	bhi.n	800da30 <wc_EccPublicKeyDecode+0xea>
            return ASN_PARSE_E;
 800da2a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800da2e:	e0bf      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>
        tag = input[*inOutIdx];
 800da30:	68bb      	ldr	r3, [r7, #8]
 800da32:	681b      	ldr	r3, [r3, #0]
 800da34:	68fa      	ldr	r2, [r7, #12]
 800da36:	4413      	add	r3, r2
 800da38:	781b      	ldrb	r3, [r3, #0]
 800da3a:	74fb      	strb	r3, [r7, #19]
        *inOutIdx += 1;
 800da3c:	68bb      	ldr	r3, [r7, #8]
 800da3e:	681b      	ldr	r3, [r3, #0]
 800da40:	1c5a      	adds	r2, r3, #1
 800da42:	68bb      	ldr	r3, [r7, #8]
 800da44:	601a      	str	r2, [r3, #0]
        if (tag != ECC_PREFIX_0)
 800da46:	7cfb      	ldrb	r3, [r7, #19]
 800da48:	2ba0      	cmp	r3, #160	; 0xa0
 800da4a:	d002      	beq.n	800da52 <wc_EccPublicKeyDecode+0x10c>
            return ASN_ECC_KEY_E;
 800da4c:	f06f 03aa 	mvn.w	r3, #170	; 0xaa
 800da50:	e0ae      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>
        if (GetLength(input, inOutIdx, &length, inSz) <= 0)
 800da52:	f107 021c 	add.w	r2, r7, #28
 800da56:	683b      	ldr	r3, [r7, #0]
 800da58:	68b9      	ldr	r1, [r7, #8]
 800da5a:	68f8      	ldr	r0, [r7, #12]
 800da5c:	f7fa fe64 	bl	8008728 <GetLength>
 800da60:	4603      	mov	r3, r0
 800da62:	2b00      	cmp	r3, #0
 800da64:	dc1a      	bgt.n	800da9c <wc_EccPublicKeyDecode+0x156>
            return ASN_PARSE_E;
 800da66:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800da6a:	e0a1      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>
    }
    /* Standard ECC public key */
    else {
        if (GetSequence(input, inOutIdx, &length, inSz) < 0)
 800da6c:	f107 021c 	add.w	r2, r7, #28
 800da70:	683b      	ldr	r3, [r7, #0]
 800da72:	68b9      	ldr	r1, [r7, #8]
 800da74:	68f8      	ldr	r0, [r7, #12]
 800da76:	f7fa ff8b 	bl	8008990 <GetSequence>
 800da7a:	4603      	mov	r3, r0
 800da7c:	2b00      	cmp	r3, #0
 800da7e:	da02      	bge.n	800da86 <wc_EccPublicKeyDecode+0x140>
            return ASN_PARSE_E;
 800da80:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800da84:	e094      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>

        ret = SkipObjectId(input, inOutIdx, inSz);
 800da86:	683a      	ldr	r2, [r7, #0]
 800da88:	68b9      	ldr	r1, [r7, #8]
 800da8a:	68f8      	ldr	r0, [r7, #12]
 800da8c:	f7fb fe0d 	bl	80096aa <SkipObjectId>
 800da90:	6278      	str	r0, [r7, #36]	; 0x24
        if (ret != 0)
 800da92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800da94:	2b00      	cmp	r3, #0
 800da96:	d001      	beq.n	800da9c <wc_EccPublicKeyDecode+0x156>
            return ret;
 800da98:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800da9a:	e089      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>
    }

    if (*inOutIdx >= inSz) {
 800da9c:	68bb      	ldr	r3, [r7, #8]
 800da9e:	681b      	ldr	r3, [r3, #0]
 800daa0:	683a      	ldr	r2, [r7, #0]
 800daa2:	429a      	cmp	r2, r3
 800daa4:	d802      	bhi.n	800daac <wc_EccPublicKeyDecode+0x166>
        return BUFFER_E;
 800daa6:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800daaa:	e081      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>
    }

    localIdx = *inOutIdx;
 800daac:	68bb      	ldr	r3, [r7, #8]
 800daae:	681b      	ldr	r3, [r3, #0]
 800dab0:	617b      	str	r3, [r7, #20]
    if (GetASNTag(input, &localIdx, &tag, inSz) == 0 &&
 800dab2:	f107 0213 	add.w	r2, r7, #19
 800dab6:	f107 0114 	add.w	r1, r7, #20
 800daba:	683b      	ldr	r3, [r7, #0]
 800dabc:	68f8      	ldr	r0, [r7, #12]
 800dabe:	f7fa feb1 	bl	8008824 <GetASNTag>
 800dac2:	4603      	mov	r3, r0
 800dac4:	2b00      	cmp	r3, #0
 800dac6:	d105      	bne.n	800dad4 <wc_EccPublicKeyDecode+0x18e>
            tag == (ASN_SEQUENCE | ASN_CONSTRUCTED)) {
 800dac8:	7cfb      	ldrb	r3, [r7, #19]
    if (GetASNTag(input, &localIdx, &tag, inSz) == 0 &&
 800daca:	2b30      	cmp	r3, #48	; 0x30
 800dacc:	d102      	bne.n	800dad4 <wc_EccPublicKeyDecode+0x18e>
            wc_ecc_free_curve(curve, key->heap);

        if (ret < 0)
            return ret;
#else
        return ASN_PARSE_E;
 800dace:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800dad2:	e06d      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>
#endif /* WOLFSSL_CUSTOM_CURVES */
    }
    else {
        /* ecc params information */
        ret = GetObjectId(input, inOutIdx, &oidSum, oidIgnoreType, inSz);
 800dad4:	f107 0218 	add.w	r2, r7, #24
 800dad8:	683b      	ldr	r3, [r7, #0]
 800dada:	9300      	str	r3, [sp, #0]
 800dadc:	2315      	movs	r3, #21
 800dade:	68b9      	ldr	r1, [r7, #8]
 800dae0:	68f8      	ldr	r0, [r7, #12]
 800dae2:	f7fb fd7f 	bl	80095e4 <GetObjectId>
 800dae6:	6278      	str	r0, [r7, #36]	; 0x24
        if (ret != 0)
 800dae8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800daea:	2b00      	cmp	r3, #0
 800daec:	d001      	beq.n	800daf2 <wc_EccPublicKeyDecode+0x1ac>
            return ret;
 800daee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800daf0:	e05e      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>

        /* get curve id */
        if ((ret = CheckCurve(oidSum)) < 0)
 800daf2:	69bb      	ldr	r3, [r7, #24]
 800daf4:	4618      	mov	r0, r3
 800daf6:	f7fc fac4 	bl	800a082 <CheckCurve>
 800dafa:	6278      	str	r0, [r7, #36]	; 0x24
 800dafc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dafe:	2b00      	cmp	r3, #0
 800db00:	da02      	bge.n	800db08 <wc_EccPublicKeyDecode+0x1c2>
            return ECC_CURVE_OID_E;
 800db02:	f06f 03ab 	mvn.w	r3, #171	; 0xab
 800db06:	e053      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>
        else {
            curve_id = ret;
 800db08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800db0a:	62bb      	str	r3, [r7, #40]	; 0x28
        }
    }

    if (isPrivFormat) {
 800db0c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800db10:	2b00      	cmp	r3, #0
 800db12:	d025      	beq.n	800db60 <wc_EccPublicKeyDecode+0x21a>
        /* Public Curve Header - skip */
        if (*inOutIdx >= inSz)
 800db14:	68bb      	ldr	r3, [r7, #8]
 800db16:	681b      	ldr	r3, [r3, #0]
 800db18:	683a      	ldr	r2, [r7, #0]
 800db1a:	429a      	cmp	r2, r3
 800db1c:	d802      	bhi.n	800db24 <wc_EccPublicKeyDecode+0x1de>
            return ASN_PARSE_E;
 800db1e:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800db22:	e045      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>
        tag = input[*inOutIdx];
 800db24:	68bb      	ldr	r3, [r7, #8]
 800db26:	681b      	ldr	r3, [r3, #0]
 800db28:	68fa      	ldr	r2, [r7, #12]
 800db2a:	4413      	add	r3, r2
 800db2c:	781b      	ldrb	r3, [r3, #0]
 800db2e:	74fb      	strb	r3, [r7, #19]
        *inOutIdx += 1;
 800db30:	68bb      	ldr	r3, [r7, #8]
 800db32:	681b      	ldr	r3, [r3, #0]
 800db34:	1c5a      	adds	r2, r3, #1
 800db36:	68bb      	ldr	r3, [r7, #8]
 800db38:	601a      	str	r2, [r3, #0]
        if (tag != ECC_PREFIX_1)
 800db3a:	7cfb      	ldrb	r3, [r7, #19]
 800db3c:	2ba1      	cmp	r3, #161	; 0xa1
 800db3e:	d002      	beq.n	800db46 <wc_EccPublicKeyDecode+0x200>
            return ASN_ECC_KEY_E;
 800db40:	f06f 03aa 	mvn.w	r3, #170	; 0xaa
 800db44:	e034      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>
        if (GetLength(input, inOutIdx, &length, inSz) <= 0)
 800db46:	f107 021c 	add.w	r2, r7, #28
 800db4a:	683b      	ldr	r3, [r7, #0]
 800db4c:	68b9      	ldr	r1, [r7, #8]
 800db4e:	68f8      	ldr	r0, [r7, #12]
 800db50:	f7fa fdea 	bl	8008728 <GetLength>
 800db54:	4603      	mov	r3, r0
 800db56:	2b00      	cmp	r3, #0
 800db58:	dc02      	bgt.n	800db60 <wc_EccPublicKeyDecode+0x21a>
            return ASN_PARSE_E;
 800db5a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800db5e:	e027      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>
    }

    /* key header */
    ret = CheckBitString(input, inOutIdx, &length, inSz, 1, NULL);
 800db60:	f107 021c 	add.w	r2, r7, #28
 800db64:	2300      	movs	r3, #0
 800db66:	9301      	str	r3, [sp, #4]
 800db68:	2301      	movs	r3, #1
 800db6a:	9300      	str	r3, [sp, #0]
 800db6c:	683b      	ldr	r3, [r7, #0]
 800db6e:	68b9      	ldr	r1, [r7, #8]
 800db70:	68f8      	ldr	r0, [r7, #12]
 800db72:	f7fb f924 	bl	8008dbe <CheckBitString>
 800db76:	6278      	str	r0, [r7, #36]	; 0x24
    if (ret != 0)
 800db78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800db7a:	2b00      	cmp	r3, #0
 800db7c:	d001      	beq.n	800db82 <wc_EccPublicKeyDecode+0x23c>
        return ret;
 800db7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800db80:	e016      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>

    /* This is the raw point data compressed or uncompressed. */
    if (wc_ecc_import_x963_ex(input + *inOutIdx, length, key,
 800db82:	68bb      	ldr	r3, [r7, #8]
 800db84:	681b      	ldr	r3, [r3, #0]
 800db86:	68fa      	ldr	r2, [r7, #12]
 800db88:	18d0      	adds	r0, r2, r3
 800db8a:	69fb      	ldr	r3, [r7, #28]
 800db8c:	4619      	mov	r1, r3
 800db8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800db90:	687a      	ldr	r2, [r7, #4]
 800db92:	f000 ff85 	bl	800eaa0 <wc_ecc_import_x963_ex>
 800db96:	4603      	mov	r3, r0
 800db98:	2b00      	cmp	r3, #0
 800db9a:	d002      	beq.n	800dba2 <wc_EccPublicKeyDecode+0x25c>
                                                            curve_id) != 0) {
        return ASN_ECC_KEY_E;
 800db9c:	f06f 03aa 	mvn.w	r3, #170	; 0xaa
 800dba0:	e006      	b.n	800dbb0 <wc_EccPublicKeyDecode+0x26a>
    }

    *inOutIdx += length;
 800dba2:	68bb      	ldr	r3, [r7, #8]
 800dba4:	681b      	ldr	r3, [r3, #0]
 800dba6:	69fa      	ldr	r2, [r7, #28]
 800dba8:	441a      	add	r2, r3
 800dbaa:	68bb      	ldr	r3, [r7, #8]
 800dbac:	601a      	str	r2, [r3, #0]

    return 0;
 800dbae:	2300      	movs	r3, #0
}
 800dbb0:	4618      	mov	r0, r3
 800dbb2:	3730      	adds	r7, #48	; 0x30
 800dbb4:	46bd      	mov	sp, r7
 800dbb6:	bd80      	pop	{r7, pc}

0800dbb8 <ctMaskLTE>:
    return (byte)((((word32)b - a - 1) >> 31) - 1);
}

/* Constant time - mask set when a <= b. */
WC_STATIC WC_INLINE byte ctMaskLTE(int a, int b)
{
 800dbb8:	b480      	push	{r7}
 800dbba:	b083      	sub	sp, #12
 800dbbc:	af00      	add	r7, sp, #0
 800dbbe:	6078      	str	r0, [r7, #4]
 800dbc0:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)b - a    ) >> 31) - 1);
 800dbc2:	683a      	ldr	r2, [r7, #0]
 800dbc4:	687b      	ldr	r3, [r7, #4]
 800dbc6:	1ad3      	subs	r3, r2, r3
 800dbc8:	0fdb      	lsrs	r3, r3, #31
 800dbca:	b2db      	uxtb	r3, r3
 800dbcc:	3b01      	subs	r3, #1
 800dbce:	b2db      	uxtb	r3, r3
}
 800dbd0:	4618      	mov	r0, r3
 800dbd2:	370c      	adds	r7, #12
 800dbd4:	46bd      	mov	sp, r7
 800dbd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dbda:	4770      	bx	lr

0800dbdc <Base64_Char2Val>:
/* 0x78: x y z           */    49,  50,  51
                            };
#define BASE64DECODE_SZ    (byte)(sizeof(base64Decode))

static WC_INLINE byte Base64_Char2Val(byte c)
{
 800dbdc:	b580      	push	{r7, lr}
 800dbde:	b084      	sub	sp, #16
 800dbe0:	af00      	add	r7, sp, #0
 800dbe2:	4603      	mov	r3, r0
 800dbe4:	71fb      	strb	r3, [r7, #7]
     * 64 bytes in a cache line - first line has 64, second has 16
     */
    byte v;
    byte mask;

    c -= BASE64_MIN;
 800dbe6:	79fb      	ldrb	r3, [r7, #7]
 800dbe8:	3b2b      	subs	r3, #43	; 0x2b
 800dbea:	71fb      	strb	r3, [r7, #7]
    mask = ctMaskLTE(c, 0x3f);
 800dbec:	79fb      	ldrb	r3, [r7, #7]
 800dbee:	213f      	movs	r1, #63	; 0x3f
 800dbf0:	4618      	mov	r0, r3
 800dbf2:	f7ff ffe1 	bl	800dbb8 <ctMaskLTE>
 800dbf6:	4603      	mov	r3, r0
 800dbf8:	73fb      	strb	r3, [r7, #15]
    /* Load a value from the first cache line and use when mask set. */
    v  = base64Decode[ c & 0x3f        ] &   mask ;
 800dbfa:	79fb      	ldrb	r3, [r7, #7]
 800dbfc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800dc00:	4a0e      	ldr	r2, [pc, #56]	; (800dc3c <Base64_Char2Val+0x60>)
 800dc02:	5cd2      	ldrb	r2, [r2, r3]
 800dc04:	7bfb      	ldrb	r3, [r7, #15]
 800dc06:	4013      	ands	r3, r2
 800dc08:	73bb      	strb	r3, [r7, #14]
    /* Load a value from the second cache line and use when mask not set. */
    v |= base64Decode[(c & 0x0f) | 0x40] & (~mask);
 800dc0a:	79fb      	ldrb	r3, [r7, #7]
 800dc0c:	f003 030f 	and.w	r3, r3, #15
 800dc10:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800dc14:	4a09      	ldr	r2, [pc, #36]	; (800dc3c <Base64_Char2Val+0x60>)
 800dc16:	5cd3      	ldrb	r3, [r2, r3]
 800dc18:	b25a      	sxtb	r2, r3
 800dc1a:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800dc1e:	43db      	mvns	r3, r3
 800dc20:	b25b      	sxtb	r3, r3
 800dc22:	4013      	ands	r3, r2
 800dc24:	b25a      	sxtb	r2, r3
 800dc26:	f997 300e 	ldrsb.w	r3, [r7, #14]
 800dc2a:	4313      	orrs	r3, r2
 800dc2c:	b25b      	sxtb	r3, r3
 800dc2e:	73bb      	strb	r3, [r7, #14]

    return v;
 800dc30:	7bbb      	ldrb	r3, [r7, #14]
#else
    return base64Decode[c - BASE64_MIN];
#endif
}
 800dc32:	4618      	mov	r0, r3
 800dc34:	3710      	adds	r7, #16
 800dc36:	46bd      	mov	sp, r7
 800dc38:	bd80      	pop	{r7, pc}
 800dc3a:	bf00      	nop
 800dc3c:	0801ad34 	.word	0x0801ad34

0800dc40 <Base64_SkipNewline>:
#endif

static WC_INLINE int Base64_SkipNewline(const byte* in, word32 *inLen, word32 *outJ)
{
 800dc40:	b480      	push	{r7}
 800dc42:	b089      	sub	sp, #36	; 0x24
 800dc44:	af00      	add	r7, sp, #0
 800dc46:	60f8      	str	r0, [r7, #12]
 800dc48:	60b9      	str	r1, [r7, #8]
 800dc4a:	607a      	str	r2, [r7, #4]
    word32 len = *inLen;
 800dc4c:	68bb      	ldr	r3, [r7, #8]
 800dc4e:	681b      	ldr	r3, [r3, #0]
 800dc50:	61fb      	str	r3, [r7, #28]
    word32 j = *outJ;
 800dc52:	687b      	ldr	r3, [r7, #4]
 800dc54:	681b      	ldr	r3, [r3, #0]
 800dc56:	61bb      	str	r3, [r7, #24]
    if (len && (in[j] == ' ' || in[j] == '\r' || in[j] == '\n')) {
 800dc58:	69fb      	ldr	r3, [r7, #28]
 800dc5a:	2b00      	cmp	r3, #0
 800dc5c:	d042      	beq.n	800dce4 <Base64_SkipNewline+0xa4>
 800dc5e:	68fa      	ldr	r2, [r7, #12]
 800dc60:	69bb      	ldr	r3, [r7, #24]
 800dc62:	4413      	add	r3, r2
 800dc64:	781b      	ldrb	r3, [r3, #0]
 800dc66:	2b20      	cmp	r3, #32
 800dc68:	d00b      	beq.n	800dc82 <Base64_SkipNewline+0x42>
 800dc6a:	68fa      	ldr	r2, [r7, #12]
 800dc6c:	69bb      	ldr	r3, [r7, #24]
 800dc6e:	4413      	add	r3, r2
 800dc70:	781b      	ldrb	r3, [r3, #0]
 800dc72:	2b0d      	cmp	r3, #13
 800dc74:	d005      	beq.n	800dc82 <Base64_SkipNewline+0x42>
 800dc76:	68fa      	ldr	r2, [r7, #12]
 800dc78:	69bb      	ldr	r3, [r7, #24]
 800dc7a:	4413      	add	r3, r2
 800dc7c:	781b      	ldrb	r3, [r3, #0]
 800dc7e:	2b0a      	cmp	r3, #10
 800dc80:	d130      	bne.n	800dce4 <Base64_SkipNewline+0xa4>
        byte endLine = in[j++];
 800dc82:	69bb      	ldr	r3, [r7, #24]
 800dc84:	1c5a      	adds	r2, r3, #1
 800dc86:	61ba      	str	r2, [r7, #24]
 800dc88:	68fa      	ldr	r2, [r7, #12]
 800dc8a:	4413      	add	r3, r2
 800dc8c:	781b      	ldrb	r3, [r3, #0]
 800dc8e:	75fb      	strb	r3, [r7, #23]
        len--;
 800dc90:	69fb      	ldr	r3, [r7, #28]
 800dc92:	3b01      	subs	r3, #1
 800dc94:	61fb      	str	r3, [r7, #28]
        while (len && endLine == ' ') {   /* allow trailing whitespace */
 800dc96:	e009      	b.n	800dcac <Base64_SkipNewline+0x6c>
            endLine = in[j++];
 800dc98:	69bb      	ldr	r3, [r7, #24]
 800dc9a:	1c5a      	adds	r2, r3, #1
 800dc9c:	61ba      	str	r2, [r7, #24]
 800dc9e:	68fa      	ldr	r2, [r7, #12]
 800dca0:	4413      	add	r3, r2
 800dca2:	781b      	ldrb	r3, [r3, #0]
 800dca4:	75fb      	strb	r3, [r7, #23]
            len--;
 800dca6:	69fb      	ldr	r3, [r7, #28]
 800dca8:	3b01      	subs	r3, #1
 800dcaa:	61fb      	str	r3, [r7, #28]
        while (len && endLine == ' ') {   /* allow trailing whitespace */
 800dcac:	69fb      	ldr	r3, [r7, #28]
 800dcae:	2b00      	cmp	r3, #0
 800dcb0:	d002      	beq.n	800dcb8 <Base64_SkipNewline+0x78>
 800dcb2:	7dfb      	ldrb	r3, [r7, #23]
 800dcb4:	2b20      	cmp	r3, #32
 800dcb6:	d0ef      	beq.n	800dc98 <Base64_SkipNewline+0x58>
        }
        if (endLine == '\r') {
 800dcb8:	7dfb      	ldrb	r3, [r7, #23]
 800dcba:	2b0d      	cmp	r3, #13
 800dcbc:	d10c      	bne.n	800dcd8 <Base64_SkipNewline+0x98>
            if (len) {
 800dcbe:	69fb      	ldr	r3, [r7, #28]
 800dcc0:	2b00      	cmp	r3, #0
 800dcc2:	d009      	beq.n	800dcd8 <Base64_SkipNewline+0x98>
                endLine = in[j++];
 800dcc4:	69bb      	ldr	r3, [r7, #24]
 800dcc6:	1c5a      	adds	r2, r3, #1
 800dcc8:	61ba      	str	r2, [r7, #24]
 800dcca:	68fa      	ldr	r2, [r7, #12]
 800dccc:	4413      	add	r3, r2
 800dcce:	781b      	ldrb	r3, [r3, #0]
 800dcd0:	75fb      	strb	r3, [r7, #23]
                len--;
 800dcd2:	69fb      	ldr	r3, [r7, #28]
 800dcd4:	3b01      	subs	r3, #1
 800dcd6:	61fb      	str	r3, [r7, #28]
            }
        }
        if (endLine != '\n') {
 800dcd8:	7dfb      	ldrb	r3, [r7, #23]
 800dcda:	2b0a      	cmp	r3, #10
 800dcdc:	d002      	beq.n	800dce4 <Base64_SkipNewline+0xa4>
            WOLFSSL_MSG("Bad end of line in Base64 Decode");
            return ASN_INPUT_E;
 800dcde:	f06f 0399 	mvn.w	r3, #153	; 0x99
 800dce2:	e00c      	b.n	800dcfe <Base64_SkipNewline+0xbe>
        }
    }
    if (!len) {
 800dce4:	69fb      	ldr	r3, [r7, #28]
 800dce6:	2b00      	cmp	r3, #0
 800dce8:	d102      	bne.n	800dcf0 <Base64_SkipNewline+0xb0>
        return BUFFER_E;
 800dcea:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800dcee:	e006      	b.n	800dcfe <Base64_SkipNewline+0xbe>
    }
    *inLen = len;
 800dcf0:	68bb      	ldr	r3, [r7, #8]
 800dcf2:	69fa      	ldr	r2, [r7, #28]
 800dcf4:	601a      	str	r2, [r3, #0]
    *outJ = j;
 800dcf6:	687b      	ldr	r3, [r7, #4]
 800dcf8:	69ba      	ldr	r2, [r7, #24]
 800dcfa:	601a      	str	r2, [r3, #0]
    return 0;
 800dcfc:	2300      	movs	r3, #0
}
 800dcfe:	4618      	mov	r0, r3
 800dd00:	3724      	adds	r7, #36	; 0x24
 800dd02:	46bd      	mov	sp, r7
 800dd04:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd08:	4770      	bx	lr

0800dd0a <Base64_Decode>:

int Base64_Decode(const byte* in, word32 inLen, byte* out, word32* outLen)
{
 800dd0a:	b580      	push	{r7, lr}
 800dd0c:	b08e      	sub	sp, #56	; 0x38
 800dd0e:	af00      	add	r7, sp, #0
 800dd10:	60f8      	str	r0, [r7, #12]
 800dd12:	60b9      	str	r1, [r7, #8]
 800dd14:	607a      	str	r2, [r7, #4]
 800dd16:	603b      	str	r3, [r7, #0]
    word32 i = 0;
 800dd18:	2300      	movs	r3, #0
 800dd1a:	637b      	str	r3, [r7, #52]	; 0x34
    word32 j = 0;
 800dd1c:	2300      	movs	r3, #0
 800dd1e:	617b      	str	r3, [r7, #20]
    word32 plainSz = inLen - ((inLen + (BASE64_LINE_SZ - 1)) / BASE64_LINE_SZ );
 800dd20:	68ba      	ldr	r2, [r7, #8]
 800dd22:	68bb      	ldr	r3, [r7, #8]
 800dd24:	333f      	adds	r3, #63	; 0x3f
 800dd26:	099b      	lsrs	r3, r3, #6
 800dd28:	1ad3      	subs	r3, r2, r3
 800dd2a:	62bb      	str	r3, [r7, #40]	; 0x28
    int ret;
#ifndef BASE64_NO_TABLE
    const byte maxIdx = BASE64DECODE_SZ + BASE64_MIN - 1;
 800dd2c:	237a      	movs	r3, #122	; 0x7a
 800dd2e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
#endif

    plainSz = (plainSz * 3 + 3) / 4;
 800dd32:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dd34:	1c5a      	adds	r2, r3, #1
 800dd36:	4613      	mov	r3, r2
 800dd38:	005b      	lsls	r3, r3, #1
 800dd3a:	4413      	add	r3, r2
 800dd3c:	089b      	lsrs	r3, r3, #2
 800dd3e:	62bb      	str	r3, [r7, #40]	; 0x28
    if (plainSz > *outLen) return BAD_FUNC_ARG;
 800dd40:	683b      	ldr	r3, [r7, #0]
 800dd42:	681b      	ldr	r3, [r3, #0]
 800dd44:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800dd46:	429a      	cmp	r2, r3
 800dd48:	f240 8129 	bls.w	800df9e <Base64_Decode+0x294>
 800dd4c:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800dd50:	e140      	b.n	800dfd4 <Base64_Decode+0x2ca>

    while (inLen > 3) {
        int pad3 = 0;
 800dd52:	2300      	movs	r3, #0
 800dd54:	633b      	str	r3, [r7, #48]	; 0x30
        int pad4 = 0;
 800dd56:	2300      	movs	r3, #0
 800dd58:	62fb      	str	r3, [r7, #44]	; 0x2c
        byte b1, b2, b3;
        byte e1, e2, e3, e4;

        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 800dd5a:	f107 0214 	add.w	r2, r7, #20
 800dd5e:	f107 0308 	add.w	r3, r7, #8
 800dd62:	4619      	mov	r1, r3
 800dd64:	68f8      	ldr	r0, [r7, #12]
 800dd66:	f7ff ff6b 	bl	800dc40 <Base64_SkipNewline>
 800dd6a:	6238      	str	r0, [r7, #32]
 800dd6c:	6a3b      	ldr	r3, [r7, #32]
 800dd6e:	2b00      	cmp	r3, #0
 800dd70:	d006      	beq.n	800dd80 <Base64_Decode+0x76>
            if (ret == BUFFER_E) {
 800dd72:	6a3b      	ldr	r3, [r7, #32]
 800dd74:	f113 0f84 	cmn.w	r3, #132	; 0x84
 800dd78:	f000 8116 	beq.w	800dfa8 <Base64_Decode+0x29e>
                /* Running out of buffer here is not an error */
                break;
            }
            return ret;
 800dd7c:	6a3b      	ldr	r3, [r7, #32]
 800dd7e:	e129      	b.n	800dfd4 <Base64_Decode+0x2ca>
        }
        e1 = in[j++];
 800dd80:	697b      	ldr	r3, [r7, #20]
 800dd82:	1c5a      	adds	r2, r3, #1
 800dd84:	617a      	str	r2, [r7, #20]
 800dd86:	68fa      	ldr	r2, [r7, #12]
 800dd88:	4413      	add	r3, r2
 800dd8a:	781b      	ldrb	r3, [r3, #0]
 800dd8c:	77fb      	strb	r3, [r7, #31]
        if (e1 == '\0') {
 800dd8e:	7ffb      	ldrb	r3, [r7, #31]
 800dd90:	2b00      	cmp	r3, #0
 800dd92:	f000 810b 	beq.w	800dfac <Base64_Decode+0x2a2>
            break;
        }
        inLen--;
 800dd96:	68bb      	ldr	r3, [r7, #8]
 800dd98:	3b01      	subs	r3, #1
 800dd9a:	60bb      	str	r3, [r7, #8]
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 800dd9c:	f107 0214 	add.w	r2, r7, #20
 800dda0:	f107 0308 	add.w	r3, r7, #8
 800dda4:	4619      	mov	r1, r3
 800dda6:	68f8      	ldr	r0, [r7, #12]
 800dda8:	f7ff ff4a 	bl	800dc40 <Base64_SkipNewline>
 800ddac:	6238      	str	r0, [r7, #32]
 800ddae:	6a3b      	ldr	r3, [r7, #32]
 800ddb0:	2b00      	cmp	r3, #0
 800ddb2:	d001      	beq.n	800ddb8 <Base64_Decode+0xae>
            return ret;
 800ddb4:	6a3b      	ldr	r3, [r7, #32]
 800ddb6:	e10d      	b.n	800dfd4 <Base64_Decode+0x2ca>
        }
        e2 = in[j++];
 800ddb8:	697b      	ldr	r3, [r7, #20]
 800ddba:	1c5a      	adds	r2, r3, #1
 800ddbc:	617a      	str	r2, [r7, #20]
 800ddbe:	68fa      	ldr	r2, [r7, #12]
 800ddc0:	4413      	add	r3, r2
 800ddc2:	781b      	ldrb	r3, [r3, #0]
 800ddc4:	77bb      	strb	r3, [r7, #30]
        inLen--;
 800ddc6:	68bb      	ldr	r3, [r7, #8]
 800ddc8:	3b01      	subs	r3, #1
 800ddca:	60bb      	str	r3, [r7, #8]
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 800ddcc:	f107 0214 	add.w	r2, r7, #20
 800ddd0:	f107 0308 	add.w	r3, r7, #8
 800ddd4:	4619      	mov	r1, r3
 800ddd6:	68f8      	ldr	r0, [r7, #12]
 800ddd8:	f7ff ff32 	bl	800dc40 <Base64_SkipNewline>
 800dddc:	6238      	str	r0, [r7, #32]
 800ddde:	6a3b      	ldr	r3, [r7, #32]
 800dde0:	2b00      	cmp	r3, #0
 800dde2:	d001      	beq.n	800dde8 <Base64_Decode+0xde>
            return ret;
 800dde4:	6a3b      	ldr	r3, [r7, #32]
 800dde6:	e0f5      	b.n	800dfd4 <Base64_Decode+0x2ca>
        }
        e3 = in[j++];
 800dde8:	697b      	ldr	r3, [r7, #20]
 800ddea:	1c5a      	adds	r2, r3, #1
 800ddec:	617a      	str	r2, [r7, #20]
 800ddee:	68fa      	ldr	r2, [r7, #12]
 800ddf0:	4413      	add	r3, r2
 800ddf2:	781b      	ldrb	r3, [r3, #0]
 800ddf4:	777b      	strb	r3, [r7, #29]
        inLen--;
 800ddf6:	68bb      	ldr	r3, [r7, #8]
 800ddf8:	3b01      	subs	r3, #1
 800ddfa:	60bb      	str	r3, [r7, #8]
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 800ddfc:	f107 0214 	add.w	r2, r7, #20
 800de00:	f107 0308 	add.w	r3, r7, #8
 800de04:	4619      	mov	r1, r3
 800de06:	68f8      	ldr	r0, [r7, #12]
 800de08:	f7ff ff1a 	bl	800dc40 <Base64_SkipNewline>
 800de0c:	6238      	str	r0, [r7, #32]
 800de0e:	6a3b      	ldr	r3, [r7, #32]
 800de10:	2b00      	cmp	r3, #0
 800de12:	d001      	beq.n	800de18 <Base64_Decode+0x10e>
            return ret;
 800de14:	6a3b      	ldr	r3, [r7, #32]
 800de16:	e0dd      	b.n	800dfd4 <Base64_Decode+0x2ca>
        }
        e4 = in[j++];
 800de18:	697b      	ldr	r3, [r7, #20]
 800de1a:	1c5a      	adds	r2, r3, #1
 800de1c:	617a      	str	r2, [r7, #20]
 800de1e:	68fa      	ldr	r2, [r7, #12]
 800de20:	4413      	add	r3, r2
 800de22:	781b      	ldrb	r3, [r3, #0]
 800de24:	773b      	strb	r3, [r7, #28]
        inLen--;
 800de26:	68bb      	ldr	r3, [r7, #8]
 800de28:	3b01      	subs	r3, #1
 800de2a:	60bb      	str	r3, [r7, #8]

        if (e3 == PAD)
 800de2c:	7f7b      	ldrb	r3, [r7, #29]
 800de2e:	2b3d      	cmp	r3, #61	; 0x3d
 800de30:	d101      	bne.n	800de36 <Base64_Decode+0x12c>
            pad3 = 1;
 800de32:	2301      	movs	r3, #1
 800de34:	633b      	str	r3, [r7, #48]	; 0x30
        if (e4 == PAD)
 800de36:	7f3b      	ldrb	r3, [r7, #28]
 800de38:	2b3d      	cmp	r3, #61	; 0x3d
 800de3a:	d101      	bne.n	800de40 <Base64_Decode+0x136>
            pad4 = 1;
 800de3c:	2301      	movs	r3, #1
 800de3e:	62fb      	str	r3, [r7, #44]	; 0x2c

        if (pad3 && !pad4)
 800de40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800de42:	2b00      	cmp	r3, #0
 800de44:	d005      	beq.n	800de52 <Base64_Decode+0x148>
 800de46:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800de48:	2b00      	cmp	r3, #0
 800de4a:	d102      	bne.n	800de52 <Base64_Decode+0x148>
            return ASN_INPUT_E;
 800de4c:	f06f 0399 	mvn.w	r3, #153	; 0x99
 800de50:	e0c0      	b.n	800dfd4 <Base64_Decode+0x2ca>

#ifndef BASE64_NO_TABLE
        if (e1 < BASE64_MIN || e2 < BASE64_MIN || e3 < BASE64_MIN ||
 800de52:	7ffb      	ldrb	r3, [r7, #31]
 800de54:	2b2a      	cmp	r3, #42	; 0x2a
 800de56:	d908      	bls.n	800de6a <Base64_Decode+0x160>
 800de58:	7fbb      	ldrb	r3, [r7, #30]
 800de5a:	2b2a      	cmp	r3, #42	; 0x2a
 800de5c:	d905      	bls.n	800de6a <Base64_Decode+0x160>
 800de5e:	7f7b      	ldrb	r3, [r7, #29]
 800de60:	2b2a      	cmp	r3, #42	; 0x2a
 800de62:	d902      	bls.n	800de6a <Base64_Decode+0x160>
 800de64:	7f3b      	ldrb	r3, [r7, #28]
 800de66:	2b2a      	cmp	r3, #42	; 0x2a
 800de68:	d802      	bhi.n	800de70 <Base64_Decode+0x166>
                                                              e4 < BASE64_MIN) {
            WOLFSSL_MSG("Bad Base64 Decode data, too small");
            return ASN_INPUT_E;
 800de6a:	f06f 0399 	mvn.w	r3, #153	; 0x99
 800de6e:	e0b1      	b.n	800dfd4 <Base64_Decode+0x2ca>
        }

        if (e1 > maxIdx || e2 > maxIdx || e3 > maxIdx || e4 > maxIdx) {
 800de70:	7ffa      	ldrb	r2, [r7, #31]
 800de72:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800de76:	429a      	cmp	r2, r3
 800de78:	d80e      	bhi.n	800de98 <Base64_Decode+0x18e>
 800de7a:	7fba      	ldrb	r2, [r7, #30]
 800de7c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800de80:	429a      	cmp	r2, r3
 800de82:	d809      	bhi.n	800de98 <Base64_Decode+0x18e>
 800de84:	7f7a      	ldrb	r2, [r7, #29]
 800de86:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800de8a:	429a      	cmp	r2, r3
 800de8c:	d804      	bhi.n	800de98 <Base64_Decode+0x18e>
 800de8e:	7f3a      	ldrb	r2, [r7, #28]
 800de90:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800de94:	429a      	cmp	r2, r3
 800de96:	d902      	bls.n	800de9e <Base64_Decode+0x194>
            WOLFSSL_MSG("Bad Base64 Decode data, too big");
            return ASN_INPUT_E;
 800de98:	f06f 0399 	mvn.w	r3, #153	; 0x99
 800de9c:	e09a      	b.n	800dfd4 <Base64_Decode+0x2ca>
        }
#endif

        if (i + 1 + !pad3 + !pad4 > *outLen) {
 800de9e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800dea0:	2b00      	cmp	r3, #0
 800dea2:	bf0c      	ite	eq
 800dea4:	2301      	moveq	r3, #1
 800dea6:	2300      	movne	r3, #0
 800dea8:	b2db      	uxtb	r3, r3
 800deaa:	461a      	mov	r2, r3
 800deac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800deae:	4413      	add	r3, r2
 800deb0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800deb2:	2a00      	cmp	r2, #0
 800deb4:	bf0c      	ite	eq
 800deb6:	2201      	moveq	r2, #1
 800deb8:	2200      	movne	r2, #0
 800deba:	b2d2      	uxtb	r2, r2
 800debc:	4413      	add	r3, r2
 800debe:	1c5a      	adds	r2, r3, #1
 800dec0:	683b      	ldr	r3, [r7, #0]
 800dec2:	681b      	ldr	r3, [r3, #0]
 800dec4:	429a      	cmp	r2, r3
 800dec6:	d902      	bls.n	800dece <Base64_Decode+0x1c4>
            WOLFSSL_MSG("Bad Base64 Decode out buffer, too small");
            return BAD_FUNC_ARG;
 800dec8:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800decc:	e082      	b.n	800dfd4 <Base64_Decode+0x2ca>
        }

        e1 = Base64_Char2Val(e1);
 800dece:	7ffb      	ldrb	r3, [r7, #31]
 800ded0:	4618      	mov	r0, r3
 800ded2:	f7ff fe83 	bl	800dbdc <Base64_Char2Val>
 800ded6:	4603      	mov	r3, r0
 800ded8:	77fb      	strb	r3, [r7, #31]
        e2 = Base64_Char2Val(e2);
 800deda:	7fbb      	ldrb	r3, [r7, #30]
 800dedc:	4618      	mov	r0, r3
 800dede:	f7ff fe7d 	bl	800dbdc <Base64_Char2Val>
 800dee2:	4603      	mov	r3, r0
 800dee4:	77bb      	strb	r3, [r7, #30]
        e3 = (e3 == PAD) ? 0 : Base64_Char2Val(e3);
 800dee6:	7f7b      	ldrb	r3, [r7, #29]
 800dee8:	2b3d      	cmp	r3, #61	; 0x3d
 800deea:	d005      	beq.n	800def8 <Base64_Decode+0x1ee>
 800deec:	7f7b      	ldrb	r3, [r7, #29]
 800deee:	4618      	mov	r0, r3
 800def0:	f7ff fe74 	bl	800dbdc <Base64_Char2Val>
 800def4:	4603      	mov	r3, r0
 800def6:	e000      	b.n	800defa <Base64_Decode+0x1f0>
 800def8:	2300      	movs	r3, #0
 800defa:	777b      	strb	r3, [r7, #29]
        e4 = (e4 == PAD) ? 0 : Base64_Char2Val(e4);
 800defc:	7f3b      	ldrb	r3, [r7, #28]
 800defe:	2b3d      	cmp	r3, #61	; 0x3d
 800df00:	d005      	beq.n	800df0e <Base64_Decode+0x204>
 800df02:	7f3b      	ldrb	r3, [r7, #28]
 800df04:	4618      	mov	r0, r3
 800df06:	f7ff fe69 	bl	800dbdc <Base64_Char2Val>
 800df0a:	4603      	mov	r3, r0
 800df0c:	e000      	b.n	800df10 <Base64_Decode+0x206>
 800df0e:	2300      	movs	r3, #0
 800df10:	773b      	strb	r3, [r7, #28]

        if (e1 == BAD || e2 == BAD || e3 == BAD || e4 == BAD) {
 800df12:	7ffb      	ldrb	r3, [r7, #31]
 800df14:	2bff      	cmp	r3, #255	; 0xff
 800df16:	d008      	beq.n	800df2a <Base64_Decode+0x220>
 800df18:	7fbb      	ldrb	r3, [r7, #30]
 800df1a:	2bff      	cmp	r3, #255	; 0xff
 800df1c:	d005      	beq.n	800df2a <Base64_Decode+0x220>
 800df1e:	7f7b      	ldrb	r3, [r7, #29]
 800df20:	2bff      	cmp	r3, #255	; 0xff
 800df22:	d002      	beq.n	800df2a <Base64_Decode+0x220>
 800df24:	7f3b      	ldrb	r3, [r7, #28]
 800df26:	2bff      	cmp	r3, #255	; 0xff
 800df28:	d102      	bne.n	800df30 <Base64_Decode+0x226>
            WOLFSSL_MSG("Bad Base64 Decode bad character");
            return ASN_INPUT_E;
 800df2a:	f06f 0399 	mvn.w	r3, #153	; 0x99
 800df2e:	e051      	b.n	800dfd4 <Base64_Decode+0x2ca>
        }

        b1 = (byte)((e1 << 2) | (e2 >> 4));
 800df30:	7ffb      	ldrb	r3, [r7, #31]
 800df32:	009b      	lsls	r3, r3, #2
 800df34:	b25a      	sxtb	r2, r3
 800df36:	7fbb      	ldrb	r3, [r7, #30]
 800df38:	091b      	lsrs	r3, r3, #4
 800df3a:	b2db      	uxtb	r3, r3
 800df3c:	b25b      	sxtb	r3, r3
 800df3e:	4313      	orrs	r3, r2
 800df40:	b25b      	sxtb	r3, r3
 800df42:	76fb      	strb	r3, [r7, #27]
        b2 = (byte)(((e2 & 0xF) << 4) | (e3 >> 2));
 800df44:	7fbb      	ldrb	r3, [r7, #30]
 800df46:	011b      	lsls	r3, r3, #4
 800df48:	b25a      	sxtb	r2, r3
 800df4a:	7f7b      	ldrb	r3, [r7, #29]
 800df4c:	089b      	lsrs	r3, r3, #2
 800df4e:	b2db      	uxtb	r3, r3
 800df50:	b25b      	sxtb	r3, r3
 800df52:	4313      	orrs	r3, r2
 800df54:	b25b      	sxtb	r3, r3
 800df56:	76bb      	strb	r3, [r7, #26]
        b3 = (byte)(((e3 & 0x3) << 6) | e4);
 800df58:	7f7b      	ldrb	r3, [r7, #29]
 800df5a:	019b      	lsls	r3, r3, #6
 800df5c:	b25a      	sxtb	r2, r3
 800df5e:	f997 301c 	ldrsb.w	r3, [r7, #28]
 800df62:	4313      	orrs	r3, r2
 800df64:	b25b      	sxtb	r3, r3
 800df66:	767b      	strb	r3, [r7, #25]

        out[i++] = b1;
 800df68:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800df6a:	1c5a      	adds	r2, r3, #1
 800df6c:	637a      	str	r2, [r7, #52]	; 0x34
 800df6e:	687a      	ldr	r2, [r7, #4]
 800df70:	4413      	add	r3, r2
 800df72:	7efa      	ldrb	r2, [r7, #27]
 800df74:	701a      	strb	r2, [r3, #0]
        if (!pad3)
 800df76:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800df78:	2b00      	cmp	r3, #0
 800df7a:	d106      	bne.n	800df8a <Base64_Decode+0x280>
            out[i++] = b2;
 800df7c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800df7e:	1c5a      	adds	r2, r3, #1
 800df80:	637a      	str	r2, [r7, #52]	; 0x34
 800df82:	687a      	ldr	r2, [r7, #4]
 800df84:	4413      	add	r3, r2
 800df86:	7eba      	ldrb	r2, [r7, #26]
 800df88:	701a      	strb	r2, [r3, #0]
        if (!pad4)
 800df8a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800df8c:	2b00      	cmp	r3, #0
 800df8e:	d10f      	bne.n	800dfb0 <Base64_Decode+0x2a6>
            out[i++] = b3;
 800df90:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800df92:	1c5a      	adds	r2, r3, #1
 800df94:	637a      	str	r2, [r7, #52]	; 0x34
 800df96:	687a      	ldr	r2, [r7, #4]
 800df98:	4413      	add	r3, r2
 800df9a:	7e7a      	ldrb	r2, [r7, #25]
 800df9c:	701a      	strb	r2, [r3, #0]
    while (inLen > 3) {
 800df9e:	68bb      	ldr	r3, [r7, #8]
 800dfa0:	2b03      	cmp	r3, #3
 800dfa2:	f63f aed6 	bhi.w	800dd52 <Base64_Decode+0x48>
 800dfa6:	e004      	b.n	800dfb2 <Base64_Decode+0x2a8>
                break;
 800dfa8:	bf00      	nop
 800dfaa:	e002      	b.n	800dfb2 <Base64_Decode+0x2a8>
            break;
 800dfac:	bf00      	nop
 800dfae:	e000      	b.n	800dfb2 <Base64_Decode+0x2a8>
        else
            break;
 800dfb0:	bf00      	nop
    }
/* If the output buffer has a room for an extra byte, add a null terminator */
    if (out && *outLen > i)
 800dfb2:	687b      	ldr	r3, [r7, #4]
 800dfb4:	2b00      	cmp	r3, #0
 800dfb6:	d009      	beq.n	800dfcc <Base64_Decode+0x2c2>
 800dfb8:	683b      	ldr	r3, [r7, #0]
 800dfba:	681b      	ldr	r3, [r3, #0]
 800dfbc:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800dfbe:	429a      	cmp	r2, r3
 800dfc0:	d204      	bcs.n	800dfcc <Base64_Decode+0x2c2>
        out[i]= '\0';
 800dfc2:	687a      	ldr	r2, [r7, #4]
 800dfc4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dfc6:	4413      	add	r3, r2
 800dfc8:	2200      	movs	r2, #0
 800dfca:	701a      	strb	r2, [r3, #0]

    *outLen = i;
 800dfcc:	683b      	ldr	r3, [r7, #0]
 800dfce:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800dfd0:	601a      	str	r2, [r3, #0]

    return 0;
 800dfd2:	2300      	movs	r3, #0
}
 800dfd4:	4618      	mov	r0, r3
 800dfd6:	3738      	adds	r7, #56	; 0x38
 800dfd8:	46bd      	mov	sp, r7
 800dfda:	bd80      	pop	{r7, pc}

0800dfdc <wc_ecc_curve_cache_free_spec_item>:
    #define FREE_CURVE_SPECS()
#endif /* ECC_CACHE_CURVE */

static void wc_ecc_curve_cache_free_spec_item(ecc_curve_spec* curve, mp_int* item,
    byte mask)
{
 800dfdc:	b580      	push	{r7, lr}
 800dfde:	b084      	sub	sp, #16
 800dfe0:	af00      	add	r7, sp, #0
 800dfe2:	60f8      	str	r0, [r7, #12]
 800dfe4:	60b9      	str	r1, [r7, #8]
 800dfe6:	4613      	mov	r3, r2
 800dfe8:	71fb      	strb	r3, [r7, #7]
    if (item) {
 800dfea:	68bb      	ldr	r3, [r7, #8]
 800dfec:	2b00      	cmp	r3, #0
 800dfee:	d002      	beq.n	800dff6 <wc_ecc_curve_cache_free_spec_item+0x1a>
    #ifdef HAVE_WOLF_BIGINT
        wc_bigint_free(&item->raw);
    #endif
        mp_clear(item);
 800dff0:	68b8      	ldr	r0, [r7, #8]
 800dff2:	f00a fd3c 	bl	8018a6e <sp_clear>
    }
    curve->load_mask &= ~mask;
 800dff6:	68fb      	ldr	r3, [r7, #12]
 800dff8:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800dffc:	b25a      	sxtb	r2, r3
 800dffe:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800e002:	43db      	mvns	r3, r3
 800e004:	b25b      	sxtb	r3, r3
 800e006:	4013      	ands	r3, r2
 800e008:	b25b      	sxtb	r3, r3
 800e00a:	b2da      	uxtb	r2, r3
 800e00c:	68fb      	ldr	r3, [r7, #12]
 800e00e:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
}
 800e012:	bf00      	nop
 800e014:	3710      	adds	r7, #16
 800e016:	46bd      	mov	sp, r7
 800e018:	bd80      	pop	{r7, pc}

0800e01a <wc_ecc_curve_cache_free_spec>:
static void wc_ecc_curve_cache_free_spec(ecc_curve_spec* curve)
{
 800e01a:	b580      	push	{r7, lr}
 800e01c:	b082      	sub	sp, #8
 800e01e:	af00      	add	r7, sp, #0
 800e020:	6078      	str	r0, [r7, #4]
    if (curve == NULL) {
 800e022:	687b      	ldr	r3, [r7, #4]
 800e024:	2b00      	cmp	r3, #0
 800e026:	d04a      	beq.n	800e0be <wc_ecc_curve_cache_free_spec+0xa4>
        return;
    }

    if (curve->load_mask & ECC_CURVE_FIELD_PRIME)
 800e028:	687b      	ldr	r3, [r7, #4]
 800e02a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800e02e:	f003 0301 	and.w	r3, r3, #1
 800e032:	2b00      	cmp	r3, #0
 800e034:	d006      	beq.n	800e044 <wc_ecc_curve_cache_free_spec+0x2a>
        wc_ecc_curve_cache_free_spec_item(curve, curve->prime, ECC_CURVE_FIELD_PRIME);
 800e036:	687b      	ldr	r3, [r7, #4]
 800e038:	685b      	ldr	r3, [r3, #4]
 800e03a:	2201      	movs	r2, #1
 800e03c:	4619      	mov	r1, r3
 800e03e:	6878      	ldr	r0, [r7, #4]
 800e040:	f7ff ffcc 	bl	800dfdc <wc_ecc_curve_cache_free_spec_item>
    if (curve->load_mask & ECC_CURVE_FIELD_AF)
 800e044:	687b      	ldr	r3, [r7, #4]
 800e046:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800e04a:	f003 0302 	and.w	r3, r3, #2
 800e04e:	2b00      	cmp	r3, #0
 800e050:	d006      	beq.n	800e060 <wc_ecc_curve_cache_free_spec+0x46>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Af, ECC_CURVE_FIELD_AF);
 800e052:	687b      	ldr	r3, [r7, #4]
 800e054:	689b      	ldr	r3, [r3, #8]
 800e056:	2202      	movs	r2, #2
 800e058:	4619      	mov	r1, r3
 800e05a:	6878      	ldr	r0, [r7, #4]
 800e05c:	f7ff ffbe 	bl	800dfdc <wc_ecc_curve_cache_free_spec_item>
#ifdef USE_ECC_B_PARAM
    if (curve->load_mask & ECC_CURVE_FIELD_BF)
        wc_ecc_curve_cache_free_spec_item(curve, curve->Bf, ECC_CURVE_FIELD_BF);
#endif
    if (curve->load_mask & ECC_CURVE_FIELD_ORDER)
 800e060:	687b      	ldr	r3, [r7, #4]
 800e062:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800e066:	f003 0308 	and.w	r3, r3, #8
 800e06a:	2b00      	cmp	r3, #0
 800e06c:	d006      	beq.n	800e07c <wc_ecc_curve_cache_free_spec+0x62>
        wc_ecc_curve_cache_free_spec_item(curve, curve->order, ECC_CURVE_FIELD_ORDER);
 800e06e:	687b      	ldr	r3, [r7, #4]
 800e070:	68db      	ldr	r3, [r3, #12]
 800e072:	2208      	movs	r2, #8
 800e074:	4619      	mov	r1, r3
 800e076:	6878      	ldr	r0, [r7, #4]
 800e078:	f7ff ffb0 	bl	800dfdc <wc_ecc_curve_cache_free_spec_item>
    if (curve->load_mask & ECC_CURVE_FIELD_GX)
 800e07c:	687b      	ldr	r3, [r7, #4]
 800e07e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800e082:	f003 0310 	and.w	r3, r3, #16
 800e086:	2b00      	cmp	r3, #0
 800e088:	d006      	beq.n	800e098 <wc_ecc_curve_cache_free_spec+0x7e>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Gx, ECC_CURVE_FIELD_GX);
 800e08a:	687b      	ldr	r3, [r7, #4]
 800e08c:	691b      	ldr	r3, [r3, #16]
 800e08e:	2210      	movs	r2, #16
 800e090:	4619      	mov	r1, r3
 800e092:	6878      	ldr	r0, [r7, #4]
 800e094:	f7ff ffa2 	bl	800dfdc <wc_ecc_curve_cache_free_spec_item>
    if (curve->load_mask & ECC_CURVE_FIELD_GY)
 800e098:	687b      	ldr	r3, [r7, #4]
 800e09a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800e09e:	f003 0320 	and.w	r3, r3, #32
 800e0a2:	2b00      	cmp	r3, #0
 800e0a4:	d006      	beq.n	800e0b4 <wc_ecc_curve_cache_free_spec+0x9a>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Gy, ECC_CURVE_FIELD_GY);
 800e0a6:	687b      	ldr	r3, [r7, #4]
 800e0a8:	695b      	ldr	r3, [r3, #20]
 800e0aa:	2220      	movs	r2, #32
 800e0ac:	4619      	mov	r1, r3
 800e0ae:	6878      	ldr	r0, [r7, #4]
 800e0b0:	f7ff ff94 	bl	800dfdc <wc_ecc_curve_cache_free_spec_item>

    curve->load_mask = 0;
 800e0b4:	687b      	ldr	r3, [r7, #4]
 800e0b6:	2200      	movs	r2, #0
 800e0b8:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 800e0bc:	e000      	b.n	800e0c0 <wc_ecc_curve_cache_free_spec+0xa6>
        return;
 800e0be:	bf00      	nop
}
 800e0c0:	3708      	adds	r7, #8
 800e0c2:	46bd      	mov	sp, r7
 800e0c4:	bd80      	pop	{r7, pc}

0800e0c6 <wc_ecc_curve_free>:

static void wc_ecc_curve_free(ecc_curve_spec* curve)
{
 800e0c6:	b580      	push	{r7, lr}
 800e0c8:	b082      	sub	sp, #8
 800e0ca:	af00      	add	r7, sp, #0
 800e0cc:	6078      	str	r0, [r7, #4]
    if (curve) {
 800e0ce:	687b      	ldr	r3, [r7, #4]
 800e0d0:	2b00      	cmp	r3, #0
 800e0d2:	d002      	beq.n	800e0da <wc_ecc_curve_free+0x14>
            wc_ecc_curve_cache_free_spec(curve);
            XFREE(curve, NULL, DYNAMIC_TYPE_ECC);
        }
        #endif
    #else
        wc_ecc_curve_cache_free_spec(curve);
 800e0d4:	6878      	ldr	r0, [r7, #4]
 800e0d6:	f7ff ffa0 	bl	800e01a <wc_ecc_curve_cache_free_spec>
    #endif
    }
}
 800e0da:	bf00      	nop
 800e0dc:	3708      	adds	r7, #8
 800e0de:	46bd      	mov	sp, r7
 800e0e0:	bd80      	pop	{r7, pc}

0800e0e2 <wc_ecc_curve_cache_load_item>:

static int wc_ecc_curve_cache_load_item(ecc_curve_spec* curve, const char* src, 
    mp_int** dst, byte mask)
{
 800e0e2:	b580      	push	{r7, lr}
 800e0e4:	b086      	sub	sp, #24
 800e0e6:	af00      	add	r7, sp, #0
 800e0e8:	60f8      	str	r0, [r7, #12]
 800e0ea:	60b9      	str	r1, [r7, #8]
 800e0ec:	607a      	str	r2, [r7, #4]
 800e0ee:	70fb      	strb	r3, [r7, #3]
    int err;

#ifndef ECC_CACHE_CURVE
    /* get mp_int from temp */
    if (curve->spec_use >= curve->spec_count) {
 800e0f0:	68fb      	ldr	r3, [r7, #12]
 800e0f2:	6a1a      	ldr	r2, [r3, #32]
 800e0f4:	68fb      	ldr	r3, [r7, #12]
 800e0f6:	69db      	ldr	r3, [r3, #28]
 800e0f8:	429a      	cmp	r2, r3
 800e0fa:	d302      	bcc.n	800e102 <wc_ecc_curve_cache_load_item+0x20>
        WOLFSSL_MSG("Invalid DECLARE_CURVE_SPECS count");
        return ECC_BAD_ARG_E;
 800e0fc:	f06f 03a9 	mvn.w	r3, #169	; 0xa9
 800e100:	e028      	b.n	800e154 <wc_ecc_curve_cache_load_item+0x72>
    }
    *dst = &curve->spec_ints[curve->spec_use++];
 800e102:	68fb      	ldr	r3, [r7, #12]
 800e104:	699a      	ldr	r2, [r3, #24]
 800e106:	68fb      	ldr	r3, [r7, #12]
 800e108:	6a1b      	ldr	r3, [r3, #32]
 800e10a:	1c58      	adds	r0, r3, #1
 800e10c:	68f9      	ldr	r1, [r7, #12]
 800e10e:	6208      	str	r0, [r1, #32]
 800e110:	f44f 7143 	mov.w	r1, #780	; 0x30c
 800e114:	fb01 f303 	mul.w	r3, r1, r3
 800e118:	441a      	add	r2, r3
 800e11a:	687b      	ldr	r3, [r7, #4]
 800e11c:	601a      	str	r2, [r3, #0]
#endif

    err = mp_init(*dst);
 800e11e:	687b      	ldr	r3, [r7, #4]
 800e120:	681b      	ldr	r3, [r3, #0]
 800e122:	4618      	mov	r0, r3
 800e124:	f00a fbf2 	bl	801890c <sp_init>
 800e128:	6178      	str	r0, [r7, #20]
    if (err == MP_OKAY) {
 800e12a:	697b      	ldr	r3, [r7, #20]
 800e12c:	2b00      	cmp	r3, #0
 800e12e:	d110      	bne.n	800e152 <wc_ecc_curve_cache_load_item+0x70>
        curve->load_mask |= mask;
 800e130:	68fb      	ldr	r3, [r7, #12]
 800e132:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 800e136:	78fb      	ldrb	r3, [r7, #3]
 800e138:	4313      	orrs	r3, r2
 800e13a:	b2da      	uxtb	r2, r3
 800e13c:	68fb      	ldr	r3, [r7, #12]
 800e13e:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

        err = mp_read_radix(*dst, src, MP_RADIX_HEX);
 800e142:	687b      	ldr	r3, [r7, #4]
 800e144:	681b      	ldr	r3, [r3, #0]
 800e146:	2210      	movs	r2, #16
 800e148:	68b9      	ldr	r1, [r7, #8]
 800e14a:	4618      	mov	r0, r3
 800e14c:	f00b f824 	bl	8019198 <sp_read_radix>
 800e150:	6178      	str	r0, [r7, #20]
    #ifdef HAVE_WOLF_BIGINT
        if (err == MP_OKAY)
            err = wc_mp_to_bigint(*dst, &(*dst)->raw);
    #endif
    }
    return err;
 800e152:	697b      	ldr	r3, [r7, #20]
}
 800e154:	4618      	mov	r0, r3
 800e156:	3718      	adds	r7, #24
 800e158:	46bd      	mov	sp, r7
 800e15a:	bd80      	pop	{r7, pc}

0800e15c <wc_ecc_curve_load>:

static int wc_ecc_curve_load(const ecc_set_type* dp, ecc_curve_spec** pCurve,
    byte load_mask)
{
 800e15c:	b580      	push	{r7, lr}
 800e15e:	b088      	sub	sp, #32
 800e160:	af00      	add	r7, sp, #0
 800e162:	60f8      	str	r0, [r7, #12]
 800e164:	60b9      	str	r1, [r7, #8]
 800e166:	4613      	mov	r3, r2
 800e168:	71fb      	strb	r3, [r7, #7]
    int ret = 0;
 800e16a:	2300      	movs	r3, #0
 800e16c:	61fb      	str	r3, [r7, #28]
    ecc_curve_spec* curve;
    byte load_items = 0; /* mask of items to load */
 800e16e:	2300      	movs	r3, #0
 800e170:	76fb      	strb	r3, [r7, #27]
#ifdef ECC_CACHE_CURVE
    int x;
#endif

    if (dp == NULL || pCurve == NULL)
 800e172:	68fb      	ldr	r3, [r7, #12]
 800e174:	2b00      	cmp	r3, #0
 800e176:	d002      	beq.n	800e17e <wc_ecc_curve_load+0x22>
 800e178:	68bb      	ldr	r3, [r7, #8]
 800e17a:	2b00      	cmp	r3, #0
 800e17c:	d102      	bne.n	800e184 <wc_ecc_curve_load+0x28>
        return BAD_FUNC_ARG;
 800e17e:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800e182:	e082      	b.n	800e28a <wc_ecc_curve_load+0x12e>
        curve = ecc_curve_spec_cache[x];
    }
    /* return new or cached curve */
    *pCurve = curve;
#else
    curve = *pCurve;
 800e184:	68bb      	ldr	r3, [r7, #8]
 800e186:	681b      	ldr	r3, [r3, #0]
 800e188:	617b      	str	r3, [r7, #20]
#endif /* ECC_CACHE_CURVE */

    /* make sure the curve is initialized */
    if (curve->dp != dp) {
 800e18a:	697b      	ldr	r3, [r7, #20]
 800e18c:	681b      	ldr	r3, [r3, #0]
 800e18e:	68fa      	ldr	r2, [r7, #12]
 800e190:	429a      	cmp	r2, r3
 800e192:	d003      	beq.n	800e19c <wc_ecc_curve_load+0x40>
        curve->load_mask = 0;
 800e194:	697b      	ldr	r3, [r7, #20]
 800e196:	2200      	movs	r2, #0
 800e198:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
        curve->order = &curve->order_lcl;
        curve->Gx = &curve->Gx_lcl;
        curve->Gy = &curve->Gy_lcl;
    #endif
    }
    curve->dp = dp; /* set dp info */
 800e19c:	697b      	ldr	r3, [r7, #20]
 800e19e:	68fa      	ldr	r2, [r7, #12]
 800e1a0:	601a      	str	r2, [r3, #0]

    /* determine items to load */
    load_items = (((byte)~(word32)curve->load_mask) & load_mask);
 800e1a2:	697b      	ldr	r3, [r7, #20]
 800e1a4:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800e1a8:	43db      	mvns	r3, r3
 800e1aa:	b2da      	uxtb	r2, r3
 800e1ac:	79fb      	ldrb	r3, [r7, #7]
 800e1ae:	4013      	ands	r3, r2
 800e1b0:	76fb      	strb	r3, [r7, #27]
    curve->load_mask |= load_items;
 800e1b2:	697b      	ldr	r3, [r7, #20]
 800e1b4:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 800e1b8:	7efb      	ldrb	r3, [r7, #27]
 800e1ba:	4313      	orrs	r3, r2
 800e1bc:	b2da      	uxtb	r2, r3
 800e1be:	697b      	ldr	r3, [r7, #20]
 800e1c0:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    /* load items */
    if (load_items & ECC_CURVE_FIELD_PRIME)
 800e1c4:	7efb      	ldrb	r3, [r7, #27]
 800e1c6:	f003 0301 	and.w	r3, r3, #1
 800e1ca:	2b00      	cmp	r3, #0
 800e1cc:	d00b      	beq.n	800e1e6 <wc_ecc_curve_load+0x8a>
        ret += wc_ecc_curve_cache_load_item(curve, dp->prime, &curve->prime,
 800e1ce:	68fb      	ldr	r3, [r7, #12]
 800e1d0:	68d9      	ldr	r1, [r3, #12]
 800e1d2:	697b      	ldr	r3, [r7, #20]
 800e1d4:	1d1a      	adds	r2, r3, #4
 800e1d6:	2301      	movs	r3, #1
 800e1d8:	6978      	ldr	r0, [r7, #20]
 800e1da:	f7ff ff82 	bl	800e0e2 <wc_ecc_curve_cache_load_item>
 800e1de:	4602      	mov	r2, r0
 800e1e0:	69fb      	ldr	r3, [r7, #28]
 800e1e2:	4413      	add	r3, r2
 800e1e4:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_PRIME);
    if (load_items & ECC_CURVE_FIELD_AF)
 800e1e6:	7efb      	ldrb	r3, [r7, #27]
 800e1e8:	f003 0302 	and.w	r3, r3, #2
 800e1ec:	2b00      	cmp	r3, #0
 800e1ee:	d00c      	beq.n	800e20a <wc_ecc_curve_load+0xae>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Af, &curve->Af,
 800e1f0:	68fb      	ldr	r3, [r7, #12]
 800e1f2:	6919      	ldr	r1, [r3, #16]
 800e1f4:	697b      	ldr	r3, [r7, #20]
 800e1f6:	f103 0208 	add.w	r2, r3, #8
 800e1fa:	2302      	movs	r3, #2
 800e1fc:	6978      	ldr	r0, [r7, #20]
 800e1fe:	f7ff ff70 	bl	800e0e2 <wc_ecc_curve_cache_load_item>
 800e202:	4602      	mov	r2, r0
 800e204:	69fb      	ldr	r3, [r7, #28]
 800e206:	4413      	add	r3, r2
 800e208:	61fb      	str	r3, [r7, #28]
#ifdef USE_ECC_B_PARAM
    if (load_items & ECC_CURVE_FIELD_BF)
        ret += wc_ecc_curve_cache_load_item(curve, dp->Bf, &curve->Bf,
            ECC_CURVE_FIELD_BF);
#endif
    if (load_items & ECC_CURVE_FIELD_ORDER)
 800e20a:	7efb      	ldrb	r3, [r7, #27]
 800e20c:	f003 0308 	and.w	r3, r3, #8
 800e210:	2b00      	cmp	r3, #0
 800e212:	d00c      	beq.n	800e22e <wc_ecc_curve_load+0xd2>
        ret += wc_ecc_curve_cache_load_item(curve, dp->order, &curve->order,
 800e214:	68fb      	ldr	r3, [r7, #12]
 800e216:	6999      	ldr	r1, [r3, #24]
 800e218:	697b      	ldr	r3, [r7, #20]
 800e21a:	f103 020c 	add.w	r2, r3, #12
 800e21e:	2308      	movs	r3, #8
 800e220:	6978      	ldr	r0, [r7, #20]
 800e222:	f7ff ff5e 	bl	800e0e2 <wc_ecc_curve_cache_load_item>
 800e226:	4602      	mov	r2, r0
 800e228:	69fb      	ldr	r3, [r7, #28]
 800e22a:	4413      	add	r3, r2
 800e22c:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_ORDER);
    if (load_items & ECC_CURVE_FIELD_GX)
 800e22e:	7efb      	ldrb	r3, [r7, #27]
 800e230:	f003 0310 	and.w	r3, r3, #16
 800e234:	2b00      	cmp	r3, #0
 800e236:	d00c      	beq.n	800e252 <wc_ecc_curve_load+0xf6>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Gx, &curve->Gx,
 800e238:	68fb      	ldr	r3, [r7, #12]
 800e23a:	69d9      	ldr	r1, [r3, #28]
 800e23c:	697b      	ldr	r3, [r7, #20]
 800e23e:	f103 0210 	add.w	r2, r3, #16
 800e242:	2310      	movs	r3, #16
 800e244:	6978      	ldr	r0, [r7, #20]
 800e246:	f7ff ff4c 	bl	800e0e2 <wc_ecc_curve_cache_load_item>
 800e24a:	4602      	mov	r2, r0
 800e24c:	69fb      	ldr	r3, [r7, #28]
 800e24e:	4413      	add	r3, r2
 800e250:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_GX);
    if (load_items & ECC_CURVE_FIELD_GY)
 800e252:	7efb      	ldrb	r3, [r7, #27]
 800e254:	f003 0320 	and.w	r3, r3, #32
 800e258:	2b00      	cmp	r3, #0
 800e25a:	d00c      	beq.n	800e276 <wc_ecc_curve_load+0x11a>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Gy, &curve->Gy,
 800e25c:	68fb      	ldr	r3, [r7, #12]
 800e25e:	6a19      	ldr	r1, [r3, #32]
 800e260:	697b      	ldr	r3, [r7, #20]
 800e262:	f103 0214 	add.w	r2, r3, #20
 800e266:	2320      	movs	r3, #32
 800e268:	6978      	ldr	r0, [r7, #20]
 800e26a:	f7ff ff3a 	bl	800e0e2 <wc_ecc_curve_cache_load_item>
 800e26e:	4602      	mov	r2, r0
 800e270:	69fb      	ldr	r3, [r7, #28]
 800e272:	4413      	add	r3, r2
 800e274:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_GY);

    /* check for error */
    if (ret != 0) {
 800e276:	69fb      	ldr	r3, [r7, #28]
 800e278:	2b00      	cmp	r3, #0
 800e27a:	d005      	beq.n	800e288 <wc_ecc_curve_load+0x12c>
        wc_ecc_curve_free(curve);
 800e27c:	6978      	ldr	r0, [r7, #20]
 800e27e:	f7ff ff22 	bl	800e0c6 <wc_ecc_curve_free>
        ret = MP_READ_E;
 800e282:	f06f 036e 	mvn.w	r3, #110	; 0x6e
 800e286:	61fb      	str	r3, [r7, #28]

#if defined(ECC_CACHE_CURVE) && !defined(SINGLE_THREADED)
    wc_UnLockMutex(&ecc_curve_cache_mutex);
#endif

    return ret;
 800e288:	69fb      	ldr	r3, [r7, #28]
}
 800e28a:	4618      	mov	r0, r3
 800e28c:	3720      	adds	r7, #32
 800e28e:	46bd      	mov	sp, r7
 800e290:	bd80      	pop	{r7, pc}
	...

0800e294 <wc_ecc_set_curve>:
        return NULL;
    return ecc_sets[curve_idx].name;
}

int wc_ecc_set_curve(ecc_key* key, int keysize, int curve_id)
{
 800e294:	b480      	push	{r7}
 800e296:	b087      	sub	sp, #28
 800e298:	af00      	add	r7, sp, #0
 800e29a:	60f8      	str	r0, [r7, #12]
 800e29c:	60b9      	str	r1, [r7, #8]
 800e29e:	607a      	str	r2, [r7, #4]
    if (keysize <= 0 && curve_id < 0) {
 800e2a0:	68bb      	ldr	r3, [r7, #8]
 800e2a2:	2b00      	cmp	r3, #0
 800e2a4:	dc05      	bgt.n	800e2b2 <wc_ecc_set_curve+0x1e>
 800e2a6:	687b      	ldr	r3, [r7, #4]
 800e2a8:	2b00      	cmp	r3, #0
 800e2aa:	da02      	bge.n	800e2b2 <wc_ecc_set_curve+0x1e>
        return BAD_FUNC_ARG;
 800e2ac:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800e2b0:	e052      	b.n	800e358 <wc_ecc_set_curve+0xc4>
    }

    if (keysize > ECC_MAXSIZE) {
 800e2b2:	68bb      	ldr	r3, [r7, #8]
 800e2b4:	2b42      	cmp	r3, #66	; 0x42
 800e2b6:	dd02      	ble.n	800e2be <wc_ecc_set_curve+0x2a>
        return ECC_BAD_ARG_E;
 800e2b8:	f06f 03a9 	mvn.w	r3, #169	; 0xa9
 800e2bc:	e04c      	b.n	800e358 <wc_ecc_set_curve+0xc4>
    }

    /* handle custom case */
    if (key->idx != ECC_CUSTOM_IDX) {
 800e2be:	68fb      	ldr	r3, [r7, #12]
 800e2c0:	685b      	ldr	r3, [r3, #4]
 800e2c2:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e2c6:	d046      	beq.n	800e356 <wc_ecc_set_curve+0xc2>
        int x;

        /* default values */
        key->idx = 0;
 800e2c8:	68fb      	ldr	r3, [r7, #12]
 800e2ca:	2200      	movs	r2, #0
 800e2cc:	605a      	str	r2, [r3, #4]
        key->dp = NULL;
 800e2ce:	68fb      	ldr	r3, [r7, #12]
 800e2d0:	2200      	movs	r2, #0
 800e2d2:	611a      	str	r2, [r3, #16]

        /* find ecc_set based on curve_id or key size */
        for (x = 0; ecc_sets[x].size != 0; x++) {
 800e2d4:	2300      	movs	r3, #0
 800e2d6:	617b      	str	r3, [r7, #20]
 800e2d8:	e01b      	b.n	800e312 <wc_ecc_set_curve+0x7e>
            if (curve_id > ECC_CURVE_DEF) {
 800e2da:	687b      	ldr	r3, [r7, #4]
 800e2dc:	2b00      	cmp	r3, #0
 800e2de:	dd0b      	ble.n	800e2f8 <wc_ecc_set_curve+0x64>
                if (curve_id == ecc_sets[x].id)
 800e2e0:	4a20      	ldr	r2, [pc, #128]	; (800e364 <wc_ecc_set_curve+0xd0>)
 800e2e2:	697b      	ldr	r3, [r7, #20]
 800e2e4:	2134      	movs	r1, #52	; 0x34
 800e2e6:	fb01 f303 	mul.w	r3, r1, r3
 800e2ea:	4413      	add	r3, r2
 800e2ec:	3304      	adds	r3, #4
 800e2ee:	681b      	ldr	r3, [r3, #0]
 800e2f0:	687a      	ldr	r2, [r7, #4]
 800e2f2:	429a      	cmp	r2, r3
 800e2f4:	d10a      	bne.n	800e30c <wc_ecc_set_curve+0x78>
                  break;
 800e2f6:	e017      	b.n	800e328 <wc_ecc_set_curve+0x94>
            }
            else if (keysize <= ecc_sets[x].size) {
 800e2f8:	4a1a      	ldr	r2, [pc, #104]	; (800e364 <wc_ecc_set_curve+0xd0>)
 800e2fa:	697b      	ldr	r3, [r7, #20]
 800e2fc:	2134      	movs	r1, #52	; 0x34
 800e2fe:	fb01 f303 	mul.w	r3, r1, r3
 800e302:	4413      	add	r3, r2
 800e304:	681b      	ldr	r3, [r3, #0]
 800e306:	68ba      	ldr	r2, [r7, #8]
 800e308:	429a      	cmp	r2, r3
 800e30a:	dd0c      	ble.n	800e326 <wc_ecc_set_curve+0x92>
        for (x = 0; ecc_sets[x].size != 0; x++) {
 800e30c:	697b      	ldr	r3, [r7, #20]
 800e30e:	3301      	adds	r3, #1
 800e310:	617b      	str	r3, [r7, #20]
 800e312:	4a14      	ldr	r2, [pc, #80]	; (800e364 <wc_ecc_set_curve+0xd0>)
 800e314:	697b      	ldr	r3, [r7, #20]
 800e316:	2134      	movs	r1, #52	; 0x34
 800e318:	fb01 f303 	mul.w	r3, r1, r3
 800e31c:	4413      	add	r3, r2
 800e31e:	681b      	ldr	r3, [r3, #0]
 800e320:	2b00      	cmp	r3, #0
 800e322:	d1da      	bne.n	800e2da <wc_ecc_set_curve+0x46>
 800e324:	e000      	b.n	800e328 <wc_ecc_set_curve+0x94>
                break;
 800e326:	bf00      	nop
            }
        }
        if (ecc_sets[x].size == 0) {
 800e328:	4a0e      	ldr	r2, [pc, #56]	; (800e364 <wc_ecc_set_curve+0xd0>)
 800e32a:	697b      	ldr	r3, [r7, #20]
 800e32c:	2134      	movs	r1, #52	; 0x34
 800e32e:	fb01 f303 	mul.w	r3, r1, r3
 800e332:	4413      	add	r3, r2
 800e334:	681b      	ldr	r3, [r3, #0]
 800e336:	2b00      	cmp	r3, #0
 800e338:	d102      	bne.n	800e340 <wc_ecc_set_curve+0xac>
            WOLFSSL_MSG("ECC Curve not found");
            return ECC_CURVE_OID_E;
 800e33a:	f06f 03ab 	mvn.w	r3, #171	; 0xab
 800e33e:	e00b      	b.n	800e358 <wc_ecc_set_curve+0xc4>
        }

        key->idx = x;
 800e340:	68fb      	ldr	r3, [r7, #12]
 800e342:	697a      	ldr	r2, [r7, #20]
 800e344:	605a      	str	r2, [r3, #4]
        key->dp  = &ecc_sets[x];
 800e346:	697b      	ldr	r3, [r7, #20]
 800e348:	2234      	movs	r2, #52	; 0x34
 800e34a:	fb02 f303 	mul.w	r3, r2, r3
 800e34e:	4a05      	ldr	r2, [pc, #20]	; (800e364 <wc_ecc_set_curve+0xd0>)
 800e350:	441a      	add	r2, r3
 800e352:	68fb      	ldr	r3, [r7, #12]
 800e354:	611a      	str	r2, [r3, #16]
    }

    return 0;
 800e356:	2300      	movs	r3, #0
}
 800e358:	4618      	mov	r0, r3
 800e35a:	371c      	adds	r7, #28
 800e35c:	46bd      	mov	sp, r7
 800e35e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e362:	4770      	bx	lr
 800e364:	0801ad8c 	.word	0x0801ad8c

0800e368 <alt_fp_init>:


#ifdef ALT_ECC_SIZE
static void alt_fp_init(mp_int* a)
{
 800e368:	b580      	push	{r7, lr}
 800e36a:	b082      	sub	sp, #8
 800e36c:	af00      	add	r7, sp, #0
 800e36e:	6078      	str	r0, [r7, #4]
    a->size = FP_SIZE_ECC;
 800e370:	687b      	ldr	r3, [r7, #4]
 800e372:	2210      	movs	r2, #16
 800e374:	605a      	str	r2, [r3, #4]
    mp_zero(a);
 800e376:	6878      	ldr	r0, [r7, #4]
 800e378:	f00a fb6b 	bl	8018a52 <sp_zero>
}
 800e37c:	bf00      	nop
 800e37e:	3708      	adds	r7, #8
 800e380:	46bd      	mov	sp, r7
 800e382:	bd80      	pop	{r7, pc}

0800e384 <wc_ecc_is_valid_idx>:
/** Returns whether an ECC idx is valid or not
  n      The idx number to check
  return 1 if valid, 0 if not
*/
int wc_ecc_is_valid_idx(int n)
{
 800e384:	b480      	push	{r7}
 800e386:	b085      	sub	sp, #20
 800e388:	af00      	add	r7, sp, #0
 800e38a:	6078      	str	r0, [r7, #4]
   int x;

   for (x = 0; ecc_sets[x].size != 0; x++)
 800e38c:	2300      	movs	r3, #0
 800e38e:	60fb      	str	r3, [r7, #12]
 800e390:	e002      	b.n	800e398 <wc_ecc_is_valid_idx+0x14>
 800e392:	68fb      	ldr	r3, [r7, #12]
 800e394:	3301      	adds	r3, #1
 800e396:	60fb      	str	r3, [r7, #12]
 800e398:	4a0c      	ldr	r2, [pc, #48]	; (800e3cc <wc_ecc_is_valid_idx+0x48>)
 800e39a:	68fb      	ldr	r3, [r7, #12]
 800e39c:	2134      	movs	r1, #52	; 0x34
 800e39e:	fb01 f303 	mul.w	r3, r1, r3
 800e3a2:	4413      	add	r3, r2
 800e3a4:	681b      	ldr	r3, [r3, #0]
 800e3a6:	2b00      	cmp	r3, #0
 800e3a8:	d1f3      	bne.n	800e392 <wc_ecc_is_valid_idx+0xe>
       ;
   /* -1 is a valid index --- indicating that the domain params
      were supplied by the user */
   if ((n >= ECC_CUSTOM_IDX) && (n < x)) {
 800e3aa:	687b      	ldr	r3, [r7, #4]
 800e3ac:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e3b0:	db05      	blt.n	800e3be <wc_ecc_is_valid_idx+0x3a>
 800e3b2:	687a      	ldr	r2, [r7, #4]
 800e3b4:	68fb      	ldr	r3, [r7, #12]
 800e3b6:	429a      	cmp	r2, r3
 800e3b8:	da01      	bge.n	800e3be <wc_ecc_is_valid_idx+0x3a>
      return 1;
 800e3ba:	2301      	movs	r3, #1
 800e3bc:	e000      	b.n	800e3c0 <wc_ecc_is_valid_idx+0x3c>
   }

   return 0;
 800e3be:	2300      	movs	r3, #0
}
 800e3c0:	4618      	mov	r0, r3
 800e3c2:	3714      	adds	r7, #20
 800e3c4:	46bd      	mov	sp, r7
 800e3c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e3ca:	4770      	bx	lr
 800e3cc:	0801ad8c 	.word	0x0801ad8c

0800e3d0 <wc_ecc_get_curve_idx>:

int wc_ecc_get_curve_idx(int curve_id)
{
 800e3d0:	b480      	push	{r7}
 800e3d2:	b085      	sub	sp, #20
 800e3d4:	af00      	add	r7, sp, #0
 800e3d6:	6078      	str	r0, [r7, #4]
    int curve_idx;
    for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {
 800e3d8:	2300      	movs	r3, #0
 800e3da:	60fb      	str	r3, [r7, #12]
 800e3dc:	e00d      	b.n	800e3fa <wc_ecc_get_curve_idx+0x2a>
        if (curve_id == ecc_sets[curve_idx].id)
 800e3de:	4a16      	ldr	r2, [pc, #88]	; (800e438 <wc_ecc_get_curve_idx+0x68>)
 800e3e0:	68fb      	ldr	r3, [r7, #12]
 800e3e2:	2134      	movs	r1, #52	; 0x34
 800e3e4:	fb01 f303 	mul.w	r3, r1, r3
 800e3e8:	4413      	add	r3, r2
 800e3ea:	3304      	adds	r3, #4
 800e3ec:	681b      	ldr	r3, [r3, #0]
 800e3ee:	687a      	ldr	r2, [r7, #4]
 800e3f0:	429a      	cmp	r2, r3
 800e3f2:	d00c      	beq.n	800e40e <wc_ecc_get_curve_idx+0x3e>
    for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {
 800e3f4:	68fb      	ldr	r3, [r7, #12]
 800e3f6:	3301      	adds	r3, #1
 800e3f8:	60fb      	str	r3, [r7, #12]
 800e3fa:	4a0f      	ldr	r2, [pc, #60]	; (800e438 <wc_ecc_get_curve_idx+0x68>)
 800e3fc:	68fb      	ldr	r3, [r7, #12]
 800e3fe:	2134      	movs	r1, #52	; 0x34
 800e400:	fb01 f303 	mul.w	r3, r1, r3
 800e404:	4413      	add	r3, r2
 800e406:	681b      	ldr	r3, [r3, #0]
 800e408:	2b00      	cmp	r3, #0
 800e40a:	d1e8      	bne.n	800e3de <wc_ecc_get_curve_idx+0xe>
 800e40c:	e000      	b.n	800e410 <wc_ecc_get_curve_idx+0x40>
            break;
 800e40e:	bf00      	nop
    }
    if (ecc_sets[curve_idx].size == 0) {
 800e410:	4a09      	ldr	r2, [pc, #36]	; (800e438 <wc_ecc_get_curve_idx+0x68>)
 800e412:	68fb      	ldr	r3, [r7, #12]
 800e414:	2134      	movs	r1, #52	; 0x34
 800e416:	fb01 f303 	mul.w	r3, r1, r3
 800e41a:	4413      	add	r3, r2
 800e41c:	681b      	ldr	r3, [r3, #0]
 800e41e:	2b00      	cmp	r3, #0
 800e420:	d102      	bne.n	800e428 <wc_ecc_get_curve_idx+0x58>
        return ECC_CURVE_INVALID;
 800e422:	f04f 33ff 	mov.w	r3, #4294967295
 800e426:	e000      	b.n	800e42a <wc_ecc_get_curve_idx+0x5a>
    }
    return curve_idx;
 800e428:	68fb      	ldr	r3, [r7, #12]
}
 800e42a:	4618      	mov	r0, r3
 800e42c:	3714      	adds	r7, #20
 800e42e:	46bd      	mov	sp, r7
 800e430:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e434:	4770      	bx	lr
 800e436:	bf00      	nop
 800e438:	0801ad8c 	.word	0x0801ad8c

0800e43c <wc_ecc_get_curve_size_from_id>:
 *
 * id      curve id, from ecc_curve_id enum in ecc.h
 * return  curve size, from ecc_sets[] on success, negative on error
 */
int wc_ecc_get_curve_size_from_id(int curve_id)
{
 800e43c:	b580      	push	{r7, lr}
 800e43e:	b084      	sub	sp, #16
 800e440:	af00      	add	r7, sp, #0
 800e442:	6078      	str	r0, [r7, #4]
    int curve_idx = wc_ecc_get_curve_idx(curve_id);
 800e444:	6878      	ldr	r0, [r7, #4]
 800e446:	f7ff ffc3 	bl	800e3d0 <wc_ecc_get_curve_idx>
 800e44a:	60f8      	str	r0, [r7, #12]
    if (curve_idx == ECC_CURVE_INVALID)
 800e44c:	68fb      	ldr	r3, [r7, #12]
 800e44e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e452:	d102      	bne.n	800e45a <wc_ecc_get_curve_size_from_id+0x1e>
        return ECC_BAD_ARG_E;
 800e454:	f06f 03a9 	mvn.w	r3, #169	; 0xa9
 800e458:	e006      	b.n	800e468 <wc_ecc_get_curve_size_from_id+0x2c>
    return ecc_sets[curve_idx].size;
 800e45a:	4a05      	ldr	r2, [pc, #20]	; (800e470 <wc_ecc_get_curve_size_from_id+0x34>)
 800e45c:	68fb      	ldr	r3, [r7, #12]
 800e45e:	2134      	movs	r1, #52	; 0x34
 800e460:	fb01 f303 	mul.w	r3, r1, r3
 800e464:	4413      	add	r3, r2
 800e466:	681b      	ldr	r3, [r3, #0]
}
 800e468:	4618      	mov	r0, r3
 800e46a:	3710      	adds	r7, #16
 800e46c:	46bd      	mov	sp, r7
 800e46e:	bd80      	pop	{r7, pc}
 800e470:	0801ad8c 	.word	0x0801ad8c

0800e474 <wc_ecc_reset>:
    return NOT_COMPILED_IN;
#endif /* !WC_NO_RNG */
}

static WC_INLINE void wc_ecc_reset(ecc_key* key)
{
 800e474:	b480      	push	{r7}
 800e476:	b083      	sub	sp, #12
 800e478:	af00      	add	r7, sp, #0
 800e47a:	6078      	str	r0, [r7, #4]
    /* make sure required key variables are reset */
    key->state = ECC_STATE_NONE;
 800e47c:	687b      	ldr	r3, [r7, #4]
 800e47e:	2200      	movs	r2, #0
 800e480:	609a      	str	r2, [r3, #8]
}
 800e482:	bf00      	nop
 800e484:	370c      	adds	r7, #12
 800e486:	46bd      	mov	sp, r7
 800e488:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e48c:	4770      	bx	lr
	...

0800e490 <ecc_make_pub_ex>:
 *
 * returns MP_OKAY on success
 */
static int ecc_make_pub_ex(ecc_key* key, ecc_curve_spec* curveIn,
        ecc_point* pubOut, WC_RNG* rng)
{
 800e490:	b580      	push	{r7, lr}
 800e492:	b094      	sub	sp, #80	; 0x50
 800e494:	af00      	add	r7, sp, #0
 800e496:	60f8      	str	r0, [r7, #12]
 800e498:	60b9      	str	r1, [r7, #8]
 800e49a:	607a      	str	r2, [r7, #4]
 800e49c:	603b      	str	r3, [r7, #0]
    int err = MP_OKAY;
 800e49e:	2300      	movs	r3, #0
 800e4a0:	64fb      	str	r3, [r7, #76]	; 0x4c
  && !defined(WOLFSSL_SILABS_SE_ACCEL)
#if !defined(WOLFSSL_SP_MATH)
    ecc_point* base = NULL;
#endif
    ecc_point* pub;
    DECLARE_CURVE_SPECS(curve, ECC_CURVE_FIELD_COUNT);
 800e4a2:	2300      	movs	r3, #0
 800e4a4:	647b      	str	r3, [r7, #68]	; 0x44
 800e4a6:	f107 0318 	add.w	r3, r7, #24
 800e4aa:	617b      	str	r3, [r7, #20]
 800e4ac:	697b      	ldr	r3, [r7, #20]
 800e4ae:	2228      	movs	r2, #40	; 0x28
 800e4b0:	2100      	movs	r1, #0
 800e4b2:	4618      	mov	r0, r3
 800e4b4:	f00a ffc3 	bl	801943e <memset>
 800e4b8:	697b      	ldr	r3, [r7, #20]
 800e4ba:	2205      	movs	r2, #5
 800e4bc:	61da      	str	r2, [r3, #28]
#endif /* !WOLFSSL_ATECC508A */

    (void)rng;

    if (key == NULL) {
 800e4be:	68fb      	ldr	r3, [r7, #12]
 800e4c0:	2b00      	cmp	r3, #0
 800e4c2:	d102      	bne.n	800e4ca <ecc_make_pub_ex+0x3a>
        return BAD_FUNC_ARG;
 800e4c4:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800e4c8:	e09f      	b.n	800e60a <ecc_make_pub_ex+0x17a>

#if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_ATECC608A) \
  && !defined(WOLFSSL_SILABS_SE_ACCEL)

    /* if ecc_point passed in then use it as output for public key point */
    if (pubOut != NULL) {
 800e4ca:	687b      	ldr	r3, [r7, #4]
 800e4cc:	2b00      	cmp	r3, #0
 800e4ce:	d002      	beq.n	800e4d6 <ecc_make_pub_ex+0x46>
        pub = pubOut;
 800e4d0:	687b      	ldr	r3, [r7, #4]
 800e4d2:	64bb      	str	r3, [r7, #72]	; 0x48
 800e4d4:	e005      	b.n	800e4e2 <ecc_make_pub_ex+0x52>
    }
    else {
        /* caching public key making it a ECC_PRIVATEKEY instead of
           ECC_PRIVATEKEY_ONLY */
        pub = &key->pubkey;
 800e4d6:	68fb      	ldr	r3, [r7, #12]
 800e4d8:	3318      	adds	r3, #24
 800e4da:	64bb      	str	r3, [r7, #72]	; 0x48
        key->type = ECC_PRIVATEKEY_ONLY;
 800e4dc:	68fb      	ldr	r3, [r7, #12]
 800e4de:	2203      	movs	r2, #3
 800e4e0:	601a      	str	r2, [r3, #0]
    }

    /* avoid loading the curve unless it is not passed in */
    if (curveIn != NULL) {
 800e4e2:	68bb      	ldr	r3, [r7, #8]
 800e4e4:	2b00      	cmp	r3, #0
 800e4e6:	d002      	beq.n	800e4ee <ecc_make_pub_ex+0x5e>
        curve = curveIn;
 800e4e8:	68bb      	ldr	r3, [r7, #8]
 800e4ea:	617b      	str	r3, [r7, #20]
 800e4ec:	e019      	b.n	800e522 <ecc_make_pub_ex+0x92>
    }
    else {
        /* load curve info */
        if (err == MP_OKAY) {
 800e4ee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e4f0:	2b00      	cmp	r3, #0
 800e4f2:	d116      	bne.n	800e522 <ecc_make_pub_ex+0x92>
            ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);
 800e4f4:	f640 703c 	movw	r0, #3900	; 0xf3c
 800e4f8:	f000 fcfe 	bl	800eef8 <wolfSSL_Malloc>
 800e4fc:	6478      	str	r0, [r7, #68]	; 0x44
 800e4fe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e500:	2b00      	cmp	r3, #0
 800e502:	d102      	bne.n	800e50a <ecc_make_pub_ex+0x7a>
 800e504:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800e508:	e07f      	b.n	800e60a <ecc_make_pub_ex+0x17a>
 800e50a:	697b      	ldr	r3, [r7, #20]
 800e50c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800e50e:	619a      	str	r2, [r3, #24]
            err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
 800e510:	68fb      	ldr	r3, [r7, #12]
 800e512:	691b      	ldr	r3, [r3, #16]
 800e514:	f107 0114 	add.w	r1, r7, #20
 800e518:	223b      	movs	r2, #59	; 0x3b
 800e51a:	4618      	mov	r0, r3
 800e51c:	f7ff fe1e 	bl	800e15c <wc_ecc_curve_load>
 800e520:	64f8      	str	r0, [r7, #76]	; 0x4c
        }
    }

    if ((err == MP_OKAY) && (mp_iszero(&key->k) || mp_isneg(&key->k) ||
 800e522:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e524:	2b00      	cmp	r3, #0
 800e526:	d114      	bne.n	800e552 <ecc_make_pub_ex+0xc2>
 800e528:	68fb      	ldr	r3, [r7, #12]
 800e52a:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800e52e:	2b00      	cmp	r3, #0
 800e530:	d00c      	beq.n	800e54c <ecc_make_pub_ex+0xbc>
                                      (mp_cmp(&key->k, curve->order) != MP_LT)))
 800e532:	68fb      	ldr	r3, [r7, #12]
 800e534:	f503 7284 	add.w	r2, r3, #264	; 0x108
 800e538:	697b      	ldr	r3, [r7, #20]
 800e53a:	68db      	ldr	r3, [r3, #12]
 800e53c:	4619      	mov	r1, r3
 800e53e:	4610      	mov	r0, r2
 800e540:	f00a fb25 	bl	8018b8e <sp_cmp>
 800e544:	4603      	mov	r3, r0
    if ((err == MP_OKAY) && (mp_iszero(&key->k) || mp_isneg(&key->k) ||
 800e546:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e54a:	d002      	beq.n	800e552 <ecc_make_pub_ex+0xc2>
    {
        err = ECC_PRIV_KEY_E;
 800e54c:	f06f 03d7 	mvn.w	r3, #215	; 0xd7
 800e550:	64fb      	str	r3, [r7, #76]	; 0x4c
    }

    if (err == MP_OKAY) {
 800e552:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e554:	2b00      	cmp	r3, #0
 800e556:	d11d      	bne.n	800e594 <ecc_make_pub_ex+0x104>
    #ifndef ALT_ECC_SIZE
        err = mp_init_multi(pub->x, pub->y, pub->z, NULL, NULL, NULL);
    #else
        pub->x = (mp_int*)&pub->xyz[0];
 800e558:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e55a:	f103 020c 	add.w	r2, r3, #12
 800e55e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e560:	601a      	str	r2, [r3, #0]
        pub->y = (mp_int*)&pub->xyz[1];
 800e562:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e564:	f103 0258 	add.w	r2, r3, #88	; 0x58
 800e568:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e56a:	605a      	str	r2, [r3, #4]
        pub->z = (mp_int*)&pub->xyz[2];
 800e56c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e56e:	f103 02a4 	add.w	r2, r3, #164	; 0xa4
 800e572:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e574:	609a      	str	r2, [r3, #8]
        alt_fp_init(pub->x);
 800e576:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e578:	681b      	ldr	r3, [r3, #0]
 800e57a:	4618      	mov	r0, r3
 800e57c:	f7ff fef4 	bl	800e368 <alt_fp_init>
        alt_fp_init(pub->y);
 800e580:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e582:	685b      	ldr	r3, [r3, #4]
 800e584:	4618      	mov	r0, r3
 800e586:	f7ff feef 	bl	800e368 <alt_fp_init>
        alt_fp_init(pub->z);
 800e58a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e58c:	689b      	ldr	r3, [r3, #8]
 800e58e:	4618      	mov	r0, r3
 800e590:	f7ff feea 	bl	800e368 <alt_fp_init>
    #endif
    }

    if (err != MP_OKAY) {
 800e594:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e596:	2b00      	cmp	r3, #0
 800e598:	d11d      	bne.n	800e5d6 <ecc_make_pub_ex+0x146>
    }
    else
#ifdef WOLFSSL_HAVE_SP_ECC
#ifndef WOLFSSL_SP_NO_256
    if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {
 800e59a:	68fb      	ldr	r3, [r7, #12]
 800e59c:	685b      	ldr	r3, [r3, #4]
 800e59e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e5a2:	d015      	beq.n	800e5d0 <ecc_make_pub_ex+0x140>
 800e5a4:	68fb      	ldr	r3, [r7, #12]
 800e5a6:	685b      	ldr	r3, [r3, #4]
 800e5a8:	4a1a      	ldr	r2, [pc, #104]	; (800e614 <ecc_make_pub_ex+0x184>)
 800e5aa:	2134      	movs	r1, #52	; 0x34
 800e5ac:	fb01 f303 	mul.w	r3, r1, r3
 800e5b0:	4413      	add	r3, r2
 800e5b2:	3304      	adds	r3, #4
 800e5b4:	681b      	ldr	r3, [r3, #0]
 800e5b6:	2b07      	cmp	r3, #7
 800e5b8:	d10a      	bne.n	800e5d0 <ecc_make_pub_ex+0x140>
        err = sp_ecc_mulmod_base_256(&key->k, pub, 1, key->heap);
 800e5ba:	68fb      	ldr	r3, [r7, #12]
 800e5bc:	f503 7084 	add.w	r0, r3, #264	; 0x108
 800e5c0:	68fb      	ldr	r3, [r7, #12]
 800e5c2:	695b      	ldr	r3, [r3, #20]
 800e5c4:	2201      	movs	r2, #1
 800e5c6:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800e5c8:	f008 ffea 	bl	80175a0 <sp_ecc_mulmod_base_256>
 800e5cc:	64f8      	str	r0, [r7, #76]	; 0x4c
 800e5ce:	e002      	b.n	800e5d6 <ecc_make_pub_ex+0x146>
    }
    else
#endif
#endif
#if defined(WOLFSSL_SP_MATH)
        err = WC_KEY_SIZE_E;
 800e5d0:	f06f 03e9 	mvn.w	r3, #233	; 0xe9
 800e5d4:	64fb      	str	r3, [r7, #76]	; 0x4c
        mp_clear(pub->z);
    #endif
    }

    /* free up local curve */
    if (curveIn == NULL) {
 800e5d6:	68bb      	ldr	r3, [r7, #8]
 800e5d8:	2b00      	cmp	r3, #0
 800e5da:	d10b      	bne.n	800e5f4 <ecc_make_pub_ex+0x164>
        wc_ecc_curve_free(curve);
 800e5dc:	697b      	ldr	r3, [r7, #20]
 800e5de:	4618      	mov	r0, r3
 800e5e0:	f7ff fd71 	bl	800e0c6 <wc_ecc_curve_free>
        FREE_CURVE_SPECS();
 800e5e4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e5e6:	643b      	str	r3, [r7, #64]	; 0x40
 800e5e8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e5ea:	2b00      	cmp	r3, #0
 800e5ec:	d002      	beq.n	800e5f4 <ecc_make_pub_ex+0x164>
 800e5ee:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800e5f0:	f000 fc9e 	bl	800ef30 <wolfSSL_Free>
    (void)curveIn;
    err = NOT_COMPILED_IN;
#endif /* WOLFSSL_ATECC508A || WOLFSSL_SILABS_SE_ACCEL */

    /* change key state if public part is cached */
    if (key->type == ECC_PRIVATEKEY_ONLY && pubOut == NULL) {
 800e5f4:	68fb      	ldr	r3, [r7, #12]
 800e5f6:	681b      	ldr	r3, [r3, #0]
 800e5f8:	2b03      	cmp	r3, #3
 800e5fa:	d105      	bne.n	800e608 <ecc_make_pub_ex+0x178>
 800e5fc:	687b      	ldr	r3, [r7, #4]
 800e5fe:	2b00      	cmp	r3, #0
 800e600:	d102      	bne.n	800e608 <ecc_make_pub_ex+0x178>
        key->type = ECC_PRIVATEKEY;
 800e602:	68fb      	ldr	r3, [r7, #12]
 800e604:	2202      	movs	r2, #2
 800e606:	601a      	str	r2, [r3, #0]
    }

    return err;
 800e608:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
}
 800e60a:	4618      	mov	r0, r3
 800e60c:	3750      	adds	r7, #80	; 0x50
 800e60e:	46bd      	mov	sp, r7
 800e610:	bd80      	pop	{r7, pc}
 800e612:	bf00      	nop
 800e614:	0801ad8c 	.word	0x0801ad8c

0800e618 <wc_ecc_init_ex>:
}

/* Setup dynamic pointers if using normal math for proper freeing */
WOLFSSL_ABI
int wc_ecc_init_ex(ecc_key* key, void* heap, int devId)
{
 800e618:	b580      	push	{r7, lr}
 800e61a:	b086      	sub	sp, #24
 800e61c:	af00      	add	r7, sp, #0
 800e61e:	60f8      	str	r0, [r7, #12]
 800e620:	60b9      	str	r1, [r7, #8]
 800e622:	607a      	str	r2, [r7, #4]
    int ret = 0;
 800e624:	2300      	movs	r3, #0
 800e626:	617b      	str	r3, [r7, #20]

    if (key == NULL) {
 800e628:	68fb      	ldr	r3, [r7, #12]
 800e62a:	2b00      	cmp	r3, #0
 800e62c:	d102      	bne.n	800e634 <wc_ecc_init_ex+0x1c>
        return BAD_FUNC_ARG;
 800e62e:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800e632:	e037      	b.n	800e6a4 <wc_ecc_init_ex+0x8c>

#ifdef ECC_DUMP_OID
    wc_ecc_dump_oids();
#endif

    XMEMSET(key, 0, sizeof(ecc_key));
 800e634:	f44f 6283 	mov.w	r2, #1048	; 0x418
 800e638:	2100      	movs	r1, #0
 800e63a:	68f8      	ldr	r0, [r7, #12]
 800e63c:	f00a feff 	bl	801943e <memset>
    key->state = ECC_STATE_NONE;
 800e640:	68fb      	ldr	r3, [r7, #12]
 800e642:	2200      	movs	r2, #0
 800e644:	609a      	str	r2, [r3, #8]

#if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A)
    key->slot = ATECC_INVALID_SLOT;
#else
#ifdef ALT_ECC_SIZE
    key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];
 800e646:	68fb      	ldr	r3, [r7, #12]
 800e648:	f103 0224 	add.w	r2, r3, #36	; 0x24
 800e64c:	68fb      	ldr	r3, [r7, #12]
 800e64e:	619a      	str	r2, [r3, #24]
    key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];
 800e650:	68fb      	ldr	r3, [r7, #12]
 800e652:	f103 0270 	add.w	r2, r3, #112	; 0x70
 800e656:	68fb      	ldr	r3, [r7, #12]
 800e658:	61da      	str	r2, [r3, #28]
    key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];
 800e65a:	68fb      	ldr	r3, [r7, #12]
 800e65c:	f103 02bc 	add.w	r2, r3, #188	; 0xbc
 800e660:	68fb      	ldr	r3, [r7, #12]
 800e662:	621a      	str	r2, [r3, #32]
    alt_fp_init(key->pubkey.x);
 800e664:	68fb      	ldr	r3, [r7, #12]
 800e666:	699b      	ldr	r3, [r3, #24]
 800e668:	4618      	mov	r0, r3
 800e66a:	f7ff fe7d 	bl	800e368 <alt_fp_init>
    alt_fp_init(key->pubkey.y);
 800e66e:	68fb      	ldr	r3, [r7, #12]
 800e670:	69db      	ldr	r3, [r3, #28]
 800e672:	4618      	mov	r0, r3
 800e674:	f7ff fe78 	bl	800e368 <alt_fp_init>
    alt_fp_init(key->pubkey.z);
 800e678:	68fb      	ldr	r3, [r7, #12]
 800e67a:	6a1b      	ldr	r3, [r3, #32]
 800e67c:	4618      	mov	r0, r3
 800e67e:	f7ff fe73 	bl	800e368 <alt_fp_init>
    ret = mp_init(&key->k);
 800e682:	68fb      	ldr	r3, [r7, #12]
 800e684:	f503 7384 	add.w	r3, r3, #264	; 0x108
 800e688:	4618      	mov	r0, r3
 800e68a:	f00a f93f 	bl	801890c <sp_init>
 800e68e:	6178      	str	r0, [r7, #20]
    if (ret != MP_OKAY) {
 800e690:	697b      	ldr	r3, [r7, #20]
 800e692:	2b00      	cmp	r3, #0
 800e694:	d002      	beq.n	800e69c <wc_ecc_init_ex+0x84>
        return MEMORY_E;
 800e696:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800e69a:	e003      	b.n	800e6a4 <wc_ecc_init_ex+0x8c>
#endif /* WOLFSSL_ATECC508A */

#ifdef WOLFSSL_HEAP_TEST
    key->heap = (void*)WOLFSSL_HEAP_TEST;
#else
    key->heap = heap;
 800e69c:	68fb      	ldr	r3, [r7, #12]
 800e69e:	68ba      	ldr	r2, [r7, #8]
 800e6a0:	615a      	str	r2, [r3, #20]
#endif

#if defined(WOLFSSL_DSP)
    key->handle = -1;
#endif
    return ret;
 800e6a2:	697b      	ldr	r3, [r7, #20]
}
 800e6a4:	4618      	mov	r0, r3
 800e6a6:	3718      	adds	r7, #24
 800e6a8:	46bd      	mov	sp, r7
 800e6aa:	bd80      	pop	{r7, pc}

0800e6ac <wc_ecc_free>:
  Free an ECC key from memory
  key   The key you wish to free
*/
WOLFSSL_ABI
int wc_ecc_free(ecc_key* key)
{
 800e6ac:	b580      	push	{r7, lr}
 800e6ae:	b082      	sub	sp, #8
 800e6b0:	af00      	add	r7, sp, #0
 800e6b2:	6078      	str	r0, [r7, #4]
    if (key == NULL) {
 800e6b4:	687b      	ldr	r3, [r7, #4]
 800e6b6:	2b00      	cmp	r3, #0
 800e6b8:	d101      	bne.n	800e6be <wc_ecc_free+0x12>
        return 0;
 800e6ba:	2300      	movs	r3, #0
 800e6bc:	e015      	b.n	800e6ea <wc_ecc_free+0x3e>
#if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A)
    atmel_ecc_free(key->slot);
    key->slot = ATECC_INVALID_SLOT;
#endif /* WOLFSSL_ATECC508A */

    mp_clear(key->pubkey.x);
 800e6be:	687b      	ldr	r3, [r7, #4]
 800e6c0:	699b      	ldr	r3, [r3, #24]
 800e6c2:	4618      	mov	r0, r3
 800e6c4:	f00a f9d3 	bl	8018a6e <sp_clear>
    mp_clear(key->pubkey.y);
 800e6c8:	687b      	ldr	r3, [r7, #4]
 800e6ca:	69db      	ldr	r3, [r3, #28]
 800e6cc:	4618      	mov	r0, r3
 800e6ce:	f00a f9ce 	bl	8018a6e <sp_clear>
    mp_clear(key->pubkey.z);
 800e6d2:	687b      	ldr	r3, [r7, #4]
 800e6d4:	6a1b      	ldr	r3, [r3, #32]
 800e6d6:	4618      	mov	r0, r3
 800e6d8:	f00a f9c9 	bl	8018a6e <sp_clear>

    mp_forcezero(&key->k);
 800e6dc:	687b      	ldr	r3, [r7, #4]
 800e6de:	f503 7384 	add.w	r3, r3, #264	; 0x108
 800e6e2:	4618      	mov	r0, r3
 800e6e4:	f00a f9e4 	bl	8018ab0 <sp_forcezero>
#ifdef WOLFSSL_CUSTOM_CURVES
    if (key->deallocSet && key->dp != NULL)
        wc_ecc_free_curve(key->dp, key->heap);
#endif

    return 0;
 800e6e8:	2300      	movs	r3, #0
}
 800e6ea:	4618      	mov	r0, r3
 800e6ec:	3708      	adds	r7, #8
 800e6ee:	46bd      	mov	sp, r7
 800e6f0:	bd80      	pop	{r7, pc}
	...

0800e6f4 <wc_ecc_verify_hash>:
 key         The corresponding public ECC key
 return      MP_OKAY if successful (even if the signature is not valid)
 */
int wc_ecc_verify_hash(const byte* sig, word32 siglen, const byte* hash,
                       word32 hashlen, int* res, ecc_key* key)
{
 800e6f4:	b580      	push	{r7, lr}
 800e6f6:	b08e      	sub	sp, #56	; 0x38
 800e6f8:	af02      	add	r7, sp, #8
 800e6fa:	60f8      	str	r0, [r7, #12]
 800e6fc:	60b9      	str	r1, [r7, #8]
 800e6fe:	607a      	str	r2, [r7, #4]
 800e700:	603b      	str	r3, [r7, #0]
    int err;
    mp_int *r = NULL, *s = NULL;
 800e702:	2300      	movs	r3, #0
 800e704:	62bb      	str	r3, [r7, #40]	; 0x28
 800e706:	2300      	movs	r3, #0
 800e708:	627b      	str	r3, [r7, #36]	; 0x24
#if (!defined(WOLFSSL_ASYNC_CRYPT) || !defined(WC_ASYNC_ENABLE_ECC)) && \
    !defined(WOLFSSL_SMALL_STACK)
    mp_int r_lcl, s_lcl;
#endif

    if (sig == NULL || hash == NULL || res == NULL || key == NULL) {
 800e70a:	68fb      	ldr	r3, [r7, #12]
 800e70c:	2b00      	cmp	r3, #0
 800e70e:	d008      	beq.n	800e722 <wc_ecc_verify_hash+0x2e>
 800e710:	687b      	ldr	r3, [r7, #4]
 800e712:	2b00      	cmp	r3, #0
 800e714:	d005      	beq.n	800e722 <wc_ecc_verify_hash+0x2e>
 800e716:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e718:	2b00      	cmp	r3, #0
 800e71a:	d002      	beq.n	800e722 <wc_ecc_verify_hash+0x2e>
 800e71c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e71e:	2b00      	cmp	r3, #0
 800e720:	d102      	bne.n	800e728 <wc_ecc_verify_hash+0x34>
        return ECC_BAD_ARG_E;
 800e722:	f06f 03a9 	mvn.w	r3, #169	; 0xa9
 800e726:	e0ac      	b.n	800e882 <wc_ecc_verify_hash+0x18e>
#else
    #ifndef WOLFSSL_SMALL_STACK
    r = &r_lcl;
    s = &s_lcl;
    #else
    r = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);
 800e728:	f44f 7043 	mov.w	r0, #780	; 0x30c
 800e72c:	f000 fbe4 	bl	800eef8 <wolfSSL_Malloc>
 800e730:	62b8      	str	r0, [r7, #40]	; 0x28
    if (r == NULL)
 800e732:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e734:	2b00      	cmp	r3, #0
 800e736:	d102      	bne.n	800e73e <wc_ecc_verify_hash+0x4a>
        return MEMORY_E;
 800e738:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800e73c:	e0a1      	b.n	800e882 <wc_ecc_verify_hash+0x18e>
    s = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);
 800e73e:	f44f 7043 	mov.w	r0, #780	; 0x30c
 800e742:	f000 fbd9 	bl	800eef8 <wolfSSL_Malloc>
 800e746:	6278      	str	r0, [r7, #36]	; 0x24
    if (s == NULL) {
 800e748:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e74a:	2b00      	cmp	r3, #0
 800e74c:	d10a      	bne.n	800e764 <wc_ecc_verify_hash+0x70>
        XFREE(r, key->heap, DYNAMIC_TYPE_ECC);
 800e74e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e750:	613b      	str	r3, [r7, #16]
 800e752:	693b      	ldr	r3, [r7, #16]
 800e754:	2b00      	cmp	r3, #0
 800e756:	d002      	beq.n	800e75e <wc_ecc_verify_hash+0x6a>
 800e758:	6938      	ldr	r0, [r7, #16]
 800e75a:	f000 fbe9 	bl	800ef30 <wolfSSL_Free>
        return MEMORY_E;
 800e75e:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800e762:	e08e      	b.n	800e882 <wc_ecc_verify_hash+0x18e>
    }
    #endif
    XMEMSET(r, 0, sizeof(mp_int));
 800e764:	f44f 7243 	mov.w	r2, #780	; 0x30c
 800e768:	2100      	movs	r1, #0
 800e76a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800e76c:	f00a fe67 	bl	801943e <memset>
    XMEMSET(s, 0, sizeof(mp_int));
 800e770:	f44f 7243 	mov.w	r2, #780	; 0x30c
 800e774:	2100      	movs	r1, #0
 800e776:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800e778:	f00a fe61 	bl	801943e <memset>
#endif /* WOLFSSL_ASYNC_CRYPT */

    switch (key->state) {
 800e77c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e77e:	689b      	ldr	r3, [r3, #8]
 800e780:	2b07      	cmp	r3, #7
 800e782:	d854      	bhi.n	800e82e <wc_ecc_verify_hash+0x13a>
 800e784:	a201      	add	r2, pc, #4	; (adr r2, 800e78c <wc_ecc_verify_hash+0x98>)
 800e786:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e78a:	bf00      	nop
 800e78c:	0800e7ad 	.word	0x0800e7ad
 800e790:	0800e82f 	.word	0x0800e82f
 800e794:	0800e82f 	.word	0x0800e82f
 800e798:	0800e82f 	.word	0x0800e82f
 800e79c:	0800e82f 	.word	0x0800e82f
 800e7a0:	0800e7ad 	.word	0x0800e7ad
 800e7a4:	0800e7cd 	.word	0x0800e7cd
 800e7a8:	0800e823 	.word	0x0800e823
        case ECC_STATE_NONE:
        case ECC_STATE_VERIFY_DECODE:
            key->state = ECC_STATE_VERIFY_DECODE;
 800e7ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e7ae:	2205      	movs	r2, #5
 800e7b0:	609a      	str	r2, [r3, #8]

            /* default to invalid signature */
            *res = 0;
 800e7b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e7b4:	2200      	movs	r2, #0
 800e7b6:	601a      	str	r2, [r3, #0]
            /* Note, DecodeECC_DSA_Sig() calls mp_init() on r and s.
             * If either of those don't allocate correctly, none of
             * the rest of this function will execute, and everything
             * gets cleaned up at the end. */
            /* decode DSA header */
            err = DecodeECC_DSA_Sig(sig, siglen, r, s);
 800e7b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e7ba:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800e7bc:	68b9      	ldr	r1, [r7, #8]
 800e7be:	68f8      	ldr	r0, [r7, #12]
 800e7c0:	f7fe ff2c 	bl	800d61c <DecodeECC_DSA_Sig>
 800e7c4:	62f8      	str	r0, [r7, #44]	; 0x2c
            if (err < 0) {
 800e7c6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e7c8:	2b00      	cmp	r3, #0
 800e7ca:	db34      	blt.n	800e836 <wc_ecc_verify_hash+0x142>
                break;
            }
            FALL_THROUGH;

        case ECC_STATE_VERIFY_DO:
            key->state = ECC_STATE_VERIFY_DO;
 800e7cc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e7ce:	2206      	movs	r2, #6
 800e7d0:	609a      	str	r2, [r3, #8]

            err = wc_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);
 800e7d2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e7d4:	9301      	str	r3, [sp, #4]
 800e7d6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e7d8:	9300      	str	r3, [sp, #0]
 800e7da:	683b      	ldr	r3, [r7, #0]
 800e7dc:	687a      	ldr	r2, [r7, #4]
 800e7de:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800e7e0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800e7e2:	f000 f8c7 	bl	800e974 <wc_ecc_verify_hash_ex>
 800e7e6:	62f8      	str	r0, [r7, #44]	; 0x2c

        #ifndef WOLFSSL_ASYNC_CRYPT
            /* done with R/S */
            mp_clear(r);
 800e7e8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800e7ea:	f00a f940 	bl	8018a6e <sp_clear>
            mp_clear(s);
 800e7ee:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800e7f0:	f00a f93d 	bl	8018a6e <sp_clear>
        #ifdef WOLFSSL_SMALL_STACK
            XFREE(s, key->heap, DYNAMIC_TYPE_ECC);
 800e7f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e7f6:	623b      	str	r3, [r7, #32]
 800e7f8:	6a3b      	ldr	r3, [r7, #32]
 800e7fa:	2b00      	cmp	r3, #0
 800e7fc:	d002      	beq.n	800e804 <wc_ecc_verify_hash+0x110>
 800e7fe:	6a38      	ldr	r0, [r7, #32]
 800e800:	f000 fb96 	bl	800ef30 <wolfSSL_Free>
            XFREE(r, key->heap, DYNAMIC_TYPE_ECC);
 800e804:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e806:	61fb      	str	r3, [r7, #28]
 800e808:	69fb      	ldr	r3, [r7, #28]
 800e80a:	2b00      	cmp	r3, #0
 800e80c:	d002      	beq.n	800e814 <wc_ecc_verify_hash+0x120>
 800e80e:	69f8      	ldr	r0, [r7, #28]
 800e810:	f000 fb8e 	bl	800ef30 <wolfSSL_Free>
            r = NULL;
 800e814:	2300      	movs	r3, #0
 800e816:	62bb      	str	r3, [r7, #40]	; 0x28
            s = NULL;
 800e818:	2300      	movs	r3, #0
 800e81a:	627b      	str	r3, [r7, #36]	; 0x24
        #endif
        #endif

            if (err < 0) {
 800e81c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e81e:	2b00      	cmp	r3, #0
 800e820:	db0b      	blt.n	800e83a <wc_ecc_verify_hash+0x146>
                break;
            }
            FALL_THROUGH;

        case ECC_STATE_VERIFY_RES:
            key->state = ECC_STATE_VERIFY_RES;
 800e822:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e824:	2207      	movs	r2, #7
 800e826:	609a      	str	r2, [r3, #8]
            err = 0;
 800e828:	2300      	movs	r3, #0
 800e82a:	62fb      	str	r3, [r7, #44]	; 0x2c
            break;
 800e82c:	e006      	b.n	800e83c <wc_ecc_verify_hash+0x148>

        default:
            err = BAD_STATE_E;
 800e82e:	f06f 03bf 	mvn.w	r3, #191	; 0xbf
 800e832:	62fb      	str	r3, [r7, #44]	; 0x2c
 800e834:	e002      	b.n	800e83c <wc_ecc_verify_hash+0x148>
                break;
 800e836:	bf00      	nop
 800e838:	e000      	b.n	800e83c <wc_ecc_verify_hash+0x148>
                break;
 800e83a:	bf00      	nop
    }

    /* if async pending then return and skip done cleanup below */
    if (err == WC_PENDING_E) {
 800e83c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e83e:	f113 0f6c 	cmn.w	r3, #108	; 0x6c
 800e842:	d106      	bne.n	800e852 <wc_ecc_verify_hash+0x15e>
        key->state++;
 800e844:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e846:	689b      	ldr	r3, [r3, #8]
 800e848:	1c5a      	adds	r2, r3, #1
 800e84a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e84c:	609a      	str	r2, [r3, #8]
        return err;
 800e84e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e850:	e017      	b.n	800e882 <wc_ecc_verify_hash+0x18e>

    /* cleanup */
#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
    wc_ecc_free_async(key);
#elif defined(WOLFSSL_SMALL_STACK)
    XFREE(s, key->heap, DYNAMIC_TYPE_ECC);
 800e852:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e854:	61bb      	str	r3, [r7, #24]
 800e856:	69bb      	ldr	r3, [r7, #24]
 800e858:	2b00      	cmp	r3, #0
 800e85a:	d002      	beq.n	800e862 <wc_ecc_verify_hash+0x16e>
 800e85c:	69b8      	ldr	r0, [r7, #24]
 800e85e:	f000 fb67 	bl	800ef30 <wolfSSL_Free>
    XFREE(r, key->heap, DYNAMIC_TYPE_ECC);
 800e862:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e864:	617b      	str	r3, [r7, #20]
 800e866:	697b      	ldr	r3, [r7, #20]
 800e868:	2b00      	cmp	r3, #0
 800e86a:	d002      	beq.n	800e872 <wc_ecc_verify_hash+0x17e>
 800e86c:	6978      	ldr	r0, [r7, #20]
 800e86e:	f000 fb5f 	bl	800ef30 <wolfSSL_Free>
    r = NULL;
 800e872:	2300      	movs	r3, #0
 800e874:	62bb      	str	r3, [r7, #40]	; 0x28
    s = NULL;
 800e876:	2300      	movs	r3, #0
 800e878:	627b      	str	r3, [r7, #36]	; 0x24
#endif

    key->state = ECC_STATE_NONE;
 800e87a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e87c:	2200      	movs	r2, #0
 800e87e:	609a      	str	r2, [r3, #8]

    return err;
 800e880:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 800e882:	4618      	mov	r0, r3
 800e884:	3730      	adds	r7, #48	; 0x30
 800e886:	46bd      	mov	sp, r7
 800e888:	bd80      	pop	{r7, pc}
 800e88a:	bf00      	nop

0800e88c <wc_ecc_check_r_s_range>:
#endif /* !NO_ASN */

static int wc_ecc_check_r_s_range(ecc_key* key, mp_int* r, mp_int* s)
{
 800e88c:	b580      	push	{r7, lr}
 800e88e:	b094      	sub	sp, #80	; 0x50
 800e890:	af00      	add	r7, sp, #0
 800e892:	60f8      	str	r0, [r7, #12]
 800e894:	60b9      	str	r1, [r7, #8]
 800e896:	607a      	str	r2, [r7, #4]
    int err;
    DECLARE_CURVE_SPECS(curve, 1);
 800e898:	2300      	movs	r3, #0
 800e89a:	64bb      	str	r3, [r7, #72]	; 0x48
 800e89c:	f107 0318 	add.w	r3, r7, #24
 800e8a0:	617b      	str	r3, [r7, #20]
 800e8a2:	697b      	ldr	r3, [r7, #20]
 800e8a4:	2228      	movs	r2, #40	; 0x28
 800e8a6:	2100      	movs	r1, #0
 800e8a8:	4618      	mov	r0, r3
 800e8aa:	f00a fdc8 	bl	801943e <memset>
 800e8ae:	697b      	ldr	r3, [r7, #20]
 800e8b0:	2201      	movs	r2, #1
 800e8b2:	61da      	str	r2, [r3, #28]

    ALLOC_CURVE_SPECS(1);
 800e8b4:	f44f 7043 	mov.w	r0, #780	; 0x30c
 800e8b8:	f000 fb1e 	bl	800eef8 <wolfSSL_Malloc>
 800e8bc:	64b8      	str	r0, [r7, #72]	; 0x48
 800e8be:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e8c0:	2b00      	cmp	r3, #0
 800e8c2:	d102      	bne.n	800e8ca <wc_ecc_check_r_s_range+0x3e>
 800e8c4:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800e8c8:	e050      	b.n	800e96c <wc_ecc_check_r_s_range+0xe0>
 800e8ca:	697b      	ldr	r3, [r7, #20]
 800e8cc:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800e8ce:	619a      	str	r2, [r3, #24]
    err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ORDER);
 800e8d0:	68fb      	ldr	r3, [r7, #12]
 800e8d2:	691b      	ldr	r3, [r3, #16]
 800e8d4:	f107 0114 	add.w	r1, r7, #20
 800e8d8:	2208      	movs	r2, #8
 800e8da:	4618      	mov	r0, r3
 800e8dc:	f7ff fc3e 	bl	800e15c <wc_ecc_curve_load>
 800e8e0:	64f8      	str	r0, [r7, #76]	; 0x4c
    if (err != 0) {
 800e8e2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e8e4:	2b00      	cmp	r3, #0
 800e8e6:	d009      	beq.n	800e8fc <wc_ecc_check_r_s_range+0x70>
        FREE_CURVE_SPECS();
 800e8e8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e8ea:	643b      	str	r3, [r7, #64]	; 0x40
 800e8ec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e8ee:	2b00      	cmp	r3, #0
 800e8f0:	d002      	beq.n	800e8f8 <wc_ecc_check_r_s_range+0x6c>
 800e8f2:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800e8f4:	f000 fb1c 	bl	800ef30 <wolfSSL_Free>
        return err;
 800e8f8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e8fa:	e037      	b.n	800e96c <wc_ecc_check_r_s_range+0xe0>
    }

    if (mp_iszero(r) || mp_iszero(s)) {
 800e8fc:	68bb      	ldr	r3, [r7, #8]
 800e8fe:	681b      	ldr	r3, [r3, #0]
 800e900:	2b00      	cmp	r3, #0
 800e902:	d003      	beq.n	800e90c <wc_ecc_check_r_s_range+0x80>
 800e904:	687b      	ldr	r3, [r7, #4]
 800e906:	681b      	ldr	r3, [r3, #0]
 800e908:	2b00      	cmp	r3, #0
 800e90a:	d102      	bne.n	800e912 <wc_ecc_check_r_s_range+0x86>
        err = MP_ZERO_E;
 800e90c:	f06f 0378 	mvn.w	r3, #120	; 0x78
 800e910:	64fb      	str	r3, [r7, #76]	; 0x4c
    }
    if ((err == 0) && (mp_cmp(r, curve->order) != MP_LT)) {
 800e912:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e914:	2b00      	cmp	r3, #0
 800e916:	d10c      	bne.n	800e932 <wc_ecc_check_r_s_range+0xa6>
 800e918:	697b      	ldr	r3, [r7, #20]
 800e91a:	68db      	ldr	r3, [r3, #12]
 800e91c:	4619      	mov	r1, r3
 800e91e:	68b8      	ldr	r0, [r7, #8]
 800e920:	f00a f935 	bl	8018b8e <sp_cmp>
 800e924:	4603      	mov	r3, r0
 800e926:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e92a:	d002      	beq.n	800e932 <wc_ecc_check_r_s_range+0xa6>
        err = MP_VAL;
 800e92c:	f06f 0302 	mvn.w	r3, #2
 800e930:	64fb      	str	r3, [r7, #76]	; 0x4c
    }
    if ((err == 0) && (mp_cmp(s, curve->order) != MP_LT)) {
 800e932:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e934:	2b00      	cmp	r3, #0
 800e936:	d10c      	bne.n	800e952 <wc_ecc_check_r_s_range+0xc6>
 800e938:	697b      	ldr	r3, [r7, #20]
 800e93a:	68db      	ldr	r3, [r3, #12]
 800e93c:	4619      	mov	r1, r3
 800e93e:	6878      	ldr	r0, [r7, #4]
 800e940:	f00a f925 	bl	8018b8e <sp_cmp>
 800e944:	4603      	mov	r3, r0
 800e946:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e94a:	d002      	beq.n	800e952 <wc_ecc_check_r_s_range+0xc6>
        err = MP_VAL;
 800e94c:	f06f 0302 	mvn.w	r3, #2
 800e950:	64fb      	str	r3, [r7, #76]	; 0x4c
    }

    wc_ecc_curve_free(curve);
 800e952:	697b      	ldr	r3, [r7, #20]
 800e954:	4618      	mov	r0, r3
 800e956:	f7ff fbb6 	bl	800e0c6 <wc_ecc_curve_free>
    FREE_CURVE_SPECS();
 800e95a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e95c:	647b      	str	r3, [r7, #68]	; 0x44
 800e95e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e960:	2b00      	cmp	r3, #0
 800e962:	d002      	beq.n	800e96a <wc_ecc_check_r_s_range+0xde>
 800e964:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800e966:	f000 fae3 	bl	800ef30 <wolfSSL_Free>
    return err;
 800e96a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
}
 800e96c:	4618      	mov	r0, r3
 800e96e:	3750      	adds	r7, #80	; 0x50
 800e970:	46bd      	mov	sp, r7
 800e972:	bd80      	pop	{r7, pc}

0800e974 <wc_ecc_verify_hash_ex>:
#elif defined(WOLFSSL_PSOC6_CRYPTO)
{
    return psoc6_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);
}
#else
{
 800e974:	b580      	push	{r7, lr}
 800e976:	b08c      	sub	sp, #48	; 0x30
 800e978:	af06      	add	r7, sp, #24
 800e97a:	60f8      	str	r0, [r7, #12]
 800e97c:	60b9      	str	r1, [r7, #8]
 800e97e:	607a      	str	r2, [r7, #4]
 800e980:	603b      	str	r3, [r7, #0]
   int           err;
   word32        keySz = 0;
 800e982:	2300      	movs	r3, #0
 800e984:	613b      	str	r3, [r7, #16]
   #endif /* WOLFSSL_SMALL_STACK */
   mp_int*       e;
   DECLARE_CURVE_SPECS(curve, ECC_CURVE_FIELD_COUNT);
#endif

   if (r == NULL || s == NULL || hash == NULL || res == NULL || key == NULL)
 800e986:	68fb      	ldr	r3, [r7, #12]
 800e988:	2b00      	cmp	r3, #0
 800e98a:	d00b      	beq.n	800e9a4 <wc_ecc_verify_hash_ex+0x30>
 800e98c:	68bb      	ldr	r3, [r7, #8]
 800e98e:	2b00      	cmp	r3, #0
 800e990:	d008      	beq.n	800e9a4 <wc_ecc_verify_hash_ex+0x30>
 800e992:	687b      	ldr	r3, [r7, #4]
 800e994:	2b00      	cmp	r3, #0
 800e996:	d005      	beq.n	800e9a4 <wc_ecc_verify_hash_ex+0x30>
 800e998:	6a3b      	ldr	r3, [r7, #32]
 800e99a:	2b00      	cmp	r3, #0
 800e99c:	d002      	beq.n	800e9a4 <wc_ecc_verify_hash_ex+0x30>
 800e99e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e9a0:	2b00      	cmp	r3, #0
 800e9a2:	d102      	bne.n	800e9aa <wc_ecc_verify_hash_ex+0x36>
       return ECC_BAD_ARG_E;
 800e9a4:	f06f 03a9 	mvn.w	r3, #169	; 0xa9
 800e9a8:	e073      	b.n	800ea92 <wc_ecc_verify_hash_ex+0x11e>

   /* default to invalid signature */
   *res = 0;
 800e9aa:	6a3b      	ldr	r3, [r7, #32]
 800e9ac:	2200      	movs	r2, #0
 800e9ae:	601a      	str	r2, [r3, #0]

   /* is the IDX valid ?  */
   if (wc_ecc_is_valid_idx(key->idx) != 1) {
 800e9b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e9b2:	685b      	ldr	r3, [r3, #4]
 800e9b4:	4618      	mov	r0, r3
 800e9b6:	f7ff fce5 	bl	800e384 <wc_ecc_is_valid_idx>
 800e9ba:	4603      	mov	r3, r0
 800e9bc:	2b01      	cmp	r3, #1
 800e9be:	d002      	beq.n	800e9c6 <wc_ecc_verify_hash_ex+0x52>
      return ECC_BAD_ARG_E;
 800e9c0:	f06f 03a9 	mvn.w	r3, #169	; 0xa9
 800e9c4:	e065      	b.n	800ea92 <wc_ecc_verify_hash_ex+0x11e>
   }

   err = wc_ecc_check_r_s_range(key, r, s);
 800e9c6:	68ba      	ldr	r2, [r7, #8]
 800e9c8:	68f9      	ldr	r1, [r7, #12]
 800e9ca:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800e9cc:	f7ff ff5e 	bl	800e88c <wc_ecc_check_r_s_range>
 800e9d0:	6178      	str	r0, [r7, #20]
   if (err != MP_OKAY) {
 800e9d2:	697b      	ldr	r3, [r7, #20]
 800e9d4:	2b00      	cmp	r3, #0
 800e9d6:	d001      	beq.n	800e9dc <wc_ecc_verify_hash_ex+0x68>
      return err;
 800e9d8:	697b      	ldr	r3, [r7, #20]
 800e9da:	e05a      	b.n	800ea92 <wc_ecc_verify_hash_ex+0x11e>
   }

   keySz = key->dp->size;
 800e9dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e9de:	691b      	ldr	r3, [r3, #16]
 800e9e0:	681b      	ldr	r3, [r3, #0]
 800e9e2:	613b      	str	r3, [r7, #16]
                                hash, hashlen,
                                res, key);

#else
  /* checking if private key with no public part */
  if (key->type == ECC_PRIVATEKEY_ONLY) {
 800e9e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e9e6:	681b      	ldr	r3, [r3, #0]
 800e9e8:	2b03      	cmp	r3, #3
 800e9ea:	d10b      	bne.n	800ea04 <wc_ecc_verify_hash_ex+0x90>
      WOLFSSL_MSG("Verify called with private key, generating public part");
      err = ecc_make_pub_ex(key, NULL, NULL, NULL);
 800e9ec:	2300      	movs	r3, #0
 800e9ee:	2200      	movs	r2, #0
 800e9f0:	2100      	movs	r1, #0
 800e9f2:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800e9f4:	f7ff fd4c 	bl	800e490 <ecc_make_pub_ex>
 800e9f8:	6178      	str	r0, [r7, #20]
      if (err != MP_OKAY) {
 800e9fa:	697b      	ldr	r3, [r7, #20]
 800e9fc:	2b00      	cmp	r3, #0
 800e9fe:	d001      	beq.n	800ea04 <wc_ecc_verify_hash_ex+0x90>
           WOLFSSL_MSG("Unable to extract public key");
           return err;
 800ea00:	697b      	ldr	r3, [r7, #20]
 800ea02:	e046      	b.n	800ea92 <wc_ecc_verify_hash_ex+0x11e>
        key->pubkey.y, key->pubkey.z, r, s, res, key->heap);
  }
#endif

#if defined(WOLFSSL_SP_MATH) && !defined(FREESCALE_LTC_ECC)
    if (key->idx == ECC_CUSTOM_IDX || 
 800ea04:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ea06:	685b      	ldr	r3, [r3, #4]
 800ea08:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ea0c:	d015      	beq.n	800ea3a <wc_ecc_verify_hash_ex+0xc6>
            (ecc_sets[key->idx].id != ECC_SECP256R1 && 
 800ea0e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ea10:	685b      	ldr	r3, [r3, #4]
 800ea12:	4a22      	ldr	r2, [pc, #136]	; (800ea9c <wc_ecc_verify_hash_ex+0x128>)
 800ea14:	2134      	movs	r1, #52	; 0x34
 800ea16:	fb01 f303 	mul.w	r3, r1, r3
 800ea1a:	4413      	add	r3, r2
 800ea1c:	3304      	adds	r3, #4
 800ea1e:	681b      	ldr	r3, [r3, #0]
    if (key->idx == ECC_CUSTOM_IDX || 
 800ea20:	2b07      	cmp	r3, #7
 800ea22:	d00d      	beq.n	800ea40 <wc_ecc_verify_hash_ex+0xcc>
             ecc_sets[key->idx].id != ECC_SECP384R1)) {
 800ea24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ea26:	685b      	ldr	r3, [r3, #4]
 800ea28:	4a1c      	ldr	r2, [pc, #112]	; (800ea9c <wc_ecc_verify_hash_ex+0x128>)
 800ea2a:	2134      	movs	r1, #52	; 0x34
 800ea2c:	fb01 f303 	mul.w	r3, r1, r3
 800ea30:	4413      	add	r3, r2
 800ea32:	3304      	adds	r3, #4
 800ea34:	681b      	ldr	r3, [r3, #0]
            (ecc_sets[key->idx].id != ECC_SECP256R1 && 
 800ea36:	2b0f      	cmp	r3, #15
 800ea38:	d002      	beq.n	800ea40 <wc_ecc_verify_hash_ex+0xcc>
        return WC_KEY_SIZE_E;
 800ea3a:	f06f 03e9 	mvn.w	r3, #233	; 0xe9
 800ea3e:	e028      	b.n	800ea92 <wc_ecc_verify_hash_ex+0x11e>
#endif

#if defined(WOLFSSL_SP_MATH) || defined(WOLFSSL_HAVE_SP_ECC) || \
             (defined(WOLFSSL_SP_MATH_ALL) && defined(WOLFSSL_HAVE_SP_ECC)) && \
                                                     !defined(FREESCALE_LTC_ECC)
    if (key->idx != ECC_CUSTOM_IDX
 800ea40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ea42:	685b      	ldr	r3, [r3, #4]
 800ea44:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ea48:	d022      	beq.n	800ea90 <wc_ecc_verify_hash_ex+0x11c>
        ecc_nb_ctx_t nb_ctx;
        XMEMSET(&nb_ctx, 0, sizeof(nb_ctx));
        err = NOT_COMPILED_IN; /* set default error */
    #endif
    #ifndef WOLFSSL_SP_NO_256
        if (ecc_sets[key->idx].id == ECC_SECP256R1) {
 800ea4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ea4c:	685b      	ldr	r3, [r3, #4]
 800ea4e:	4a13      	ldr	r2, [pc, #76]	; (800ea9c <wc_ecc_verify_hash_ex+0x128>)
 800ea50:	2134      	movs	r1, #52	; 0x34
 800ea52:	fb01 f303 	mul.w	r3, r1, r3
 800ea56:	4413      	add	r3, r2
 800ea58:	3304      	adds	r3, #4
 800ea5a:	681b      	ldr	r3, [r3, #0]
 800ea5c:	2b07      	cmp	r3, #7
 800ea5e:	d117      	bne.n	800ea90 <wc_ecc_verify_hash_ex+0x11c>
            } while (err == FP_WOULDBLOCK);
            return err;
            #endif
        #endif /* WC_ECC_NONBLOCK */
        #if !defined(WC_ECC_NONBLOCK) || (defined(WC_ECC_NONBLOCK) && !defined(WC_ECC_NONBLOCK_ONLY))
            return sp_ecc_verify_256(hash, hashlen, key->pubkey.x, 
 800ea60:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ea62:	6999      	ldr	r1, [r3, #24]
 800ea64:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ea66:	69d8      	ldr	r0, [r3, #28]
 800ea68:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ea6a:	6a1b      	ldr	r3, [r3, #32]
 800ea6c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800ea6e:	6952      	ldr	r2, [r2, #20]
 800ea70:	9204      	str	r2, [sp, #16]
 800ea72:	6a3a      	ldr	r2, [r7, #32]
 800ea74:	9203      	str	r2, [sp, #12]
 800ea76:	68ba      	ldr	r2, [r7, #8]
 800ea78:	9202      	str	r2, [sp, #8]
 800ea7a:	68fa      	ldr	r2, [r7, #12]
 800ea7c:	9201      	str	r2, [sp, #4]
 800ea7e:	9300      	str	r3, [sp, #0]
 800ea80:	4603      	mov	r3, r0
 800ea82:	460a      	mov	r2, r1
 800ea84:	6839      	ldr	r1, [r7, #0]
 800ea86:	6878      	ldr	r0, [r7, #4]
 800ea88:	f009 fdb4 	bl	80185f4 <sp_ecc_verify_256>
 800ea8c:	4603      	mov	r3, r0
 800ea8e:	e000      	b.n	800ea92 <wc_ecc_verify_hash_ex+0x11e>
#endif /* WOLFSSL_ATECC508A */

   (void)keySz;
   (void)hashlen;

   return err;
 800ea90:	697b      	ldr	r3, [r7, #20]
}
 800ea92:	4618      	mov	r0, r3
 800ea94:	3718      	adds	r7, #24
 800ea96:	46bd      	mov	sp, r7
 800ea98:	bd80      	pop	{r7, pc}
 800ea9a:	bf00      	nop
 800ea9c:	0801ad8c 	.word	0x0801ad8c

0800eaa0 <wc_ecc_import_x963_ex>:

#ifdef HAVE_ECC_KEY_IMPORT
/* import public ECC key in ANSI X9.63 format */
int wc_ecc_import_x963_ex(const byte* in, word32 inLen, ecc_key* key,
                          int curve_id)
{
 800eaa0:	b580      	push	{r7, lr}
 800eaa2:	b088      	sub	sp, #32
 800eaa4:	af00      	add	r7, sp, #0
 800eaa6:	60f8      	str	r0, [r7, #12]
 800eaa8:	60b9      	str	r1, [r7, #8]
 800eaaa:	607a      	str	r2, [r7, #4]
 800eaac:	603b      	str	r3, [r7, #0]
    int err = MP_OKAY;
 800eaae:	2300      	movs	r3, #0
 800eab0:	61fb      	str	r3, [r7, #28]
#ifdef HAVE_COMP_KEY
    int compressed = 0;
#endif
    int keysize = 0;
 800eab2:	2300      	movs	r3, #0
 800eab4:	61bb      	str	r3, [r7, #24]
    byte pointType;

    if (in == NULL || key == NULL)
 800eab6:	68fb      	ldr	r3, [r7, #12]
 800eab8:	2b00      	cmp	r3, #0
 800eaba:	d002      	beq.n	800eac2 <wc_ecc_import_x963_ex+0x22>
 800eabc:	687b      	ldr	r3, [r7, #4]
 800eabe:	2b00      	cmp	r3, #0
 800eac0:	d102      	bne.n	800eac8 <wc_ecc_import_x963_ex+0x28>
        return BAD_FUNC_ARG;
 800eac2:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800eac6:	e09d      	b.n	800ec04 <wc_ecc_import_x963_ex+0x164>

    /* must be odd */
    if ((inLen & 1) == 0) {
 800eac8:	68bb      	ldr	r3, [r7, #8]
 800eaca:	f003 0301 	and.w	r3, r3, #1
 800eace:	2b00      	cmp	r3, #0
 800ead0:	d102      	bne.n	800ead8 <wc_ecc_import_x963_ex+0x38>
        return ECC_BAD_ARG_E;
 800ead2:	f06f 03a9 	mvn.w	r3, #169	; 0xa9
 800ead6:	e095      	b.n	800ec04 <wc_ecc_import_x963_ex+0x164>
    }

    /* make sure required variables are reset */
    wc_ecc_reset(key);
 800ead8:	6878      	ldr	r0, [r7, #4]
 800eada:	f7ff fccb 	bl	800e474 <wc_ecc_reset>

    /* init key */
    #ifdef ALT_ECC_SIZE
        key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];
 800eade:	687b      	ldr	r3, [r7, #4]
 800eae0:	f103 0224 	add.w	r2, r3, #36	; 0x24
 800eae4:	687b      	ldr	r3, [r7, #4]
 800eae6:	619a      	str	r2, [r3, #24]
        key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];
 800eae8:	687b      	ldr	r3, [r7, #4]
 800eaea:	f103 0270 	add.w	r2, r3, #112	; 0x70
 800eaee:	687b      	ldr	r3, [r7, #4]
 800eaf0:	61da      	str	r2, [r3, #28]
        key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];
 800eaf2:	687b      	ldr	r3, [r7, #4]
 800eaf4:	f103 02bc 	add.w	r2, r3, #188	; 0xbc
 800eaf8:	687b      	ldr	r3, [r7, #4]
 800eafa:	621a      	str	r2, [r3, #32]
        alt_fp_init(key->pubkey.x);
 800eafc:	687b      	ldr	r3, [r7, #4]
 800eafe:	699b      	ldr	r3, [r3, #24]
 800eb00:	4618      	mov	r0, r3
 800eb02:	f7ff fc31 	bl	800e368 <alt_fp_init>
        alt_fp_init(key->pubkey.y);
 800eb06:	687b      	ldr	r3, [r7, #4]
 800eb08:	69db      	ldr	r3, [r3, #28]
 800eb0a:	4618      	mov	r0, r3
 800eb0c:	f7ff fc2c 	bl	800e368 <alt_fp_init>
        alt_fp_init(key->pubkey.z);
 800eb10:	687b      	ldr	r3, [r7, #4]
 800eb12:	6a1b      	ldr	r3, [r3, #32]
 800eb14:	4618      	mov	r0, r3
 800eb16:	f7ff fc27 	bl	800e368 <alt_fp_init>
        err = mp_init(&key->k);
 800eb1a:	687b      	ldr	r3, [r7, #4]
 800eb1c:	f503 7384 	add.w	r3, r3, #264	; 0x108
 800eb20:	4618      	mov	r0, r3
 800eb22:	f009 fef3 	bl	801890c <sp_init>
 800eb26:	61f8      	str	r0, [r7, #28]
    #else
        err = mp_init_multi(&key->k,
                    key->pubkey.x, key->pubkey.y, key->pubkey.z, NULL, NULL);
    #endif
    if (err != MP_OKAY)
 800eb28:	69fb      	ldr	r3, [r7, #28]
 800eb2a:	2b00      	cmp	r3, #0
 800eb2c:	d002      	beq.n	800eb34 <wc_ecc_import_x963_ex+0x94>
        return MEMORY_E;
 800eb2e:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800eb32:	e067      	b.n	800ec04 <wc_ecc_import_x963_ex+0x164>

    /* check for point type (4, 2, or 3) */
    pointType = in[0];
 800eb34:	68fb      	ldr	r3, [r7, #12]
 800eb36:	781b      	ldrb	r3, [r3, #0]
 800eb38:	75fb      	strb	r3, [r7, #23]
    if (pointType != ECC_POINT_UNCOMP && pointType != ECC_POINT_COMP_EVEN &&
 800eb3a:	7dfb      	ldrb	r3, [r7, #23]
 800eb3c:	2b04      	cmp	r3, #4
 800eb3e:	d008      	beq.n	800eb52 <wc_ecc_import_x963_ex+0xb2>
 800eb40:	7dfb      	ldrb	r3, [r7, #23]
 800eb42:	2b02      	cmp	r3, #2
 800eb44:	d005      	beq.n	800eb52 <wc_ecc_import_x963_ex+0xb2>
 800eb46:	7dfb      	ldrb	r3, [r7, #23]
 800eb48:	2b03      	cmp	r3, #3
 800eb4a:	d002      	beq.n	800eb52 <wc_ecc_import_x963_ex+0xb2>
                                         pointType != ECC_POINT_COMP_ODD) {
        err = ASN_PARSE_E;
 800eb4c:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800eb50:	61fb      	str	r3, [r7, #28]
    }

    if (pointType == ECC_POINT_COMP_EVEN || pointType == ECC_POINT_COMP_ODD) {
 800eb52:	7dfb      	ldrb	r3, [r7, #23]
 800eb54:	2b02      	cmp	r3, #2
 800eb56:	d002      	beq.n	800eb5e <wc_ecc_import_x963_ex+0xbe>
 800eb58:	7dfb      	ldrb	r3, [r7, #23]
 800eb5a:	2b03      	cmp	r3, #3
 800eb5c:	d102      	bne.n	800eb64 <wc_ecc_import_x963_ex+0xc4>
    #ifdef HAVE_COMP_KEY
        compressed = 1;
    #else
        err = NOT_COMPILED_IN;
 800eb5e:	f06f 03ad 	mvn.w	r3, #173	; 0xad
 800eb62:	61fb      	str	r3, [r7, #28]
    #endif
    }

    /* adjust to skip first byte */
    inLen -= 1;
 800eb64:	68bb      	ldr	r3, [r7, #8]
 800eb66:	3b01      	subs	r3, #1
 800eb68:	60bb      	str	r3, [r7, #8]
    in += 1;
 800eb6a:	68fb      	ldr	r3, [r7, #12]
 800eb6c:	3301      	adds	r3, #1
 800eb6e:	60fb      	str	r3, [r7, #12]
    #endif
            XMEMCPY(key->pubkey_raw, (byte*)in, inLen);
    }
#endif

    if (err == MP_OKAY) {
 800eb70:	69fb      	ldr	r3, [r7, #28]
 800eb72:	2b00      	cmp	r3, #0
 800eb74:	d10b      	bne.n	800eb8e <wc_ecc_import_x963_ex+0xee>
        if (compressed)
            inLen = inLen*2 + 1;  /* used uncompressed len */
    #endif

        /* determine key size */
        keysize = (inLen>>1);
 800eb76:	68bb      	ldr	r3, [r7, #8]
 800eb78:	085b      	lsrs	r3, r3, #1
 800eb7a:	61bb      	str	r3, [r7, #24]
        err = wc_ecc_set_curve(key, keysize, curve_id);
 800eb7c:	683a      	ldr	r2, [r7, #0]
 800eb7e:	69b9      	ldr	r1, [r7, #24]
 800eb80:	6878      	ldr	r0, [r7, #4]
 800eb82:	f7ff fb87 	bl	800e294 <wc_ecc_set_curve>
 800eb86:	61f8      	str	r0, [r7, #28]
        key->type = ECC_PUBLICKEY;
 800eb88:	687b      	ldr	r3, [r7, #4]
 800eb8a:	2201      	movs	r2, #1
 800eb8c:	601a      	str	r2, [r3, #0]
    }

    /* read data */
    if (err == MP_OKAY)
 800eb8e:	69fb      	ldr	r3, [r7, #28]
 800eb90:	2b00      	cmp	r3, #0
 800eb92:	d107      	bne.n	800eba4 <wc_ecc_import_x963_ex+0x104>
        err = mp_read_unsigned_bin(key->pubkey.x, (byte*)in, keysize);
 800eb94:	687b      	ldr	r3, [r7, #4]
 800eb96:	699b      	ldr	r3, [r3, #24]
 800eb98:	69ba      	ldr	r2, [r7, #24]
 800eb9a:	68f9      	ldr	r1, [r7, #12]
 800eb9c:	4618      	mov	r0, r3
 800eb9e:	f00a f97d 	bl	8018e9c <sp_read_unsigned_bin>
 800eba2:	61f8      	str	r0, [r7, #28]
        }
#endif
    }
#endif /* HAVE_COMP_KEY */

    if (err == MP_OKAY) {
 800eba4:	69fb      	ldr	r3, [r7, #28]
 800eba6:	2b00      	cmp	r3, #0
 800eba8:	d109      	bne.n	800ebbe <wc_ecc_import_x963_ex+0x11e>
    #ifdef HAVE_COMP_KEY
        if (compressed == 0)
    #endif
        {
            err = mp_read_unsigned_bin(key->pubkey.y, (byte*)in + keysize,
 800ebaa:	687b      	ldr	r3, [r7, #4]
 800ebac:	69d8      	ldr	r0, [r3, #28]
 800ebae:	69bb      	ldr	r3, [r7, #24]
 800ebb0:	68fa      	ldr	r2, [r7, #12]
 800ebb2:	4413      	add	r3, r2
 800ebb4:	69ba      	ldr	r2, [r7, #24]
 800ebb6:	4619      	mov	r1, r3
 800ebb8:	f00a f970 	bl	8018e9c <sp_read_unsigned_bin>
 800ebbc:	61f8      	str	r0, [r7, #28]
                                                                      keysize);
        }
    }
    if (err == MP_OKAY)
 800ebbe:	69fb      	ldr	r3, [r7, #28]
 800ebc0:	2b00      	cmp	r3, #0
 800ebc2:	d106      	bne.n	800ebd2 <wc_ecc_import_x963_ex+0x132>
        err = mp_set(key->pubkey.z, 1);
 800ebc4:	687b      	ldr	r3, [r7, #4]
 800ebc6:	6a1b      	ldr	r3, [r3, #32]
 800ebc8:	2101      	movs	r1, #1
 800ebca:	4618      	mov	r0, r3
 800ebcc:	f00a f84e 	bl	8018c6c <sp_set>
 800ebd0:	61f8      	str	r0, [r7, #28]
#ifdef WOLFSSL_VALIDATE_ECC_IMPORT
    if (err == MP_OKAY)
        err = wc_ecc_check_key(key);
#endif

    if (err != MP_OKAY) {
 800ebd2:	69fb      	ldr	r3, [r7, #28]
 800ebd4:	2b00      	cmp	r3, #0
 800ebd6:	d014      	beq.n	800ec02 <wc_ecc_import_x963_ex+0x162>
        mp_clear(key->pubkey.x);
 800ebd8:	687b      	ldr	r3, [r7, #4]
 800ebda:	699b      	ldr	r3, [r3, #24]
 800ebdc:	4618      	mov	r0, r3
 800ebde:	f009 ff46 	bl	8018a6e <sp_clear>
        mp_clear(key->pubkey.y);
 800ebe2:	687b      	ldr	r3, [r7, #4]
 800ebe4:	69db      	ldr	r3, [r3, #28]
 800ebe6:	4618      	mov	r0, r3
 800ebe8:	f009 ff41 	bl	8018a6e <sp_clear>
        mp_clear(key->pubkey.z);
 800ebec:	687b      	ldr	r3, [r7, #4]
 800ebee:	6a1b      	ldr	r3, [r3, #32]
 800ebf0:	4618      	mov	r0, r3
 800ebf2:	f009 ff3c 	bl	8018a6e <sp_clear>
        mp_clear(&key->k);
 800ebf6:	687b      	ldr	r3, [r7, #4]
 800ebf8:	f503 7384 	add.w	r3, r3, #264	; 0x108
 800ebfc:	4618      	mov	r0, r3
 800ebfe:	f009 ff36 	bl	8018a6e <sp_clear>
    }

    return err;
 800ec02:	69fb      	ldr	r3, [r7, #28]
}
 800ec04:	4618      	mov	r0, r3
 800ec06:	3720      	adds	r7, #32
 800ec08:	46bd      	mov	sp, r7
 800ec0a:	bd80      	pop	{r7, pc}

0800ec0c <wc_ecc_import_private_key_ex>:
#ifdef HAVE_ECC_KEY_IMPORT
/* import private key, public part optional if (pub) passed as NULL */
int wc_ecc_import_private_key_ex(const byte* priv, word32 privSz,
                                 const byte* pub, word32 pubSz, ecc_key* key,
                                 int curve_id)
{
 800ec0c:	b580      	push	{r7, lr}
 800ec0e:	b086      	sub	sp, #24
 800ec10:	af00      	add	r7, sp, #0
 800ec12:	60f8      	str	r0, [r7, #12]
 800ec14:	60b9      	str	r1, [r7, #8]
 800ec16:	607a      	str	r2, [r7, #4]
 800ec18:	603b      	str	r3, [r7, #0]
    int ret;
#ifdef WOLFSSL_CRYPTOCELL
    const CRYS_ECPKI_Domain_t* pDomain;
    CRYS_ECPKI_BUILD_TempData_t tempBuff;
#endif
    if (key == NULL || priv == NULL)
 800ec1a:	6a3b      	ldr	r3, [r7, #32]
 800ec1c:	2b00      	cmp	r3, #0
 800ec1e:	d002      	beq.n	800ec26 <wc_ecc_import_private_key_ex+0x1a>
 800ec20:	68fb      	ldr	r3, [r7, #12]
 800ec22:	2b00      	cmp	r3, #0
 800ec24:	d102      	bne.n	800ec2c <wc_ecc_import_private_key_ex+0x20>
        return BAD_FUNC_ARG;
 800ec26:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800ec2a:	e036      	b.n	800ec9a <wc_ecc_import_private_key_ex+0x8e>

    /* public optional, NULL if only importing private */
    if (pub != NULL) {
 800ec2c:	687b      	ldr	r3, [r7, #4]
 800ec2e:	2b00      	cmp	r3, #0
 800ec30:	d017      	beq.n	800ec62 <wc_ecc_import_private_key_ex+0x56>
    #ifndef NO_ASN
        word32 idx = 0;
 800ec32:	2300      	movs	r3, #0
 800ec34:	613b      	str	r3, [r7, #16]
        ret = wc_ecc_import_x963_ex(pub, pubSz, key, curve_id);
 800ec36:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ec38:	6a3a      	ldr	r2, [r7, #32]
 800ec3a:	6839      	ldr	r1, [r7, #0]
 800ec3c:	6878      	ldr	r0, [r7, #4]
 800ec3e:	f7ff ff2f 	bl	800eaa0 <wc_ecc_import_x963_ex>
 800ec42:	6178      	str	r0, [r7, #20]
        if (ret < 0)
 800ec44:	697b      	ldr	r3, [r7, #20]
 800ec46:	2b00      	cmp	r3, #0
 800ec48:	da07      	bge.n	800ec5a <wc_ecc_import_private_key_ex+0x4e>
            ret = wc_EccPublicKeyDecode(pub, &idx, key, pubSz);
 800ec4a:	f107 0110 	add.w	r1, r7, #16
 800ec4e:	683b      	ldr	r3, [r7, #0]
 800ec50:	6a3a      	ldr	r2, [r7, #32]
 800ec52:	6878      	ldr	r0, [r7, #4]
 800ec54:	f7fe fe77 	bl	800d946 <wc_EccPublicKeyDecode>
 800ec58:	6178      	str	r0, [r7, #20]
        key->type = ECC_PRIVATEKEY;
 800ec5a:	6a3b      	ldr	r3, [r7, #32]
 800ec5c:	2202      	movs	r2, #2
 800ec5e:	601a      	str	r2, [r3, #0]
 800ec60:	e00c      	b.n	800ec7c <wc_ecc_import_private_key_ex+0x70>
        ret = NOT_COMPILED_IN;
    #endif
    }
    else {
        /* make sure required variables are reset */
        wc_ecc_reset(key);
 800ec62:	6a38      	ldr	r0, [r7, #32]
 800ec64:	f7ff fc06 	bl	800e474 <wc_ecc_reset>

        /* set key size */
        ret = wc_ecc_set_curve(key, privSz, curve_id);
 800ec68:	68bb      	ldr	r3, [r7, #8]
 800ec6a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800ec6c:	4619      	mov	r1, r3
 800ec6e:	6a38      	ldr	r0, [r7, #32]
 800ec70:	f7ff fb10 	bl	800e294 <wc_ecc_set_curve>
 800ec74:	6178      	str	r0, [r7, #20]
        key->type = ECC_PRIVATEKEY_ONLY;
 800ec76:	6a3b      	ldr	r3, [r7, #32]
 800ec78:	2203      	movs	r2, #3
 800ec7a:	601a      	str	r2, [r3, #0]
    }

    if (ret != 0)
 800ec7c:	697b      	ldr	r3, [r7, #20]
 800ec7e:	2b00      	cmp	r3, #0
 800ec80:	d001      	beq.n	800ec86 <wc_ecc_import_private_key_ex+0x7a>
        return ret;
 800ec82:	697b      	ldr	r3, [r7, #20]
 800ec84:	e009      	b.n	800ec9a <wc_ecc_import_private_key_ex+0x8e>
            ret = silabs_ecc_import_private(key, key->dp->size);
        }
    }
#else

    ret = mp_read_unsigned_bin(&key->k, priv, privSz);
 800ec86:	6a3b      	ldr	r3, [r7, #32]
 800ec88:	f503 7384 	add.w	r3, r3, #264	; 0x108
 800ec8c:	68ba      	ldr	r2, [r7, #8]
 800ec8e:	68f9      	ldr	r1, [r7, #12]
 800ec90:	4618      	mov	r0, r3
 800ec92:	f00a f903 	bl	8018e9c <sp_read_unsigned_bin>
 800ec96:	6178      	str	r0, [r7, #20]
    if ((pub != NULL) && (ret == MP_OKAY))
        /* public key needed to perform key validation */
        ret = ecc_check_privkey_gen_helper(key);
#endif

    return ret;
 800ec98:	697b      	ldr	r3, [r7, #20]
}
 800ec9a:	4618      	mov	r0, r3
 800ec9c:	3718      	adds	r7, #24
 800ec9e:	46bd      	mov	sp, r7
 800eca0:	bd80      	pop	{r7, pc}

0800eca2 <wc_ecc_size>:
}
#endif /* HAVE_ECC_KEY_IMPORT */

/* key size in octets */
int wc_ecc_size(ecc_key* key)
{
 800eca2:	b480      	push	{r7}
 800eca4:	b083      	sub	sp, #12
 800eca6:	af00      	add	r7, sp, #0
 800eca8:	6078      	str	r0, [r7, #4]
    if (key == NULL)
 800ecaa:	687b      	ldr	r3, [r7, #4]
 800ecac:	2b00      	cmp	r3, #0
 800ecae:	d101      	bne.n	800ecb4 <wc_ecc_size+0x12>
        return 0;
 800ecb0:	2300      	movs	r3, #0
 800ecb2:	e002      	b.n	800ecba <wc_ecc_size+0x18>

    return key->dp->size;
 800ecb4:	687b      	ldr	r3, [r7, #4]
 800ecb6:	691b      	ldr	r3, [r3, #16]
 800ecb8:	681b      	ldr	r3, [r3, #0]
}
 800ecba:	4618      	mov	r0, r3
 800ecbc:	370c      	adds	r7, #12
 800ecbe:	46bd      	mov	sp, r7
 800ecc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ecc4:	4770      	bx	lr
	...

0800ecc8 <wc_ecc_get_oid>:

#endif /* HAVE_COMP_KEY */


int wc_ecc_get_oid(word32 oidSum, const byte** oid, word32* oidSz)
{
 800ecc8:	b480      	push	{r7}
 800ecca:	b087      	sub	sp, #28
 800eccc:	af00      	add	r7, sp, #0
 800ecce:	60f8      	str	r0, [r7, #12]
 800ecd0:	60b9      	str	r1, [r7, #8]
 800ecd2:	607a      	str	r2, [r7, #4]
    int x;

    if (oidSum == 0) {
 800ecd4:	68fb      	ldr	r3, [r7, #12]
 800ecd6:	2b00      	cmp	r3, #0
 800ecd8:	d102      	bne.n	800ece0 <wc_ecc_get_oid+0x18>
        return BAD_FUNC_ARG;
 800ecda:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800ecde:	e040      	b.n	800ed62 <wc_ecc_get_oid+0x9a>
    }

    /* find matching OID sum (based on encoded value) */
    for (x = 0; ecc_sets[x].size != 0; x++) {
 800ece0:	2300      	movs	r3, #0
 800ece2:	617b      	str	r3, [r7, #20]
 800ece4:	e032      	b.n	800ed4c <wc_ecc_get_oid+0x84>
        if (ecc_sets[x].oidSum == oidSum) {
 800ece6:	4a22      	ldr	r2, [pc, #136]	; (800ed70 <wc_ecc_get_oid+0xa8>)
 800ece8:	697b      	ldr	r3, [r7, #20]
 800ecea:	2134      	movs	r1, #52	; 0x34
 800ecec:	fb01 f303 	mul.w	r3, r1, r3
 800ecf0:	4413      	add	r3, r2
 800ecf2:	332c      	adds	r3, #44	; 0x2c
 800ecf4:	681b      	ldr	r3, [r3, #0]
 800ecf6:	68fa      	ldr	r2, [r7, #12]
 800ecf8:	429a      	cmp	r2, r3
 800ecfa:	d124      	bne.n	800ed46 <wc_ecc_get_oid+0x7e>
            /* on success return curve id */
            if (ret == 0) {
                ret = ecc_sets[x].id;
            }
        #else
            if (oidSz) {
 800ecfc:	687b      	ldr	r3, [r7, #4]
 800ecfe:	2b00      	cmp	r3, #0
 800ed00:	d009      	beq.n	800ed16 <wc_ecc_get_oid+0x4e>
                *oidSz = ecc_sets[x].oidSz;
 800ed02:	4a1b      	ldr	r2, [pc, #108]	; (800ed70 <wc_ecc_get_oid+0xa8>)
 800ed04:	697b      	ldr	r3, [r7, #20]
 800ed06:	2134      	movs	r1, #52	; 0x34
 800ed08:	fb01 f303 	mul.w	r3, r1, r3
 800ed0c:	4413      	add	r3, r2
 800ed0e:	3328      	adds	r3, #40	; 0x28
 800ed10:	681a      	ldr	r2, [r3, #0]
 800ed12:	687b      	ldr	r3, [r7, #4]
 800ed14:	601a      	str	r2, [r3, #0]
            }
            if (oid) {
 800ed16:	68bb      	ldr	r3, [r7, #8]
 800ed18:	2b00      	cmp	r3, #0
 800ed1a:	d009      	beq.n	800ed30 <wc_ecc_get_oid+0x68>
                *oid = ecc_sets[x].oid;
 800ed1c:	4a14      	ldr	r2, [pc, #80]	; (800ed70 <wc_ecc_get_oid+0xa8>)
 800ed1e:	697b      	ldr	r3, [r7, #20]
 800ed20:	2134      	movs	r1, #52	; 0x34
 800ed22:	fb01 f303 	mul.w	r3, r1, r3
 800ed26:	4413      	add	r3, r2
 800ed28:	3324      	adds	r3, #36	; 0x24
 800ed2a:	681a      	ldr	r2, [r3, #0]
 800ed2c:	68bb      	ldr	r3, [r7, #8]
 800ed2e:	601a      	str	r2, [r3, #0]
            }
            ret = ecc_sets[x].id;
 800ed30:	4a0f      	ldr	r2, [pc, #60]	; (800ed70 <wc_ecc_get_oid+0xa8>)
 800ed32:	697b      	ldr	r3, [r7, #20]
 800ed34:	2134      	movs	r1, #52	; 0x34
 800ed36:	fb01 f303 	mul.w	r3, r1, r3
 800ed3a:	4413      	add	r3, r2
 800ed3c:	3304      	adds	r3, #4
 800ed3e:	681b      	ldr	r3, [r3, #0]
 800ed40:	613b      	str	r3, [r7, #16]
        #endif
            return ret;
 800ed42:	693b      	ldr	r3, [r7, #16]
 800ed44:	e00d      	b.n	800ed62 <wc_ecc_get_oid+0x9a>
    for (x = 0; ecc_sets[x].size != 0; x++) {
 800ed46:	697b      	ldr	r3, [r7, #20]
 800ed48:	3301      	adds	r3, #1
 800ed4a:	617b      	str	r3, [r7, #20]
 800ed4c:	4a08      	ldr	r2, [pc, #32]	; (800ed70 <wc_ecc_get_oid+0xa8>)
 800ed4e:	697b      	ldr	r3, [r7, #20]
 800ed50:	2134      	movs	r1, #52	; 0x34
 800ed52:	fb01 f303 	mul.w	r3, r1, r3
 800ed56:	4413      	add	r3, r2
 800ed58:	681b      	ldr	r3, [r3, #0]
 800ed5a:	2b00      	cmp	r3, #0
 800ed5c:	d1c3      	bne.n	800ece6 <wc_ecc_get_oid+0x1e>
        }
    }

    return NOT_COMPILED_IN;
 800ed5e:	f06f 03ad 	mvn.w	r3, #173	; 0xad
}
 800ed62:	4618      	mov	r0, r3
 800ed64:	371c      	adds	r7, #28
 800ed66:	46bd      	mov	sp, r7
 800ed68:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ed6c:	4770      	bx	lr
 800ed6e:	bf00      	nop
 800ed70:	0801ad8c 	.word	0x0801ad8c

0800ed74 <wc_HashGetDigestSize>:

#ifndef NO_HASH_WRAPPER

/* Get Hash digest size */
int wc_HashGetDigestSize(enum wc_HashType hash_type)
{
 800ed74:	b480      	push	{r7}
 800ed76:	b085      	sub	sp, #20
 800ed78:	af00      	add	r7, sp, #0
 800ed7a:	4603      	mov	r3, r0
 800ed7c:	71fb      	strb	r3, [r7, #7]
    int dig_size = HASH_TYPE_E; /* Default to hash type error */
 800ed7e:	f06f 03e7 	mvn.w	r3, #231	; 0xe7
 800ed82:	60fb      	str	r3, [r7, #12]
    switch(hash_type)
 800ed84:	79fb      	ldrb	r3, [r7, #7]
 800ed86:	3b01      	subs	r3, #1
 800ed88:	2b0e      	cmp	r3, #14
 800ed8a:	d824      	bhi.n	800edd6 <wc_HashGetDigestSize+0x62>
 800ed8c:	a201      	add	r2, pc, #4	; (adr r2, 800ed94 <wc_HashGetDigestSize+0x20>)
 800ed8e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ed92:	bf00      	nop
 800ed94:	0800eddf 	.word	0x0800eddf
 800ed98:	0800eddf 	.word	0x0800eddf
 800ed9c:	0800eddf 	.word	0x0800eddf
 800eda0:	0800eddf 	.word	0x0800eddf
 800eda4:	0800eddf 	.word	0x0800eddf
 800eda8:	0800edd1 	.word	0x0800edd1
 800edac:	0800eddf 	.word	0x0800eddf
 800edb0:	0800eddf 	.word	0x0800eddf
 800edb4:	0800eddf 	.word	0x0800eddf
 800edb8:	0800eddf 	.word	0x0800eddf
 800edbc:	0800eddf 	.word	0x0800eddf
 800edc0:	0800eddf 	.word	0x0800eddf
 800edc4:	0800eddf 	.word	0x0800eddf
 800edc8:	0800eddf 	.word	0x0800eddf
 800edcc:	0800eddf 	.word	0x0800eddf
            dig_size = WC_SHA224_DIGEST_SIZE;
        #endif
            break;
        case WC_HASH_TYPE_SHA256:
        #ifndef NO_SHA256
            dig_size = WC_SHA256_DIGEST_SIZE;
 800edd0:	2320      	movs	r3, #32
 800edd2:	60fb      	str	r3, [r7, #12]
        #endif
            break;
 800edd4:	e004      	b.n	800ede0 <wc_HashGetDigestSize+0x6c>
            break;

        /* Not Supported */
        case WC_HASH_TYPE_NONE:
        default:
            dig_size = BAD_FUNC_ARG;
 800edd6:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800edda:	60fb      	str	r3, [r7, #12]
            break;
 800eddc:	e000      	b.n	800ede0 <wc_HashGetDigestSize+0x6c>
            break;
 800edde:	bf00      	nop
    }
    return dig_size;
 800ede0:	68fb      	ldr	r3, [r7, #12]
}
 800ede2:	4618      	mov	r0, r3
 800ede4:	3714      	adds	r7, #20
 800ede6:	46bd      	mov	sp, r7
 800ede8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800edec:	4770      	bx	lr
 800edee:	bf00      	nop

0800edf0 <wc_Hash>:
}

/* Generic Hashing Wrapper */
int wc_Hash(enum wc_HashType hash_type, const byte* data,
    word32 data_len, byte* hash, word32 hash_len)
{
 800edf0:	b580      	push	{r7, lr}
 800edf2:	b086      	sub	sp, #24
 800edf4:	af00      	add	r7, sp, #0
 800edf6:	60b9      	str	r1, [r7, #8]
 800edf8:	607a      	str	r2, [r7, #4]
 800edfa:	603b      	str	r3, [r7, #0]
 800edfc:	4603      	mov	r3, r0
 800edfe:	73fb      	strb	r3, [r7, #15]
    int ret = HASH_TYPE_E; /* Default to hash type error */
 800ee00:	f06f 03e7 	mvn.w	r3, #231	; 0xe7
 800ee04:	617b      	str	r3, [r7, #20]
    word32 dig_size;

    /* Validate hash buffer size */
    dig_size = wc_HashGetDigestSize(hash_type);
 800ee06:	7bfb      	ldrb	r3, [r7, #15]
 800ee08:	4618      	mov	r0, r3
 800ee0a:	f7ff ffb3 	bl	800ed74 <wc_HashGetDigestSize>
 800ee0e:	4603      	mov	r3, r0
 800ee10:	613b      	str	r3, [r7, #16]
    if (hash_len < dig_size) {
 800ee12:	6a3a      	ldr	r2, [r7, #32]
 800ee14:	693b      	ldr	r3, [r7, #16]
 800ee16:	429a      	cmp	r2, r3
 800ee18:	d202      	bcs.n	800ee20 <wc_Hash+0x30>
        return BUFFER_E;
 800ee1a:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800ee1e:	e02a      	b.n	800ee76 <wc_Hash+0x86>
    (void)data;
    (void)data_len;
    (void)hash;
    (void)hash_len;

    switch(hash_type)
 800ee20:	7bfb      	ldrb	r3, [r7, #15]
 800ee22:	3b03      	subs	r3, #3
 800ee24:	2b0a      	cmp	r3, #10
 800ee26:	d820      	bhi.n	800ee6a <wc_Hash+0x7a>
 800ee28:	a201      	add	r2, pc, #4	; (adr r2, 800ee30 <wc_Hash+0x40>)
 800ee2a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ee2e:	bf00      	nop
 800ee30:	0800ee73 	.word	0x0800ee73
 800ee34:	0800ee73 	.word	0x0800ee73
 800ee38:	0800ee73 	.word	0x0800ee73
 800ee3c:	0800ee5d 	.word	0x0800ee5d
 800ee40:	0800ee73 	.word	0x0800ee73
 800ee44:	0800ee73 	.word	0x0800ee73
 800ee48:	0800ee73 	.word	0x0800ee73
 800ee4c:	0800ee73 	.word	0x0800ee73
 800ee50:	0800ee73 	.word	0x0800ee73
 800ee54:	0800ee73 	.word	0x0800ee73
 800ee58:	0800ee73 	.word	0x0800ee73
            ret = wc_Sha224Hash(data, data_len, hash);
#endif
            break;
        case WC_HASH_TYPE_SHA256:
#ifndef NO_SHA256
            ret = wc_Sha256Hash(data, data_len, hash);
 800ee5c:	683a      	ldr	r2, [r7, #0]
 800ee5e:	6879      	ldr	r1, [r7, #4]
 800ee60:	68b8      	ldr	r0, [r7, #8]
 800ee62:	f000 f80d 	bl	800ee80 <wc_Sha256Hash>
 800ee66:	6178      	str	r0, [r7, #20]
#endif
            break;
 800ee68:	e004      	b.n	800ee74 <wc_Hash+0x84>
        case WC_HASH_TYPE_MD4:
        case WC_HASH_TYPE_BLAKE2B:
        case WC_HASH_TYPE_BLAKE2S:
        case WC_HASH_TYPE_NONE:
        default:
            ret = BAD_FUNC_ARG;
 800ee6a:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800ee6e:	617b      	str	r3, [r7, #20]
            break;
 800ee70:	e000      	b.n	800ee74 <wc_Hash+0x84>
            break;
 800ee72:	bf00      	nop
    }
    return ret;
 800ee74:	697b      	ldr	r3, [r7, #20]
}
 800ee76:	4618      	mov	r0, r3
 800ee78:	3718      	adds	r7, #24
 800ee7a:	46bd      	mov	sp, r7
 800ee7c:	bd80      	pop	{r7, pc}
 800ee7e:	bf00      	nop

0800ee80 <wc_Sha256Hash>:
}
#endif /* WOLFSSL_SHA224 */

#if !defined(NO_SHA256)
    int wc_Sha256Hash(const byte* data, word32 len, byte* hash)
    {
 800ee80:	b580      	push	{r7, lr}
 800ee82:	b088      	sub	sp, #32
 800ee84:	af00      	add	r7, sp, #0
 800ee86:	60f8      	str	r0, [r7, #12]
 800ee88:	60b9      	str	r1, [r7, #8]
 800ee8a:	607a      	str	r2, [r7, #4]
        int ret = 0;
 800ee8c:	2300      	movs	r3, #0
 800ee8e:	61fb      	str	r3, [r7, #28]
    #ifdef WOLFSSL_SMALL_STACK
        wc_Sha256* sha256;
    #else
        wc_Sha256 sha256[1];
    #endif
        int devId = INVALID_DEVID;
 800ee90:	f06f 0301 	mvn.w	r3, #1
 800ee94:	61bb      	str	r3, [r7, #24]

    #ifdef WOLFSSL_SMALL_STACK
        sha256 = (wc_Sha256*)XMALLOC(sizeof(wc_Sha256), NULL,
 800ee96:	2070      	movs	r0, #112	; 0x70
 800ee98:	f000 f82e 	bl	800eef8 <wolfSSL_Malloc>
 800ee9c:	6178      	str	r0, [r7, #20]
            DYNAMIC_TYPE_TMP_BUFFER);
        if (sha256 == NULL)
 800ee9e:	697b      	ldr	r3, [r7, #20]
 800eea0:	2b00      	cmp	r3, #0
 800eea2:	d102      	bne.n	800eeaa <wc_Sha256Hash+0x2a>
            return MEMORY_E;
 800eea4:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800eea8:	e022      	b.n	800eef0 <wc_Sha256Hash+0x70>
        /* only use devId if its not an empty hash */
        if (data != NULL && len > 0)
            devId = wc_CryptoCb_GetDevIdAtIndex(0);
    #endif

        if ((ret = wc_InitSha256_ex(sha256, NULL, devId)) != 0) {
 800eeaa:	69ba      	ldr	r2, [r7, #24]
 800eeac:	2100      	movs	r1, #0
 800eeae:	6978      	ldr	r0, [r7, #20]
 800eeb0:	f001 fade 	bl	8010470 <wc_InitSha256_ex>
 800eeb4:	61f8      	str	r0, [r7, #28]
 800eeb6:	69fb      	ldr	r3, [r7, #28]
 800eeb8:	2b00      	cmp	r3, #0
 800eeba:	d110      	bne.n	800eede <wc_Sha256Hash+0x5e>
            WOLFSSL_MSG("InitSha256 failed");
        }
        else {
            if ((ret = wc_Sha256Update(sha256, data, len)) != 0) {
 800eebc:	68ba      	ldr	r2, [r7, #8]
 800eebe:	68f9      	ldr	r1, [r7, #12]
 800eec0:	6978      	ldr	r0, [r7, #20]
 800eec2:	f001 ff25 	bl	8010d10 <wc_Sha256Update>
 800eec6:	61f8      	str	r0, [r7, #28]
 800eec8:	69fb      	ldr	r3, [r7, #28]
 800eeca:	2b00      	cmp	r3, #0
 800eecc:	d104      	bne.n	800eed8 <wc_Sha256Hash+0x58>
                WOLFSSL_MSG("Sha256Update failed");
            }
            else if ((ret = wc_Sha256Final(sha256, hash)) != 0) {
 800eece:	6879      	ldr	r1, [r7, #4]
 800eed0:	6978      	ldr	r0, [r7, #20]
 800eed2:	f001 ffb9 	bl	8010e48 <wc_Sha256Final>
 800eed6:	61f8      	str	r0, [r7, #28]
                WOLFSSL_MSG("Sha256Final failed");
            }
            wc_Sha256Free(sha256);
 800eed8:	6978      	ldr	r0, [r7, #20]
 800eeda:	f001 ffe0 	bl	8010e9e <wc_Sha256Free>
        }


    #ifdef WOLFSSL_SMALL_STACK
        XFREE(sha256, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800eede:	697b      	ldr	r3, [r7, #20]
 800eee0:	613b      	str	r3, [r7, #16]
 800eee2:	693b      	ldr	r3, [r7, #16]
 800eee4:	2b00      	cmp	r3, #0
 800eee6:	d002      	beq.n	800eeee <wc_Sha256Hash+0x6e>
 800eee8:	6938      	ldr	r0, [r7, #16]
 800eeea:	f000 f821 	bl	800ef30 <wolfSSL_Free>
    #endif

        return ret;
 800eeee:	69fb      	ldr	r3, [r7, #28]
    }
 800eef0:	4618      	mov	r0, r3
 800eef2:	3720      	adds	r7, #32
 800eef4:	46bd      	mov	sp, r7
 800eef6:	bd80      	pop	{r7, pc}

0800eef8 <wolfSSL_Malloc>:
#ifdef WOLFSSL_DEBUG_MEMORY
void* wolfSSL_Malloc(size_t size, const char* func, unsigned int line)
#else
void* wolfSSL_Malloc(size_t size)
#endif
{
 800eef8:	b580      	push	{r7, lr}
 800eefa:	b084      	sub	sp, #16
 800eefc:	af00      	add	r7, sp, #0
 800eefe:	6078      	str	r0, [r7, #4]
    void* res = 0;
 800ef00:	2300      	movs	r3, #0
 800ef02:	60fb      	str	r3, [r7, #12]

    if (malloc_function) {
 800ef04:	4b09      	ldr	r3, [pc, #36]	; (800ef2c <wolfSSL_Malloc+0x34>)
 800ef06:	681b      	ldr	r3, [r3, #0]
 800ef08:	2b00      	cmp	r3, #0
 800ef0a:	d005      	beq.n	800ef18 <wolfSSL_Malloc+0x20>
    #ifdef WOLFSSL_DEBUG_MEMORY
        res = malloc_function(size, func, line);
    #else
        res = malloc_function(size);
 800ef0c:	4b07      	ldr	r3, [pc, #28]	; (800ef2c <wolfSSL_Malloc+0x34>)
 800ef0e:	681b      	ldr	r3, [r3, #0]
 800ef10:	6878      	ldr	r0, [r7, #4]
 800ef12:	4798      	blx	r3
 800ef14:	60f8      	str	r0, [r7, #12]
 800ef16:	e004      	b.n	800ef22 <wolfSSL_Malloc+0x2a>
    #endif
    }
    else {
    #ifndef WOLFSSL_NO_MALLOC
        res = malloc(size);
 800ef18:	6878      	ldr	r0, [r7, #4]
 800ef1a:	f00a fa3b 	bl	8019394 <malloc>
 800ef1e:	4603      	mov	r3, r0
 800ef20:	60fb      	str	r3, [r7, #12]
        gMemFailCount = gMemFailCountSeed; /* reset */
        return NULL;
    }
#endif

    return res;
 800ef22:	68fb      	ldr	r3, [r7, #12]
}
 800ef24:	4618      	mov	r0, r3
 800ef26:	3710      	adds	r7, #16
 800ef28:	46bd      	mov	sp, r7
 800ef2a:	bd80      	pop	{r7, pc}
 800ef2c:	2000022c 	.word	0x2000022c

0800ef30 <wolfSSL_Free>:
#ifdef WOLFSSL_DEBUG_MEMORY
void wolfSSL_Free(void *ptr, const char* func, unsigned int line)
#else
void wolfSSL_Free(void *ptr)
#endif
{
 800ef30:	b580      	push	{r7, lr}
 800ef32:	b082      	sub	sp, #8
 800ef34:	af00      	add	r7, sp, #0
 800ef36:	6078      	str	r0, [r7, #4]
    (void)func;
    (void)line;
#endif
#endif

    if (free_function) {
 800ef38:	4b07      	ldr	r3, [pc, #28]	; (800ef58 <wolfSSL_Free+0x28>)
 800ef3a:	681b      	ldr	r3, [r3, #0]
 800ef3c:	2b00      	cmp	r3, #0
 800ef3e:	d004      	beq.n	800ef4a <wolfSSL_Free+0x1a>
    #ifdef WOLFSSL_DEBUG_MEMORY
        free_function(ptr, func, line);
    #else
        free_function(ptr);
 800ef40:	4b05      	ldr	r3, [pc, #20]	; (800ef58 <wolfSSL_Free+0x28>)
 800ef42:	681b      	ldr	r3, [r3, #0]
 800ef44:	6878      	ldr	r0, [r7, #4]
 800ef46:	4798      	blx	r3
        free(ptr);
    #else
        WOLFSSL_MSG("No free available");
    #endif
    }
}
 800ef48:	e002      	b.n	800ef50 <wolfSSL_Free+0x20>
        free(ptr);
 800ef4a:	6878      	ldr	r0, [r7, #4]
 800ef4c:	f00a fa2a 	bl	80193a4 <free>
}
 800ef50:	bf00      	nop
 800ef52:	3708      	adds	r7, #8
 800ef54:	46bd      	mov	sp, r7
 800ef56:	bd80      	pop	{r7, pc}
 800ef58:	20000230 	.word	0x20000230

0800ef5c <ForceZero>:
{
 800ef5c:	b480      	push	{r7}
 800ef5e:	b085      	sub	sp, #20
 800ef60:	af00      	add	r7, sp, #0
 800ef62:	6078      	str	r0, [r7, #4]
 800ef64:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 800ef66:	687b      	ldr	r3, [r7, #4]
 800ef68:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 800ef6a:	e004      	b.n	800ef76 <ForceZero+0x1a>
 800ef6c:	68fb      	ldr	r3, [r7, #12]
 800ef6e:	1c5a      	adds	r2, r3, #1
 800ef70:	60fa      	str	r2, [r7, #12]
 800ef72:	2200      	movs	r2, #0
 800ef74:	701a      	strb	r2, [r3, #0]
 800ef76:	683b      	ldr	r3, [r7, #0]
 800ef78:	1e5a      	subs	r2, r3, #1
 800ef7a:	603a      	str	r2, [r7, #0]
 800ef7c:	2b00      	cmp	r3, #0
 800ef7e:	d1f5      	bne.n	800ef6c <ForceZero+0x10>
}
 800ef80:	bf00      	nop
 800ef82:	3714      	adds	r7, #20
 800ef84:	46bd      	mov	sp, r7
 800ef86:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ef8a:	4770      	bx	lr

0800ef8c <Hash_DRBG_Uninstantiate>:
    return ret;
}

/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_DRBG_Uninstantiate(DRBG_internal* drbg)
{
 800ef8c:	b580      	push	{r7, lr}
 800ef8e:	b086      	sub	sp, #24
 800ef90:	af00      	add	r7, sp, #0
 800ef92:	6078      	str	r0, [r7, #4]
    word32 i;
    int    compareSum = 0;
 800ef94:	2300      	movs	r3, #0
 800ef96:	613b      	str	r3, [r7, #16]
    byte*  compareDrbg = (byte*)drbg;
 800ef98:	687b      	ldr	r3, [r7, #4]
 800ef9a:	60fb      	str	r3, [r7, #12]

#ifdef WOLFSSL_SMALL_STACK_CACHE
    wc_Sha256Free(&drbg->sha256);
#endif

    ForceZero(drbg, sizeof(DRBG_internal));
 800ef9c:	2178      	movs	r1, #120	; 0x78
 800ef9e:	6878      	ldr	r0, [r7, #4]
 800efa0:	f7ff ffdc 	bl	800ef5c <ForceZero>

    for (i = 0; i < sizeof(DRBG_internal); i++)
 800efa4:	2300      	movs	r3, #0
 800efa6:	617b      	str	r3, [r7, #20]
 800efa8:	e00a      	b.n	800efc0 <Hash_DRBG_Uninstantiate+0x34>
        compareSum |= compareDrbg[i] ^ 0;
 800efaa:	68fa      	ldr	r2, [r7, #12]
 800efac:	697b      	ldr	r3, [r7, #20]
 800efae:	4413      	add	r3, r2
 800efb0:	781b      	ldrb	r3, [r3, #0]
 800efb2:	461a      	mov	r2, r3
 800efb4:	693b      	ldr	r3, [r7, #16]
 800efb6:	4313      	orrs	r3, r2
 800efb8:	613b      	str	r3, [r7, #16]
    for (i = 0; i < sizeof(DRBG_internal); i++)
 800efba:	697b      	ldr	r3, [r7, #20]
 800efbc:	3301      	adds	r3, #1
 800efbe:	617b      	str	r3, [r7, #20]
 800efc0:	697b      	ldr	r3, [r7, #20]
 800efc2:	2b77      	cmp	r3, #119	; 0x77
 800efc4:	d9f1      	bls.n	800efaa <Hash_DRBG_Uninstantiate+0x1e>

    return (compareSum == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 800efc6:	693b      	ldr	r3, [r7, #16]
 800efc8:	2b00      	cmp	r3, #0
 800efca:	bf14      	ite	ne
 800efcc:	2301      	movne	r3, #1
 800efce:	2300      	moveq	r3, #0
 800efd0:	b2db      	uxtb	r3, r3
}
 800efd2:	4618      	mov	r0, r3
 800efd4:	3718      	adds	r7, #24
 800efd6:	46bd      	mov	sp, r7
 800efd8:	bd80      	pop	{r7, pc}

0800efda <wc_FreeRng>:
    return wc_RNG_GenerateBlock(rng, b, 1);
}


int wc_FreeRng(WC_RNG* rng)
{
 800efda:	b580      	push	{r7, lr}
 800efdc:	b084      	sub	sp, #16
 800efde:	af00      	add	r7, sp, #0
 800efe0:	6078      	str	r0, [r7, #4]
    int ret = 0;
 800efe2:	2300      	movs	r3, #0
 800efe4:	60fb      	str	r3, [r7, #12]

    if (rng == NULL)
 800efe6:	687b      	ldr	r3, [r7, #4]
 800efe8:	2b00      	cmp	r3, #0
 800efea:	d102      	bne.n	800eff2 <wc_FreeRng+0x18>
        return BAD_FUNC_ARG;
 800efec:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800eff0:	e01e      	b.n	800f030 <wc_FreeRng+0x56>
#if defined(WOLFSSL_ASYNC_CRYPT)
    wolfAsync_DevCtxFree(&rng->asyncDev, WOLFSSL_ASYNC_MARKER_RNG);
#endif

#ifdef HAVE_HASHDRBG
    if (rng->drbg != NULL) {
 800eff2:	687b      	ldr	r3, [r7, #4]
 800eff4:	689b      	ldr	r3, [r3, #8]
 800eff6:	2b00      	cmp	r3, #0
 800eff8:	d016      	beq.n	800f028 <wc_FreeRng+0x4e>
      if (Hash_DRBG_Uninstantiate((DRBG_internal *)rng->drbg) != DRBG_SUCCESS)
 800effa:	687b      	ldr	r3, [r7, #4]
 800effc:	689b      	ldr	r3, [r3, #8]
 800effe:	4618      	mov	r0, r3
 800f000:	f7ff ffc4 	bl	800ef8c <Hash_DRBG_Uninstantiate>
 800f004:	4603      	mov	r3, r0
 800f006:	2b00      	cmp	r3, #0
 800f008:	d002      	beq.n	800f010 <wc_FreeRng+0x36>
            ret = RNG_FAILURE_E;
 800f00a:	f06f 03c6 	mvn.w	r3, #198	; 0xc6
 800f00e:	60fb      	str	r3, [r7, #12]

    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
        XFREE(rng->drbg, rng->heap, DYNAMIC_TYPE_RNG);
 800f010:	687b      	ldr	r3, [r7, #4]
 800f012:	689b      	ldr	r3, [r3, #8]
 800f014:	60bb      	str	r3, [r7, #8]
 800f016:	68bb      	ldr	r3, [r7, #8]
 800f018:	2b00      	cmp	r3, #0
 800f01a:	d002      	beq.n	800f022 <wc_FreeRng+0x48>
 800f01c:	68b8      	ldr	r0, [r7, #8]
 800f01e:	f7ff ff87 	bl	800ef30 <wolfSSL_Free>
    #endif
        rng->drbg = NULL;
 800f022:	687b      	ldr	r3, [r7, #4]
 800f024:	2200      	movs	r2, #0
 800f026:	609a      	str	r2, [r3, #8]
    }

    rng->status = DRBG_NOT_INIT;
 800f028:	687b      	ldr	r3, [r7, #4]
 800f02a:	2200      	movs	r2, #0
 800f02c:	731a      	strb	r2, [r3, #12]
#endif /* HAVE_HASHDRBG */

    return ret;
 800f02e:	68fb      	ldr	r3, [r7, #12]
}
 800f030:	4618      	mov	r0, r3
 800f032:	3710      	adds	r7, #16
 800f034:	46bd      	mov	sp, r7
 800f036:	bd80      	pop	{r7, pc}

0800f038 <ForceZero>:
{
 800f038:	b480      	push	{r7}
 800f03a:	b085      	sub	sp, #20
 800f03c:	af00      	add	r7, sp, #0
 800f03e:	6078      	str	r0, [r7, #4]
 800f040:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 800f042:	687b      	ldr	r3, [r7, #4]
 800f044:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 800f046:	e004      	b.n	800f052 <ForceZero+0x1a>
 800f048:	68fb      	ldr	r3, [r7, #12]
 800f04a:	1c5a      	adds	r2, r3, #1
 800f04c:	60fa      	str	r2, [r7, #12]
 800f04e:	2200      	movs	r2, #0
 800f050:	701a      	strb	r2, [r3, #0]
 800f052:	683b      	ldr	r3, [r7, #0]
 800f054:	1e5a      	subs	r2, r3, #1
 800f056:	603a      	str	r2, [r7, #0]
 800f058:	2b00      	cmp	r3, #0
 800f05a:	d1f5      	bne.n	800f048 <ForceZero+0x10>
}
 800f05c:	bf00      	nop
 800f05e:	3714      	adds	r7, #20
 800f060:	46bd      	mov	sp, r7
 800f062:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f066:	4770      	bx	lr

0800f068 <ConstantCompare>:
{
 800f068:	b480      	push	{r7}
 800f06a:	b087      	sub	sp, #28
 800f06c:	af00      	add	r7, sp, #0
 800f06e:	60f8      	str	r0, [r7, #12]
 800f070:	60b9      	str	r1, [r7, #8]
 800f072:	607a      	str	r2, [r7, #4]
    int compareSum = 0;
 800f074:	2300      	movs	r3, #0
 800f076:	613b      	str	r3, [r7, #16]
    for (i = 0; i < length; i++) {
 800f078:	2300      	movs	r3, #0
 800f07a:	617b      	str	r3, [r7, #20]
 800f07c:	e010      	b.n	800f0a0 <ConstantCompare+0x38>
        compareSum |= a[i] ^ b[i];
 800f07e:	697b      	ldr	r3, [r7, #20]
 800f080:	68fa      	ldr	r2, [r7, #12]
 800f082:	4413      	add	r3, r2
 800f084:	781a      	ldrb	r2, [r3, #0]
 800f086:	697b      	ldr	r3, [r7, #20]
 800f088:	68b9      	ldr	r1, [r7, #8]
 800f08a:	440b      	add	r3, r1
 800f08c:	781b      	ldrb	r3, [r3, #0]
 800f08e:	4053      	eors	r3, r2
 800f090:	b2db      	uxtb	r3, r3
 800f092:	461a      	mov	r2, r3
 800f094:	693b      	ldr	r3, [r7, #16]
 800f096:	4313      	orrs	r3, r2
 800f098:	613b      	str	r3, [r7, #16]
    for (i = 0; i < length; i++) {
 800f09a:	697b      	ldr	r3, [r7, #20]
 800f09c:	3301      	adds	r3, #1
 800f09e:	617b      	str	r3, [r7, #20]
 800f0a0:	697a      	ldr	r2, [r7, #20]
 800f0a2:	687b      	ldr	r3, [r7, #4]
 800f0a4:	429a      	cmp	r2, r3
 800f0a6:	dbea      	blt.n	800f07e <ConstantCompare+0x16>
    return compareSum;
 800f0a8:	693b      	ldr	r3, [r7, #16]
}
 800f0aa:	4618      	mov	r0, r3
 800f0ac:	371c      	adds	r7, #28
 800f0ae:	46bd      	mov	sp, r7
 800f0b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f0b4:	4770      	bx	lr

0800f0b6 <ctMaskGT>:
{
 800f0b6:	b480      	push	{r7}
 800f0b8:	b083      	sub	sp, #12
 800f0ba:	af00      	add	r7, sp, #0
 800f0bc:	6078      	str	r0, [r7, #4]
 800f0be:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)a - b - 1) >> 31) - 1);
 800f0c0:	687a      	ldr	r2, [r7, #4]
 800f0c2:	683b      	ldr	r3, [r7, #0]
 800f0c4:	1ad3      	subs	r3, r2, r3
 800f0c6:	3b01      	subs	r3, #1
 800f0c8:	0fdb      	lsrs	r3, r3, #31
 800f0ca:	b2db      	uxtb	r3, r3
 800f0cc:	3b01      	subs	r3, #1
 800f0ce:	b2db      	uxtb	r3, r3
}
 800f0d0:	4618      	mov	r0, r3
 800f0d2:	370c      	adds	r7, #12
 800f0d4:	46bd      	mov	sp, r7
 800f0d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f0da:	4770      	bx	lr

0800f0dc <ctMaskGTE>:
{
 800f0dc:	b480      	push	{r7}
 800f0de:	b083      	sub	sp, #12
 800f0e0:	af00      	add	r7, sp, #0
 800f0e2:	6078      	str	r0, [r7, #4]
 800f0e4:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)a - b    ) >> 31) - 1);
 800f0e6:	687a      	ldr	r2, [r7, #4]
 800f0e8:	683b      	ldr	r3, [r7, #0]
 800f0ea:	1ad3      	subs	r3, r2, r3
 800f0ec:	0fdb      	lsrs	r3, r3, #31
 800f0ee:	b2db      	uxtb	r3, r3
 800f0f0:	3b01      	subs	r3, #1
 800f0f2:	b2db      	uxtb	r3, r3
}
 800f0f4:	4618      	mov	r0, r3
 800f0f6:	370c      	adds	r7, #12
 800f0f8:	46bd      	mov	sp, r7
 800f0fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f0fe:	4770      	bx	lr

0800f100 <ctMaskLT>:
{
 800f100:	b480      	push	{r7}
 800f102:	b083      	sub	sp, #12
 800f104:	af00      	add	r7, sp, #0
 800f106:	6078      	str	r0, [r7, #4]
 800f108:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)b - a - 1) >> 31) - 1);
 800f10a:	683a      	ldr	r2, [r7, #0]
 800f10c:	687b      	ldr	r3, [r7, #4]
 800f10e:	1ad3      	subs	r3, r2, r3
 800f110:	3b01      	subs	r3, #1
 800f112:	0fdb      	lsrs	r3, r3, #31
 800f114:	b2db      	uxtb	r3, r3
 800f116:	3b01      	subs	r3, #1
 800f118:	b2db      	uxtb	r3, r3
}
 800f11a:	4618      	mov	r0, r3
 800f11c:	370c      	adds	r7, #12
 800f11e:	46bd      	mov	sp, r7
 800f120:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f124:	4770      	bx	lr

0800f126 <ctMaskLTE>:
{
 800f126:	b480      	push	{r7}
 800f128:	b083      	sub	sp, #12
 800f12a:	af00      	add	r7, sp, #0
 800f12c:	6078      	str	r0, [r7, #4]
 800f12e:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)b - a    ) >> 31) - 1);
 800f130:	683a      	ldr	r2, [r7, #0]
 800f132:	687b      	ldr	r3, [r7, #4]
 800f134:	1ad3      	subs	r3, r2, r3
 800f136:	0fdb      	lsrs	r3, r3, #31
 800f138:	b2db      	uxtb	r3, r3
 800f13a:	3b01      	subs	r3, #1
 800f13c:	b2db      	uxtb	r3, r3
}
 800f13e:	4618      	mov	r0, r3
 800f140:	370c      	adds	r7, #12
 800f142:	46bd      	mov	sp, r7
 800f144:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f148:	4770      	bx	lr

0800f14a <ctMaskEq>:

/* Constant time - mask set when a == b. */
WC_STATIC WC_INLINE byte ctMaskEq(int a, int b)
{
 800f14a:	b590      	push	{r4, r7, lr}
 800f14c:	b083      	sub	sp, #12
 800f14e:	af00      	add	r7, sp, #0
 800f150:	6078      	str	r0, [r7, #4]
 800f152:	6039      	str	r1, [r7, #0]
    return (byte)(~ctMaskGT(a, b)) & (byte)(~ctMaskLT(a, b));
 800f154:	6839      	ldr	r1, [r7, #0]
 800f156:	6878      	ldr	r0, [r7, #4]
 800f158:	f7ff ffad 	bl	800f0b6 <ctMaskGT>
 800f15c:	4603      	mov	r3, r0
 800f15e:	461c      	mov	r4, r3
 800f160:	6839      	ldr	r1, [r7, #0]
 800f162:	6878      	ldr	r0, [r7, #4]
 800f164:	f7ff ffcc 	bl	800f100 <ctMaskLT>
 800f168:	4603      	mov	r3, r0
 800f16a:	4323      	orrs	r3, r4
 800f16c:	b2db      	uxtb	r3, r3
 800f16e:	43db      	mvns	r3, r3
 800f170:	b2db      	uxtb	r3, r3
}
 800f172:	4618      	mov	r0, r3
 800f174:	370c      	adds	r7, #12
 800f176:	46bd      	mov	sp, r7
 800f178:	bd90      	pop	{r4, r7, pc}

0800f17a <ctMask16GT>:

/* Constant time - sets 16 bit integer mask when a > b */
WC_STATIC WC_INLINE word16 ctMask16GT(int a, int b)
{
 800f17a:	b480      	push	{r7}
 800f17c:	b083      	sub	sp, #12
 800f17e:	af00      	add	r7, sp, #0
 800f180:	6078      	str	r0, [r7, #4]
 800f182:	6039      	str	r1, [r7, #0]
    return (word16)((((word32)a - b - 1) >> 31) - 1);
 800f184:	687a      	ldr	r2, [r7, #4]
 800f186:	683b      	ldr	r3, [r7, #0]
 800f188:	1ad3      	subs	r3, r2, r3
 800f18a:	3b01      	subs	r3, #1
 800f18c:	0fdb      	lsrs	r3, r3, #31
 800f18e:	b29b      	uxth	r3, r3
 800f190:	3b01      	subs	r3, #1
 800f192:	b29b      	uxth	r3, r3
}
 800f194:	4618      	mov	r0, r3
 800f196:	370c      	adds	r7, #12
 800f198:	46bd      	mov	sp, r7
 800f19a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f19e:	4770      	bx	lr

0800f1a0 <ctMask16LT>:
    return (word16)((((word32)a - b    ) >> 31) - 1);
}

/* Constant time - sets 16 bit integer mask when a < b. */
WC_STATIC WC_INLINE word16 ctMask16LT(int a, int b)
{
 800f1a0:	b480      	push	{r7}
 800f1a2:	b083      	sub	sp, #12
 800f1a4:	af00      	add	r7, sp, #0
 800f1a6:	6078      	str	r0, [r7, #4]
 800f1a8:	6039      	str	r1, [r7, #0]
    return (word16)((((word32)b - a - 1) >> 31) - 1);
 800f1aa:	683a      	ldr	r2, [r7, #0]
 800f1ac:	687b      	ldr	r3, [r7, #4]
 800f1ae:	1ad3      	subs	r3, r2, r3
 800f1b0:	3b01      	subs	r3, #1
 800f1b2:	0fdb      	lsrs	r3, r3, #31
 800f1b4:	b29b      	uxth	r3, r3
 800f1b6:	3b01      	subs	r3, #1
 800f1b8:	b29b      	uxth	r3, r3
}
 800f1ba:	4618      	mov	r0, r3
 800f1bc:	370c      	adds	r7, #12
 800f1be:	46bd      	mov	sp, r7
 800f1c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f1c4:	4770      	bx	lr

0800f1c6 <ctMask16Eq>:
    return (word16)((((word32)b - a    ) >> 31) - 1);
}

/* Constant time - sets 16 bit integer mask when a == b. */
WC_STATIC WC_INLINE word16 ctMask16Eq(int a, int b)
{
 800f1c6:	b590      	push	{r4, r7, lr}
 800f1c8:	b083      	sub	sp, #12
 800f1ca:	af00      	add	r7, sp, #0
 800f1cc:	6078      	str	r0, [r7, #4]
 800f1ce:	6039      	str	r1, [r7, #0]
    return (word16)(~ctMask16GT(a, b)) & (word16)(~ctMask16LT(a, b));
 800f1d0:	6839      	ldr	r1, [r7, #0]
 800f1d2:	6878      	ldr	r0, [r7, #4]
 800f1d4:	f7ff ffd1 	bl	800f17a <ctMask16GT>
 800f1d8:	4603      	mov	r3, r0
 800f1da:	461c      	mov	r4, r3
 800f1dc:	6839      	ldr	r1, [r7, #0]
 800f1de:	6878      	ldr	r0, [r7, #4]
 800f1e0:	f7ff ffde 	bl	800f1a0 <ctMask16LT>
 800f1e4:	4603      	mov	r3, r0
 800f1e6:	4323      	orrs	r3, r4
 800f1e8:	b29b      	uxth	r3, r3
 800f1ea:	43db      	mvns	r3, r3
 800f1ec:	b29b      	uxth	r3, r3
}
 800f1ee:	4618      	mov	r0, r3
 800f1f0:	370c      	adds	r7, #12
 800f1f2:	46bd      	mov	sp, r7
 800f1f4:	bd90      	pop	{r4, r7, pc}

0800f1f6 <ctMaskNotEq>:

/* Constant time - mask set when a != b. */
WC_STATIC WC_INLINE byte ctMaskNotEq(int a, int b)
{
 800f1f6:	b590      	push	{r4, r7, lr}
 800f1f8:	b083      	sub	sp, #12
 800f1fa:	af00      	add	r7, sp, #0
 800f1fc:	6078      	str	r0, [r7, #4]
 800f1fe:	6039      	str	r1, [r7, #0]
    return (byte)ctMaskGT(a, b) | (byte)ctMaskLT(a, b);
 800f200:	6839      	ldr	r1, [r7, #0]
 800f202:	6878      	ldr	r0, [r7, #4]
 800f204:	f7ff ff57 	bl	800f0b6 <ctMaskGT>
 800f208:	4603      	mov	r3, r0
 800f20a:	461c      	mov	r4, r3
 800f20c:	6839      	ldr	r1, [r7, #0]
 800f20e:	6878      	ldr	r0, [r7, #4]
 800f210:	f7ff ff76 	bl	800f100 <ctMaskLT>
 800f214:	4603      	mov	r3, r0
 800f216:	4323      	orrs	r3, r4
 800f218:	b2db      	uxtb	r3, r3
}
 800f21a:	4618      	mov	r0, r3
 800f21c:	370c      	adds	r7, #12
 800f21e:	46bd      	mov	sp, r7
 800f220:	bd90      	pop	{r4, r7, pc}

0800f222 <ctMaskSelInt>:
    return (byte)((b & ((byte)~(word32)m)) | (a & m));
}

/* Constant time - select integer a when mask is set and integer b otherwise. */
WC_STATIC WC_INLINE int ctMaskSelInt(byte m, int a, int b)
{
 800f222:	b480      	push	{r7}
 800f224:	b085      	sub	sp, #20
 800f226:	af00      	add	r7, sp, #0
 800f228:	4603      	mov	r3, r0
 800f22a:	60b9      	str	r1, [r7, #8]
 800f22c:	607a      	str	r2, [r7, #4]
 800f22e:	73fb      	strb	r3, [r7, #15]
    return (b & (~(signed int)(signed char)m)) |
 800f230:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800f234:	43da      	mvns	r2, r3
 800f236:	687b      	ldr	r3, [r7, #4]
 800f238:	401a      	ands	r2, r3
           (a & ( (signed int)(signed char)m));
 800f23a:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800f23e:	4619      	mov	r1, r3
 800f240:	68bb      	ldr	r3, [r7, #8]
 800f242:	400b      	ands	r3, r1
    return (b & (~(signed int)(signed char)m)) |
 800f244:	4313      	orrs	r3, r2
}
 800f246:	4618      	mov	r0, r3
 800f248:	3714      	adds	r7, #20
 800f24a:	46bd      	mov	sp, r7
 800f24c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f250:	4770      	bx	lr

0800f252 <wc_RsaCleanup>:
    RSA_STATE_DECRYPT_RES,
};


static void wc_RsaCleanup(RsaKey* key)
{
 800f252:	b580      	push	{r7, lr}
 800f254:	b084      	sub	sp, #16
 800f256:	af00      	add	r7, sp, #0
 800f258:	6078      	str	r0, [r7, #4]
#ifndef WOLFSSL_RSA_VERIFY_INLINE
    if (key && key->data) {
 800f25a:	687b      	ldr	r3, [r7, #4]
 800f25c:	2b00      	cmp	r3, #0
 800f25e:	d047      	beq.n	800f2f0 <wc_RsaCleanup+0x9e>
 800f260:	687b      	ldr	r3, [r7, #4]
 800f262:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f266:	3304      	adds	r3, #4
 800f268:	681b      	ldr	r3, [r3, #0]
 800f26a:	2b00      	cmp	r3, #0
 800f26c:	d040      	beq.n	800f2f0 <wc_RsaCleanup+0x9e>
        /* make sure any allocated memory is free'd */
        if (key->dataIsAlloc) {
 800f26e:	687b      	ldr	r3, [r7, #4]
 800f270:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f274:	3318      	adds	r3, #24
 800f276:	781b      	ldrb	r3, [r3, #0]
 800f278:	2b00      	cmp	r3, #0
 800f27a:	d02d      	beq.n	800f2d8 <wc_RsaCleanup+0x86>
        #ifndef WOLFSSL_RSA_PUBLIC_ONLY
            if (key->type == RSA_PRIVATE_DECRYPT ||
 800f27c:	687b      	ldr	r3, [r7, #4]
 800f27e:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f282:	3308      	adds	r3, #8
 800f284:	681b      	ldr	r3, [r3, #0]
 800f286:	2b03      	cmp	r3, #3
 800f288:	d006      	beq.n	800f298 <wc_RsaCleanup+0x46>
                key->type == RSA_PRIVATE_ENCRYPT) {
 800f28a:	687b      	ldr	r3, [r7, #4]
 800f28c:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f290:	3308      	adds	r3, #8
 800f292:	681b      	ldr	r3, [r3, #0]
            if (key->type == RSA_PRIVATE_DECRYPT ||
 800f294:	2b02      	cmp	r3, #2
 800f296:	d10d      	bne.n	800f2b4 <wc_RsaCleanup+0x62>
                ForceZero(key->data, key->dataLen);
 800f298:	687b      	ldr	r3, [r7, #4]
 800f29a:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f29e:	3304      	adds	r3, #4
 800f2a0:	681a      	ldr	r2, [r3, #0]
 800f2a2:	687b      	ldr	r3, [r7, #4]
 800f2a4:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f2a8:	3310      	adds	r3, #16
 800f2aa:	681b      	ldr	r3, [r3, #0]
 800f2ac:	4619      	mov	r1, r3
 800f2ae:	4610      	mov	r0, r2
 800f2b0:	f7ff fec2 	bl	800f038 <ForceZero>
            }
        #endif
            XFREE(key->data, key->heap, DYNAMIC_TYPE_WOLF_BIGINT);
 800f2b4:	687b      	ldr	r3, [r7, #4]
 800f2b6:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f2ba:	3304      	adds	r3, #4
 800f2bc:	681b      	ldr	r3, [r3, #0]
 800f2be:	60fb      	str	r3, [r7, #12]
 800f2c0:	68fb      	ldr	r3, [r7, #12]
 800f2c2:	2b00      	cmp	r3, #0
 800f2c4:	d002      	beq.n	800f2cc <wc_RsaCleanup+0x7a>
 800f2c6:	68f8      	ldr	r0, [r7, #12]
 800f2c8:	f7ff fe32 	bl	800ef30 <wolfSSL_Free>
            key->dataIsAlloc = 0;
 800f2cc:	687b      	ldr	r3, [r7, #4]
 800f2ce:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f2d2:	3318      	adds	r3, #24
 800f2d4:	2200      	movs	r2, #0
 800f2d6:	701a      	strb	r2, [r3, #0]
        }
        key->data = NULL;
 800f2d8:	687b      	ldr	r3, [r7, #4]
 800f2da:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f2de:	3304      	adds	r3, #4
 800f2e0:	2200      	movs	r2, #0
 800f2e2:	601a      	str	r2, [r3, #0]
        key->dataLen = 0;
 800f2e4:	687b      	ldr	r3, [r7, #4]
 800f2e6:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f2ea:	3310      	adds	r3, #16
 800f2ec:	2200      	movs	r2, #0
 800f2ee:	601a      	str	r2, [r3, #0]
    }
#else
    (void)key;
#endif
}
 800f2f0:	bf00      	nop
 800f2f2:	3710      	adds	r7, #16
 800f2f4:	46bd      	mov	sp, r7
 800f2f6:	bd80      	pop	{r7, pc}

0800f2f8 <wc_InitRsaKey_ex>:

int wc_InitRsaKey_ex(RsaKey* key, void* heap, int devId)
{
 800f2f8:	b5b0      	push	{r4, r5, r7, lr}
 800f2fa:	b088      	sub	sp, #32
 800f2fc:	af02      	add	r7, sp, #8
 800f2fe:	60f8      	str	r0, [r7, #12]
 800f300:	60b9      	str	r1, [r7, #8]
 800f302:	607a      	str	r2, [r7, #4]
    int ret = 0;
 800f304:	2300      	movs	r3, #0
 800f306:	617b      	str	r3, [r7, #20]

    if (key == NULL) {
 800f308:	68fb      	ldr	r3, [r7, #12]
 800f30a:	2b00      	cmp	r3, #0
 800f30c:	d102      	bne.n	800f314 <wc_InitRsaKey_ex+0x1c>
        return BAD_FUNC_ARG;
 800f30e:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800f312:	e06c      	b.n	800f3ee <wc_InitRsaKey_ex+0xf6>
    }

    XMEMSET(key, 0, sizeof(RsaKey));
 800f314:	f641 027c 	movw	r2, #6268	; 0x187c
 800f318:	2100      	movs	r1, #0
 800f31a:	68f8      	ldr	r0, [r7, #12]
 800f31c:	f00a f88f 	bl	801943e <memset>

    key->type = RSA_TYPE_UNKNOWN;
 800f320:	68fb      	ldr	r3, [r7, #12]
 800f322:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f326:	3308      	adds	r3, #8
 800f328:	f04f 32ff 	mov.w	r2, #4294967295
 800f32c:	601a      	str	r2, [r3, #0]
    key->state = RSA_STATE_NONE;
 800f32e:	68fb      	ldr	r3, [r7, #12]
 800f330:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f334:	330c      	adds	r3, #12
 800f336:	2200      	movs	r2, #0
 800f338:	601a      	str	r2, [r3, #0]
    key->heap = heap;
 800f33a:	68fb      	ldr	r3, [r7, #12]
 800f33c:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f340:	68ba      	ldr	r2, [r7, #8]
 800f342:	601a      	str	r2, [r3, #0]
#ifndef WOLFSSL_RSA_VERIFY_INLINE
    key->dataIsAlloc = 0;
 800f344:	68fb      	ldr	r3, [r7, #12]
 800f346:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f34a:	3318      	adds	r3, #24
 800f34c:	2200      	movs	r2, #0
 800f34e:	701a      	strb	r2, [r3, #0]
    key->data = NULL;
 800f350:	68fb      	ldr	r3, [r7, #12]
 800f352:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f356:	3304      	adds	r3, #4
 800f358:	2200      	movs	r2, #0
 800f35a:	601a      	str	r2, [r3, #0]
#endif
    key->dataLen = 0;
 800f35c:	68fb      	ldr	r3, [r7, #12]
 800f35e:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f362:	3310      	adds	r3, #16
 800f364:	2200      	movs	r2, #0
 800f366:	601a      	str	r2, [r3, #0]
#ifdef WC_RSA_BLINDING
    key->rng = NULL;
 800f368:	68fb      	ldr	r3, [r7, #12]
 800f36a:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f36e:	3314      	adds	r3, #20
 800f370:	2200      	movs	r2, #0
 800f372:	601a      	str	r2, [r3, #0]
            return ret;
    #endif /* WC_ASYNC_ENABLE_RSA */
#endif /* WOLFSSL_ASYNC_CRYPT */

#ifndef WOLFSSL_RSA_PUBLIC_ONLY
    ret = mp_init_multi(&key->n, &key->e, NULL, NULL, NULL, NULL);
 800f374:	68f8      	ldr	r0, [r7, #12]
 800f376:	68fb      	ldr	r3, [r7, #12]
 800f378:	f503 7143 	add.w	r1, r3, #780	; 0x30c
 800f37c:	2300      	movs	r3, #0
 800f37e:	9301      	str	r3, [sp, #4]
 800f380:	2300      	movs	r3, #0
 800f382:	9300      	str	r3, [sp, #0]
 800f384:	2300      	movs	r3, #0
 800f386:	2200      	movs	r2, #0
 800f388:	f009 fadc 	bl	8018944 <sp_init_multi>
 800f38c:	6178      	str	r0, [r7, #20]
    if (ret != MP_OKAY)
 800f38e:	697b      	ldr	r3, [r7, #20]
 800f390:	2b00      	cmp	r3, #0
 800f392:	d001      	beq.n	800f398 <wc_InitRsaKey_ex+0xa0>
        return ret;
 800f394:	697b      	ldr	r3, [r7, #20]
 800f396:	e02a      	b.n	800f3ee <wc_InitRsaKey_ex+0xf6>

#if !defined(WOLFSSL_KEY_GEN) && !defined(OPENSSL_EXTRA) && defined(RSA_LOW_MEM)
    ret = mp_init_multi(&key->d, &key->p, &key->q, NULL, NULL, NULL);
#else
    ret = mp_init_multi(&key->d, &key->p, &key->q, &key->dP, &key->dQ, &key->u);
 800f398:	68fb      	ldr	r3, [r7, #12]
 800f39a:	f503 60c3 	add.w	r0, r3, #1560	; 0x618
 800f39e:	68fb      	ldr	r3, [r7, #12]
 800f3a0:	f603 1124 	addw	r1, r3, #2340	; 0x924
 800f3a4:	68fb      	ldr	r3, [r7, #12]
 800f3a6:	f503 6443 	add.w	r4, r3, #3120	; 0xc30
 800f3aa:	68fb      	ldr	r3, [r7, #12]
 800f3ac:	f603 753c 	addw	r5, r3, #3900	; 0xf3c
 800f3b0:	68fb      	ldr	r3, [r7, #12]
 800f3b2:	f503 5392 	add.w	r3, r3, #4672	; 0x1240
 800f3b6:	3308      	adds	r3, #8
 800f3b8:	68fa      	ldr	r2, [r7, #12]
 800f3ba:	f502 52aa 	add.w	r2, r2, #5440	; 0x1540
 800f3be:	3214      	adds	r2, #20
 800f3c0:	9201      	str	r2, [sp, #4]
 800f3c2:	9300      	str	r3, [sp, #0]
 800f3c4:	462b      	mov	r3, r5
 800f3c6:	4622      	mov	r2, r4
 800f3c8:	f009 fabc 	bl	8018944 <sp_init_multi>
 800f3cc:	6178      	str	r0, [r7, #20]
#endif
    if (ret != MP_OKAY) {
 800f3ce:	697b      	ldr	r3, [r7, #20]
 800f3d0:	2b00      	cmp	r3, #0
 800f3d2:	d00b      	beq.n	800f3ec <wc_InitRsaKey_ex+0xf4>
        mp_clear(&key->n);
 800f3d4:	68fb      	ldr	r3, [r7, #12]
 800f3d6:	4618      	mov	r0, r3
 800f3d8:	f009 fb49 	bl	8018a6e <sp_clear>
        mp_clear(&key->e);
 800f3dc:	68fb      	ldr	r3, [r7, #12]
 800f3de:	f503 7343 	add.w	r3, r3, #780	; 0x30c
 800f3e2:	4618      	mov	r0, r3
 800f3e4:	f009 fb43 	bl	8018a6e <sp_clear>
        return ret;
 800f3e8:	697b      	ldr	r3, [r7, #20]
 800f3ea:	e000      	b.n	800f3ee <wc_InitRsaKey_ex+0xf6>
#ifdef WOLFSSL_AFALG_XILINX_RSA
    key->alFd = WC_SOCK_NOTSET;
    key->rdFd = WC_SOCK_NOTSET;
#endif

    return ret;
 800f3ec:	697b      	ldr	r3, [r7, #20]
}
 800f3ee:	4618      	mov	r0, r3
 800f3f0:	3718      	adds	r7, #24
 800f3f2:	46bd      	mov	sp, r7
 800f3f4:	bdb0      	pop	{r4, r5, r7, pc}

0800f3f6 <wc_FreeRsaKey>:
    return ret;
}
#endif /* WOLFSSL_CRYPTOCELL */

int wc_FreeRsaKey(RsaKey* key)
{
 800f3f6:	b580      	push	{r7, lr}
 800f3f8:	b084      	sub	sp, #16
 800f3fa:	af00      	add	r7, sp, #0
 800f3fc:	6078      	str	r0, [r7, #4]
    int ret = 0;
 800f3fe:	2300      	movs	r3, #0
 800f400:	60fb      	str	r3, [r7, #12]

    if (key == NULL) {
 800f402:	687b      	ldr	r3, [r7, #4]
 800f404:	2b00      	cmp	r3, #0
 800f406:	d102      	bne.n	800f40e <wc_FreeRsaKey+0x18>
        return BAD_FUNC_ARG;
 800f408:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800f40c:	e060      	b.n	800f4d0 <wc_FreeRsaKey+0xda>
    }

    wc_RsaCleanup(key);
 800f40e:	6878      	ldr	r0, [r7, #4]
 800f410:	f7ff ff1f 	bl	800f252 <wc_RsaCleanup>
#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_RSA)
    wolfAsync_DevCtxFree(&key->asyncDev, WOLFSSL_ASYNC_MARKER_RSA);
#endif

#ifndef WOLFSSL_RSA_PUBLIC_ONLY
    if (key->type == RSA_PRIVATE) {
 800f414:	687b      	ldr	r3, [r7, #4]
 800f416:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800f41a:	3308      	adds	r3, #8
 800f41c:	681b      	ldr	r3, [r3, #0]
 800f41e:	2b01      	cmp	r3, #1
 800f420:	d125      	bne.n	800f46e <wc_FreeRsaKey+0x78>
#if defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA) || !defined(RSA_LOW_MEM)
        mp_forcezero(&key->u);
 800f422:	687b      	ldr	r3, [r7, #4]
 800f424:	f503 53aa 	add.w	r3, r3, #5440	; 0x1540
 800f428:	3314      	adds	r3, #20
 800f42a:	4618      	mov	r0, r3
 800f42c:	f009 fb40 	bl	8018ab0 <sp_forcezero>
        mp_forcezero(&key->dQ);
 800f430:	687b      	ldr	r3, [r7, #4]
 800f432:	f503 5392 	add.w	r3, r3, #4672	; 0x1240
 800f436:	3308      	adds	r3, #8
 800f438:	4618      	mov	r0, r3
 800f43a:	f009 fb39 	bl	8018ab0 <sp_forcezero>
        mp_forcezero(&key->dP);
 800f43e:	687b      	ldr	r3, [r7, #4]
 800f440:	f603 733c 	addw	r3, r3, #3900	; 0xf3c
 800f444:	4618      	mov	r0, r3
 800f446:	f009 fb33 	bl	8018ab0 <sp_forcezero>
#endif
        mp_forcezero(&key->q);
 800f44a:	687b      	ldr	r3, [r7, #4]
 800f44c:	f503 6343 	add.w	r3, r3, #3120	; 0xc30
 800f450:	4618      	mov	r0, r3
 800f452:	f009 fb2d 	bl	8018ab0 <sp_forcezero>
        mp_forcezero(&key->p);
 800f456:	687b      	ldr	r3, [r7, #4]
 800f458:	f603 1324 	addw	r3, r3, #2340	; 0x924
 800f45c:	4618      	mov	r0, r3
 800f45e:	f009 fb27 	bl	8018ab0 <sp_forcezero>
        mp_forcezero(&key->d);
 800f462:	687b      	ldr	r3, [r7, #4]
 800f464:	f503 63c3 	add.w	r3, r3, #1560	; 0x618
 800f468:	4618      	mov	r0, r3
 800f46a:	f009 fb21 	bl	8018ab0 <sp_forcezero>
    }
    /* private part */
#if defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA) || !defined(RSA_LOW_MEM)
    mp_clear(&key->u);
 800f46e:	687b      	ldr	r3, [r7, #4]
 800f470:	f503 53aa 	add.w	r3, r3, #5440	; 0x1540
 800f474:	3314      	adds	r3, #20
 800f476:	4618      	mov	r0, r3
 800f478:	f009 faf9 	bl	8018a6e <sp_clear>
    mp_clear(&key->dQ);
 800f47c:	687b      	ldr	r3, [r7, #4]
 800f47e:	f503 5392 	add.w	r3, r3, #4672	; 0x1240
 800f482:	3308      	adds	r3, #8
 800f484:	4618      	mov	r0, r3
 800f486:	f009 faf2 	bl	8018a6e <sp_clear>
    mp_clear(&key->dP);
 800f48a:	687b      	ldr	r3, [r7, #4]
 800f48c:	f603 733c 	addw	r3, r3, #3900	; 0xf3c
 800f490:	4618      	mov	r0, r3
 800f492:	f009 faec 	bl	8018a6e <sp_clear>
#endif
    mp_clear(&key->q);
 800f496:	687b      	ldr	r3, [r7, #4]
 800f498:	f503 6343 	add.w	r3, r3, #3120	; 0xc30
 800f49c:	4618      	mov	r0, r3
 800f49e:	f009 fae6 	bl	8018a6e <sp_clear>
    mp_clear(&key->p);
 800f4a2:	687b      	ldr	r3, [r7, #4]
 800f4a4:	f603 1324 	addw	r3, r3, #2340	; 0x924
 800f4a8:	4618      	mov	r0, r3
 800f4aa:	f009 fae0 	bl	8018a6e <sp_clear>
    mp_clear(&key->d);
 800f4ae:	687b      	ldr	r3, [r7, #4]
 800f4b0:	f503 63c3 	add.w	r3, r3, #1560	; 0x618
 800f4b4:	4618      	mov	r0, r3
 800f4b6:	f009 fada 	bl	8018a6e <sp_clear>
#endif /* WOLFSSL_RSA_PUBLIC_ONLY */

    /* public part */
    mp_clear(&key->e);
 800f4ba:	687b      	ldr	r3, [r7, #4]
 800f4bc:	f503 7343 	add.w	r3, r3, #780	; 0x30c
 800f4c0:	4618      	mov	r0, r3
 800f4c2:	f009 fad4 	bl	8018a6e <sp_clear>
    mp_clear(&key->n);
 800f4c6:	687b      	ldr	r3, [r7, #4]
 800f4c8:	4618      	mov	r0, r3
 800f4ca:	f009 fad0 	bl	8018a6e <sp_clear>
        close(key->rdFd);
        key->rdFd = WC_SOCK_NOTSET;
    }
#endif

    return ret;
 800f4ce:	68fb      	ldr	r3, [r7, #12]
}
 800f4d0:	4618      	mov	r0, r3
 800f4d2:	3710      	adds	r7, #16
 800f4d4:	46bd      	mov	sp, r7
 800f4d6:	bd80      	pop	{r7, pc}

0800f4d8 <RsaMGF1>:
   outSz: size of output buffer
 */
#if !defined(NO_SHA) || !defined(NO_SHA256) || defined(WOLFSSL_SHA384) || defined(WOLFSSL_SHA512)
static int RsaMGF1(enum wc_HashType hType, byte* seed, word32 seedSz,
                                        byte* out, word32 outSz, void* heap)
{
 800f4d8:	b580      	push	{r7, lr}
 800f4da:	b09a      	sub	sp, #104	; 0x68
 800f4dc:	af02      	add	r7, sp, #8
 800f4de:	60b9      	str	r1, [r7, #8]
 800f4e0:	607a      	str	r2, [r7, #4]
 800f4e2:	603b      	str	r3, [r7, #0]
 800f4e4:	4603      	mov	r3, r0
 800f4e6:	73fb      	strb	r3, [r7, #15]
    word32 tmpSz;
    int hLen;
    int ret;
    word32 counter;
    word32 idx;
    hLen    = wc_HashGetDigestSize(hType);
 800f4e8:	7bfb      	ldrb	r3, [r7, #15]
 800f4ea:	4618      	mov	r0, r3
 800f4ec:	f7ff fc42 	bl	800ed74 <wc_HashGetDigestSize>
 800f4f0:	6478      	str	r0, [r7, #68]	; 0x44
    counter = 0;
 800f4f2:	2300      	movs	r3, #0
 800f4f4:	653b      	str	r3, [r7, #80]	; 0x50
    idx     = 0;
 800f4f6:	2300      	movs	r3, #0
 800f4f8:	64fb      	str	r3, [r7, #76]	; 0x4c

    (void)heap;

    /* check error return of wc_HashGetDigestSize */
    if (hLen < 0) {
 800f4fa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f4fc:	2b00      	cmp	r3, #0
 800f4fe:	da01      	bge.n	800f504 <RsaMGF1+0x2c>
        return hLen;
 800f500:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f502:	e08f      	b.n	800f624 <RsaMGF1+0x14c>
    }

    /* if tmp is not large enough than use some dynamic memory */
    if ((seedSz + 4) > sizeof(tmpA) || (word32)hLen > sizeof(tmpA)) {
 800f504:	687b      	ldr	r3, [r7, #4]
 800f506:	3304      	adds	r3, #4
 800f508:	2b24      	cmp	r3, #36	; 0x24
 800f50a:	d802      	bhi.n	800f512 <RsaMGF1+0x3a>
 800f50c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f50e:	2b24      	cmp	r3, #36	; 0x24
 800f510:	d914      	bls.n	800f53c <RsaMGF1+0x64>
        /* find largest amount of memory needed which will be the max of
         * hLen and (seedSz + 4) since tmp is used to store the hash digest */
        tmpSz = ((seedSz + 4) > (word32)hLen)? seedSz + 4: (word32)hLen;
 800f512:	687b      	ldr	r3, [r7, #4]
 800f514:	1d1a      	adds	r2, r3, #4
 800f516:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f518:	4293      	cmp	r3, r2
 800f51a:	bf38      	it	cc
 800f51c:	4613      	movcc	r3, r2
 800f51e:	657b      	str	r3, [r7, #84]	; 0x54
        tmp = (byte*)XMALLOC(tmpSz, heap, DYNAMIC_TYPE_RSA_BUFFER);
 800f520:	6d78      	ldr	r0, [r7, #84]	; 0x54
 800f522:	f7ff fce9 	bl	800eef8 <wolfSSL_Malloc>
 800f526:	65f8      	str	r0, [r7, #92]	; 0x5c
        if (tmp == NULL) {
 800f528:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800f52a:	2b00      	cmp	r3, #0
 800f52c:	d102      	bne.n	800f534 <RsaMGF1+0x5c>
            return MEMORY_E;
 800f52e:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800f532:	e077      	b.n	800f624 <RsaMGF1+0x14c>
        }
        tmpF = 1; /* make sure to free memory when done */
 800f534:	2301      	movs	r3, #1
 800f536:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b
 800f53a:	e007      	b.n	800f54c <RsaMGF1+0x74>
    }
    else {
        /* use array on the stack */
        tmpSz = sizeof(tmpA);
 800f53c:	2324      	movs	r3, #36	; 0x24
 800f53e:	657b      	str	r3, [r7, #84]	; 0x54
        tmp  = tmpA;
 800f540:	f107 0314 	add.w	r3, r7, #20
 800f544:	65fb      	str	r3, [r7, #92]	; 0x5c
        tmpF = 0; /* no need to free memory at end */
 800f546:	2300      	movs	r3, #0
 800f548:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b
    }

    do {
        int i = 0;
 800f54c:	2300      	movs	r3, #0
 800f54e:	64bb      	str	r3, [r7, #72]	; 0x48
        XMEMCPY(tmp, seed, seedSz);
 800f550:	687a      	ldr	r2, [r7, #4]
 800f552:	68b9      	ldr	r1, [r7, #8]
 800f554:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 800f556:	f009 ff4e 	bl	80193f6 <memcpy>

        /* counter to byte array appended to tmp */
        tmp[seedSz]     = (byte)((counter >> 24) & 0xFF);
 800f55a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f55c:	0e19      	lsrs	r1, r3, #24
 800f55e:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800f560:	687b      	ldr	r3, [r7, #4]
 800f562:	4413      	add	r3, r2
 800f564:	b2ca      	uxtb	r2, r1
 800f566:	701a      	strb	r2, [r3, #0]
        tmp[seedSz + 1] = (byte)((counter >> 16) & 0xFF);
 800f568:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f56a:	0c19      	lsrs	r1, r3, #16
 800f56c:	687b      	ldr	r3, [r7, #4]
 800f56e:	3301      	adds	r3, #1
 800f570:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800f572:	4413      	add	r3, r2
 800f574:	b2ca      	uxtb	r2, r1
 800f576:	701a      	strb	r2, [r3, #0]
        tmp[seedSz + 2] = (byte)((counter >>  8) & 0xFF);
 800f578:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f57a:	0a19      	lsrs	r1, r3, #8
 800f57c:	687b      	ldr	r3, [r7, #4]
 800f57e:	3302      	adds	r3, #2
 800f580:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800f582:	4413      	add	r3, r2
 800f584:	b2ca      	uxtb	r2, r1
 800f586:	701a      	strb	r2, [r3, #0]
        tmp[seedSz + 3] = (byte)((counter)       & 0xFF);
 800f588:	687b      	ldr	r3, [r7, #4]
 800f58a:	3303      	adds	r3, #3
 800f58c:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800f58e:	4413      	add	r3, r2
 800f590:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800f592:	b2d2      	uxtb	r2, r2
 800f594:	701a      	strb	r2, [r3, #0]

        /* hash and append to existing output */
        if ((ret = wc_Hash(hType, tmp, (seedSz + 4), tmp, tmpSz)) != 0) {
 800f596:	687b      	ldr	r3, [r7, #4]
 800f598:	1d1a      	adds	r2, r3, #4
 800f59a:	7bf8      	ldrb	r0, [r7, #15]
 800f59c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f59e:	9300      	str	r3, [sp, #0]
 800f5a0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800f5a2:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 800f5a4:	f7ff fc24 	bl	800edf0 <wc_Hash>
 800f5a8:	6438      	str	r0, [r7, #64]	; 0x40
 800f5aa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f5ac:	2b00      	cmp	r3, #0
 800f5ae:	d00d      	beq.n	800f5cc <RsaMGF1+0xf4>
            /* check for if dynamic memory was needed, then free */
            if (tmpF) {
 800f5b0:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 800f5b4:	2b00      	cmp	r3, #0
 800f5b6:	d007      	beq.n	800f5c8 <RsaMGF1+0xf0>
                XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 800f5b8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800f5ba:	63bb      	str	r3, [r7, #56]	; 0x38
 800f5bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f5be:	2b00      	cmp	r3, #0
 800f5c0:	d002      	beq.n	800f5c8 <RsaMGF1+0xf0>
 800f5c2:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800f5c4:	f7ff fcb4 	bl	800ef30 <wolfSSL_Free>
            }
            return ret;
 800f5c8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f5ca:	e02b      	b.n	800f624 <RsaMGF1+0x14c>
        }

        for (i = 0; i < hLen && idx < outSz; i++) {
 800f5cc:	2300      	movs	r3, #0
 800f5ce:	64bb      	str	r3, [r7, #72]	; 0x48
 800f5d0:	e00c      	b.n	800f5ec <RsaMGF1+0x114>
            out[idx++] = tmp[i];
 800f5d2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f5d4:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800f5d6:	441a      	add	r2, r3
 800f5d8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f5da:	1c59      	adds	r1, r3, #1
 800f5dc:	64f9      	str	r1, [r7, #76]	; 0x4c
 800f5de:	6839      	ldr	r1, [r7, #0]
 800f5e0:	440b      	add	r3, r1
 800f5e2:	7812      	ldrb	r2, [r2, #0]
 800f5e4:	701a      	strb	r2, [r3, #0]
        for (i = 0; i < hLen && idx < outSz; i++) {
 800f5e6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f5e8:	3301      	adds	r3, #1
 800f5ea:	64bb      	str	r3, [r7, #72]	; 0x48
 800f5ec:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800f5ee:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f5f0:	429a      	cmp	r2, r3
 800f5f2:	da03      	bge.n	800f5fc <RsaMGF1+0x124>
 800f5f4:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800f5f6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f5f8:	429a      	cmp	r2, r3
 800f5fa:	d3ea      	bcc.n	800f5d2 <RsaMGF1+0xfa>
        }
        counter++;
 800f5fc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f5fe:	3301      	adds	r3, #1
 800f600:	653b      	str	r3, [r7, #80]	; 0x50
    } while (idx < outSz);
 800f602:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800f604:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f606:	429a      	cmp	r2, r3
 800f608:	d3a0      	bcc.n	800f54c <RsaMGF1+0x74>

    /* check for if dynamic memory was needed, then free */
    if (tmpF) {
 800f60a:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 800f60e:	2b00      	cmp	r3, #0
 800f610:	d007      	beq.n	800f622 <RsaMGF1+0x14a>
        XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 800f612:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800f614:	63fb      	str	r3, [r7, #60]	; 0x3c
 800f616:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f618:	2b00      	cmp	r3, #0
 800f61a:	d002      	beq.n	800f622 <RsaMGF1+0x14a>
 800f61c:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800f61e:	f7ff fc87 	bl	800ef30 <wolfSSL_Free>
    }

    return 0;
 800f622:	2300      	movs	r3, #0
}
 800f624:	4618      	mov	r0, r3
 800f626:	3760      	adds	r7, #96	; 0x60
 800f628:	46bd      	mov	sp, r7
 800f62a:	bd80      	pop	{r7, pc}

0800f62c <RsaMGF>:
/* helper function to direct which mask generation function is used
   switched on type input
 */
static int RsaMGF(int type, byte* seed, word32 seedSz, byte* out,
                                                    word32 outSz, void* heap)
{
 800f62c:	b580      	push	{r7, lr}
 800f62e:	b088      	sub	sp, #32
 800f630:	af02      	add	r7, sp, #8
 800f632:	60f8      	str	r0, [r7, #12]
 800f634:	60b9      	str	r1, [r7, #8]
 800f636:	607a      	str	r2, [r7, #4]
 800f638:	603b      	str	r3, [r7, #0]
    int ret;

    switch(type) {
 800f63a:	68fb      	ldr	r3, [r7, #12]
 800f63c:	2b01      	cmp	r3, #1
 800f63e:	d10b      	bne.n	800f658 <RsaMGF+0x2c>
        case WC_MGF1SHA224:
            ret = RsaMGF1(WC_HASH_TYPE_SHA224, seed, seedSz, out, outSz, heap);
            break;
    #endif
        case WC_MGF1SHA256:
            ret = RsaMGF1(WC_HASH_TYPE_SHA256, seed, seedSz, out, outSz, heap);
 800f640:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f642:	9301      	str	r3, [sp, #4]
 800f644:	6a3b      	ldr	r3, [r7, #32]
 800f646:	9300      	str	r3, [sp, #0]
 800f648:	683b      	ldr	r3, [r7, #0]
 800f64a:	687a      	ldr	r2, [r7, #4]
 800f64c:	68b9      	ldr	r1, [r7, #8]
 800f64e:	2006      	movs	r0, #6
 800f650:	f7ff ff42 	bl	800f4d8 <RsaMGF1>
 800f654:	6178      	str	r0, [r7, #20]
            break;
 800f656:	e002      	b.n	800f65e <RsaMGF+0x32>
            ret = RsaMGF1(WC_HASH_TYPE_SHA512, seed, seedSz, out, outSz, heap);
            break;
    #endif
        default:
            WOLFSSL_MSG("Unknown MGF type: check build options");
            ret = BAD_FUNC_ARG;
 800f658:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800f65c:	617b      	str	r3, [r7, #20]
    (void)seedSz;
    (void)out;
    (void)outSz;
    (void)heap;

    return ret;
 800f65e:	697b      	ldr	r3, [r7, #20]
}
 800f660:	4618      	mov	r0, r3
 800f662:	3718      	adds	r7, #24
 800f664:	46bd      	mov	sp, r7
 800f666:	bd80      	pop	{r7, pc}

0800f668 <RsaUnPad_OAEP>:
/* UnPad plaintext, set start to *output, return length of plaintext,
 * < 0 on error */
static int RsaUnPad_OAEP(byte *pkcsBlock, unsigned int pkcsBlockLen,
                            byte **output, enum wc_HashType hType, int mgf,
                            byte* optLabel, word32 labelLen, void* heap)
{
 800f668:	b580      	push	{r7, lr}
 800f66a:	b096      	sub	sp, #88	; 0x58
 800f66c:	af02      	add	r7, sp, #8
 800f66e:	60f8      	str	r0, [r7, #12]
 800f670:	60b9      	str	r1, [r7, #8]
 800f672:	607a      	str	r2, [r7, #4]
 800f674:	70fb      	strb	r3, [r7, #3]
    byte h[WC_MAX_DIGEST_SIZE]; /* max digest size */
    byte* tmp;
    word32 idx;

    /* no label is allowed, but catch if no label provided and length > 0 */
    if (optLabel == NULL && labelLen > 0) {
 800f676:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800f678:	2b00      	cmp	r3, #0
 800f67a:	d105      	bne.n	800f688 <RsaUnPad_OAEP+0x20>
 800f67c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800f67e:	2b00      	cmp	r3, #0
 800f680:	d002      	beq.n	800f688 <RsaUnPad_OAEP+0x20>
        return BUFFER_E;
 800f682:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800f686:	e0fc      	b.n	800f882 <RsaUnPad_OAEP+0x21a>
    }

    hLen = wc_HashGetDigestSize(hType);
 800f688:	78fb      	ldrb	r3, [r7, #3]
 800f68a:	4618      	mov	r0, r3
 800f68c:	f7ff fb72 	bl	800ed74 <wc_HashGetDigestSize>
 800f690:	64b8      	str	r0, [r7, #72]	; 0x48
    if ((hLen < 0) || (pkcsBlockLen < (2 * (word32)hLen + 2))) {
 800f692:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f694:	2b00      	cmp	r3, #0
 800f696:	db05      	blt.n	800f6a4 <RsaUnPad_OAEP+0x3c>
 800f698:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f69a:	3301      	adds	r3, #1
 800f69c:	005b      	lsls	r3, r3, #1
 800f69e:	68ba      	ldr	r2, [r7, #8]
 800f6a0:	429a      	cmp	r2, r3
 800f6a2:	d202      	bcs.n	800f6aa <RsaUnPad_OAEP+0x42>
        return BAD_FUNC_ARG;
 800f6a4:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800f6a8:	e0eb      	b.n	800f882 <RsaUnPad_OAEP+0x21a>
    }

    tmp = (byte*)XMALLOC(pkcsBlockLen, heap, DYNAMIC_TYPE_RSA_BUFFER);
 800f6aa:	68b8      	ldr	r0, [r7, #8]
 800f6ac:	f7ff fc24 	bl	800eef8 <wolfSSL_Malloc>
 800f6b0:	6478      	str	r0, [r7, #68]	; 0x44
    if (tmp == NULL) {
 800f6b2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f6b4:	2b00      	cmp	r3, #0
 800f6b6:	d102      	bne.n	800f6be <RsaUnPad_OAEP+0x56>
        return MEMORY_E;
 800f6b8:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800f6bc:	e0e1      	b.n	800f882 <RsaUnPad_OAEP+0x21a>
    }
    XMEMSET(tmp, 0, pkcsBlockLen);
 800f6be:	68ba      	ldr	r2, [r7, #8]
 800f6c0:	2100      	movs	r1, #0
 800f6c2:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800f6c4:	f009 febb 	bl	801943e <memset>

    /* find seedMask value */
    if ((ret = RsaMGF(mgf, (byte*)(pkcsBlock + (hLen + 1)),
 800f6c8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f6ca:	3301      	adds	r3, #1
 800f6cc:	68fa      	ldr	r2, [r7, #12]
 800f6ce:	18d1      	adds	r1, r2, r3
                            pkcsBlockLen - hLen - 1, tmp, hLen, heap)) != 0) {
 800f6d0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f6d2:	68ba      	ldr	r2, [r7, #8]
 800f6d4:	1ad3      	subs	r3, r2, r3
    if ((ret = RsaMGF(mgf, (byte*)(pkcsBlock + (hLen + 1)),
 800f6d6:	1e58      	subs	r0, r3, #1
 800f6d8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f6da:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800f6dc:	9201      	str	r2, [sp, #4]
 800f6de:	9300      	str	r3, [sp, #0]
 800f6e0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f6e2:	4602      	mov	r2, r0
 800f6e4:	6db8      	ldr	r0, [r7, #88]	; 0x58
 800f6e6:	f7ff ffa1 	bl	800f62c <RsaMGF>
 800f6ea:	6438      	str	r0, [r7, #64]	; 0x40
 800f6ec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f6ee:	2b00      	cmp	r3, #0
 800f6f0:	d009      	beq.n	800f706 <RsaUnPad_OAEP+0x9e>
        XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 800f6f2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f6f4:	637b      	str	r3, [r7, #52]	; 0x34
 800f6f6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f6f8:	2b00      	cmp	r3, #0
 800f6fa:	d002      	beq.n	800f702 <RsaUnPad_OAEP+0x9a>
 800f6fc:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800f6fe:	f7ff fc17 	bl	800ef30 <wolfSSL_Free>
        return ret;
 800f702:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f704:	e0bd      	b.n	800f882 <RsaUnPad_OAEP+0x21a>
    }

    /* xor seedMask value with maskedSeed to get seed value */
    for (idx = 0; idx < (word32)hLen; idx++) {
 800f706:	2300      	movs	r3, #0
 800f708:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f70a:	e011      	b.n	800f730 <RsaUnPad_OAEP+0xc8>
        tmp[idx] = tmp[idx] ^ pkcsBlock[1 + idx];
 800f70c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800f70e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f710:	4413      	add	r3, r2
 800f712:	7819      	ldrb	r1, [r3, #0]
 800f714:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f716:	3301      	adds	r3, #1
 800f718:	68fa      	ldr	r2, [r7, #12]
 800f71a:	4413      	add	r3, r2
 800f71c:	781a      	ldrb	r2, [r3, #0]
 800f71e:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800f720:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f722:	4403      	add	r3, r0
 800f724:	404a      	eors	r2, r1
 800f726:	b2d2      	uxtb	r2, r2
 800f728:	701a      	strb	r2, [r3, #0]
    for (idx = 0; idx < (word32)hLen; idx++) {
 800f72a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f72c:	3301      	adds	r3, #1
 800f72e:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f730:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f732:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800f734:	429a      	cmp	r2, r3
 800f736:	d3e9      	bcc.n	800f70c <RsaUnPad_OAEP+0xa4>
    }

    /* get dbMask value */
    if ((ret = RsaMGF(mgf, tmp, hLen, tmp + hLen,
 800f738:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800f73a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f73c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800f73e:	18d0      	adds	r0, r2, r3
                                       pkcsBlockLen - hLen - 1, heap)) != 0) {
 800f740:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f742:	68ba      	ldr	r2, [r7, #8]
 800f744:	1ad3      	subs	r3, r2, r3
    if ((ret = RsaMGF(mgf, tmp, hLen, tmp + hLen,
 800f746:	3b01      	subs	r3, #1
 800f748:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800f74a:	9201      	str	r2, [sp, #4]
 800f74c:	9300      	str	r3, [sp, #0]
 800f74e:	4603      	mov	r3, r0
 800f750:	460a      	mov	r2, r1
 800f752:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800f754:	6db8      	ldr	r0, [r7, #88]	; 0x58
 800f756:	f7ff ff69 	bl	800f62c <RsaMGF>
 800f75a:	6438      	str	r0, [r7, #64]	; 0x40
 800f75c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f75e:	2b00      	cmp	r3, #0
 800f760:	d009      	beq.n	800f776 <RsaUnPad_OAEP+0x10e>
        XFREE(tmp, NULL, DYNAMIC_TYPE_RSA_BUFFER);
 800f762:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f764:	63bb      	str	r3, [r7, #56]	; 0x38
 800f766:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f768:	2b00      	cmp	r3, #0
 800f76a:	d002      	beq.n	800f772 <RsaUnPad_OAEP+0x10a>
 800f76c:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800f76e:	f7ff fbdf 	bl	800ef30 <wolfSSL_Free>
        return ret;
 800f772:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f774:	e085      	b.n	800f882 <RsaUnPad_OAEP+0x21a>
    }

    /* get DB value by doing maskedDB xor dbMask */
    for (idx = 0; idx < (pkcsBlockLen - hLen - 1); idx++) {
 800f776:	2300      	movs	r3, #0
 800f778:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f77a:	e018      	b.n	800f7ae <RsaUnPad_OAEP+0x146>
        pkcsBlock[hLen + 1 + idx] = pkcsBlock[hLen + 1 + idx] ^ tmp[idx + hLen];
 800f77c:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800f77e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f780:	4413      	add	r3, r2
 800f782:	3301      	adds	r3, #1
 800f784:	68fa      	ldr	r2, [r7, #12]
 800f786:	4413      	add	r3, r2
 800f788:	7819      	ldrb	r1, [r3, #0]
 800f78a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800f78c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f78e:	4413      	add	r3, r2
 800f790:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800f792:	4413      	add	r3, r2
 800f794:	781a      	ldrb	r2, [r3, #0]
 800f796:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 800f798:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f79a:	4403      	add	r3, r0
 800f79c:	3301      	adds	r3, #1
 800f79e:	68f8      	ldr	r0, [r7, #12]
 800f7a0:	4403      	add	r3, r0
 800f7a2:	404a      	eors	r2, r1
 800f7a4:	b2d2      	uxtb	r2, r2
 800f7a6:	701a      	strb	r2, [r3, #0]
    for (idx = 0; idx < (pkcsBlockLen - hLen - 1); idx++) {
 800f7a8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f7aa:	3301      	adds	r3, #1
 800f7ac:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f7ae:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f7b0:	68ba      	ldr	r2, [r7, #8]
 800f7b2:	1ad3      	subs	r3, r2, r3
 800f7b4:	3b01      	subs	r3, #1
 800f7b6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800f7b8:	429a      	cmp	r2, r3
 800f7ba:	d3df      	bcc.n	800f77c <RsaUnPad_OAEP+0x114>
    }

    /* done with use of tmp buffer */
    XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 800f7bc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f7be:	63fb      	str	r3, [r7, #60]	; 0x3c
 800f7c0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f7c2:	2b00      	cmp	r3, #0
 800f7c4:	d002      	beq.n	800f7cc <RsaUnPad_OAEP+0x164>
 800f7c6:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800f7c8:	f7ff fbb2 	bl	800ef30 <wolfSSL_Free>

    /* advance idx to index of PS and msg separator, account for PS size of 0*/
    idx = hLen + 1 + hLen;
 800f7cc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f7ce:	1c5a      	adds	r2, r3, #1
 800f7d0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f7d2:	4413      	add	r3, r2
 800f7d4:	64fb      	str	r3, [r7, #76]	; 0x4c
    while (idx < pkcsBlockLen && pkcsBlock[idx] == 0) {idx++;}
 800f7d6:	e002      	b.n	800f7de <RsaUnPad_OAEP+0x176>
 800f7d8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f7da:	3301      	adds	r3, #1
 800f7dc:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f7de:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800f7e0:	68bb      	ldr	r3, [r7, #8]
 800f7e2:	429a      	cmp	r2, r3
 800f7e4:	d205      	bcs.n	800f7f2 <RsaUnPad_OAEP+0x18a>
 800f7e6:	68fa      	ldr	r2, [r7, #12]
 800f7e8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f7ea:	4413      	add	r3, r2
 800f7ec:	781b      	ldrb	r3, [r3, #0]
 800f7ee:	2b00      	cmp	r3, #0
 800f7f0:	d0f2      	beq.n	800f7d8 <RsaUnPad_OAEP+0x170>

    /* create hash of label for comparison with hash sent */
    if ((ret = wc_Hash(hType, optLabel, labelLen, h, hLen)) != 0) {
 800f7f2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f7f4:	f107 0214 	add.w	r2, r7, #20
 800f7f8:	78f8      	ldrb	r0, [r7, #3]
 800f7fa:	9300      	str	r3, [sp, #0]
 800f7fc:	4613      	mov	r3, r2
 800f7fe:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800f800:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 800f802:	f7ff faf5 	bl	800edf0 <wc_Hash>
 800f806:	6438      	str	r0, [r7, #64]	; 0x40
 800f808:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f80a:	2b00      	cmp	r3, #0
 800f80c:	d001      	beq.n	800f812 <RsaUnPad_OAEP+0x1aa>
        return ret;
 800f80e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f810:	e037      	b.n	800f882 <RsaUnPad_OAEP+0x21a>
       Comparison of lHash, Y, and separator value needs to all happen in
       constant time.
       Attackers should not be able to get error condition from the timing of
       these checks.
     */
    ret = 0;
 800f812:	2300      	movs	r3, #0
 800f814:	643b      	str	r3, [r7, #64]	; 0x40
    ret |= ConstantCompare(pkcsBlock + hLen + 1, h, hLen);
 800f816:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f818:	3301      	adds	r3, #1
 800f81a:	68fa      	ldr	r2, [r7, #12]
 800f81c:	4413      	add	r3, r2
 800f81e:	f107 0114 	add.w	r1, r7, #20
 800f822:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800f824:	4618      	mov	r0, r3
 800f826:	f7ff fc1f 	bl	800f068 <ConstantCompare>
 800f82a:	4602      	mov	r2, r0
 800f82c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f82e:	4313      	orrs	r3, r2
 800f830:	643b      	str	r3, [r7, #64]	; 0x40
    ret += pkcsBlock[idx++] ^ 0x01; /* separator value is 0x01 */
 800f832:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f834:	1c5a      	adds	r2, r3, #1
 800f836:	64fa      	str	r2, [r7, #76]	; 0x4c
 800f838:	68fa      	ldr	r2, [r7, #12]
 800f83a:	4413      	add	r3, r2
 800f83c:	781b      	ldrb	r3, [r3, #0]
 800f83e:	f083 0301 	eor.w	r3, r3, #1
 800f842:	b2db      	uxtb	r3, r3
 800f844:	461a      	mov	r2, r3
 800f846:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f848:	4413      	add	r3, r2
 800f84a:	643b      	str	r3, [r7, #64]	; 0x40
    ret += pkcsBlock[0]     ^ 0x00; /* Y, the first value, should be 0 */
 800f84c:	68fb      	ldr	r3, [r7, #12]
 800f84e:	781b      	ldrb	r3, [r3, #0]
 800f850:	461a      	mov	r2, r3
 800f852:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f854:	4413      	add	r3, r2
 800f856:	643b      	str	r3, [r7, #64]	; 0x40

    /* Return 0 data length on error. */
    idx = ctMaskSelInt(ctMaskEq(ret, 0), idx, pkcsBlockLen);
 800f858:	2100      	movs	r1, #0
 800f85a:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800f85c:	f7ff fc75 	bl	800f14a <ctMaskEq>
 800f860:	4603      	mov	r3, r0
 800f862:	4618      	mov	r0, r3
 800f864:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f866:	68ba      	ldr	r2, [r7, #8]
 800f868:	4619      	mov	r1, r3
 800f86a:	f7ff fcda 	bl	800f222 <ctMaskSelInt>
 800f86e:	4603      	mov	r3, r0
 800f870:	64fb      	str	r3, [r7, #76]	; 0x4c

    /* adjust pointer to correct location in array and return size of M */
    *output = (byte*)(pkcsBlock + idx);
 800f872:	68fa      	ldr	r2, [r7, #12]
 800f874:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f876:	441a      	add	r2, r3
 800f878:	687b      	ldr	r3, [r7, #4]
 800f87a:	601a      	str	r2, [r3, #0]
    return pkcsBlockLen - idx;
 800f87c:	68ba      	ldr	r2, [r7, #8]
 800f87e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f880:	1ad3      	subs	r3, r2, r3
}
 800f882:	4618      	mov	r0, r3
 800f884:	3750      	adds	r7, #80	; 0x50
 800f886:	46bd      	mov	sp, r7
 800f888:	bd80      	pop	{r7, pc}

0800f88a <RsaUnPad_PSS>:
                 and other negative values on error.
 */
static int RsaUnPad_PSS(byte *pkcsBlock, unsigned int pkcsBlockLen,
                        byte **output, enum wc_HashType hType, int mgf,
                        int saltLen, int bits, void* heap)
{
 800f88a:	b580      	push	{r7, lr}
 800f88c:	b090      	sub	sp, #64	; 0x40
 800f88e:	af02      	add	r7, sp, #8
 800f890:	60f8      	str	r0, [r7, #12]
 800f892:	60b9      	str	r1, [r7, #8]
 800f894:	607a      	str	r2, [r7, #4]
 800f896:	70fb      	strb	r3, [r7, #3]
    if (pkcsBlockLen > RSA_MAX_SIZE/8) {
        return MEMORY_E;
    }
#endif

    hLen = wc_HashGetDigestSize(hType);
 800f898:	78fb      	ldrb	r3, [r7, #3]
 800f89a:	4618      	mov	r0, r3
 800f89c:	f7ff fa6a 	bl	800ed74 <wc_HashGetDigestSize>
 800f8a0:	6338      	str	r0, [r7, #48]	; 0x30
    if (hLen < 0)
 800f8a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f8a4:	2b00      	cmp	r3, #0
 800f8a6:	da01      	bge.n	800f8ac <RsaUnPad_PSS+0x22>
        return hLen;
 800f8a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f8aa:	e0f7      	b.n	800fa9c <RsaUnPad_PSS+0x212>
    bits = (bits - 1) & 0x7;
 800f8ac:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f8ae:	3b01      	subs	r3, #1
 800f8b0:	f003 0307 	and.w	r3, r3, #7
 800f8b4:	64bb      	str	r3, [r7, #72]	; 0x48
    if ((pkcsBlock[0] & (0xff << bits)) != 0) {
 800f8b6:	68fb      	ldr	r3, [r7, #12]
 800f8b8:	781b      	ldrb	r3, [r3, #0]
 800f8ba:	4619      	mov	r1, r3
 800f8bc:	22ff      	movs	r2, #255	; 0xff
 800f8be:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f8c0:	fa02 f303 	lsl.w	r3, r2, r3
 800f8c4:	400b      	ands	r3, r1
 800f8c6:	2b00      	cmp	r3, #0
 800f8c8:	d002      	beq.n	800f8d0 <RsaUnPad_PSS+0x46>
        return BAD_PADDING_E;
 800f8ca:	f06f 03c0 	mvn.w	r3, #192	; 0xc0
 800f8ce:	e0e5      	b.n	800fa9c <RsaUnPad_PSS+0x212>
    }
    if (bits == 0) {
 800f8d0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f8d2:	2b00      	cmp	r3, #0
 800f8d4:	d105      	bne.n	800f8e2 <RsaUnPad_PSS+0x58>
        pkcsBlock++;
 800f8d6:	68fb      	ldr	r3, [r7, #12]
 800f8d8:	3301      	adds	r3, #1
 800f8da:	60fb      	str	r3, [r7, #12]
        pkcsBlockLen--;
 800f8dc:	68bb      	ldr	r3, [r7, #8]
 800f8de:	3b01      	subs	r3, #1
 800f8e0:	60bb      	str	r3, [r7, #8]
    }
    maskLen = (int)pkcsBlockLen - 1 - hLen;
 800f8e2:	68bb      	ldr	r3, [r7, #8]
 800f8e4:	1e5a      	subs	r2, r3, #1
 800f8e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f8e8:	1ad3      	subs	r3, r2, r3
 800f8ea:	62fb      	str	r3, [r7, #44]	; 0x2c
    if (maskLen < 0) {
 800f8ec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f8ee:	2b00      	cmp	r3, #0
 800f8f0:	da02      	bge.n	800f8f8 <RsaUnPad_PSS+0x6e>
        WOLFSSL_MSG("RsaUnPad_PSS: Hash too large");
        return WC_KEY_SIZE_E;
 800f8f2:	f06f 03e9 	mvn.w	r3, #233	; 0xe9
 800f8f6:	e0d1      	b.n	800fa9c <RsaUnPad_PSS+0x212>
    }

    if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {
 800f8f8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f8fa:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f8fe:	d102      	bne.n	800f906 <RsaUnPad_PSS+0x7c>
        saltLen = hLen;
 800f900:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f902:	647b      	str	r3, [r7, #68]	; 0x44
 800f904:	e00d      	b.n	800f922 <RsaUnPad_PSS+0x98>
            if (orig_bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE)
                saltLen = RSA_PSS_SALT_MAX_SZ;
        #endif
    }
#ifndef WOLFSSL_PSS_LONG_SALT
    else if (saltLen > hLen)
 800f906:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800f908:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f90a:	429a      	cmp	r2, r3
 800f90c:	dd02      	ble.n	800f914 <RsaUnPad_PSS+0x8a>
        return PSS_SALTLEN_E;
 800f90e:	f06f 03f9 	mvn.w	r3, #249	; 0xf9
 800f912:	e0c3      	b.n	800fa9c <RsaUnPad_PSS+0x212>
#endif
#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
    else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT)
 800f914:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f916:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f91a:	da02      	bge.n	800f922 <RsaUnPad_PSS+0x98>
        return PSS_SALTLEN_E;
 800f91c:	f06f 03f9 	mvn.w	r3, #249	; 0xf9
 800f920:	e0bc      	b.n	800fa9c <RsaUnPad_PSS+0x212>
    if (maskLen < saltLen + 1) {
 800f922:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f924:	3301      	adds	r3, #1
 800f926:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800f928:	429a      	cmp	r2, r3
 800f92a:	da02      	bge.n	800f932 <RsaUnPad_PSS+0xa8>
        return PSS_SALTLEN_E;
 800f92c:	f06f 03f9 	mvn.w	r3, #249	; 0xf9
 800f930:	e0b4      	b.n	800fa9c <RsaUnPad_PSS+0x212>
    if (saltLen != RSA_PSS_SALT_LEN_DISCOVER && maskLen < saltLen + 1) {
        return WC_KEY_SIZE_E;
    }
#endif

    if (pkcsBlock[pkcsBlockLen - 1] != RSA_PSS_PAD_TERM) {
 800f932:	68bb      	ldr	r3, [r7, #8]
 800f934:	3b01      	subs	r3, #1
 800f936:	68fa      	ldr	r2, [r7, #12]
 800f938:	4413      	add	r3, r2
 800f93a:	781b      	ldrb	r3, [r3, #0]
 800f93c:	2bbc      	cmp	r3, #188	; 0xbc
 800f93e:	d002      	beq.n	800f946 <RsaUnPad_PSS+0xbc>
        WOLFSSL_MSG("RsaUnPad_PSS: Padding Term Error");
        return BAD_PADDING_E;
 800f940:	f06f 03c0 	mvn.w	r3, #192	; 0xc0
 800f944:	e0aa      	b.n	800fa9c <RsaUnPad_PSS+0x212>
    }

#if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
    tmp = (byte*)XMALLOC(maskLen, heap, DYNAMIC_TYPE_RSA_BUFFER);
 800f946:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f948:	4618      	mov	r0, r3
 800f94a:	f7ff fad5 	bl	800eef8 <wolfSSL_Malloc>
 800f94e:	62b8      	str	r0, [r7, #40]	; 0x28
    if (tmp == NULL) {
 800f950:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f952:	2b00      	cmp	r3, #0
 800f954:	d102      	bne.n	800f95c <RsaUnPad_PSS+0xd2>
        return MEMORY_E;
 800f956:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800f95a:	e09f      	b.n	800fa9c <RsaUnPad_PSS+0x212>
    }
#endif

    if ((ret = RsaMGF(mgf, pkcsBlock + maskLen, hLen, tmp, maskLen,
 800f95c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f95e:	68fa      	ldr	r2, [r7, #12]
 800f960:	18d1      	adds	r1, r2, r3
 800f962:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800f964:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f966:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800f968:	9201      	str	r2, [sp, #4]
 800f96a:	9300      	str	r3, [sp, #0]
 800f96c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f96e:	4602      	mov	r2, r0
 800f970:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800f972:	f7ff fe5b 	bl	800f62c <RsaMGF>
 800f976:	6278      	str	r0, [r7, #36]	; 0x24
 800f978:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f97a:	2b00      	cmp	r3, #0
 800f97c:	d009      	beq.n	800f992 <RsaUnPad_PSS+0x108>
                                                                  heap)) != 0) {
        XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 800f97e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f980:	617b      	str	r3, [r7, #20]
 800f982:	697b      	ldr	r3, [r7, #20]
 800f984:	2b00      	cmp	r3, #0
 800f986:	d002      	beq.n	800f98e <RsaUnPad_PSS+0x104>
 800f988:	6978      	ldr	r0, [r7, #20]
 800f98a:	f7ff fad1 	bl	800ef30 <wolfSSL_Free>
        return ret;
 800f98e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f990:	e084      	b.n	800fa9c <RsaUnPad_PSS+0x212>
    }

    tmp[0] &= (1 << bits) - 1;
 800f992:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f994:	781b      	ldrb	r3, [r3, #0]
 800f996:	b25a      	sxtb	r2, r3
 800f998:	2101      	movs	r1, #1
 800f99a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f99c:	fa01 f303 	lsl.w	r3, r1, r3
 800f9a0:	b2db      	uxtb	r3, r3
 800f9a2:	3b01      	subs	r3, #1
 800f9a4:	b2db      	uxtb	r3, r3
 800f9a6:	b25b      	sxtb	r3, r3
 800f9a8:	4013      	ands	r3, r2
 800f9aa:	b25b      	sxtb	r3, r3
 800f9ac:	b2da      	uxtb	r2, r3
 800f9ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f9b0:	701a      	strb	r2, [r3, #0]
    pkcsBlock[0] &= (1 << bits) - 1;
 800f9b2:	68fb      	ldr	r3, [r7, #12]
 800f9b4:	781b      	ldrb	r3, [r3, #0]
 800f9b6:	b25a      	sxtb	r2, r3
 800f9b8:	2101      	movs	r1, #1
 800f9ba:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f9bc:	fa01 f303 	lsl.w	r3, r1, r3
 800f9c0:	b2db      	uxtb	r3, r3
 800f9c2:	3b01      	subs	r3, #1
 800f9c4:	b2db      	uxtb	r3, r3
 800f9c6:	b25b      	sxtb	r3, r3
 800f9c8:	4013      	ands	r3, r2
 800f9ca:	b25b      	sxtb	r3, r3
 800f9cc:	b2da      	uxtb	r2, r3
 800f9ce:	68fb      	ldr	r3, [r7, #12]
 800f9d0:	701a      	strb	r2, [r3, #0]
        saltLen = maskLen - (i + 1);
    }
    else
#endif
    {
        for (i = 0; i < maskLen - 1 - saltLen; i++) {
 800f9d2:	2300      	movs	r3, #0
 800f9d4:	637b      	str	r3, [r7, #52]	; 0x34
 800f9d6:	e017      	b.n	800fa08 <RsaUnPad_PSS+0x17e>
            if (tmp[i] != pkcsBlock[i]) {
 800f9d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f9da:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800f9dc:	4413      	add	r3, r2
 800f9de:	781a      	ldrb	r2, [r3, #0]
 800f9e0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f9e2:	68f9      	ldr	r1, [r7, #12]
 800f9e4:	440b      	add	r3, r1
 800f9e6:	781b      	ldrb	r3, [r3, #0]
 800f9e8:	429a      	cmp	r2, r3
 800f9ea:	d00a      	beq.n	800fa02 <RsaUnPad_PSS+0x178>
                XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 800f9ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f9ee:	61bb      	str	r3, [r7, #24]
 800f9f0:	69bb      	ldr	r3, [r7, #24]
 800f9f2:	2b00      	cmp	r3, #0
 800f9f4:	d002      	beq.n	800f9fc <RsaUnPad_PSS+0x172>
 800f9f6:	69b8      	ldr	r0, [r7, #24]
 800f9f8:	f7ff fa9a 	bl	800ef30 <wolfSSL_Free>
                WOLFSSL_MSG("RsaUnPad_PSS: Padding Error Match");
                return PSS_SALTLEN_E;
 800f9fc:	f06f 03f9 	mvn.w	r3, #249	; 0xf9
 800fa00:	e04c      	b.n	800fa9c <RsaUnPad_PSS+0x212>
        for (i = 0; i < maskLen - 1 - saltLen; i++) {
 800fa02:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fa04:	3301      	adds	r3, #1
 800fa06:	637b      	str	r3, [r7, #52]	; 0x34
 800fa08:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fa0a:	1e5a      	subs	r2, r3, #1
 800fa0c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800fa0e:	1ad3      	subs	r3, r2, r3
 800fa10:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800fa12:	429a      	cmp	r2, r3
 800fa14:	dbe0      	blt.n	800f9d8 <RsaUnPad_PSS+0x14e>
            }
        }
        if (tmp[i] != (pkcsBlock[i] ^ 0x01)) {
 800fa16:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fa18:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800fa1a:	4413      	add	r3, r2
 800fa1c:	781a      	ldrb	r2, [r3, #0]
 800fa1e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fa20:	68f9      	ldr	r1, [r7, #12]
 800fa22:	440b      	add	r3, r1
 800fa24:	781b      	ldrb	r3, [r3, #0]
 800fa26:	f083 0301 	eor.w	r3, r3, #1
 800fa2a:	b2db      	uxtb	r3, r3
 800fa2c:	429a      	cmp	r2, r3
 800fa2e:	d00a      	beq.n	800fa46 <RsaUnPad_PSS+0x1bc>
            XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 800fa30:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fa32:	61fb      	str	r3, [r7, #28]
 800fa34:	69fb      	ldr	r3, [r7, #28]
 800fa36:	2b00      	cmp	r3, #0
 800fa38:	d002      	beq.n	800fa40 <RsaUnPad_PSS+0x1b6>
 800fa3a:	69f8      	ldr	r0, [r7, #28]
 800fa3c:	f7ff fa78 	bl	800ef30 <wolfSSL_Free>
            WOLFSSL_MSG("RsaUnPad_PSS: Padding Error End");
            return PSS_SALTLEN_E;
 800fa40:	f06f 03f9 	mvn.w	r3, #249	; 0xf9
 800fa44:	e02a      	b.n	800fa9c <RsaUnPad_PSS+0x212>
        }
    }
    for (i++; i < maskLen; i++)
 800fa46:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fa48:	3301      	adds	r3, #1
 800fa4a:	637b      	str	r3, [r7, #52]	; 0x34
 800fa4c:	e010      	b.n	800fa70 <RsaUnPad_PSS+0x1e6>
        pkcsBlock[i] ^= tmp[i];
 800fa4e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fa50:	68fa      	ldr	r2, [r7, #12]
 800fa52:	4413      	add	r3, r2
 800fa54:	7819      	ldrb	r1, [r3, #0]
 800fa56:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fa58:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800fa5a:	4413      	add	r3, r2
 800fa5c:	781a      	ldrb	r2, [r3, #0]
 800fa5e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fa60:	68f8      	ldr	r0, [r7, #12]
 800fa62:	4403      	add	r3, r0
 800fa64:	404a      	eors	r2, r1
 800fa66:	b2d2      	uxtb	r2, r2
 800fa68:	701a      	strb	r2, [r3, #0]
    for (i++; i < maskLen; i++)
 800fa6a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fa6c:	3301      	adds	r3, #1
 800fa6e:	637b      	str	r3, [r7, #52]	; 0x34
 800fa70:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800fa72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fa74:	429a      	cmp	r2, r3
 800fa76:	dbea      	blt.n	800fa4e <RsaUnPad_PSS+0x1c4>

#if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
    XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 800fa78:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fa7a:	623b      	str	r3, [r7, #32]
 800fa7c:	6a3b      	ldr	r3, [r7, #32]
 800fa7e:	2b00      	cmp	r3, #0
 800fa80:	d002      	beq.n	800fa88 <RsaUnPad_PSS+0x1fe>
 800fa82:	6a38      	ldr	r0, [r7, #32]
 800fa84:	f7ff fa54 	bl	800ef30 <wolfSSL_Free>
#endif

    *output = pkcsBlock + maskLen - saltLen;
 800fa88:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800fa8a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800fa8c:	1ad3      	subs	r3, r2, r3
 800fa8e:	68fa      	ldr	r2, [r7, #12]
 800fa90:	441a      	add	r2, r3
 800fa92:	687b      	ldr	r3, [r7, #4]
 800fa94:	601a      	str	r2, [r3, #0]
    return saltLen + hLen;
 800fa96:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800fa98:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fa9a:	4413      	add	r3, r2
}
 800fa9c:	4618      	mov	r0, r3
 800fa9e:	3738      	adds	r7, #56	; 0x38
 800faa0:	46bd      	mov	sp, r7
 800faa2:	bd80      	pop	{r7, pc}

0800faa4 <RsaUnPad>:

/* UnPad plaintext, set start to *output, return length of plaintext,
 * < 0 on error */
static int RsaUnPad(const byte *pkcsBlock, unsigned int pkcsBlockLen,
                    byte **output, byte padValue)
{
 800faa4:	b590      	push	{r4, r7, lr}
 800faa6:	b089      	sub	sp, #36	; 0x24
 800faa8:	af00      	add	r7, sp, #0
 800faaa:	60f8      	str	r0, [r7, #12]
 800faac:	60b9      	str	r1, [r7, #8]
 800faae:	607a      	str	r2, [r7, #4]
 800fab0:	70fb      	strb	r3, [r7, #3]
    int    ret = BAD_FUNC_ARG;
 800fab2:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800fab6:	61fb      	str	r3, [r7, #28]
    word16 i;
#ifndef WOLFSSL_RSA_VERIFY_ONLY
    byte   invalid = 0;
 800fab8:	2300      	movs	r3, #0
 800faba:	757b      	strb	r3, [r7, #21]
#endif

    if (output == NULL || pkcsBlockLen < 2 || pkcsBlockLen > 0xFFFF) {
 800fabc:	687b      	ldr	r3, [r7, #4]
 800fabe:	2b00      	cmp	r3, #0
 800fac0:	d006      	beq.n	800fad0 <RsaUnPad+0x2c>
 800fac2:	68bb      	ldr	r3, [r7, #8]
 800fac4:	2b01      	cmp	r3, #1
 800fac6:	d903      	bls.n	800fad0 <RsaUnPad+0x2c>
 800fac8:	68bb      	ldr	r3, [r7, #8]
 800faca:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800face:	d302      	bcc.n	800fad6 <RsaUnPad+0x32>
        return BAD_FUNC_ARG;
 800fad0:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800fad4:	e0a0      	b.n	800fc18 <RsaUnPad+0x174>
    }

    if (padValue == RSA_BLOCK_TYPE_1) {
 800fad6:	78fb      	ldrb	r3, [r7, #3]
 800fad8:	2b01      	cmp	r3, #1
 800fada:	d132      	bne.n	800fb42 <RsaUnPad+0x9e>
        /* First byte must be 0x00 and Second byte, block type, 0x01 */
        if (pkcsBlock[0] != 0 || pkcsBlock[1] != RSA_BLOCK_TYPE_1) {
 800fadc:	68fb      	ldr	r3, [r7, #12]
 800fade:	781b      	ldrb	r3, [r3, #0]
 800fae0:	2b00      	cmp	r3, #0
 800fae2:	d104      	bne.n	800faee <RsaUnPad+0x4a>
 800fae4:	68fb      	ldr	r3, [r7, #12]
 800fae6:	3301      	adds	r3, #1
 800fae8:	781b      	ldrb	r3, [r3, #0]
 800faea:	2b01      	cmp	r3, #1
 800faec:	d002      	beq.n	800faf4 <RsaUnPad+0x50>
            WOLFSSL_MSG("RsaUnPad error, invalid formatting");
            return RSA_PAD_E;
 800faee:	f06f 03c8 	mvn.w	r3, #200	; 0xc8
 800faf2:	e091      	b.n	800fc18 <RsaUnPad+0x174>
        }

        /* check the padding until we find the separator */
        for (i = 2; i < pkcsBlockLen && pkcsBlock[i++] == 0xFF; ) { }
 800faf4:	2302      	movs	r3, #2
 800faf6:	837b      	strh	r3, [r7, #26]
 800faf8:	bf00      	nop
 800fafa:	8b7b      	ldrh	r3, [r7, #26]
 800fafc:	68ba      	ldr	r2, [r7, #8]
 800fafe:	429a      	cmp	r2, r3
 800fb00:	d908      	bls.n	800fb14 <RsaUnPad+0x70>
 800fb02:	8b7b      	ldrh	r3, [r7, #26]
 800fb04:	1c5a      	adds	r2, r3, #1
 800fb06:	837a      	strh	r2, [r7, #26]
 800fb08:	461a      	mov	r2, r3
 800fb0a:	68fb      	ldr	r3, [r7, #12]
 800fb0c:	4413      	add	r3, r2
 800fb0e:	781b      	ldrb	r3, [r3, #0]
 800fb10:	2bff      	cmp	r3, #255	; 0xff
 800fb12:	d0f2      	beq.n	800fafa <RsaUnPad+0x56>

        /* Minimum of 11 bytes of pre-message data and must have separator. */
        if (i < RSA_MIN_PAD_SZ || pkcsBlock[i-1] != 0) {
 800fb14:	8b7b      	ldrh	r3, [r7, #26]
 800fb16:	2b0a      	cmp	r3, #10
 800fb18:	d906      	bls.n	800fb28 <RsaUnPad+0x84>
 800fb1a:	8b7b      	ldrh	r3, [r7, #26]
 800fb1c:	3b01      	subs	r3, #1
 800fb1e:	68fa      	ldr	r2, [r7, #12]
 800fb20:	4413      	add	r3, r2
 800fb22:	781b      	ldrb	r3, [r3, #0]
 800fb24:	2b00      	cmp	r3, #0
 800fb26:	d002      	beq.n	800fb2e <RsaUnPad+0x8a>
            WOLFSSL_MSG("RsaUnPad error, bad formatting");
            return RSA_PAD_E;
 800fb28:	f06f 03c8 	mvn.w	r3, #200	; 0xc8
 800fb2c:	e074      	b.n	800fc18 <RsaUnPad+0x174>
        }

        *output = (byte *)(pkcsBlock + i);
 800fb2e:	8b7b      	ldrh	r3, [r7, #26]
 800fb30:	68fa      	ldr	r2, [r7, #12]
 800fb32:	441a      	add	r2, r3
 800fb34:	687b      	ldr	r3, [r7, #4]
 800fb36:	601a      	str	r2, [r3, #0]
        ret = pkcsBlockLen - i;
 800fb38:	8b7b      	ldrh	r3, [r7, #26]
 800fb3a:	68ba      	ldr	r2, [r7, #8]
 800fb3c:	1ad3      	subs	r3, r2, r3
 800fb3e:	61fb      	str	r3, [r7, #28]
 800fb40:	e069      	b.n	800fc16 <RsaUnPad+0x172>
    }
#ifndef WOLFSSL_RSA_VERIFY_ONLY
    else {
        word16 j;
        word16 pastSep = 0;
 800fb42:	2300      	movs	r3, #0
 800fb44:	82fb      	strh	r3, [r7, #22]

        /* Decrypted with private key - unpad must be constant time. */
        for (i = 0, j = 2; j < pkcsBlockLen; j++) {
 800fb46:	2300      	movs	r3, #0
 800fb48:	837b      	strh	r3, [r7, #26]
 800fb4a:	2302      	movs	r3, #2
 800fb4c:	833b      	strh	r3, [r7, #24]
 800fb4e:	e025      	b.n	800fb9c <RsaUnPad+0xf8>
           /* Update i if not passed the separator and at separator. */
            i |= (~pastSep) & ctMask16Eq(pkcsBlock[j], 0x00) & (j + 1);
 800fb50:	8afb      	ldrh	r3, [r7, #22]
 800fb52:	43dc      	mvns	r4, r3
 800fb54:	8b3b      	ldrh	r3, [r7, #24]
 800fb56:	68fa      	ldr	r2, [r7, #12]
 800fb58:	4413      	add	r3, r2
 800fb5a:	781b      	ldrb	r3, [r3, #0]
 800fb5c:	2100      	movs	r1, #0
 800fb5e:	4618      	mov	r0, r3
 800fb60:	f7ff fb31 	bl	800f1c6 <ctMask16Eq>
 800fb64:	4603      	mov	r3, r0
 800fb66:	ea04 0203 	and.w	r2, r4, r3
 800fb6a:	8b3b      	ldrh	r3, [r7, #24]
 800fb6c:	3301      	adds	r3, #1
 800fb6e:	4013      	ands	r3, r2
 800fb70:	b21a      	sxth	r2, r3
 800fb72:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 800fb76:	4313      	orrs	r3, r2
 800fb78:	b21b      	sxth	r3, r3
 800fb7a:	837b      	strh	r3, [r7, #26]
            pastSep |= ctMask16Eq(pkcsBlock[j], 0x00);
 800fb7c:	8b3b      	ldrh	r3, [r7, #24]
 800fb7e:	68fa      	ldr	r2, [r7, #12]
 800fb80:	4413      	add	r3, r2
 800fb82:	781b      	ldrb	r3, [r3, #0]
 800fb84:	2100      	movs	r1, #0
 800fb86:	4618      	mov	r0, r3
 800fb88:	f7ff fb1d 	bl	800f1c6 <ctMask16Eq>
 800fb8c:	4603      	mov	r3, r0
 800fb8e:	461a      	mov	r2, r3
 800fb90:	8afb      	ldrh	r3, [r7, #22]
 800fb92:	4313      	orrs	r3, r2
 800fb94:	82fb      	strh	r3, [r7, #22]
        for (i = 0, j = 2; j < pkcsBlockLen; j++) {
 800fb96:	8b3b      	ldrh	r3, [r7, #24]
 800fb98:	3301      	adds	r3, #1
 800fb9a:	833b      	strh	r3, [r7, #24]
 800fb9c:	8b3b      	ldrh	r3, [r7, #24]
 800fb9e:	68ba      	ldr	r2, [r7, #8]
 800fba0:	429a      	cmp	r2, r3
 800fba2:	d8d5      	bhi.n	800fb50 <RsaUnPad+0xac>
        }

        /* Minimum of 11 bytes of pre-message data - including leading 0x00. */
        invalid |= ctMaskLT(i, RSA_MIN_PAD_SZ);
 800fba4:	8b7b      	ldrh	r3, [r7, #26]
 800fba6:	210b      	movs	r1, #11
 800fba8:	4618      	mov	r0, r3
 800fbaa:	f7ff faa9 	bl	800f100 <ctMaskLT>
 800fbae:	4603      	mov	r3, r0
 800fbb0:	461a      	mov	r2, r3
 800fbb2:	7d7b      	ldrb	r3, [r7, #21]
 800fbb4:	4313      	orrs	r3, r2
 800fbb6:	757b      	strb	r3, [r7, #21]
        /* Must have seen separator. */
        invalid |= ~pastSep;
 800fbb8:	8afb      	ldrh	r3, [r7, #22]
 800fbba:	b25b      	sxtb	r3, r3
 800fbbc:	43db      	mvns	r3, r3
 800fbbe:	b25a      	sxtb	r2, r3
 800fbc0:	f997 3015 	ldrsb.w	r3, [r7, #21]
 800fbc4:	4313      	orrs	r3, r2
 800fbc6:	b25b      	sxtb	r3, r3
 800fbc8:	757b      	strb	r3, [r7, #21]
        /* First byte must be 0x00. */
        invalid |= ctMaskNotEq(pkcsBlock[0], 0x00);
 800fbca:	68fb      	ldr	r3, [r7, #12]
 800fbcc:	781b      	ldrb	r3, [r3, #0]
 800fbce:	2100      	movs	r1, #0
 800fbd0:	4618      	mov	r0, r3
 800fbd2:	f7ff fb10 	bl	800f1f6 <ctMaskNotEq>
 800fbd6:	4603      	mov	r3, r0
 800fbd8:	461a      	mov	r2, r3
 800fbda:	7d7b      	ldrb	r3, [r7, #21]
 800fbdc:	4313      	orrs	r3, r2
 800fbde:	757b      	strb	r3, [r7, #21]
        /* Check against expected block type: padValue */
        invalid |= ctMaskNotEq(pkcsBlock[1], padValue);
 800fbe0:	68fb      	ldr	r3, [r7, #12]
 800fbe2:	3301      	adds	r3, #1
 800fbe4:	781b      	ldrb	r3, [r3, #0]
 800fbe6:	461a      	mov	r2, r3
 800fbe8:	78fb      	ldrb	r3, [r7, #3]
 800fbea:	4619      	mov	r1, r3
 800fbec:	4610      	mov	r0, r2
 800fbee:	f7ff fb02 	bl	800f1f6 <ctMaskNotEq>
 800fbf2:	4603      	mov	r3, r0
 800fbf4:	461a      	mov	r2, r3
 800fbf6:	7d7b      	ldrb	r3, [r7, #21]
 800fbf8:	4313      	orrs	r3, r2
 800fbfa:	757b      	strb	r3, [r7, #21]

        *output = (byte *)(pkcsBlock + i);
 800fbfc:	8b7b      	ldrh	r3, [r7, #26]
 800fbfe:	68fa      	ldr	r2, [r7, #12]
 800fc00:	441a      	add	r2, r3
 800fc02:	687b      	ldr	r3, [r7, #4]
 800fc04:	601a      	str	r2, [r3, #0]
        ret = ((int)~invalid) & (pkcsBlockLen - i);
 800fc06:	7d7b      	ldrb	r3, [r7, #21]
 800fc08:	43db      	mvns	r3, r3
 800fc0a:	4619      	mov	r1, r3
 800fc0c:	8b7b      	ldrh	r3, [r7, #26]
 800fc0e:	68ba      	ldr	r2, [r7, #8]
 800fc10:	1ad3      	subs	r3, r2, r3
 800fc12:	400b      	ands	r3, r1
 800fc14:	61fb      	str	r3, [r7, #28]
    }
#endif

    return ret;
 800fc16:	69fb      	ldr	r3, [r7, #28]
}
 800fc18:	4618      	mov	r0, r3
 800fc1a:	3724      	adds	r7, #36	; 0x24
 800fc1c:	46bd      	mov	sp, r7
 800fc1e:	bd90      	pop	{r4, r7, pc}

0800fc20 <wc_RsaUnPad_ex>:
 */
int wc_RsaUnPad_ex(byte* pkcsBlock, word32 pkcsBlockLen, byte** out,
                   byte padValue, int padType, enum wc_HashType hType,
                   int mgf, byte* optLabel, word32 labelLen, int saltLen,
                   int bits, void* heap)
{
 800fc20:	b580      	push	{r7, lr}
 800fc22:	b08a      	sub	sp, #40	; 0x28
 800fc24:	af04      	add	r7, sp, #16
 800fc26:	60f8      	str	r0, [r7, #12]
 800fc28:	60b9      	str	r1, [r7, #8]
 800fc2a:	607a      	str	r2, [r7, #4]
 800fc2c:	70fb      	strb	r3, [r7, #3]
    int ret;

    switch (padType) {
 800fc2e:	6a3b      	ldr	r3, [r7, #32]
 800fc30:	2b01      	cmp	r3, #1
 800fc32:	d00b      	beq.n	800fc4c <wc_RsaUnPad_ex+0x2c>
 800fc34:	2b02      	cmp	r3, #2
 800fc36:	d01b      	beq.n	800fc70 <wc_RsaUnPad_ex+0x50>
 800fc38:	2b00      	cmp	r3, #0
 800fc3a:	d12b      	bne.n	800fc94 <wc_RsaUnPad_ex+0x74>
        case WC_RSA_PKCSV15_PAD:
            /*WOLFSSL_MSG("wolfSSL Using RSA PKCSV15 un-padding");*/
            ret = RsaUnPad(pkcsBlock, pkcsBlockLen, out, padValue);
 800fc3c:	78fb      	ldrb	r3, [r7, #3]
 800fc3e:	687a      	ldr	r2, [r7, #4]
 800fc40:	68b9      	ldr	r1, [r7, #8]
 800fc42:	68f8      	ldr	r0, [r7, #12]
 800fc44:	f7ff ff2e 	bl	800faa4 <RsaUnPad>
 800fc48:	6178      	str	r0, [r7, #20]
            break;
 800fc4a:	e026      	b.n	800fc9a <wc_RsaUnPad_ex+0x7a>

    #ifndef WC_NO_RSA_OAEP
        case WC_RSA_OAEP_PAD:
            WOLFSSL_MSG("wolfSSL Using RSA OAEP un-padding");
            ret = RsaUnPad_OAEP((byte*)pkcsBlock, pkcsBlockLen, out,
 800fc4c:	f897 2024 	ldrb.w	r2, [r7, #36]	; 0x24
 800fc50:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800fc52:	9303      	str	r3, [sp, #12]
 800fc54:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fc56:	9302      	str	r3, [sp, #8]
 800fc58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fc5a:	9301      	str	r3, [sp, #4]
 800fc5c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fc5e:	9300      	str	r3, [sp, #0]
 800fc60:	4613      	mov	r3, r2
 800fc62:	687a      	ldr	r2, [r7, #4]
 800fc64:	68b9      	ldr	r1, [r7, #8]
 800fc66:	68f8      	ldr	r0, [r7, #12]
 800fc68:	f7ff fcfe 	bl	800f668 <RsaUnPad_OAEP>
 800fc6c:	6178      	str	r0, [r7, #20]
                                        hType, mgf, optLabel, labelLen, heap);
            break;
 800fc6e:	e014      	b.n	800fc9a <wc_RsaUnPad_ex+0x7a>
    #endif

    #ifdef WC_RSA_PSS
        case WC_RSA_PSS_PAD:
            WOLFSSL_MSG("wolfSSL Using RSA PSS un-padding");
            ret = RsaUnPad_PSS((byte*)pkcsBlock, pkcsBlockLen, out, hType, mgf,
 800fc70:	f897 2024 	ldrb.w	r2, [r7, #36]	; 0x24
 800fc74:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800fc76:	9303      	str	r3, [sp, #12]
 800fc78:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800fc7a:	9302      	str	r3, [sp, #8]
 800fc7c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fc7e:	9301      	str	r3, [sp, #4]
 800fc80:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fc82:	9300      	str	r3, [sp, #0]
 800fc84:	4613      	mov	r3, r2
 800fc86:	687a      	ldr	r2, [r7, #4]
 800fc88:	68b9      	ldr	r1, [r7, #8]
 800fc8a:	68f8      	ldr	r0, [r7, #12]
 800fc8c:	f7ff fdfd 	bl	800f88a <RsaUnPad_PSS>
 800fc90:	6178      	str	r0, [r7, #20]
                                                           saltLen, bits, heap);
            break;
 800fc92:	e002      	b.n	800fc9a <wc_RsaUnPad_ex+0x7a>
            break;
    #endif /* WC_RSA_NO_PADDING */

        default:
            WOLFSSL_MSG("Unknown RSA UnPad Type");
            ret = RSA_PAD_E;
 800fc94:	f06f 03c8 	mvn.w	r3, #200	; 0xc8
 800fc98:	617b      	str	r3, [r7, #20]
    (void)labelLen;
    (void)saltLen;
    (void)bits;
    (void)heap;

    return ret;
 800fc9a:	697b      	ldr	r3, [r7, #20]
}
 800fc9c:	4618      	mov	r0, r3
 800fc9e:	3718      	adds	r7, #24
 800fca0:	46bd      	mov	sp, r7
 800fca2:	bd80      	pop	{r7, pc}

0800fca4 <wc_RsaFunctionSync>:
}

#else
static int wc_RsaFunctionSync(const byte* in, word32 inLen, byte* out,
                          word32* outLen, int type, RsaKey* key, WC_RNG* rng)
{
 800fca4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fca6:	b08d      	sub	sp, #52	; 0x34
 800fca8:	af08      	add	r7, sp, #32
 800fcaa:	60f8      	str	r0, [r7, #12]
 800fcac:	60b9      	str	r1, [r7, #8]
 800fcae:	607a      	str	r2, [r7, #4]
 800fcb0:	603b      	str	r3, [r7, #0]
    word32 keyLen = 0;
#endif

#ifdef WOLFSSL_HAVE_SP_RSA
#ifndef WOLFSSL_SP_NO_2048
    if (mp_count_bits(&key->n) == 2048) {
 800fcb2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fcb4:	4618      	mov	r0, r3
 800fcb6:	f008 ff8d 	bl	8018bd4 <sp_count_bits>
 800fcba:	4603      	mov	r3, r0
 800fcbc:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800fcc0:	d15e      	bne.n	800fd80 <wc_RsaFunctionSync+0xdc>
        switch(type) {
 800fcc2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fcc4:	2b03      	cmp	r3, #3
 800fcc6:	d85b      	bhi.n	800fd80 <wc_RsaFunctionSync+0xdc>
 800fcc8:	a201      	add	r2, pc, #4	; (adr r2, 800fcd0 <wc_RsaFunctionSync+0x2c>)
 800fcca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800fcce:	bf00      	nop
 800fcd0:	0800fd61 	.word	0x0800fd61
 800fcd4:	0800fd61 	.word	0x0800fd61
 800fcd8:	0800fce1 	.word	0x0800fce1
 800fcdc:	0800fce1 	.word	0x0800fce1
#ifndef WOLFSSL_RSA_PUBLIC_ONLY
        case RSA_PRIVATE_DECRYPT:
        case RSA_PRIVATE_ENCRYPT:
    #ifdef WC_RSA_BLINDING
            if (rng == NULL)
 800fce0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fce2:	2b00      	cmp	r3, #0
 800fce4:	d102      	bne.n	800fcec <wc_RsaFunctionSync+0x48>
                return MISSING_RNG_E;
 800fce6:	f06f 03eb 	mvn.w	r3, #235	; 0xeb
 800fcea:	e0b1      	b.n	800fe50 <wc_RsaFunctionSync+0x1ac>
    #endif
    #ifndef RSA_LOW_MEM
            if ((mp_count_bits(&key->p) == 1024) &&
 800fcec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fcee:	f603 1324 	addw	r3, r3, #2340	; 0x924
 800fcf2:	4618      	mov	r0, r3
 800fcf4:	f008 ff6e 	bl	8018bd4 <sp_count_bits>
 800fcf8:	4603      	mov	r3, r0
 800fcfa:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800fcfe:	d13e      	bne.n	800fd7e <wc_RsaFunctionSync+0xda>
                                             (mp_count_bits(&key->q) == 1024)) {
 800fd00:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fd02:	f503 6343 	add.w	r3, r3, #3120	; 0xc30
 800fd06:	4618      	mov	r0, r3
 800fd08:	f008 ff64 	bl	8018bd4 <sp_count_bits>
 800fd0c:	4603      	mov	r3, r0
            if ((mp_count_bits(&key->p) == 1024) &&
 800fd0e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800fd12:	d134      	bne.n	800fd7e <wc_RsaFunctionSync+0xda>
                return sp_RsaPrivate_2048(in, inLen, &key->d, &key->p, &key->q,
 800fd14:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fd16:	f503 66c3 	add.w	r6, r3, #1560	; 0x618
 800fd1a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fd1c:	f603 1c24 	addw	ip, r3, #2340	; 0x924
 800fd20:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fd22:	f503 6143 	add.w	r1, r3, #3120	; 0xc30
 800fd26:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fd28:	f603 703c 	addw	r0, r3, #3900	; 0xf3c
 800fd2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fd2e:	f503 5392 	add.w	r3, r3, #4672	; 0x1240
 800fd32:	3308      	adds	r3, #8
 800fd34:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800fd36:	f502 52aa 	add.w	r2, r2, #5440	; 0x1540
 800fd3a:	3214      	adds	r2, #20
 800fd3c:	6afc      	ldr	r4, [r7, #44]	; 0x2c
 800fd3e:	683d      	ldr	r5, [r7, #0]
 800fd40:	9506      	str	r5, [sp, #24]
 800fd42:	687d      	ldr	r5, [r7, #4]
 800fd44:	9505      	str	r5, [sp, #20]
 800fd46:	9404      	str	r4, [sp, #16]
 800fd48:	9203      	str	r2, [sp, #12]
 800fd4a:	9302      	str	r3, [sp, #8]
 800fd4c:	9001      	str	r0, [sp, #4]
 800fd4e:	9100      	str	r1, [sp, #0]
 800fd50:	4663      	mov	r3, ip
 800fd52:	4632      	mov	r2, r6
 800fd54:	68b9      	ldr	r1, [r7, #8]
 800fd56:	68f8      	ldr	r0, [r7, #12]
 800fd58:	f002 fd41 	bl	80127de <sp_RsaPrivate_2048>
 800fd5c:	4603      	mov	r3, r0
 800fd5e:	e077      	b.n	800fe50 <wc_RsaFunctionSync+0x1ac>
                                      NULL, NULL, &key->n, out, outLen);
    #endif
#endif
        case RSA_PUBLIC_ENCRYPT:
        case RSA_PUBLIC_DECRYPT:
            return sp_RsaPublic_2048(in, inLen, &key->e, &key->n, out, outLen);
 800fd60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fd62:	f503 7243 	add.w	r2, r3, #780	; 0x30c
 800fd66:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800fd68:	683b      	ldr	r3, [r7, #0]
 800fd6a:	9301      	str	r3, [sp, #4]
 800fd6c:	687b      	ldr	r3, [r7, #4]
 800fd6e:	9300      	str	r3, [sp, #0]
 800fd70:	460b      	mov	r3, r1
 800fd72:	68b9      	ldr	r1, [r7, #8]
 800fd74:	68f8      	ldr	r0, [r7, #12]
 800fd76:	f002 fbd0 	bl	801251a <sp_RsaPublic_2048>
 800fd7a:	4603      	mov	r3, r0
 800fd7c:	e068      	b.n	800fe50 <wc_RsaFunctionSync+0x1ac>
            break;
 800fd7e:	bf00      	nop
        }
    }
#endif
#ifndef WOLFSSL_SP_NO_3072
    if (mp_count_bits(&key->n) == 3072) {
 800fd80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fd82:	4618      	mov	r0, r3
 800fd84:	f008 ff26 	bl	8018bd4 <sp_count_bits>
 800fd88:	4603      	mov	r3, r0
 800fd8a:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800fd8e:	d15d      	bne.n	800fe4c <wc_RsaFunctionSync+0x1a8>
        switch(type) {
 800fd90:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fd92:	2b03      	cmp	r3, #3
 800fd94:	d85a      	bhi.n	800fe4c <wc_RsaFunctionSync+0x1a8>
 800fd96:	a201      	add	r2, pc, #4	; (adr r2, 800fd9c <wc_RsaFunctionSync+0xf8>)
 800fd98:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800fd9c:	0800fe2d 	.word	0x0800fe2d
 800fda0:	0800fe2d 	.word	0x0800fe2d
 800fda4:	0800fdad 	.word	0x0800fdad
 800fda8:	0800fdad 	.word	0x0800fdad
#ifndef WOLFSSL_RSA_PUBLIC_ONLY
        case RSA_PRIVATE_DECRYPT:
        case RSA_PRIVATE_ENCRYPT:
    #ifdef WC_RSA_BLINDING
            if (rng == NULL)
 800fdac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fdae:	2b00      	cmp	r3, #0
 800fdb0:	d102      	bne.n	800fdb8 <wc_RsaFunctionSync+0x114>
                return MISSING_RNG_E;
 800fdb2:	f06f 03eb 	mvn.w	r3, #235	; 0xeb
 800fdb6:	e04b      	b.n	800fe50 <wc_RsaFunctionSync+0x1ac>
    #endif
    #ifndef RSA_LOW_MEM
            if ((mp_count_bits(&key->p) == 1536) &&
 800fdb8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fdba:	f603 1324 	addw	r3, r3, #2340	; 0x924
 800fdbe:	4618      	mov	r0, r3
 800fdc0:	f008 ff08 	bl	8018bd4 <sp_count_bits>
 800fdc4:	4603      	mov	r3, r0
 800fdc6:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 800fdca:	d13e      	bne.n	800fe4a <wc_RsaFunctionSync+0x1a6>
                                             (mp_count_bits(&key->q) == 1536)) {
 800fdcc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fdce:	f503 6343 	add.w	r3, r3, #3120	; 0xc30
 800fdd2:	4618      	mov	r0, r3
 800fdd4:	f008 fefe 	bl	8018bd4 <sp_count_bits>
 800fdd8:	4603      	mov	r3, r0
            if ((mp_count_bits(&key->p) == 1536) &&
 800fdda:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 800fdde:	d134      	bne.n	800fe4a <wc_RsaFunctionSync+0x1a6>
                return sp_RsaPrivate_3072(in, inLen, &key->d, &key->p, &key->q,
 800fde0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fde2:	f503 66c3 	add.w	r6, r3, #1560	; 0x618
 800fde6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fde8:	f603 1c24 	addw	ip, r3, #2340	; 0x924
 800fdec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fdee:	f503 6143 	add.w	r1, r3, #3120	; 0xc30
 800fdf2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fdf4:	f603 703c 	addw	r0, r3, #3900	; 0xf3c
 800fdf8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fdfa:	f503 5392 	add.w	r3, r3, #4672	; 0x1240
 800fdfe:	3308      	adds	r3, #8
 800fe00:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800fe02:	f502 52aa 	add.w	r2, r2, #5440	; 0x1540
 800fe06:	3214      	adds	r2, #20
 800fe08:	6afc      	ldr	r4, [r7, #44]	; 0x2c
 800fe0a:	683d      	ldr	r5, [r7, #0]
 800fe0c:	9506      	str	r5, [sp, #24]
 800fe0e:	687d      	ldr	r5, [r7, #4]
 800fe10:	9505      	str	r5, [sp, #20]
 800fe12:	9404      	str	r4, [sp, #16]
 800fe14:	9203      	str	r2, [sp, #12]
 800fe16:	9302      	str	r3, [sp, #8]
 800fe18:	9001      	str	r0, [sp, #4]
 800fe1a:	9100      	str	r1, [sp, #0]
 800fe1c:	4663      	mov	r3, ip
 800fe1e:	4632      	mov	r2, r6
 800fe20:	68b9      	ldr	r1, [r7, #8]
 800fe22:	68f8      	ldr	r0, [r7, #12]
 800fe24:	f004 fa98 	bl	8014358 <sp_RsaPrivate_3072>
 800fe28:	4603      	mov	r3, r0
 800fe2a:	e011      	b.n	800fe50 <wc_RsaFunctionSync+0x1ac>
                                      NULL, NULL, &key->n, out, outLen);
    #endif
#endif
        case RSA_PUBLIC_ENCRYPT:
        case RSA_PUBLIC_DECRYPT:
            return sp_RsaPublic_3072(in, inLen, &key->e, &key->n, out, outLen);
 800fe2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fe2e:	f503 7243 	add.w	r2, r3, #780	; 0x30c
 800fe32:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800fe34:	683b      	ldr	r3, [r7, #0]
 800fe36:	9301      	str	r3, [sp, #4]
 800fe38:	687b      	ldr	r3, [r7, #4]
 800fe3a:	9300      	str	r3, [sp, #0]
 800fe3c:	460b      	mov	r3, r1
 800fe3e:	68b9      	ldr	r1, [r7, #8]
 800fe40:	68f8      	ldr	r0, [r7, #12]
 800fe42:	f004 f926 	bl	8014092 <sp_RsaPublic_3072>
 800fe46:	4603      	mov	r3, r0
 800fe48:	e002      	b.n	800fe50 <wc_RsaFunctionSync+0x1ac>
            break;
 800fe4a:	bf00      	nop
#endif /* WOLFSSL_HAVE_SP_RSA */

#if defined(WOLFSSL_SP_MATH)
    (void)rng;
    WOLFSSL_MSG("SP Key Size Error");
    return WC_KEY_SIZE_E;
 800fe4c:	f06f 03e9 	mvn.w	r3, #233	; 0xe9
    XFREE(rnd, key->heap, DYNAMIC_TYPE_RSA);
#endif
#endif /* WC_RSA_BLINDING */
    return ret;
#endif /* WOLFSSL_SP_MATH */
}
 800fe50:	4618      	mov	r0, r3
 800fe52:	3714      	adds	r7, #20
 800fe54:	46bd      	mov	sp, r7
 800fe56:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800fe58 <wc_RsaFunction>:
}
#endif /* WOLFSSL_CRYPTOCELL */

int wc_RsaFunction(const byte* in, word32 inLen, byte* out,
                          word32* outLen, int type, RsaKey* key, WC_RNG* rng)
{
 800fe58:	b580      	push	{r7, lr}
 800fe5a:	b08c      	sub	sp, #48	; 0x30
 800fe5c:	af04      	add	r7, sp, #16
 800fe5e:	60f8      	str	r0, [r7, #12]
 800fe60:	60b9      	str	r1, [r7, #8]
 800fe62:	607a      	str	r2, [r7, #4]
 800fe64:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800fe66:	2300      	movs	r3, #0
 800fe68:	61fb      	str	r3, [r7, #28]

    if (key == NULL || in == NULL || inLen == 0 || out == NULL ||
 800fe6a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fe6c:	2b00      	cmp	r3, #0
 800fe6e:	d013      	beq.n	800fe98 <wc_RsaFunction+0x40>
 800fe70:	68fb      	ldr	r3, [r7, #12]
 800fe72:	2b00      	cmp	r3, #0
 800fe74:	d010      	beq.n	800fe98 <wc_RsaFunction+0x40>
 800fe76:	68bb      	ldr	r3, [r7, #8]
 800fe78:	2b00      	cmp	r3, #0
 800fe7a:	d00d      	beq.n	800fe98 <wc_RsaFunction+0x40>
 800fe7c:	687b      	ldr	r3, [r7, #4]
 800fe7e:	2b00      	cmp	r3, #0
 800fe80:	d00a      	beq.n	800fe98 <wc_RsaFunction+0x40>
 800fe82:	683b      	ldr	r3, [r7, #0]
 800fe84:	2b00      	cmp	r3, #0
 800fe86:	d007      	beq.n	800fe98 <wc_RsaFunction+0x40>
            outLen == NULL || *outLen == 0 || type == RSA_TYPE_UNKNOWN) {
 800fe88:	683b      	ldr	r3, [r7, #0]
 800fe8a:	681b      	ldr	r3, [r3, #0]
 800fe8c:	2b00      	cmp	r3, #0
 800fe8e:	d003      	beq.n	800fe98 <wc_RsaFunction+0x40>
 800fe90:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fe92:	f1b3 3fff 	cmp.w	r3, #4294967295
 800fe96:	d102      	bne.n	800fe9e <wc_RsaFunction+0x46>
        return BAD_FUNC_ARG;
 800fe98:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800fe9c:	e083      	b.n	800ffa6 <wc_RsaFunction+0x14e>
    }
#endif

#ifndef TEST_UNPAD_CONSTANT_TIME
#ifndef NO_RSA_BOUNDS_CHECK
    if (type == RSA_PRIVATE_DECRYPT &&
 800fe9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fea0:	2b03      	cmp	r3, #3
 800fea2:	d162      	bne.n	800ff6a <wc_RsaFunction+0x112>
        key->state == RSA_STATE_DECRYPT_EXPTMOD) {
 800fea4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fea6:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800feaa:	330c      	adds	r3, #12
 800feac:	681b      	ldr	r3, [r3, #0]
    if (type == RSA_PRIVATE_DECRYPT &&
 800feae:	2b04      	cmp	r3, #4
 800feb0:	d15b      	bne.n	800ff6a <wc_RsaFunction+0x112>
#else
        mp_int c[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
        c = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_RSA);
 800feb2:	f44f 7043 	mov.w	r0, #780	; 0x30c
 800feb6:	f7ff f81f 	bl	800eef8 <wolfSSL_Malloc>
 800feba:	61b8      	str	r0, [r7, #24]
        if (c == NULL)
 800febc:	69bb      	ldr	r3, [r7, #24]
 800febe:	2b00      	cmp	r3, #0
 800fec0:	d102      	bne.n	800fec8 <wc_RsaFunction+0x70>
            ret = MEMORY_E;
 800fec2:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800fec6:	61fb      	str	r3, [r7, #28]
#endif

        if (mp_init(c) != MP_OKAY)
 800fec8:	69b8      	ldr	r0, [r7, #24]
 800feca:	f008 fd1f 	bl	801890c <sp_init>
 800fece:	4603      	mov	r3, r0
 800fed0:	2b00      	cmp	r3, #0
 800fed2:	d002      	beq.n	800feda <wc_RsaFunction+0x82>
            ret = MP_INIT_E;
 800fed4:	f06f 036d 	mvn.w	r3, #109	; 0x6d
 800fed8:	61fb      	str	r3, [r7, #28]
        if (ret == 0) {
 800feda:	69fb      	ldr	r3, [r7, #28]
 800fedc:	2b00      	cmp	r3, #0
 800fede:	d10a      	bne.n	800fef6 <wc_RsaFunction+0x9e>
            if (mp_read_unsigned_bin(c, in, inLen) != 0)
 800fee0:	68ba      	ldr	r2, [r7, #8]
 800fee2:	68f9      	ldr	r1, [r7, #12]
 800fee4:	69b8      	ldr	r0, [r7, #24]
 800fee6:	f008 ffd9 	bl	8018e9c <sp_read_unsigned_bin>
 800feea:	4603      	mov	r3, r0
 800feec:	2b00      	cmp	r3, #0
 800feee:	d002      	beq.n	800fef6 <wc_RsaFunction+0x9e>
                ret = MP_READ_E;
 800fef0:	f06f 036e 	mvn.w	r3, #110	; 0x6e
 800fef4:	61fb      	str	r3, [r7, #28]
        }
        if (ret == 0) {
 800fef6:	69fb      	ldr	r3, [r7, #28]
 800fef8:	2b00      	cmp	r3, #0
 800fefa:	d109      	bne.n	800ff10 <wc_RsaFunction+0xb8>
            /* check c > 1 */
            if (mp_cmp_d(c, 1) != MP_GT)
 800fefc:	2101      	movs	r1, #1
 800fefe:	69b8      	ldr	r0, [r7, #24]
 800ff00:	f008 fed7 	bl	8018cb2 <sp_cmp_d>
 800ff04:	4603      	mov	r3, r0
 800ff06:	2b01      	cmp	r3, #1
 800ff08:	d002      	beq.n	800ff10 <wc_RsaFunction+0xb8>
                ret = RSA_OUT_OF_RANGE_E;
 800ff0a:	f06f 03fc 	mvn.w	r3, #252	; 0xfc
 800ff0e:	61fb      	str	r3, [r7, #28]
        }
        if (ret == 0) {
 800ff10:	69fb      	ldr	r3, [r7, #28]
 800ff12:	2b00      	cmp	r3, #0
 800ff14:	d10a      	bne.n	800ff2c <wc_RsaFunction+0xd4>
            /* add c+1 */
            if (mp_add_d(c, 1, c) != MP_OKAY)
 800ff16:	69ba      	ldr	r2, [r7, #24]
 800ff18:	2101      	movs	r1, #1
 800ff1a:	69b8      	ldr	r0, [r7, #24]
 800ff1c:	f008 ff88 	bl	8018e30 <sp_add_d>
 800ff20:	4603      	mov	r3, r0
 800ff22:	2b00      	cmp	r3, #0
 800ff24:	d002      	beq.n	800ff2c <wc_RsaFunction+0xd4>
                ret = MP_ADD_E;
 800ff26:	f06f 0372 	mvn.w	r3, #114	; 0x72
 800ff2a:	61fb      	str	r3, [r7, #28]
        }
        if (ret == 0) {
 800ff2c:	69fb      	ldr	r3, [r7, #28]
 800ff2e:	2b00      	cmp	r3, #0
 800ff30:	d10b      	bne.n	800ff4a <wc_RsaFunction+0xf2>
            /* check c+1 < n */
            if (mp_cmp(c, &key->n) != MP_LT)
 800ff32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ff34:	4619      	mov	r1, r3
 800ff36:	69b8      	ldr	r0, [r7, #24]
 800ff38:	f008 fe29 	bl	8018b8e <sp_cmp>
 800ff3c:	4603      	mov	r3, r0
 800ff3e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ff42:	d002      	beq.n	800ff4a <wc_RsaFunction+0xf2>
                ret = RSA_OUT_OF_RANGE_E;
 800ff44:	f06f 03fc 	mvn.w	r3, #252	; 0xfc
 800ff48:	61fb      	str	r3, [r7, #28]
        }
        mp_clear(c);
 800ff4a:	69b8      	ldr	r0, [r7, #24]
 800ff4c:	f008 fd8f 	bl	8018a6e <sp_clear>

#ifdef WOLFSSL_SMALL_STACK
        XFREE(c, key->heap, DYNAMIC_TYPE_RSA);
 800ff50:	69bb      	ldr	r3, [r7, #24]
 800ff52:	617b      	str	r3, [r7, #20]
 800ff54:	697b      	ldr	r3, [r7, #20]
 800ff56:	2b00      	cmp	r3, #0
 800ff58:	d002      	beq.n	800ff60 <wc_RsaFunction+0x108>
 800ff5a:	6978      	ldr	r0, [r7, #20]
 800ff5c:	f7fe ffe8 	bl	800ef30 <wolfSSL_Free>
#endif

        if (ret != 0)
 800ff60:	69fb      	ldr	r3, [r7, #28]
 800ff62:	2b00      	cmp	r3, #0
 800ff64:	d001      	beq.n	800ff6a <wc_RsaFunction+0x112>
            return ret;
 800ff66:	69fb      	ldr	r3, [r7, #28]
 800ff68:	e01d      	b.n	800ffa6 <wc_RsaFunction+0x14e>
        ret = wc_RsaFunctionNonBlock(in, inLen, out, outLen, type, key);
    }
    else
#endif
    {
        ret = wc_RsaFunctionSync(in, inLen, out, outLen, type, key, rng);
 800ff6a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ff6c:	9302      	str	r3, [sp, #8]
 800ff6e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ff70:	9301      	str	r3, [sp, #4]
 800ff72:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ff74:	9300      	str	r3, [sp, #0]
 800ff76:	683b      	ldr	r3, [r7, #0]
 800ff78:	687a      	ldr	r2, [r7, #4]
 800ff7a:	68b9      	ldr	r1, [r7, #8]
 800ff7c:	68f8      	ldr	r0, [r7, #12]
 800ff7e:	f7ff fe91 	bl	800fca4 <wc_RsaFunctionSync>
 800ff82:	61f8      	str	r0, [r7, #28]
    }

    /* handle error */
    if (ret < 0 && ret != WC_PENDING_E
 800ff84:	69fb      	ldr	r3, [r7, #28]
 800ff86:	2b00      	cmp	r3, #0
 800ff88:	da0c      	bge.n	800ffa4 <wc_RsaFunction+0x14c>
 800ff8a:	69fb      	ldr	r3, [r7, #28]
 800ff8c:	f113 0f6c 	cmn.w	r3, #108	; 0x6c
 800ff90:	d008      	beq.n	800ffa4 <wc_RsaFunction+0x14c>
        if (ret == MP_EXPTMOD_E) {
            /* This can happen due to incorrectly set FP_MAX_BITS or missing XREALLOC */
            WOLFSSL_MSG("RSA_FUNCTION MP_EXPTMOD_E: memory/config problem");
        }

        key->state = RSA_STATE_NONE;
 800ff92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ff94:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800ff98:	330c      	adds	r3, #12
 800ff9a:	2200      	movs	r2, #0
 800ff9c:	601a      	str	r2, [r3, #0]
        wc_RsaCleanup(key);
 800ff9e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800ffa0:	f7ff f957 	bl	800f252 <wc_RsaCleanup>
    }

    return ret;
 800ffa4:	69fb      	ldr	r3, [r7, #28]
}
 800ffa6:	4618      	mov	r0, r3
 800ffa8:	3720      	adds	r7, #32
 800ffaa:	46bd      	mov	sp, r7
 800ffac:	bd80      	pop	{r7, pc}
	...

0800ffb0 <RsaPrivateDecryptEx>:
                            word32 outLen, byte** outPtr, RsaKey* key,
                            int rsa_type, byte pad_value, int pad_type,
                            enum wc_HashType hash, int mgf,
                            byte* label, word32 labelSz, int saltLen,
                            WC_RNG* rng)
{
 800ffb0:	b5b0      	push	{r4, r5, r7, lr}
 800ffb2:	b092      	sub	sp, #72	; 0x48
 800ffb4:	af08      	add	r7, sp, #32
 800ffb6:	60f8      	str	r0, [r7, #12]
 800ffb8:	60b9      	str	r1, [r7, #8]
 800ffba:	607a      	str	r2, [r7, #4]
 800ffbc:	603b      	str	r3, [r7, #0]
    int ret = RSA_WRONG_TYPE_E;
 800ffbe:	f06f 0381 	mvn.w	r3, #129	; 0x81
 800ffc2:	627b      	str	r3, [r7, #36]	; 0x24
    byte* pad = NULL;
 800ffc4:	2300      	movs	r3, #0
 800ffc6:	613b      	str	r3, [r7, #16]

    if (in == NULL || inLen == 0 || out == NULL || key == NULL) {
 800ffc8:	68fb      	ldr	r3, [r7, #12]
 800ffca:	2b00      	cmp	r3, #0
 800ffcc:	d008      	beq.n	800ffe0 <RsaPrivateDecryptEx+0x30>
 800ffce:	68bb      	ldr	r3, [r7, #8]
 800ffd0:	2b00      	cmp	r3, #0
 800ffd2:	d005      	beq.n	800ffe0 <RsaPrivateDecryptEx+0x30>
 800ffd4:	687b      	ldr	r3, [r7, #4]
 800ffd6:	2b00      	cmp	r3, #0
 800ffd8:	d002      	beq.n	800ffe0 <RsaPrivateDecryptEx+0x30>
 800ffda:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ffdc:	2b00      	cmp	r3, #0
 800ffde:	d102      	bne.n	800ffe6 <RsaPrivateDecryptEx+0x36>
        return BAD_FUNC_ARG;
 800ffe0:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800ffe4:	e149      	b.n	801027a <RsaPrivateDecryptEx+0x2ca>
    }

    switch (key->state) {
 800ffe6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ffe8:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 800ffec:	330c      	adds	r3, #12
 800ffee:	681b      	ldr	r3, [r3, #0]
 800fff0:	2b06      	cmp	r3, #6
 800fff2:	f200 812b 	bhi.w	801024c <RsaPrivateDecryptEx+0x29c>
 800fff6:	a201      	add	r2, pc, #4	; (adr r2, 800fffc <RsaPrivateDecryptEx+0x4c>)
 800fff8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800fffc:	08010019 	.word	0x08010019
 8010000:	0801024d 	.word	0x0801024d
 8010004:	0801024d 	.word	0x0801024d
 8010008:	0801024d 	.word	0x0801024d
 801000c:	080100a3 	.word	0x080100a3
 8010010:	080100f7 	.word	0x080100f7
 8010014:	08010255 	.word	0x08010255
    case RSA_STATE_NONE:
        key->dataLen = inLen;
 8010018:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801001a:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 801001e:	3310      	adds	r3, #16
 8010020:	68ba      	ldr	r2, [r7, #8]
 8010022:	601a      	str	r2, [r3, #0]
    #endif /* WOLFSSL_CRYPTOCELL */


#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE)
        /* verify the tmp ptr is NULL, otherwise indicates bad state */
        if (key->data != NULL) {
 8010024:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010026:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 801002a:	3304      	adds	r3, #4
 801002c:	681b      	ldr	r3, [r3, #0]
 801002e:	2b00      	cmp	r3, #0
 8010030:	d003      	beq.n	801003a <RsaPrivateDecryptEx+0x8a>
            ret = BAD_STATE_E;
 8010032:	f06f 03bf 	mvn.w	r3, #191	; 0xbf
 8010036:	627b      	str	r3, [r7, #36]	; 0x24
            break;
 8010038:	e10f      	b.n	801025a <RsaPrivateDecryptEx+0x2aa>
        }

        /* if not doing this inline then allocate a buffer for it */
        if (outPtr == NULL) {
 801003a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801003c:	2b00      	cmp	r3, #0
 801003e:	d124      	bne.n	801008a <RsaPrivateDecryptEx+0xda>
            key->data = (byte*)XMALLOC(inLen, key->heap,
 8010040:	68b8      	ldr	r0, [r7, #8]
 8010042:	f7fe ff59 	bl	800eef8 <wolfSSL_Malloc>
 8010046:	4602      	mov	r2, r0
 8010048:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801004a:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 801004e:	3304      	adds	r3, #4
 8010050:	601a      	str	r2, [r3, #0]
                                                      DYNAMIC_TYPE_WOLF_BIGINT);
            key->dataIsAlloc = 1;
 8010052:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010054:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 8010058:	3318      	adds	r3, #24
 801005a:	2201      	movs	r2, #1
 801005c:	701a      	strb	r2, [r3, #0]
            if (key->data == NULL) {
 801005e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010060:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 8010064:	3304      	adds	r3, #4
 8010066:	681b      	ldr	r3, [r3, #0]
 8010068:	2b00      	cmp	r3, #0
 801006a:	d103      	bne.n	8010074 <RsaPrivateDecryptEx+0xc4>
                ret = MEMORY_E;
 801006c:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 8010070:	627b      	str	r3, [r7, #36]	; 0x24
                break;
 8010072:	e0f2      	b.n	801025a <RsaPrivateDecryptEx+0x2aa>
            }
            XMEMCPY(key->data, in, inLen);
 8010074:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010076:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 801007a:	3304      	adds	r3, #4
 801007c:	681b      	ldr	r3, [r3, #0]
 801007e:	68ba      	ldr	r2, [r7, #8]
 8010080:	68f9      	ldr	r1, [r7, #12]
 8010082:	4618      	mov	r0, r3
 8010084:	f009 f9b7 	bl	80193f6 <memcpy>
 8010088:	e005      	b.n	8010096 <RsaPrivateDecryptEx+0xe6>
        }
        else {
            key->data = out;
 801008a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801008c:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 8010090:	3304      	adds	r3, #4
 8010092:	687a      	ldr	r2, [r7, #4]
 8010094:	601a      	str	r2, [r3, #0]
        }
#endif

        key->state = RSA_STATE_DECRYPT_EXPTMOD;
 8010096:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010098:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 801009c:	330c      	adds	r3, #12
 801009e:	2204      	movs	r2, #4
 80100a0:	601a      	str	r2, [r3, #0]
        FALL_THROUGH;

    case RSA_STATE_DECRYPT_EXPTMOD:
#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE)
        ret = wc_RsaFunction(key->data, inLen, key->data, &key->dataLen,
 80100a2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80100a4:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 80100a8:	3304      	adds	r3, #4
 80100aa:	6818      	ldr	r0, [r3, #0]
 80100ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80100ae:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 80100b2:	3304      	adds	r3, #4
 80100b4:	6819      	ldr	r1, [r3, #0]
 80100b6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80100b8:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 80100bc:	3310      	adds	r3, #16
 80100be:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80100c0:	9202      	str	r2, [sp, #8]
 80100c2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80100c4:	9201      	str	r2, [sp, #4]
 80100c6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80100c8:	9200      	str	r2, [sp, #0]
 80100ca:	460a      	mov	r2, r1
 80100cc:	68b9      	ldr	r1, [r7, #8]
 80100ce:	f7ff fec3 	bl	800fe58 <wc_RsaFunction>
 80100d2:	6278      	str	r0, [r7, #36]	; 0x24
                                                            rsa_type, key, rng);
#else
        ret = wc_RsaFunction(in, inLen, out, &key->dataLen, rsa_type, key, rng);
#endif

        if (ret >= 0 || ret == WC_PENDING_E) {
 80100d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80100d6:	2b00      	cmp	r3, #0
 80100d8:	da03      	bge.n	80100e2 <RsaPrivateDecryptEx+0x132>
 80100da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80100dc:	f113 0f6c 	cmn.w	r3, #108	; 0x6c
 80100e0:	d105      	bne.n	80100ee <RsaPrivateDecryptEx+0x13e>
            key->state = RSA_STATE_DECRYPT_UNPAD;
 80100e2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80100e4:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 80100e8:	330c      	adds	r3, #12
 80100ea:	2205      	movs	r2, #5
 80100ec:	601a      	str	r2, [r3, #0]
        }
        if (ret < 0) {
 80100ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80100f0:	2b00      	cmp	r3, #0
 80100f2:	f2c0 80b1 	blt.w	8010258 <RsaPrivateDecryptEx+0x2a8>

        FALL_THROUGH;

    case RSA_STATE_DECRYPT_UNPAD:
#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE)
        ret = wc_RsaUnPad_ex(key->data, key->dataLen, &pad, pad_value, pad_type,
 80100f6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80100f8:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 80100fc:	3304      	adds	r3, #4
 80100fe:	681c      	ldr	r4, [r3, #0]
 8010100:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010102:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 8010106:	3310      	adds	r3, #16
 8010108:	681d      	ldr	r5, [r3, #0]
                             hash, mgf, label, labelSz, saltLen,
                             mp_count_bits(&key->n), key->heap);
 801010a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
        ret = wc_RsaUnPad_ex(key->data, key->dataLen, &pad, pad_value, pad_type,
 801010c:	4618      	mov	r0, r3
 801010e:	f008 fd61 	bl	8018bd4 <sp_count_bits>
 8010112:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010114:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 8010118:	681b      	ldr	r3, [r3, #0]
 801011a:	f897 1044 	ldrb.w	r1, [r7, #68]	; 0x44
 801011e:	f107 0210 	add.w	r2, r7, #16
 8010122:	9307      	str	r3, [sp, #28]
 8010124:	9006      	str	r0, [sp, #24]
 8010126:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010128:	9305      	str	r3, [sp, #20]
 801012a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801012c:	9304      	str	r3, [sp, #16]
 801012e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010130:	9303      	str	r3, [sp, #12]
 8010132:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010134:	9302      	str	r3, [sp, #8]
 8010136:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 801013a:	9301      	str	r3, [sp, #4]
 801013c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801013e:	9300      	str	r3, [sp, #0]
 8010140:	460b      	mov	r3, r1
 8010142:	4629      	mov	r1, r5
 8010144:	4620      	mov	r0, r4
 8010146:	f7ff fd6b 	bl	800fc20 <wc_RsaUnPad_ex>
 801014a:	6278      	str	r0, [r7, #36]	; 0x24
#else
        ret = wc_RsaUnPad_ex(out, key->dataLen, &pad, pad_value, pad_type, hash,
                             mgf, label, labelSz, saltLen,
                             mp_count_bits(&key->n), key->heap);
#endif
        if (rsa_type == RSA_PUBLIC_DECRYPT && ret > (int)outLen)
 801014c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801014e:	2b01      	cmp	r3, #1
 8010150:	d107      	bne.n	8010162 <RsaPrivateDecryptEx+0x1b2>
 8010152:	683b      	ldr	r3, [r7, #0]
 8010154:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8010156:	429a      	cmp	r2, r3
 8010158:	dd03      	ble.n	8010162 <RsaPrivateDecryptEx+0x1b2>
            ret = RSA_BUFFER_E;
 801015a:	f06f 0382 	mvn.w	r3, #130	; 0x82
 801015e:	627b      	str	r3, [r7, #36]	; 0x24
 8010160:	e06d      	b.n	801023e <RsaPrivateDecryptEx+0x28e>
        else if (ret >= 0 && pad != NULL) {
 8010162:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010164:	2b00      	cmp	r3, #0
 8010166:	db6a      	blt.n	801023e <RsaPrivateDecryptEx+0x28e>
 8010168:	693b      	ldr	r3, [r7, #16]
 801016a:	2b00      	cmp	r3, #0
 801016c:	d067      	beq.n	801023e <RsaPrivateDecryptEx+0x28e>
#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE)
            signed char c;
#endif

            /* only copy output if not inline */
            if (outPtr == NULL) {
 801016e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010170:	2b00      	cmp	r3, #0
 8010172:	d148      	bne.n	8010206 <RsaPrivateDecryptEx+0x256>
#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE)
                if (rsa_type == RSA_PRIVATE_DECRYPT) {
 8010174:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010176:	2b03      	cmp	r3, #3
 8010178:	d13e      	bne.n	80101f8 <RsaPrivateDecryptEx+0x248>
                    word32 i, j;
                    int start = (int)((size_t)pad - (size_t)key->data);
 801017a:	693b      	ldr	r3, [r7, #16]
 801017c:	461a      	mov	r2, r3
 801017e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010180:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 8010184:	3304      	adds	r3, #4
 8010186:	681b      	ldr	r3, [r3, #0]
 8010188:	1ad3      	subs	r3, r2, r3
 801018a:	61bb      	str	r3, [r7, #24]

                    for (i = 0, j = 0; j < key->dataLen; j++) {
 801018c:	2300      	movs	r3, #0
 801018e:	623b      	str	r3, [r7, #32]
 8010190:	2300      	movs	r3, #0
 8010192:	61fb      	str	r3, [r7, #28]
 8010194:	e027      	b.n	80101e6 <RsaPrivateDecryptEx+0x236>
                        out[i] = key->data[j];
 8010196:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010198:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 801019c:	3304      	adds	r3, #4
 801019e:	681a      	ldr	r2, [r3, #0]
 80101a0:	69fb      	ldr	r3, [r7, #28]
 80101a2:	441a      	add	r2, r3
 80101a4:	6879      	ldr	r1, [r7, #4]
 80101a6:	6a3b      	ldr	r3, [r7, #32]
 80101a8:	440b      	add	r3, r1
 80101aa:	7812      	ldrb	r2, [r2, #0]
 80101ac:	701a      	strb	r2, [r3, #0]
                        c  = ctMaskGTE(j, start);
 80101ae:	69fb      	ldr	r3, [r7, #28]
 80101b0:	69b9      	ldr	r1, [r7, #24]
 80101b2:	4618      	mov	r0, r3
 80101b4:	f7fe ff92 	bl	800f0dc <ctMaskGTE>
 80101b8:	4603      	mov	r3, r0
 80101ba:	75fb      	strb	r3, [r7, #23]
                        c &= ctMaskLT(i, outLen);
 80101bc:	6a3b      	ldr	r3, [r7, #32]
 80101be:	683a      	ldr	r2, [r7, #0]
 80101c0:	4611      	mov	r1, r2
 80101c2:	4618      	mov	r0, r3
 80101c4:	f7fe ff9c 	bl	800f100 <ctMaskLT>
 80101c8:	4603      	mov	r3, r0
 80101ca:	b25a      	sxtb	r2, r3
 80101cc:	7dfb      	ldrb	r3, [r7, #23]
 80101ce:	4013      	ands	r3, r2
 80101d0:	75fb      	strb	r3, [r7, #23]
                        /* 0 - no add, -1 add */
                        i += (word32)((byte)(-c));
 80101d2:	7dfb      	ldrb	r3, [r7, #23]
 80101d4:	425b      	negs	r3, r3
 80101d6:	b2db      	uxtb	r3, r3
 80101d8:	461a      	mov	r2, r3
 80101da:	6a3b      	ldr	r3, [r7, #32]
 80101dc:	4413      	add	r3, r2
 80101de:	623b      	str	r3, [r7, #32]
                    for (i = 0, j = 0; j < key->dataLen; j++) {
 80101e0:	69fb      	ldr	r3, [r7, #28]
 80101e2:	3301      	adds	r3, #1
 80101e4:	61fb      	str	r3, [r7, #28]
 80101e6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80101e8:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 80101ec:	3310      	adds	r3, #16
 80101ee:	681b      	ldr	r3, [r3, #0]
 80101f0:	69fa      	ldr	r2, [r7, #28]
 80101f2:	429a      	cmp	r2, r3
 80101f4:	d3cf      	bcc.n	8010196 <RsaPrivateDecryptEx+0x1e6>
 80101f6:	e009      	b.n	801020c <RsaPrivateDecryptEx+0x25c>
                    }
                }
                else
#endif
                {
                    XMEMCPY(out, pad, ret);
 80101f8:	693b      	ldr	r3, [r7, #16]
 80101fa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80101fc:	4619      	mov	r1, r3
 80101fe:	6878      	ldr	r0, [r7, #4]
 8010200:	f009 f8f9 	bl	80193f6 <memcpy>
 8010204:	e002      	b.n	801020c <RsaPrivateDecryptEx+0x25c>
                }
            }
            else
                *outPtr = pad;
 8010206:	693a      	ldr	r2, [r7, #16]
 8010208:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801020a:	601a      	str	r2, [r3, #0]

#if !defined(WOLFSSL_RSA_VERIFY_ONLY)
            ret = ctMaskSelInt(ctMaskLTE(ret, outLen), ret, RSA_BUFFER_E);
 801020c:	683b      	ldr	r3, [r7, #0]
 801020e:	4619      	mov	r1, r3
 8010210:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010212:	f7fe ff88 	bl	800f126 <ctMaskLTE>
 8010216:	4603      	mov	r3, r0
 8010218:	f06f 0282 	mvn.w	r2, #130	; 0x82
 801021c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801021e:	4618      	mov	r0, r3
 8010220:	f7fe ffff 	bl	800f222 <ctMaskSelInt>
 8010224:	6278      	str	r0, [r7, #36]	; 0x24
            ret = ctMaskSelInt(ctMaskNotEq(ret, 0), ret, RSA_BUFFER_E);
 8010226:	2100      	movs	r1, #0
 8010228:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801022a:	f7fe ffe4 	bl	800f1f6 <ctMaskNotEq>
 801022e:	4603      	mov	r3, r0
 8010230:	f06f 0282 	mvn.w	r2, #130	; 0x82
 8010234:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8010236:	4618      	mov	r0, r3
 8010238:	f7fe fff3 	bl	800f222 <ctMaskSelInt>
 801023c:	6278      	str	r0, [r7, #36]	; 0x24
            if (outLen < (word32)ret)
                ret = RSA_BUFFER_E;
#endif
        }

        key->state = RSA_STATE_DECRYPT_RES;
 801023e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010240:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 8010244:	330c      	adds	r3, #12
 8010246:	2206      	movs	r2, #6
 8010248:	601a      	str	r2, [r3, #0]
                if (outPtr)
                    *outPtr = in;
            }
        }
    #endif
        break;
 801024a:	e003      	b.n	8010254 <RsaPrivateDecryptEx+0x2a4>

    default:
        ret = BAD_STATE_E;
 801024c:	f06f 03bf 	mvn.w	r3, #191	; 0xbf
 8010250:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 8010252:	e002      	b.n	801025a <RsaPrivateDecryptEx+0x2aa>
        break;
 8010254:	bf00      	nop
 8010256:	e000      	b.n	801025a <RsaPrivateDecryptEx+0x2aa>
            break;
 8010258:	bf00      	nop
    }

    /* if async pending then return and skip done cleanup below */
    if (ret == WC_PENDING_E
 801025a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801025c:	f113 0f6c 	cmn.w	r3, #108	; 0x6c
 8010260:	d101      	bne.n	8010266 <RsaPrivateDecryptEx+0x2b6>
    #ifdef WC_RSA_NONBLOCK
        || ret == FP_WOULDBLOCK
    #endif
    ) {
        return ret;
 8010262:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010264:	e009      	b.n	801027a <RsaPrivateDecryptEx+0x2ca>
    }

    key->state = RSA_STATE_NONE;
 8010266:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010268:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 801026c:	330c      	adds	r3, #12
 801026e:	2200      	movs	r2, #0
 8010270:	601a      	str	r2, [r3, #0]
    wc_RsaCleanup(key);
 8010272:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8010274:	f7fe ffed 	bl	800f252 <wc_RsaCleanup>

    return ret;
 8010278:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 801027a:	4618      	mov	r0, r3
 801027c:	3728      	adds	r7, #40	; 0x28
 801027e:	46bd      	mov	sp, r7
 8010280:	bdb0      	pop	{r4, r5, r7, pc}
 8010282:	bf00      	nop

08010284 <wc_RsaSSL_VerifyInline>:
#endif /* WC_NO_RSA_OAEP || WC_RSA_NO_PADDING */
#endif /* WOLFSSL_RSA_PUBLIC_ONLY */

#if !defined(WOLFSSL_CRYPTOCELL)
int wc_RsaSSL_VerifyInline(byte* in, word32 inLen, byte** out, RsaKey* key)
{
 8010284:	b580      	push	{r7, lr}
 8010286:	b092      	sub	sp, #72	; 0x48
 8010288:	af0c      	add	r7, sp, #48	; 0x30
 801028a:	60f8      	str	r0, [r7, #12]
 801028c:	60b9      	str	r1, [r7, #8]
 801028e:	607a      	str	r2, [r7, #4]
 8010290:	603b      	str	r3, [r7, #0]
    WC_RNG* rng;
#ifdef WC_RSA_BLINDING
    rng = key->rng;
 8010292:	683b      	ldr	r3, [r7, #0]
 8010294:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 8010298:	3314      	adds	r3, #20
 801029a:	681b      	ldr	r3, [r3, #0]
 801029c:	617b      	str	r3, [r7, #20]
#else
    rng = NULL;
#endif
    return RsaPrivateDecryptEx(in, inLen, in, inLen, out, key,
 801029e:	697b      	ldr	r3, [r7, #20]
 80102a0:	930a      	str	r3, [sp, #40]	; 0x28
 80102a2:	2300      	movs	r3, #0
 80102a4:	9309      	str	r3, [sp, #36]	; 0x24
 80102a6:	2300      	movs	r3, #0
 80102a8:	9308      	str	r3, [sp, #32]
 80102aa:	2300      	movs	r3, #0
 80102ac:	9307      	str	r3, [sp, #28]
 80102ae:	2300      	movs	r3, #0
 80102b0:	9306      	str	r3, [sp, #24]
 80102b2:	2300      	movs	r3, #0
 80102b4:	9305      	str	r3, [sp, #20]
 80102b6:	2300      	movs	r3, #0
 80102b8:	9304      	str	r3, [sp, #16]
 80102ba:	2301      	movs	r3, #1
 80102bc:	9303      	str	r3, [sp, #12]
 80102be:	2301      	movs	r3, #1
 80102c0:	9302      	str	r3, [sp, #8]
 80102c2:	683b      	ldr	r3, [r7, #0]
 80102c4:	9301      	str	r3, [sp, #4]
 80102c6:	687b      	ldr	r3, [r7, #4]
 80102c8:	9300      	str	r3, [sp, #0]
 80102ca:	68bb      	ldr	r3, [r7, #8]
 80102cc:	68fa      	ldr	r2, [r7, #12]
 80102ce:	68b9      	ldr	r1, [r7, #8]
 80102d0:	68f8      	ldr	r0, [r7, #12]
 80102d2:	f7ff fe6d 	bl	800ffb0 <RsaPrivateDecryptEx>
 80102d6:	4603      	mov	r3, r0
        RSA_PUBLIC_DECRYPT, RSA_BLOCK_TYPE_1, WC_RSA_PKCSV15_PAD,
        WC_HASH_TYPE_NONE, WC_MGF1NONE, NULL, 0, 0, rng);
}
 80102d8:	4618      	mov	r0, r3
 80102da:	3718      	adds	r7, #24
 80102dc:	46bd      	mov	sp, r7
 80102de:	bd80      	pop	{r7, pc}

080102e0 <wc_RsaEncryptSize>:
#endif

#if !defined(WOLFSSL_RSA_VERIFY_ONLY) || !defined(WOLFSSL_SP_MATH) || \
                                                             defined(WC_RSA_PSS)
int wc_RsaEncryptSize(RsaKey* key)
{
 80102e0:	b580      	push	{r7, lr}
 80102e2:	b084      	sub	sp, #16
 80102e4:	af00      	add	r7, sp, #0
 80102e6:	6078      	str	r0, [r7, #4]
    int ret;

    if (key == NULL) {
 80102e8:	687b      	ldr	r3, [r7, #4]
 80102ea:	2b00      	cmp	r3, #0
 80102ec:	d102      	bne.n	80102f4 <wc_RsaEncryptSize+0x14>
        return BAD_FUNC_ARG;
 80102ee:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 80102f2:	e005      	b.n	8010300 <wc_RsaEncryptSize+0x20>
    }

    ret = mp_unsigned_bin_size(&key->n);
 80102f4:	687b      	ldr	r3, [r7, #4]
 80102f6:	4618      	mov	r0, r3
 80102f8:	f008 fdb7 	bl	8018e6a <sp_unsigned_bin_size>
 80102fc:	60f8      	str	r0, [r7, #12]
    if (ret == 0 && key->devId != INVALID_DEVID) {
        ret = 2048/8; /* hardware handles, use 2048-bit as default */
    }
#endif

    return ret;
 80102fe:	68fb      	ldr	r3, [r7, #12]
}
 8010300:	4618      	mov	r0, r3
 8010302:	3710      	adds	r7, #16
 8010304:	46bd      	mov	sp, r7
 8010306:	bd80      	pop	{r7, pc}

08010308 <rotlFixed>:
    {
 8010308:	b480      	push	{r7}
 801030a:	b083      	sub	sp, #12
 801030c:	af00      	add	r7, sp, #0
 801030e:	6078      	str	r0, [r7, #4]
 8010310:	6039      	str	r1, [r7, #0]
        return (x << y) | (x >> (sizeof(y) * 8 - y));
 8010312:	687a      	ldr	r2, [r7, #4]
 8010314:	683b      	ldr	r3, [r7, #0]
 8010316:	f1c3 0320 	rsb	r3, r3, #32
 801031a:	fa62 f303 	ror.w	r3, r2, r3
    }
 801031e:	4618      	mov	r0, r3
 8010320:	370c      	adds	r7, #12
 8010322:	46bd      	mov	sp, r7
 8010324:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010328:	4770      	bx	lr

0801032a <rotrFixed>:
    {
 801032a:	b480      	push	{r7}
 801032c:	b083      	sub	sp, #12
 801032e:	af00      	add	r7, sp, #0
 8010330:	6078      	str	r0, [r7, #4]
 8010332:	6039      	str	r1, [r7, #0]
        return (x >> y) | (x << (sizeof(y) * 8 - y));
 8010334:	687a      	ldr	r2, [r7, #4]
 8010336:	683b      	ldr	r3, [r7, #0]
 8010338:	fa62 f303 	ror.w	r3, r2, r3
    }
 801033c:	4618      	mov	r0, r3
 801033e:	370c      	adds	r7, #12
 8010340:	46bd      	mov	sp, r7
 8010342:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010346:	4770      	bx	lr

08010348 <ByteReverseWord32>:
{
 8010348:	b580      	push	{r7, lr}
 801034a:	b082      	sub	sp, #8
 801034c:	af00      	add	r7, sp, #0
 801034e:	6078      	str	r0, [r7, #4]
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 8010350:	687b      	ldr	r3, [r7, #4]
 8010352:	0a1b      	lsrs	r3, r3, #8
 8010354:	f003 12ff 	and.w	r2, r3, #16711935	; 0xff00ff
 8010358:	687b      	ldr	r3, [r7, #4]
 801035a:	021b      	lsls	r3, r3, #8
 801035c:	f003 23ff 	and.w	r3, r3, #4278255360	; 0xff00ff00
 8010360:	4313      	orrs	r3, r2
 8010362:	607b      	str	r3, [r7, #4]
    return rotlFixed(value, 16U);
 8010364:	2110      	movs	r1, #16
 8010366:	6878      	ldr	r0, [r7, #4]
 8010368:	f7ff ffce 	bl	8010308 <rotlFixed>
 801036c:	4603      	mov	r3, r0
}
 801036e:	4618      	mov	r0, r3
 8010370:	3708      	adds	r7, #8
 8010372:	46bd      	mov	sp, r7
 8010374:	bd80      	pop	{r7, pc}

08010376 <ByteReverseWords>:
{
 8010376:	b590      	push	{r4, r7, lr}
 8010378:	b087      	sub	sp, #28
 801037a:	af00      	add	r7, sp, #0
 801037c:	60f8      	str	r0, [r7, #12]
 801037e:	60b9      	str	r1, [r7, #8]
 8010380:	607a      	str	r2, [r7, #4]
    word32 count = byteCount/(word32)sizeof(word32), i;
 8010382:	687b      	ldr	r3, [r7, #4]
 8010384:	089b      	lsrs	r3, r3, #2
 8010386:	613b      	str	r3, [r7, #16]
    for (i = 0; i < count; i++)
 8010388:	2300      	movs	r3, #0
 801038a:	617b      	str	r3, [r7, #20]
 801038c:	e010      	b.n	80103b0 <ByteReverseWords+0x3a>
        out[i] = ByteReverseWord32(in[i]);
 801038e:	697b      	ldr	r3, [r7, #20]
 8010390:	009b      	lsls	r3, r3, #2
 8010392:	68ba      	ldr	r2, [r7, #8]
 8010394:	4413      	add	r3, r2
 8010396:	6819      	ldr	r1, [r3, #0]
 8010398:	697b      	ldr	r3, [r7, #20]
 801039a:	009b      	lsls	r3, r3, #2
 801039c:	68fa      	ldr	r2, [r7, #12]
 801039e:	18d4      	adds	r4, r2, r3
 80103a0:	4608      	mov	r0, r1
 80103a2:	f7ff ffd1 	bl	8010348 <ByteReverseWord32>
 80103a6:	4603      	mov	r3, r0
 80103a8:	6023      	str	r3, [r4, #0]
    for (i = 0; i < count; i++)
 80103aa:	697b      	ldr	r3, [r7, #20]
 80103ac:	3301      	adds	r3, #1
 80103ae:	617b      	str	r3, [r7, #20]
 80103b0:	697a      	ldr	r2, [r7, #20]
 80103b2:	693b      	ldr	r3, [r7, #16]
 80103b4:	429a      	cmp	r2, r3
 80103b6:	d3ea      	bcc.n	801038e <ByteReverseWords+0x18>
}
 80103b8:	bf00      	nop
 80103ba:	371c      	adds	r7, #28
 80103bc:	46bd      	mov	sp, r7
 80103be:	bd90      	pop	{r4, r7, pc}

080103c0 <min>:
    {
 80103c0:	b480      	push	{r7}
 80103c2:	b083      	sub	sp, #12
 80103c4:	af00      	add	r7, sp, #0
 80103c6:	6078      	str	r0, [r7, #4]
 80103c8:	6039      	str	r1, [r7, #0]
        return a > b ? b : a;
 80103ca:	687a      	ldr	r2, [r7, #4]
 80103cc:	683b      	ldr	r3, [r7, #0]
 80103ce:	4293      	cmp	r3, r2
 80103d0:	bf28      	it	cs
 80103d2:	4613      	movcs	r3, r2
    }
 80103d4:	4618      	mov	r0, r3
 80103d6:	370c      	adds	r7, #12
 80103d8:	46bd      	mov	sp, r7
 80103da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80103de:	4770      	bx	lr

080103e0 <InitSha256>:
    (!defined(WOLFSSL_RENESAS_TSIP_CRYPT) || defined(NO_WOLFSSL_RENESAS_TSIP_HASH)) && \
    !defined(WOLFSSL_PSOC6_CRYPTO) && !defined(WOLFSSL_IMXRT_DCP) && !defined(WOLFSSL_SILABS_SE_ACCEL)


static int InitSha256(wc_Sha256* sha256)
{
 80103e0:	b580      	push	{r7, lr}
 80103e2:	b084      	sub	sp, #16
 80103e4:	af00      	add	r7, sp, #0
 80103e6:	6078      	str	r0, [r7, #4]
    int ret = 0;
 80103e8:	2300      	movs	r3, #0
 80103ea:	60fb      	str	r3, [r7, #12]

    if (sha256 == NULL)
 80103ec:	687b      	ldr	r3, [r7, #4]
 80103ee:	2b00      	cmp	r3, #0
 80103f0:	d102      	bne.n	80103f8 <InitSha256+0x18>
        return BAD_FUNC_ARG;
 80103f2:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 80103f6:	e027      	b.n	8010448 <InitSha256+0x68>

    XMEMSET(sha256->digest, 0, sizeof(sha256->digest));
 80103f8:	687b      	ldr	r3, [r7, #4]
 80103fa:	2220      	movs	r2, #32
 80103fc:	2100      	movs	r1, #0
 80103fe:	4618      	mov	r0, r3
 8010400:	f009 f81d 	bl	801943e <memset>
    sha256->digest[0] = 0x6A09E667L;
 8010404:	687b      	ldr	r3, [r7, #4]
 8010406:	4a12      	ldr	r2, [pc, #72]	; (8010450 <InitSha256+0x70>)
 8010408:	601a      	str	r2, [r3, #0]
    sha256->digest[1] = 0xBB67AE85L;
 801040a:	687b      	ldr	r3, [r7, #4]
 801040c:	4a11      	ldr	r2, [pc, #68]	; (8010454 <InitSha256+0x74>)
 801040e:	605a      	str	r2, [r3, #4]
    sha256->digest[2] = 0x3C6EF372L;
 8010410:	687b      	ldr	r3, [r7, #4]
 8010412:	4a11      	ldr	r2, [pc, #68]	; (8010458 <InitSha256+0x78>)
 8010414:	609a      	str	r2, [r3, #8]
    sha256->digest[3] = 0xA54FF53AL;
 8010416:	687b      	ldr	r3, [r7, #4]
 8010418:	4a10      	ldr	r2, [pc, #64]	; (801045c <InitSha256+0x7c>)
 801041a:	60da      	str	r2, [r3, #12]
    sha256->digest[4] = 0x510E527FL;
 801041c:	687b      	ldr	r3, [r7, #4]
 801041e:	4a10      	ldr	r2, [pc, #64]	; (8010460 <InitSha256+0x80>)
 8010420:	611a      	str	r2, [r3, #16]
    sha256->digest[5] = 0x9B05688CL;
 8010422:	687b      	ldr	r3, [r7, #4]
 8010424:	4a0f      	ldr	r2, [pc, #60]	; (8010464 <InitSha256+0x84>)
 8010426:	615a      	str	r2, [r3, #20]
    sha256->digest[6] = 0x1F83D9ABL;
 8010428:	687b      	ldr	r3, [r7, #4]
 801042a:	4a0f      	ldr	r2, [pc, #60]	; (8010468 <InitSha256+0x88>)
 801042c:	619a      	str	r2, [r3, #24]
    sha256->digest[7] = 0x5BE0CD19L;
 801042e:	687b      	ldr	r3, [r7, #4]
 8010430:	4a0e      	ldr	r2, [pc, #56]	; (801046c <InitSha256+0x8c>)
 8010432:	61da      	str	r2, [r3, #28]

    sha256->buffLen = 0;
 8010434:	687b      	ldr	r3, [r7, #4]
 8010436:	2200      	movs	r2, #0
 8010438:	661a      	str	r2, [r3, #96]	; 0x60
    sha256->loLen   = 0;
 801043a:	687b      	ldr	r3, [r7, #4]
 801043c:	2200      	movs	r2, #0
 801043e:	665a      	str	r2, [r3, #100]	; 0x64
    sha256->hiLen   = 0;
 8010440:	687b      	ldr	r3, [r7, #4]
 8010442:	2200      	movs	r2, #0
 8010444:	669a      	str	r2, [r3, #104]	; 0x68
#if defined(WOLFSSL_HASH_FLAGS) || defined(WOLF_CRYPTO_CB)
    sha256->flags = 0;
#endif

    return ret;
 8010446:	68fb      	ldr	r3, [r7, #12]
}
 8010448:	4618      	mov	r0, r3
 801044a:	3710      	adds	r7, #16
 801044c:	46bd      	mov	sp, r7
 801044e:	bd80      	pop	{r7, pc}
 8010450:	6a09e667 	.word	0x6a09e667
 8010454:	bb67ae85 	.word	0xbb67ae85
 8010458:	3c6ef372 	.word	0x3c6ef372
 801045c:	a54ff53a 	.word	0xa54ff53a
 8010460:	510e527f 	.word	0x510e527f
 8010464:	9b05688c 	.word	0x9b05688c
 8010468:	1f83d9ab 	.word	0x1f83d9ab
 801046c:	5be0cd19 	.word	0x5be0cd19

08010470 <wc_InitSha256_ex>:

#else
    #define NEED_SOFT_SHA256

    int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
    {
 8010470:	b580      	push	{r7, lr}
 8010472:	b086      	sub	sp, #24
 8010474:	af00      	add	r7, sp, #0
 8010476:	60f8      	str	r0, [r7, #12]
 8010478:	60b9      	str	r1, [r7, #8]
 801047a:	607a      	str	r2, [r7, #4]
        int ret = 0;
 801047c:	2300      	movs	r3, #0
 801047e:	617b      	str	r3, [r7, #20]
        if (sha256 == NULL)
 8010480:	68fb      	ldr	r3, [r7, #12]
 8010482:	2b00      	cmp	r3, #0
 8010484:	d102      	bne.n	801048c <wc_InitSha256_ex+0x1c>
            return BAD_FUNC_ARG;
 8010486:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 801048a:	e00c      	b.n	80104a6 <wc_InitSha256_ex+0x36>

        sha256->heap = heap;
 801048c:	68fb      	ldr	r3, [r7, #12]
 801048e:	68ba      	ldr	r2, [r7, #8]
 8010490:	66da      	str	r2, [r3, #108]	; 0x6c
    #endif
    #ifdef WOLFSSL_SMALL_STACK_CACHE
        sha256->W = NULL;
    #endif

        ret = InitSha256(sha256);
 8010492:	68f8      	ldr	r0, [r7, #12]
 8010494:	f7ff ffa4 	bl	80103e0 <InitSha256>
 8010498:	6178      	str	r0, [r7, #20]
        if (ret != 0)
 801049a:	697b      	ldr	r3, [r7, #20]
 801049c:	2b00      	cmp	r3, #0
 801049e:	d001      	beq.n	80104a4 <wc_InitSha256_ex+0x34>
            return ret;
 80104a0:	697b      	ldr	r3, [r7, #20]
 80104a2:	e000      	b.n	80104a6 <wc_InitSha256_ex+0x36>
                            WOLFSSL_ASYNC_MARKER_SHA256, sha256->heap, devId);
    #else
        (void)devId;
    #endif /* WOLFSSL_ASYNC_CRYPT */

        return ret;
 80104a4:	697b      	ldr	r3, [r7, #20]
    }
 80104a6:	4618      	mov	r0, r3
 80104a8:	3718      	adds	r7, #24
 80104aa:	46bd      	mov	sp, r7
 80104ac:	bd80      	pop	{r7, pc}
	...

080104b0 <Transform_Sha256>:
         t1 = Sigma0(a(j)) + Maj(a(j), b(j), c(j)); \
         d(j) += t0; \
         h(j)  = t0 + t1

    static int Transform_Sha256(wc_Sha256* sha256, const byte* data)
    {
 80104b0:	b5b0      	push	{r4, r5, r7, lr}
 80104b2:	b090      	sub	sp, #64	; 0x40
 80104b4:	af00      	add	r7, sp, #0
 80104b6:	6078      	str	r0, [r7, #4]
 80104b8:	6039      	str	r1, [r7, #0]
                return MEMORY_E;
            sha256->W = W;
        }
    #elif defined(WOLFSSL_SMALL_STACK)
        word32* W;
        W = (word32*)XMALLOC(sizeof(word32) * WC_SHA256_BLOCK_SIZE, NULL,
 80104ba:	f44f 7080 	mov.w	r0, #256	; 0x100
 80104be:	f7fe fd1b 	bl	800eef8 <wolfSSL_Malloc>
 80104c2:	63b8      	str	r0, [r7, #56]	; 0x38
                                                       DYNAMIC_TYPE_TMP_BUFFER);
        if (W == NULL)
 80104c4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80104c6:	2b00      	cmp	r3, #0
 80104c8:	d102      	bne.n	80104d0 <Transform_Sha256+0x20>
            return MEMORY_E;
 80104ca:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 80104ce:	e360      	b.n	8010b92 <Transform_Sha256+0x6e2>
    #else
        word32 W[WC_SHA256_BLOCK_SIZE];
    #endif

        /* Copy context->state[] to working vars */
        for (i = 0; i < 8; i++)
 80104d0:	2300      	movs	r3, #0
 80104d2:	63fb      	str	r3, [r7, #60]	; 0x3c
 80104d4:	e00d      	b.n	80104f2 <Transform_Sha256+0x42>
            S[i] = sha256->digest[i];
 80104d6:	687b      	ldr	r3, [r7, #4]
 80104d8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80104da:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80104de:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80104e0:	009b      	lsls	r3, r3, #2
 80104e2:	f107 0140 	add.w	r1, r7, #64	; 0x40
 80104e6:	440b      	add	r3, r1
 80104e8:	f843 2c34 	str.w	r2, [r3, #-52]
        for (i = 0; i < 8; i++)
 80104ec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80104ee:	3301      	adds	r3, #1
 80104f0:	63fb      	str	r3, [r7, #60]	; 0x3c
 80104f2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80104f4:	2b07      	cmp	r3, #7
 80104f6:	ddee      	ble.n	80104d6 <Transform_Sha256+0x26>

        for (i = 0; i < 16; i++)
 80104f8:	2300      	movs	r3, #0
 80104fa:	63fb      	str	r3, [r7, #60]	; 0x3c
 80104fc:	e00c      	b.n	8010518 <Transform_Sha256+0x68>
            W[i] = *((word32*)&data[i*sizeof(word32)]);
 80104fe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010500:	009b      	lsls	r3, r3, #2
 8010502:	683a      	ldr	r2, [r7, #0]
 8010504:	441a      	add	r2, r3
 8010506:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010508:	009b      	lsls	r3, r3, #2
 801050a:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 801050c:	440b      	add	r3, r1
 801050e:	6812      	ldr	r2, [r2, #0]
 8010510:	601a      	str	r2, [r3, #0]
        for (i = 0; i < 16; i++)
 8010512:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010514:	3301      	adds	r3, #1
 8010516:	63fb      	str	r3, [r7, #60]	; 0x3c
 8010518:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801051a:	2b0f      	cmp	r3, #15
 801051c:	ddef      	ble.n	80104fe <Transform_Sha256+0x4e>

        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
 801051e:	2310      	movs	r3, #16
 8010520:	63fb      	str	r3, [r7, #60]	; 0x3c
 8010522:	e066      	b.n	80105f2 <Transform_Sha256+0x142>
            W[i] = Gamma1(W[i-2]) + W[i-7] + Gamma0(W[i-15]) + W[i-16];
 8010524:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010526:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 801052a:	3b02      	subs	r3, #2
 801052c:	009b      	lsls	r3, r3, #2
 801052e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8010530:	4413      	add	r3, r2
 8010532:	681b      	ldr	r3, [r3, #0]
 8010534:	2111      	movs	r1, #17
 8010536:	4618      	mov	r0, r3
 8010538:	f7ff fef7 	bl	801032a <rotrFixed>
 801053c:	4604      	mov	r4, r0
 801053e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010540:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8010544:	3b02      	subs	r3, #2
 8010546:	009b      	lsls	r3, r3, #2
 8010548:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801054a:	4413      	add	r3, r2
 801054c:	681b      	ldr	r3, [r3, #0]
 801054e:	2113      	movs	r1, #19
 8010550:	4618      	mov	r0, r3
 8010552:	f7ff feea 	bl	801032a <rotrFixed>
 8010556:	4603      	mov	r3, r0
 8010558:	ea84 0203 	eor.w	r2, r4, r3
 801055c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801055e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8010562:	3b02      	subs	r3, #2
 8010564:	009b      	lsls	r3, r3, #2
 8010566:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8010568:	440b      	add	r3, r1
 801056a:	681b      	ldr	r3, [r3, #0]
 801056c:	0a9b      	lsrs	r3, r3, #10
 801056e:	405a      	eors	r2, r3
 8010570:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010572:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8010576:	3b07      	subs	r3, #7
 8010578:	009b      	lsls	r3, r3, #2
 801057a:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 801057c:	440b      	add	r3, r1
 801057e:	681b      	ldr	r3, [r3, #0]
 8010580:	18d4      	adds	r4, r2, r3
 8010582:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010584:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8010588:	3b0f      	subs	r3, #15
 801058a:	009b      	lsls	r3, r3, #2
 801058c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801058e:	4413      	add	r3, r2
 8010590:	681b      	ldr	r3, [r3, #0]
 8010592:	2107      	movs	r1, #7
 8010594:	4618      	mov	r0, r3
 8010596:	f7ff fec8 	bl	801032a <rotrFixed>
 801059a:	4605      	mov	r5, r0
 801059c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801059e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80105a2:	3b0f      	subs	r3, #15
 80105a4:	009b      	lsls	r3, r3, #2
 80105a6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80105a8:	4413      	add	r3, r2
 80105aa:	681b      	ldr	r3, [r3, #0]
 80105ac:	2112      	movs	r1, #18
 80105ae:	4618      	mov	r0, r3
 80105b0:	f7ff febb 	bl	801032a <rotrFixed>
 80105b4:	4603      	mov	r3, r0
 80105b6:	ea85 0203 	eor.w	r2, r5, r3
 80105ba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80105bc:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80105c0:	3b0f      	subs	r3, #15
 80105c2:	009b      	lsls	r3, r3, #2
 80105c4:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 80105c6:	440b      	add	r3, r1
 80105c8:	681b      	ldr	r3, [r3, #0]
 80105ca:	08db      	lsrs	r3, r3, #3
 80105cc:	4053      	eors	r3, r2
 80105ce:	18e1      	adds	r1, r4, r3
 80105d0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80105d2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80105d6:	3b10      	subs	r3, #16
 80105d8:	009b      	lsls	r3, r3, #2
 80105da:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80105dc:	4413      	add	r3, r2
 80105de:	681a      	ldr	r2, [r3, #0]
 80105e0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80105e2:	009b      	lsls	r3, r3, #2
 80105e4:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80105e6:	4403      	add	r3, r0
 80105e8:	440a      	add	r2, r1
 80105ea:	601a      	str	r2, [r3, #0]
        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
 80105ec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80105ee:	3301      	adds	r3, #1
 80105f0:	63fb      	str	r3, [r7, #60]	; 0x3c
 80105f2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80105f4:	2b3f      	cmp	r3, #63	; 0x3f
 80105f6:	dd95      	ble.n	8010524 <Transform_Sha256+0x74>
                RND(j);
            }
        }
    #else
        /* partially loop unrolled */
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
 80105f8:	2300      	movs	r3, #0
 80105fa:	63fb      	str	r3, [r7, #60]	; 0x3c
 80105fc:	e2a3      	b.n	8010b46 <Transform_Sha256+0x696>
            RND(0); RND(1); RND(2); RND(3);
 80105fe:	6abc      	ldr	r4, [r7, #40]	; 0x28
 8010600:	69fb      	ldr	r3, [r7, #28]
 8010602:	2106      	movs	r1, #6
 8010604:	4618      	mov	r0, r3
 8010606:	f7ff fe90 	bl	801032a <rotrFixed>
 801060a:	4605      	mov	r5, r0
 801060c:	69fb      	ldr	r3, [r7, #28]
 801060e:	210b      	movs	r1, #11
 8010610:	4618      	mov	r0, r3
 8010612:	f7ff fe8a 	bl	801032a <rotrFixed>
 8010616:	4603      	mov	r3, r0
 8010618:	405d      	eors	r5, r3
 801061a:	69fb      	ldr	r3, [r7, #28]
 801061c:	2119      	movs	r1, #25
 801061e:	4618      	mov	r0, r3
 8010620:	f7ff fe83 	bl	801032a <rotrFixed>
 8010624:	4603      	mov	r3, r0
 8010626:	406b      	eors	r3, r5
 8010628:	18e2      	adds	r2, r4, r3
 801062a:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801062c:	69f8      	ldr	r0, [r7, #28]
 801062e:	6a3c      	ldr	r4, [r7, #32]
 8010630:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010632:	4063      	eors	r3, r4
 8010634:	4003      	ands	r3, r0
 8010636:	404b      	eors	r3, r1
 8010638:	441a      	add	r2, r3
 801063a:	49bd      	ldr	r1, [pc, #756]	; (8010930 <Transform_Sha256+0x480>)
 801063c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801063e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010642:	441a      	add	r2, r3
 8010644:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010646:	009b      	lsls	r3, r3, #2
 8010648:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 801064a:	440b      	add	r3, r1
 801064c:	681b      	ldr	r3, [r3, #0]
 801064e:	4413      	add	r3, r2
 8010650:	633b      	str	r3, [r7, #48]	; 0x30
 8010652:	68fb      	ldr	r3, [r7, #12]
 8010654:	2102      	movs	r1, #2
 8010656:	4618      	mov	r0, r3
 8010658:	f7ff fe67 	bl	801032a <rotrFixed>
 801065c:	4604      	mov	r4, r0
 801065e:	68fb      	ldr	r3, [r7, #12]
 8010660:	210d      	movs	r1, #13
 8010662:	4618      	mov	r0, r3
 8010664:	f7ff fe61 	bl	801032a <rotrFixed>
 8010668:	4603      	mov	r3, r0
 801066a:	405c      	eors	r4, r3
 801066c:	68fb      	ldr	r3, [r7, #12]
 801066e:	2116      	movs	r1, #22
 8010670:	4618      	mov	r0, r3
 8010672:	f7ff fe5a 	bl	801032a <rotrFixed>
 8010676:	4603      	mov	r3, r0
 8010678:	ea84 0203 	eor.w	r2, r4, r3
 801067c:	68f9      	ldr	r1, [r7, #12]
 801067e:	693b      	ldr	r3, [r7, #16]
 8010680:	4319      	orrs	r1, r3
 8010682:	697b      	ldr	r3, [r7, #20]
 8010684:	4019      	ands	r1, r3
 8010686:	68f8      	ldr	r0, [r7, #12]
 8010688:	693b      	ldr	r3, [r7, #16]
 801068a:	4003      	ands	r3, r0
 801068c:	430b      	orrs	r3, r1
 801068e:	4413      	add	r3, r2
 8010690:	62fb      	str	r3, [r7, #44]	; 0x2c
 8010692:	69ba      	ldr	r2, [r7, #24]
 8010694:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010696:	4413      	add	r3, r2
 8010698:	61bb      	str	r3, [r7, #24]
 801069a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801069c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801069e:	4413      	add	r3, r2
 80106a0:	62bb      	str	r3, [r7, #40]	; 0x28
 80106a2:	6a7c      	ldr	r4, [r7, #36]	; 0x24
 80106a4:	69bb      	ldr	r3, [r7, #24]
 80106a6:	2106      	movs	r1, #6
 80106a8:	4618      	mov	r0, r3
 80106aa:	f7ff fe3e 	bl	801032a <rotrFixed>
 80106ae:	4605      	mov	r5, r0
 80106b0:	69bb      	ldr	r3, [r7, #24]
 80106b2:	210b      	movs	r1, #11
 80106b4:	4618      	mov	r0, r3
 80106b6:	f7ff fe38 	bl	801032a <rotrFixed>
 80106ba:	4603      	mov	r3, r0
 80106bc:	405d      	eors	r5, r3
 80106be:	69bb      	ldr	r3, [r7, #24]
 80106c0:	2119      	movs	r1, #25
 80106c2:	4618      	mov	r0, r3
 80106c4:	f7ff fe31 	bl	801032a <rotrFixed>
 80106c8:	4603      	mov	r3, r0
 80106ca:	406b      	eors	r3, r5
 80106cc:	18e2      	adds	r2, r4, r3
 80106ce:	6a39      	ldr	r1, [r7, #32]
 80106d0:	69b8      	ldr	r0, [r7, #24]
 80106d2:	69fc      	ldr	r4, [r7, #28]
 80106d4:	6a3b      	ldr	r3, [r7, #32]
 80106d6:	4063      	eors	r3, r4
 80106d8:	4003      	ands	r3, r0
 80106da:	404b      	eors	r3, r1
 80106dc:	441a      	add	r2, r3
 80106de:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80106e0:	3301      	adds	r3, #1
 80106e2:	4993      	ldr	r1, [pc, #588]	; (8010930 <Transform_Sha256+0x480>)
 80106e4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80106e8:	441a      	add	r2, r3
 80106ea:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80106ec:	3301      	adds	r3, #1
 80106ee:	009b      	lsls	r3, r3, #2
 80106f0:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 80106f2:	440b      	add	r3, r1
 80106f4:	681b      	ldr	r3, [r3, #0]
 80106f6:	4413      	add	r3, r2
 80106f8:	633b      	str	r3, [r7, #48]	; 0x30
 80106fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80106fc:	2102      	movs	r1, #2
 80106fe:	4618      	mov	r0, r3
 8010700:	f7ff fe13 	bl	801032a <rotrFixed>
 8010704:	4604      	mov	r4, r0
 8010706:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010708:	210d      	movs	r1, #13
 801070a:	4618      	mov	r0, r3
 801070c:	f7ff fe0d 	bl	801032a <rotrFixed>
 8010710:	4603      	mov	r3, r0
 8010712:	405c      	eors	r4, r3
 8010714:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010716:	2116      	movs	r1, #22
 8010718:	4618      	mov	r0, r3
 801071a:	f7ff fe06 	bl	801032a <rotrFixed>
 801071e:	4603      	mov	r3, r0
 8010720:	ea84 0203 	eor.w	r2, r4, r3
 8010724:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8010726:	68fb      	ldr	r3, [r7, #12]
 8010728:	4319      	orrs	r1, r3
 801072a:	693b      	ldr	r3, [r7, #16]
 801072c:	4019      	ands	r1, r3
 801072e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8010730:	68fb      	ldr	r3, [r7, #12]
 8010732:	4003      	ands	r3, r0
 8010734:	430b      	orrs	r3, r1
 8010736:	4413      	add	r3, r2
 8010738:	62fb      	str	r3, [r7, #44]	; 0x2c
 801073a:	697a      	ldr	r2, [r7, #20]
 801073c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801073e:	4413      	add	r3, r2
 8010740:	617b      	str	r3, [r7, #20]
 8010742:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8010744:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010746:	4413      	add	r3, r2
 8010748:	627b      	str	r3, [r7, #36]	; 0x24
 801074a:	6a3c      	ldr	r4, [r7, #32]
 801074c:	697b      	ldr	r3, [r7, #20]
 801074e:	2106      	movs	r1, #6
 8010750:	4618      	mov	r0, r3
 8010752:	f7ff fdea 	bl	801032a <rotrFixed>
 8010756:	4605      	mov	r5, r0
 8010758:	697b      	ldr	r3, [r7, #20]
 801075a:	210b      	movs	r1, #11
 801075c:	4618      	mov	r0, r3
 801075e:	f7ff fde4 	bl	801032a <rotrFixed>
 8010762:	4603      	mov	r3, r0
 8010764:	405d      	eors	r5, r3
 8010766:	697b      	ldr	r3, [r7, #20]
 8010768:	2119      	movs	r1, #25
 801076a:	4618      	mov	r0, r3
 801076c:	f7ff fddd 	bl	801032a <rotrFixed>
 8010770:	4603      	mov	r3, r0
 8010772:	406b      	eors	r3, r5
 8010774:	18e2      	adds	r2, r4, r3
 8010776:	69f9      	ldr	r1, [r7, #28]
 8010778:	6978      	ldr	r0, [r7, #20]
 801077a:	69bc      	ldr	r4, [r7, #24]
 801077c:	69fb      	ldr	r3, [r7, #28]
 801077e:	4063      	eors	r3, r4
 8010780:	4003      	ands	r3, r0
 8010782:	404b      	eors	r3, r1
 8010784:	441a      	add	r2, r3
 8010786:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010788:	3302      	adds	r3, #2
 801078a:	4969      	ldr	r1, [pc, #420]	; (8010930 <Transform_Sha256+0x480>)
 801078c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010790:	441a      	add	r2, r3
 8010792:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010794:	3302      	adds	r3, #2
 8010796:	009b      	lsls	r3, r3, #2
 8010798:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 801079a:	440b      	add	r3, r1
 801079c:	681b      	ldr	r3, [r3, #0]
 801079e:	4413      	add	r3, r2
 80107a0:	633b      	str	r3, [r7, #48]	; 0x30
 80107a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80107a4:	2102      	movs	r1, #2
 80107a6:	4618      	mov	r0, r3
 80107a8:	f7ff fdbf 	bl	801032a <rotrFixed>
 80107ac:	4604      	mov	r4, r0
 80107ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80107b0:	210d      	movs	r1, #13
 80107b2:	4618      	mov	r0, r3
 80107b4:	f7ff fdb9 	bl	801032a <rotrFixed>
 80107b8:	4603      	mov	r3, r0
 80107ba:	405c      	eors	r4, r3
 80107bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80107be:	2116      	movs	r1, #22
 80107c0:	4618      	mov	r0, r3
 80107c2:	f7ff fdb2 	bl	801032a <rotrFixed>
 80107c6:	4603      	mov	r3, r0
 80107c8:	ea84 0203 	eor.w	r2, r4, r3
 80107cc:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80107ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80107d0:	4319      	orrs	r1, r3
 80107d2:	68fb      	ldr	r3, [r7, #12]
 80107d4:	4019      	ands	r1, r3
 80107d6:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80107d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80107da:	4003      	ands	r3, r0
 80107dc:	430b      	orrs	r3, r1
 80107de:	4413      	add	r3, r2
 80107e0:	62fb      	str	r3, [r7, #44]	; 0x2c
 80107e2:	693a      	ldr	r2, [r7, #16]
 80107e4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80107e6:	4413      	add	r3, r2
 80107e8:	613b      	str	r3, [r7, #16]
 80107ea:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80107ec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80107ee:	4413      	add	r3, r2
 80107f0:	623b      	str	r3, [r7, #32]
 80107f2:	69fc      	ldr	r4, [r7, #28]
 80107f4:	693b      	ldr	r3, [r7, #16]
 80107f6:	2106      	movs	r1, #6
 80107f8:	4618      	mov	r0, r3
 80107fa:	f7ff fd96 	bl	801032a <rotrFixed>
 80107fe:	4605      	mov	r5, r0
 8010800:	693b      	ldr	r3, [r7, #16]
 8010802:	210b      	movs	r1, #11
 8010804:	4618      	mov	r0, r3
 8010806:	f7ff fd90 	bl	801032a <rotrFixed>
 801080a:	4603      	mov	r3, r0
 801080c:	405d      	eors	r5, r3
 801080e:	693b      	ldr	r3, [r7, #16]
 8010810:	2119      	movs	r1, #25
 8010812:	4618      	mov	r0, r3
 8010814:	f7ff fd89 	bl	801032a <rotrFixed>
 8010818:	4603      	mov	r3, r0
 801081a:	406b      	eors	r3, r5
 801081c:	18e2      	adds	r2, r4, r3
 801081e:	69b9      	ldr	r1, [r7, #24]
 8010820:	6938      	ldr	r0, [r7, #16]
 8010822:	697c      	ldr	r4, [r7, #20]
 8010824:	69bb      	ldr	r3, [r7, #24]
 8010826:	4063      	eors	r3, r4
 8010828:	4003      	ands	r3, r0
 801082a:	404b      	eors	r3, r1
 801082c:	441a      	add	r2, r3
 801082e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010830:	3303      	adds	r3, #3
 8010832:	493f      	ldr	r1, [pc, #252]	; (8010930 <Transform_Sha256+0x480>)
 8010834:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010838:	441a      	add	r2, r3
 801083a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801083c:	3303      	adds	r3, #3
 801083e:	009b      	lsls	r3, r3, #2
 8010840:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8010842:	440b      	add	r3, r1
 8010844:	681b      	ldr	r3, [r3, #0]
 8010846:	4413      	add	r3, r2
 8010848:	633b      	str	r3, [r7, #48]	; 0x30
 801084a:	6a3b      	ldr	r3, [r7, #32]
 801084c:	2102      	movs	r1, #2
 801084e:	4618      	mov	r0, r3
 8010850:	f7ff fd6b 	bl	801032a <rotrFixed>
 8010854:	4604      	mov	r4, r0
 8010856:	6a3b      	ldr	r3, [r7, #32]
 8010858:	210d      	movs	r1, #13
 801085a:	4618      	mov	r0, r3
 801085c:	f7ff fd65 	bl	801032a <rotrFixed>
 8010860:	4603      	mov	r3, r0
 8010862:	405c      	eors	r4, r3
 8010864:	6a3b      	ldr	r3, [r7, #32]
 8010866:	2116      	movs	r1, #22
 8010868:	4618      	mov	r0, r3
 801086a:	f7ff fd5e 	bl	801032a <rotrFixed>
 801086e:	4603      	mov	r3, r0
 8010870:	ea84 0203 	eor.w	r2, r4, r3
 8010874:	6a39      	ldr	r1, [r7, #32]
 8010876:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010878:	4319      	orrs	r1, r3
 801087a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801087c:	4019      	ands	r1, r3
 801087e:	6a38      	ldr	r0, [r7, #32]
 8010880:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010882:	4003      	ands	r3, r0
 8010884:	430b      	orrs	r3, r1
 8010886:	4413      	add	r3, r2
 8010888:	62fb      	str	r3, [r7, #44]	; 0x2c
 801088a:	68fa      	ldr	r2, [r7, #12]
 801088c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801088e:	4413      	add	r3, r2
 8010890:	60fb      	str	r3, [r7, #12]
 8010892:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8010894:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010896:	4413      	add	r3, r2
 8010898:	61fb      	str	r3, [r7, #28]
            RND(4); RND(5); RND(6); RND(7);
 801089a:	69bc      	ldr	r4, [r7, #24]
 801089c:	68fb      	ldr	r3, [r7, #12]
 801089e:	2106      	movs	r1, #6
 80108a0:	4618      	mov	r0, r3
 80108a2:	f7ff fd42 	bl	801032a <rotrFixed>
 80108a6:	4605      	mov	r5, r0
 80108a8:	68fb      	ldr	r3, [r7, #12]
 80108aa:	210b      	movs	r1, #11
 80108ac:	4618      	mov	r0, r3
 80108ae:	f7ff fd3c 	bl	801032a <rotrFixed>
 80108b2:	4603      	mov	r3, r0
 80108b4:	405d      	eors	r5, r3
 80108b6:	68fb      	ldr	r3, [r7, #12]
 80108b8:	2119      	movs	r1, #25
 80108ba:	4618      	mov	r0, r3
 80108bc:	f7ff fd35 	bl	801032a <rotrFixed>
 80108c0:	4603      	mov	r3, r0
 80108c2:	406b      	eors	r3, r5
 80108c4:	18e2      	adds	r2, r4, r3
 80108c6:	6979      	ldr	r1, [r7, #20]
 80108c8:	68f8      	ldr	r0, [r7, #12]
 80108ca:	693c      	ldr	r4, [r7, #16]
 80108cc:	697b      	ldr	r3, [r7, #20]
 80108ce:	4063      	eors	r3, r4
 80108d0:	4003      	ands	r3, r0
 80108d2:	404b      	eors	r3, r1
 80108d4:	441a      	add	r2, r3
 80108d6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80108d8:	3304      	adds	r3, #4
 80108da:	4915      	ldr	r1, [pc, #84]	; (8010930 <Transform_Sha256+0x480>)
 80108dc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80108e0:	441a      	add	r2, r3
 80108e2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80108e4:	3304      	adds	r3, #4
 80108e6:	009b      	lsls	r3, r3, #2
 80108e8:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 80108ea:	440b      	add	r3, r1
 80108ec:	681b      	ldr	r3, [r3, #0]
 80108ee:	4413      	add	r3, r2
 80108f0:	633b      	str	r3, [r7, #48]	; 0x30
 80108f2:	69fb      	ldr	r3, [r7, #28]
 80108f4:	2102      	movs	r1, #2
 80108f6:	4618      	mov	r0, r3
 80108f8:	f7ff fd17 	bl	801032a <rotrFixed>
 80108fc:	4604      	mov	r4, r0
 80108fe:	69fb      	ldr	r3, [r7, #28]
 8010900:	210d      	movs	r1, #13
 8010902:	4618      	mov	r0, r3
 8010904:	f7ff fd11 	bl	801032a <rotrFixed>
 8010908:	4603      	mov	r3, r0
 801090a:	405c      	eors	r4, r3
 801090c:	69fb      	ldr	r3, [r7, #28]
 801090e:	2116      	movs	r1, #22
 8010910:	4618      	mov	r0, r3
 8010912:	f7ff fd0a 	bl	801032a <rotrFixed>
 8010916:	4603      	mov	r3, r0
 8010918:	ea84 0203 	eor.w	r2, r4, r3
 801091c:	69f9      	ldr	r1, [r7, #28]
 801091e:	6a3b      	ldr	r3, [r7, #32]
 8010920:	4319      	orrs	r1, r3
 8010922:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010924:	4019      	ands	r1, r3
 8010926:	69f8      	ldr	r0, [r7, #28]
 8010928:	6a3b      	ldr	r3, [r7, #32]
 801092a:	4003      	ands	r3, r0
 801092c:	430b      	orrs	r3, r1
 801092e:	e001      	b.n	8010934 <Transform_Sha256+0x484>
 8010930:	0801adf4 	.word	0x0801adf4
 8010934:	4413      	add	r3, r2
 8010936:	62fb      	str	r3, [r7, #44]	; 0x2c
 8010938:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801093a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801093c:	4413      	add	r3, r2
 801093e:	62bb      	str	r3, [r7, #40]	; 0x28
 8010940:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8010942:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010944:	4413      	add	r3, r2
 8010946:	61bb      	str	r3, [r7, #24]
 8010948:	697c      	ldr	r4, [r7, #20]
 801094a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801094c:	2106      	movs	r1, #6
 801094e:	4618      	mov	r0, r3
 8010950:	f7ff fceb 	bl	801032a <rotrFixed>
 8010954:	4605      	mov	r5, r0
 8010956:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010958:	210b      	movs	r1, #11
 801095a:	4618      	mov	r0, r3
 801095c:	f7ff fce5 	bl	801032a <rotrFixed>
 8010960:	4603      	mov	r3, r0
 8010962:	405d      	eors	r5, r3
 8010964:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010966:	2119      	movs	r1, #25
 8010968:	4618      	mov	r0, r3
 801096a:	f7ff fcde 	bl	801032a <rotrFixed>
 801096e:	4603      	mov	r3, r0
 8010970:	406b      	eors	r3, r5
 8010972:	18e2      	adds	r2, r4, r3
 8010974:	6939      	ldr	r1, [r7, #16]
 8010976:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8010978:	68fc      	ldr	r4, [r7, #12]
 801097a:	693b      	ldr	r3, [r7, #16]
 801097c:	4063      	eors	r3, r4
 801097e:	4003      	ands	r3, r0
 8010980:	404b      	eors	r3, r1
 8010982:	441a      	add	r2, r3
 8010984:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010986:	3305      	adds	r3, #5
 8010988:	4984      	ldr	r1, [pc, #528]	; (8010b9c <Transform_Sha256+0x6ec>)
 801098a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801098e:	441a      	add	r2, r3
 8010990:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010992:	3305      	adds	r3, #5
 8010994:	009b      	lsls	r3, r3, #2
 8010996:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8010998:	440b      	add	r3, r1
 801099a:	681b      	ldr	r3, [r3, #0]
 801099c:	4413      	add	r3, r2
 801099e:	633b      	str	r3, [r7, #48]	; 0x30
 80109a0:	69bb      	ldr	r3, [r7, #24]
 80109a2:	2102      	movs	r1, #2
 80109a4:	4618      	mov	r0, r3
 80109a6:	f7ff fcc0 	bl	801032a <rotrFixed>
 80109aa:	4604      	mov	r4, r0
 80109ac:	69bb      	ldr	r3, [r7, #24]
 80109ae:	210d      	movs	r1, #13
 80109b0:	4618      	mov	r0, r3
 80109b2:	f7ff fcba 	bl	801032a <rotrFixed>
 80109b6:	4603      	mov	r3, r0
 80109b8:	405c      	eors	r4, r3
 80109ba:	69bb      	ldr	r3, [r7, #24]
 80109bc:	2116      	movs	r1, #22
 80109be:	4618      	mov	r0, r3
 80109c0:	f7ff fcb3 	bl	801032a <rotrFixed>
 80109c4:	4603      	mov	r3, r0
 80109c6:	ea84 0203 	eor.w	r2, r4, r3
 80109ca:	69b9      	ldr	r1, [r7, #24]
 80109cc:	69fb      	ldr	r3, [r7, #28]
 80109ce:	4319      	orrs	r1, r3
 80109d0:	6a3b      	ldr	r3, [r7, #32]
 80109d2:	4019      	ands	r1, r3
 80109d4:	69b8      	ldr	r0, [r7, #24]
 80109d6:	69fb      	ldr	r3, [r7, #28]
 80109d8:	4003      	ands	r3, r0
 80109da:	430b      	orrs	r3, r1
 80109dc:	4413      	add	r3, r2
 80109de:	62fb      	str	r3, [r7, #44]	; 0x2c
 80109e0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80109e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80109e4:	4413      	add	r3, r2
 80109e6:	627b      	str	r3, [r7, #36]	; 0x24
 80109e8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80109ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80109ec:	4413      	add	r3, r2
 80109ee:	617b      	str	r3, [r7, #20]
 80109f0:	693c      	ldr	r4, [r7, #16]
 80109f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80109f4:	2106      	movs	r1, #6
 80109f6:	4618      	mov	r0, r3
 80109f8:	f7ff fc97 	bl	801032a <rotrFixed>
 80109fc:	4605      	mov	r5, r0
 80109fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010a00:	210b      	movs	r1, #11
 8010a02:	4618      	mov	r0, r3
 8010a04:	f7ff fc91 	bl	801032a <rotrFixed>
 8010a08:	4603      	mov	r3, r0
 8010a0a:	405d      	eors	r5, r3
 8010a0c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010a0e:	2119      	movs	r1, #25
 8010a10:	4618      	mov	r0, r3
 8010a12:	f7ff fc8a 	bl	801032a <rotrFixed>
 8010a16:	4603      	mov	r3, r0
 8010a18:	406b      	eors	r3, r5
 8010a1a:	18e2      	adds	r2, r4, r3
 8010a1c:	68f9      	ldr	r1, [r7, #12]
 8010a1e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010a20:	6abc      	ldr	r4, [r7, #40]	; 0x28
 8010a22:	68fb      	ldr	r3, [r7, #12]
 8010a24:	4063      	eors	r3, r4
 8010a26:	4003      	ands	r3, r0
 8010a28:	404b      	eors	r3, r1
 8010a2a:	441a      	add	r2, r3
 8010a2c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010a2e:	3306      	adds	r3, #6
 8010a30:	495a      	ldr	r1, [pc, #360]	; (8010b9c <Transform_Sha256+0x6ec>)
 8010a32:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010a36:	441a      	add	r2, r3
 8010a38:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010a3a:	3306      	adds	r3, #6
 8010a3c:	009b      	lsls	r3, r3, #2
 8010a3e:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8010a40:	440b      	add	r3, r1
 8010a42:	681b      	ldr	r3, [r3, #0]
 8010a44:	4413      	add	r3, r2
 8010a46:	633b      	str	r3, [r7, #48]	; 0x30
 8010a48:	697b      	ldr	r3, [r7, #20]
 8010a4a:	2102      	movs	r1, #2
 8010a4c:	4618      	mov	r0, r3
 8010a4e:	f7ff fc6c 	bl	801032a <rotrFixed>
 8010a52:	4604      	mov	r4, r0
 8010a54:	697b      	ldr	r3, [r7, #20]
 8010a56:	210d      	movs	r1, #13
 8010a58:	4618      	mov	r0, r3
 8010a5a:	f7ff fc66 	bl	801032a <rotrFixed>
 8010a5e:	4603      	mov	r3, r0
 8010a60:	405c      	eors	r4, r3
 8010a62:	697b      	ldr	r3, [r7, #20]
 8010a64:	2116      	movs	r1, #22
 8010a66:	4618      	mov	r0, r3
 8010a68:	f7ff fc5f 	bl	801032a <rotrFixed>
 8010a6c:	4603      	mov	r3, r0
 8010a6e:	ea84 0203 	eor.w	r2, r4, r3
 8010a72:	6979      	ldr	r1, [r7, #20]
 8010a74:	69bb      	ldr	r3, [r7, #24]
 8010a76:	4319      	orrs	r1, r3
 8010a78:	69fb      	ldr	r3, [r7, #28]
 8010a7a:	4019      	ands	r1, r3
 8010a7c:	6978      	ldr	r0, [r7, #20]
 8010a7e:	69bb      	ldr	r3, [r7, #24]
 8010a80:	4003      	ands	r3, r0
 8010a82:	430b      	orrs	r3, r1
 8010a84:	4413      	add	r3, r2
 8010a86:	62fb      	str	r3, [r7, #44]	; 0x2c
 8010a88:	6a3a      	ldr	r2, [r7, #32]
 8010a8a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010a8c:	4413      	add	r3, r2
 8010a8e:	623b      	str	r3, [r7, #32]
 8010a90:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8010a92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010a94:	4413      	add	r3, r2
 8010a96:	613b      	str	r3, [r7, #16]
 8010a98:	68fc      	ldr	r4, [r7, #12]
 8010a9a:	6a3b      	ldr	r3, [r7, #32]
 8010a9c:	2106      	movs	r1, #6
 8010a9e:	4618      	mov	r0, r3
 8010aa0:	f7ff fc43 	bl	801032a <rotrFixed>
 8010aa4:	4605      	mov	r5, r0
 8010aa6:	6a3b      	ldr	r3, [r7, #32]
 8010aa8:	210b      	movs	r1, #11
 8010aaa:	4618      	mov	r0, r3
 8010aac:	f7ff fc3d 	bl	801032a <rotrFixed>
 8010ab0:	4603      	mov	r3, r0
 8010ab2:	405d      	eors	r5, r3
 8010ab4:	6a3b      	ldr	r3, [r7, #32]
 8010ab6:	2119      	movs	r1, #25
 8010ab8:	4618      	mov	r0, r3
 8010aba:	f7ff fc36 	bl	801032a <rotrFixed>
 8010abe:	4603      	mov	r3, r0
 8010ac0:	406b      	eors	r3, r5
 8010ac2:	18e2      	adds	r2, r4, r3
 8010ac4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8010ac6:	6a38      	ldr	r0, [r7, #32]
 8010ac8:	6a7c      	ldr	r4, [r7, #36]	; 0x24
 8010aca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010acc:	4063      	eors	r3, r4
 8010ace:	4003      	ands	r3, r0
 8010ad0:	404b      	eors	r3, r1
 8010ad2:	441a      	add	r2, r3
 8010ad4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010ad6:	3307      	adds	r3, #7
 8010ad8:	4930      	ldr	r1, [pc, #192]	; (8010b9c <Transform_Sha256+0x6ec>)
 8010ada:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010ade:	441a      	add	r2, r3
 8010ae0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010ae2:	3307      	adds	r3, #7
 8010ae4:	009b      	lsls	r3, r3, #2
 8010ae6:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8010ae8:	440b      	add	r3, r1
 8010aea:	681b      	ldr	r3, [r3, #0]
 8010aec:	4413      	add	r3, r2
 8010aee:	633b      	str	r3, [r7, #48]	; 0x30
 8010af0:	693b      	ldr	r3, [r7, #16]
 8010af2:	2102      	movs	r1, #2
 8010af4:	4618      	mov	r0, r3
 8010af6:	f7ff fc18 	bl	801032a <rotrFixed>
 8010afa:	4604      	mov	r4, r0
 8010afc:	693b      	ldr	r3, [r7, #16]
 8010afe:	210d      	movs	r1, #13
 8010b00:	4618      	mov	r0, r3
 8010b02:	f7ff fc12 	bl	801032a <rotrFixed>
 8010b06:	4603      	mov	r3, r0
 8010b08:	405c      	eors	r4, r3
 8010b0a:	693b      	ldr	r3, [r7, #16]
 8010b0c:	2116      	movs	r1, #22
 8010b0e:	4618      	mov	r0, r3
 8010b10:	f7ff fc0b 	bl	801032a <rotrFixed>
 8010b14:	4603      	mov	r3, r0
 8010b16:	ea84 0203 	eor.w	r2, r4, r3
 8010b1a:	6939      	ldr	r1, [r7, #16]
 8010b1c:	697b      	ldr	r3, [r7, #20]
 8010b1e:	4319      	orrs	r1, r3
 8010b20:	69bb      	ldr	r3, [r7, #24]
 8010b22:	4019      	ands	r1, r3
 8010b24:	6938      	ldr	r0, [r7, #16]
 8010b26:	697b      	ldr	r3, [r7, #20]
 8010b28:	4003      	ands	r3, r0
 8010b2a:	430b      	orrs	r3, r1
 8010b2c:	4413      	add	r3, r2
 8010b2e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8010b30:	69fa      	ldr	r2, [r7, #28]
 8010b32:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010b34:	4413      	add	r3, r2
 8010b36:	61fb      	str	r3, [r7, #28]
 8010b38:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8010b3a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010b3c:	4413      	add	r3, r2
 8010b3e:	60fb      	str	r3, [r7, #12]
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
 8010b40:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010b42:	3308      	adds	r3, #8
 8010b44:	63fb      	str	r3, [r7, #60]	; 0x3c
 8010b46:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010b48:	2b3f      	cmp	r3, #63	; 0x3f
 8010b4a:	f77f ad58 	ble.w	80105fe <Transform_Sha256+0x14e>
        }
    #endif /* USE_SLOW_SHA256 */

        /* Add the working vars back into digest state[] */
        for (i = 0; i < 8; i++) {
 8010b4e:	2300      	movs	r3, #0
 8010b50:	63fb      	str	r3, [r7, #60]	; 0x3c
 8010b52:	e012      	b.n	8010b7a <Transform_Sha256+0x6ca>
            sha256->digest[i] += S[i];
 8010b54:	687b      	ldr	r3, [r7, #4]
 8010b56:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010b58:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010b5c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010b5e:	009b      	lsls	r3, r3, #2
 8010b60:	f107 0140 	add.w	r1, r7, #64	; 0x40
 8010b64:	440b      	add	r3, r1
 8010b66:	f853 3c34 	ldr.w	r3, [r3, #-52]
 8010b6a:	18d1      	adds	r1, r2, r3
 8010b6c:	687b      	ldr	r3, [r7, #4]
 8010b6e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010b70:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i = 0; i < 8; i++) {
 8010b74:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010b76:	3301      	adds	r3, #1
 8010b78:	63fb      	str	r3, [r7, #60]	; 0x3c
 8010b7a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010b7c:	2b07      	cmp	r3, #7
 8010b7e:	dde9      	ble.n	8010b54 <Transform_Sha256+0x6a4>
        }

    #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SMALL_STACK_CACHE)
        XFREE(W, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8010b80:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010b82:	637b      	str	r3, [r7, #52]	; 0x34
 8010b84:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010b86:	2b00      	cmp	r3, #0
 8010b88:	d002      	beq.n	8010b90 <Transform_Sha256+0x6e0>
 8010b8a:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8010b8c:	f7fe f9d0 	bl	800ef30 <wolfSSL_Free>
    #endif
        return 0;
 8010b90:	2300      	movs	r3, #0
    }
 8010b92:	4618      	mov	r0, r3
 8010b94:	3740      	adds	r7, #64	; 0x40
 8010b96:	46bd      	mov	sp, r7
 8010b98:	bdb0      	pop	{r4, r5, r7, pc}
 8010b9a:	bf00      	nop
 8010b9c:	0801adf4 	.word	0x0801adf4

08010ba0 <AddLength>:


#ifdef XTRANSFORM

    static WC_INLINE void AddLength(wc_Sha256* sha256, word32 len)
    {
 8010ba0:	b480      	push	{r7}
 8010ba2:	b085      	sub	sp, #20
 8010ba4:	af00      	add	r7, sp, #0
 8010ba6:	6078      	str	r0, [r7, #4]
 8010ba8:	6039      	str	r1, [r7, #0]
        word32 tmp = sha256->loLen;
 8010baa:	687b      	ldr	r3, [r7, #4]
 8010bac:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8010bae:	60fb      	str	r3, [r7, #12]
        if ((sha256->loLen += len) < tmp) {
 8010bb0:	687b      	ldr	r3, [r7, #4]
 8010bb2:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8010bb4:	683b      	ldr	r3, [r7, #0]
 8010bb6:	441a      	add	r2, r3
 8010bb8:	687b      	ldr	r3, [r7, #4]
 8010bba:	665a      	str	r2, [r3, #100]	; 0x64
 8010bbc:	687b      	ldr	r3, [r7, #4]
 8010bbe:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8010bc0:	68fa      	ldr	r2, [r7, #12]
 8010bc2:	429a      	cmp	r2, r3
 8010bc4:	d904      	bls.n	8010bd0 <AddLength+0x30>
            sha256->hiLen++;                       /* carry low to high */
 8010bc6:	687b      	ldr	r3, [r7, #4]
 8010bc8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8010bca:	1c5a      	adds	r2, r3, #1
 8010bcc:	687b      	ldr	r3, [r7, #4]
 8010bce:	669a      	str	r2, [r3, #104]	; 0x68
        }
    }
 8010bd0:	bf00      	nop
 8010bd2:	3714      	adds	r7, #20
 8010bd4:	46bd      	mov	sp, r7
 8010bd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010bda:	4770      	bx	lr

08010bdc <Sha256Update>:

    /* do block size increments/updates */
    static WC_INLINE int Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)
    {
 8010bdc:	b580      	push	{r7, lr}
 8010bde:	b088      	sub	sp, #32
 8010be0:	af00      	add	r7, sp, #0
 8010be2:	60f8      	str	r0, [r7, #12]
 8010be4:	60b9      	str	r1, [r7, #8]
 8010be6:	607a      	str	r2, [r7, #4]
        int ret = 0;
 8010be8:	2300      	movs	r3, #0
 8010bea:	61fb      	str	r3, [r7, #28]
        word32 blocksLen;
        byte* local;

        if (sha256 == NULL || (data == NULL && len > 0)) {
 8010bec:	68fb      	ldr	r3, [r7, #12]
 8010bee:	2b00      	cmp	r3, #0
 8010bf0:	d005      	beq.n	8010bfe <Sha256Update+0x22>
 8010bf2:	68bb      	ldr	r3, [r7, #8]
 8010bf4:	2b00      	cmp	r3, #0
 8010bf6:	d105      	bne.n	8010c04 <Sha256Update+0x28>
 8010bf8:	687b      	ldr	r3, [r7, #4]
 8010bfa:	2b00      	cmp	r3, #0
 8010bfc:	d002      	beq.n	8010c04 <Sha256Update+0x28>
            return BAD_FUNC_ARG;
 8010bfe:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8010c02:	e081      	b.n	8010d08 <Sha256Update+0x12c>
        }

        if (data == NULL && len == 0) {
 8010c04:	68bb      	ldr	r3, [r7, #8]
 8010c06:	2b00      	cmp	r3, #0
 8010c08:	d104      	bne.n	8010c14 <Sha256Update+0x38>
 8010c0a:	687b      	ldr	r3, [r7, #4]
 8010c0c:	2b00      	cmp	r3, #0
 8010c0e:	d101      	bne.n	8010c14 <Sha256Update+0x38>
            /* valid, but do nothing */
            return 0;
 8010c10:	2300      	movs	r3, #0
 8010c12:	e079      	b.n	8010d08 <Sha256Update+0x12c>
        }

        /* check that internal buffLen is valid */
        if (sha256->buffLen >= WC_SHA256_BLOCK_SIZE) {
 8010c14:	68fb      	ldr	r3, [r7, #12]
 8010c16:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010c18:	2b3f      	cmp	r3, #63	; 0x3f
 8010c1a:	d902      	bls.n	8010c22 <Sha256Update+0x46>
            return BUFFER_E;
 8010c1c:	f06f 0383 	mvn.w	r3, #131	; 0x83
 8010c20:	e072      	b.n	8010d08 <Sha256Update+0x12c>
        }

        /* add length for final */
        AddLength(sha256, len);
 8010c22:	6879      	ldr	r1, [r7, #4]
 8010c24:	68f8      	ldr	r0, [r7, #12]
 8010c26:	f7ff ffbb 	bl	8010ba0 <AddLength>

        local = (byte*)sha256->buffer;
 8010c2a:	68fb      	ldr	r3, [r7, #12]
 8010c2c:	3320      	adds	r3, #32
 8010c2e:	61bb      	str	r3, [r7, #24]

        /* process any remainder from previous operation */
        if (sha256->buffLen > 0) {
 8010c30:	68fb      	ldr	r3, [r7, #12]
 8010c32:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010c34:	2b00      	cmp	r3, #0
 8010c36:	d056      	beq.n	8010ce6 <Sha256Update+0x10a>
            blocksLen = min(len, WC_SHA256_BLOCK_SIZE - sha256->buffLen);
 8010c38:	68fb      	ldr	r3, [r7, #12]
 8010c3a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010c3c:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 8010c40:	4619      	mov	r1, r3
 8010c42:	6878      	ldr	r0, [r7, #4]
 8010c44:	f7ff fbbc 	bl	80103c0 <min>
 8010c48:	6178      	str	r0, [r7, #20]
            XMEMCPY(&local[sha256->buffLen], data, blocksLen);
 8010c4a:	68fb      	ldr	r3, [r7, #12]
 8010c4c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010c4e:	69ba      	ldr	r2, [r7, #24]
 8010c50:	4413      	add	r3, r2
 8010c52:	697a      	ldr	r2, [r7, #20]
 8010c54:	68b9      	ldr	r1, [r7, #8]
 8010c56:	4618      	mov	r0, r3
 8010c58:	f008 fbcd 	bl	80193f6 <memcpy>

            sha256->buffLen += blocksLen;
 8010c5c:	68fb      	ldr	r3, [r7, #12]
 8010c5e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8010c60:	697b      	ldr	r3, [r7, #20]
 8010c62:	441a      	add	r2, r3
 8010c64:	68fb      	ldr	r3, [r7, #12]
 8010c66:	661a      	str	r2, [r3, #96]	; 0x60
            data            += blocksLen;
 8010c68:	68ba      	ldr	r2, [r7, #8]
 8010c6a:	697b      	ldr	r3, [r7, #20]
 8010c6c:	4413      	add	r3, r2
 8010c6e:	60bb      	str	r3, [r7, #8]
            len             -= blocksLen;
 8010c70:	687a      	ldr	r2, [r7, #4]
 8010c72:	697b      	ldr	r3, [r7, #20]
 8010c74:	1ad3      	subs	r3, r2, r3
 8010c76:	607b      	str	r3, [r7, #4]

            if (sha256->buffLen == WC_SHA256_BLOCK_SIZE) {
 8010c78:	68fb      	ldr	r3, [r7, #12]
 8010c7a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010c7c:	2b40      	cmp	r3, #64	; 0x40
 8010c7e:	d132      	bne.n	8010ce6 <Sha256Update+0x10a>
                #if defined(USE_INTEL_SPEEDUP) && \
                          (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
                if (!IS_INTEL_AVX1(intel_flags) && !IS_INTEL_AVX2(intel_flags))
                #endif
                {
                    ByteReverseWords(sha256->buffer, sha256->buffer,
 8010c80:	68fb      	ldr	r3, [r7, #12]
 8010c82:	f103 0020 	add.w	r0, r3, #32
 8010c86:	68fb      	ldr	r3, [r7, #12]
 8010c88:	3320      	adds	r3, #32
 8010c8a:	2240      	movs	r2, #64	; 0x40
 8010c8c:	4619      	mov	r1, r3
 8010c8e:	f7ff fb72 	bl	8010376 <ByteReverseWords>
                    ret = XTRANSFORM(sha256, (const byte*)local);
                } else {
                    esp_sha256_process(sha256, (const byte*)local);
                }
            #else
                ret = XTRANSFORM(sha256, (const byte*)local);
 8010c92:	69b9      	ldr	r1, [r7, #24]
 8010c94:	68f8      	ldr	r0, [r7, #12]
 8010c96:	f7ff fc0b 	bl	80104b0 <Transform_Sha256>
 8010c9a:	61f8      	str	r0, [r7, #28]
            #endif

                if (ret == 0)
 8010c9c:	69fb      	ldr	r3, [r7, #28]
 8010c9e:	2b00      	cmp	r3, #0
 8010ca0:	d103      	bne.n	8010caa <Sha256Update+0xce>
                    sha256->buffLen = 0;
 8010ca2:	68fb      	ldr	r3, [r7, #12]
 8010ca4:	2200      	movs	r2, #0
 8010ca6:	661a      	str	r2, [r3, #96]	; 0x60
 8010ca8:	e01d      	b.n	8010ce6 <Sha256Update+0x10a>
                else
                    len = 0; /* error */
 8010caa:	2300      	movs	r3, #0
 8010cac:	607b      	str	r3, [r7, #4]
        #endif
    #endif /* XTRANSFORM_LEN */
    #if !defined(XTRANSFORM_LEN) || (defined(USE_INTEL_SPEEDUP) && \
                         (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2)))
        {
            while (len >= WC_SHA256_BLOCK_SIZE) {
 8010cae:	e01a      	b.n	8010ce6 <Sha256Update+0x10a>
                word32* local32 = sha256->buffer;
 8010cb0:	68fb      	ldr	r3, [r7, #12]
 8010cb2:	3320      	adds	r3, #32
 8010cb4:	613b      	str	r3, [r7, #16]
                    local32 = (word32*)data;
                }
                else
            #endif
                {
                    XMEMCPY(local32, data, WC_SHA256_BLOCK_SIZE);
 8010cb6:	2240      	movs	r2, #64	; 0x40
 8010cb8:	68b9      	ldr	r1, [r7, #8]
 8010cba:	6938      	ldr	r0, [r7, #16]
 8010cbc:	f008 fb9b 	bl	80193f6 <memcpy>
                }

                data += WC_SHA256_BLOCK_SIZE;
 8010cc0:	68bb      	ldr	r3, [r7, #8]
 8010cc2:	3340      	adds	r3, #64	; 0x40
 8010cc4:	60bb      	str	r3, [r7, #8]
                len  -= WC_SHA256_BLOCK_SIZE;
 8010cc6:	687b      	ldr	r3, [r7, #4]
 8010cc8:	3b40      	subs	r3, #64	; 0x40
 8010cca:	607b      	str	r3, [r7, #4]
                #if defined(USE_INTEL_SPEEDUP) && \
                          (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
                if (!IS_INTEL_AVX1(intel_flags) && !IS_INTEL_AVX2(intel_flags))
                #endif
                {
                    ByteReverseWords(local32, local32, WC_SHA256_BLOCK_SIZE);
 8010ccc:	2240      	movs	r2, #64	; 0x40
 8010cce:	6939      	ldr	r1, [r7, #16]
 8010cd0:	6938      	ldr	r0, [r7, #16]
 8010cd2:	f7ff fb50 	bl	8010376 <ByteReverseWords>
                    ret = XTRANSFORM(sha256, (const byte*)local32);
                } else {
                    esp_sha256_process(sha256, (const byte*)local32);
                }
            #else
                ret = XTRANSFORM(sha256, (const byte*)local32);
 8010cd6:	6939      	ldr	r1, [r7, #16]
 8010cd8:	68f8      	ldr	r0, [r7, #12]
 8010cda:	f7ff fbe9 	bl	80104b0 <Transform_Sha256>
 8010cde:	61f8      	str	r0, [r7, #28]
            #endif

                if (ret != 0)
 8010ce0:	69fb      	ldr	r3, [r7, #28]
 8010ce2:	2b00      	cmp	r3, #0
 8010ce4:	d103      	bne.n	8010cee <Sha256Update+0x112>
            while (len >= WC_SHA256_BLOCK_SIZE) {
 8010ce6:	687b      	ldr	r3, [r7, #4]
 8010ce8:	2b3f      	cmp	r3, #63	; 0x3f
 8010cea:	d8e1      	bhi.n	8010cb0 <Sha256Update+0xd4>
 8010cec:	e000      	b.n	8010cf0 <Sha256Update+0x114>
                    break;
 8010cee:	bf00      	nop
            }
        }
    #endif

        /* save remainder */
        if (len > 0) {
 8010cf0:	687b      	ldr	r3, [r7, #4]
 8010cf2:	2b00      	cmp	r3, #0
 8010cf4:	d007      	beq.n	8010d06 <Sha256Update+0x12a>
            XMEMCPY(local, data, len);
 8010cf6:	687a      	ldr	r2, [r7, #4]
 8010cf8:	68b9      	ldr	r1, [r7, #8]
 8010cfa:	69b8      	ldr	r0, [r7, #24]
 8010cfc:	f008 fb7b 	bl	80193f6 <memcpy>
            sha256->buffLen = len;
 8010d00:	68fb      	ldr	r3, [r7, #12]
 8010d02:	687a      	ldr	r2, [r7, #4]
 8010d04:	661a      	str	r2, [r3, #96]	; 0x60
        }

        return ret;
 8010d06:	69fb      	ldr	r3, [r7, #28]
    }
 8010d08:	4618      	mov	r0, r3
 8010d0a:	3720      	adds	r7, #32
 8010d0c:	46bd      	mov	sp, r7
 8010d0e:	bd80      	pop	{r7, pc}

08010d10 <wc_Sha256Update>:

    int wc_Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)
    {
 8010d10:	b580      	push	{r7, lr}
 8010d12:	b084      	sub	sp, #16
 8010d14:	af00      	add	r7, sp, #0
 8010d16:	60f8      	str	r0, [r7, #12]
 8010d18:	60b9      	str	r1, [r7, #8]
 8010d1a:	607a      	str	r2, [r7, #4]
        if (sha256 == NULL || (data == NULL && len > 0)) {
 8010d1c:	68fb      	ldr	r3, [r7, #12]
 8010d1e:	2b00      	cmp	r3, #0
 8010d20:	d005      	beq.n	8010d2e <wc_Sha256Update+0x1e>
 8010d22:	68bb      	ldr	r3, [r7, #8]
 8010d24:	2b00      	cmp	r3, #0
 8010d26:	d105      	bne.n	8010d34 <wc_Sha256Update+0x24>
 8010d28:	687b      	ldr	r3, [r7, #4]
 8010d2a:	2b00      	cmp	r3, #0
 8010d2c:	d002      	beq.n	8010d34 <wc_Sha256Update+0x24>
            return BAD_FUNC_ARG;
 8010d2e:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8010d32:	e00d      	b.n	8010d50 <wc_Sha256Update+0x40>
        }

        if (data == NULL && len == 0) {
 8010d34:	68bb      	ldr	r3, [r7, #8]
 8010d36:	2b00      	cmp	r3, #0
 8010d38:	d104      	bne.n	8010d44 <wc_Sha256Update+0x34>
 8010d3a:	687b      	ldr	r3, [r7, #4]
 8010d3c:	2b00      	cmp	r3, #0
 8010d3e:	d101      	bne.n	8010d44 <wc_Sha256Update+0x34>
            /* valid, but do nothing */
            return 0;
 8010d40:	2300      	movs	r3, #0
 8010d42:	e005      	b.n	8010d50 <wc_Sha256Update+0x40>
            return IntelQaSymSha256(&sha256->asyncDev, NULL, data, len);
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        return Sha256Update(sha256, data, len);
 8010d44:	687a      	ldr	r2, [r7, #4]
 8010d46:	68b9      	ldr	r1, [r7, #8]
 8010d48:	68f8      	ldr	r0, [r7, #12]
 8010d4a:	f7ff ff47 	bl	8010bdc <Sha256Update>
 8010d4e:	4603      	mov	r3, r0
    }
 8010d50:	4618      	mov	r0, r3
 8010d52:	3710      	adds	r7, #16
 8010d54:	46bd      	mov	sp, r7
 8010d56:	bd80      	pop	{r7, pc}

08010d58 <Sha256Final>:

    static WC_INLINE int Sha256Final(wc_Sha256* sha256)
    {
 8010d58:	b580      	push	{r7, lr}
 8010d5a:	b084      	sub	sp, #16
 8010d5c:	af00      	add	r7, sp, #0
 8010d5e:	6078      	str	r0, [r7, #4]

        int ret;
        byte* local;

        if (sha256 == NULL) {
 8010d60:	687b      	ldr	r3, [r7, #4]
 8010d62:	2b00      	cmp	r3, #0
 8010d64:	d102      	bne.n	8010d6c <Sha256Final+0x14>
            return BAD_FUNC_ARG;
 8010d66:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8010d6a:	e069      	b.n	8010e40 <Sha256Final+0xe8>
        }

        local = (byte*)sha256->buffer;
 8010d6c:	687b      	ldr	r3, [r7, #4]
 8010d6e:	3320      	adds	r3, #32
 8010d70:	60fb      	str	r3, [r7, #12]
        local[sha256->buffLen++] = 0x80; /* add 1 */
 8010d72:	687b      	ldr	r3, [r7, #4]
 8010d74:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010d76:	1c59      	adds	r1, r3, #1
 8010d78:	687a      	ldr	r2, [r7, #4]
 8010d7a:	6611      	str	r1, [r2, #96]	; 0x60
 8010d7c:	68fa      	ldr	r2, [r7, #12]
 8010d7e:	4413      	add	r3, r2
 8010d80:	2280      	movs	r2, #128	; 0x80
 8010d82:	701a      	strb	r2, [r3, #0]

        /* pad with zeros */
        if (sha256->buffLen > WC_SHA256_PAD_SIZE) {
 8010d84:	687b      	ldr	r3, [r7, #4]
 8010d86:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010d88:	2b38      	cmp	r3, #56	; 0x38
 8010d8a:	d924      	bls.n	8010dd6 <Sha256Final+0x7e>
            XMEMSET(&local[sha256->buffLen], 0,
 8010d8c:	687b      	ldr	r3, [r7, #4]
 8010d8e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010d90:	68fa      	ldr	r2, [r7, #12]
 8010d92:	18d0      	adds	r0, r2, r3
 8010d94:	687b      	ldr	r3, [r7, #4]
 8010d96:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010d98:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 8010d9c:	461a      	mov	r2, r3
 8010d9e:	2100      	movs	r1, #0
 8010da0:	f008 fb4d 	bl	801943e <memset>
                WC_SHA256_BLOCK_SIZE - sha256->buffLen);
            sha256->buffLen += WC_SHA256_BLOCK_SIZE - sha256->buffLen;
 8010da4:	687b      	ldr	r3, [r7, #4]
 8010da6:	2240      	movs	r2, #64	; 0x40
 8010da8:	661a      	str	r2, [r3, #96]	; 0x60
            #if defined(USE_INTEL_SPEEDUP) && \
                          (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
            if (!IS_INTEL_AVX1(intel_flags) && !IS_INTEL_AVX2(intel_flags))
            #endif
            {
                ByteReverseWords(sha256->buffer, sha256->buffer,
 8010daa:	687b      	ldr	r3, [r7, #4]
 8010dac:	f103 0020 	add.w	r0, r3, #32
 8010db0:	687b      	ldr	r3, [r7, #4]
 8010db2:	3320      	adds	r3, #32
 8010db4:	2240      	movs	r2, #64	; 0x40
 8010db6:	4619      	mov	r1, r3
 8010db8:	f7ff fadd 	bl	8010376 <ByteReverseWords>
                ret = XTRANSFORM(sha256, (const byte*)local);
            } else {
                ret = esp_sha256_process(sha256, (const byte*)local);
            }
        #else
            ret = XTRANSFORM(sha256, (const byte*)local);
 8010dbc:	68f9      	ldr	r1, [r7, #12]
 8010dbe:	6878      	ldr	r0, [r7, #4]
 8010dc0:	f7ff fb76 	bl	80104b0 <Transform_Sha256>
 8010dc4:	60b8      	str	r0, [r7, #8]
        #endif
            if (ret != 0)
 8010dc6:	68bb      	ldr	r3, [r7, #8]
 8010dc8:	2b00      	cmp	r3, #0
 8010dca:	d001      	beq.n	8010dd0 <Sha256Final+0x78>
                return ret;
 8010dcc:	68bb      	ldr	r3, [r7, #8]
 8010dce:	e037      	b.n	8010e40 <Sha256Final+0xe8>

            sha256->buffLen = 0;
 8010dd0:	687b      	ldr	r3, [r7, #4]
 8010dd2:	2200      	movs	r2, #0
 8010dd4:	661a      	str	r2, [r3, #96]	; 0x60
        }
        XMEMSET(&local[sha256->buffLen], 0,
 8010dd6:	687b      	ldr	r3, [r7, #4]
 8010dd8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010dda:	68fa      	ldr	r2, [r7, #12]
 8010ddc:	18d0      	adds	r0, r2, r3
 8010dde:	687b      	ldr	r3, [r7, #4]
 8010de0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010de2:	f1c3 0338 	rsb	r3, r3, #56	; 0x38
 8010de6:	461a      	mov	r2, r3
 8010de8:	2100      	movs	r1, #0
 8010dea:	f008 fb28 	bl	801943e <memset>
            WC_SHA256_PAD_SIZE - sha256->buffLen);

        /* put lengths in bits */
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
 8010dee:	687b      	ldr	r3, [r7, #4]
 8010df0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8010df2:	0f5a      	lsrs	r2, r3, #29
                                                         (sha256->hiLen << 3);
 8010df4:	687b      	ldr	r3, [r7, #4]
 8010df6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8010df8:	00db      	lsls	r3, r3, #3
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
 8010dfa:	441a      	add	r2, r3
 8010dfc:	687b      	ldr	r3, [r7, #4]
 8010dfe:	669a      	str	r2, [r3, #104]	; 0x68
        sha256->loLen = sha256->loLen << 3;
 8010e00:	687b      	ldr	r3, [r7, #4]
 8010e02:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8010e04:	00da      	lsls	r2, r3, #3
 8010e06:	687b      	ldr	r3, [r7, #4]
 8010e08:	665a      	str	r2, [r3, #100]	; 0x64
        #if defined(USE_INTEL_SPEEDUP) && \
                          (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2))
        if (!IS_INTEL_AVX1(intel_flags) && !IS_INTEL_AVX2(intel_flags))
        #endif
        {
            ByteReverseWords(sha256->buffer, sha256->buffer,
 8010e0a:	687b      	ldr	r3, [r7, #4]
 8010e0c:	f103 0020 	add.w	r0, r3, #32
 8010e10:	687b      	ldr	r3, [r7, #4]
 8010e12:	3320      	adds	r3, #32
 8010e14:	2240      	movs	r2, #64	; 0x40
 8010e16:	4619      	mov	r1, r3
 8010e18:	f7ff faad 	bl	8010376 <ByteReverseWords>
                WC_SHA256_BLOCK_SIZE);
        }
    #endif
        /* ! length ordering dependent on digest endian type ! */
        XMEMCPY(&local[WC_SHA256_PAD_SIZE], &sha256->hiLen, sizeof(word32));
 8010e1c:	68fb      	ldr	r3, [r7, #12]
 8010e1e:	3338      	adds	r3, #56	; 0x38
 8010e20:	687a      	ldr	r2, [r7, #4]
 8010e22:	3268      	adds	r2, #104	; 0x68
 8010e24:	6812      	ldr	r2, [r2, #0]
 8010e26:	601a      	str	r2, [r3, #0]
        XMEMCPY(&local[WC_SHA256_PAD_SIZE + sizeof(word32)], &sha256->loLen,
 8010e28:	68fb      	ldr	r3, [r7, #12]
 8010e2a:	333c      	adds	r3, #60	; 0x3c
 8010e2c:	687a      	ldr	r2, [r7, #4]
 8010e2e:	3264      	adds	r2, #100	; 0x64
 8010e30:	6812      	ldr	r2, [r2, #0]
 8010e32:	601a      	str	r2, [r3, #0]
            ret = XTRANSFORM(sha256, (const byte*)local);
        } else {
            ret = esp_sha256_digest_process(sha256, 1);
        }
    #else
        ret = XTRANSFORM(sha256, (const byte*)local);
 8010e34:	68f9      	ldr	r1, [r7, #12]
 8010e36:	6878      	ldr	r0, [r7, #4]
 8010e38:	f7ff fb3a 	bl	80104b0 <Transform_Sha256>
 8010e3c:	60b8      	str	r0, [r7, #8]
    #endif

        return ret;
 8010e3e:	68bb      	ldr	r3, [r7, #8]
    }
 8010e40:	4618      	mov	r0, r3
 8010e42:	3710      	adds	r7, #16
 8010e44:	46bd      	mov	sp, r7
 8010e46:	bd80      	pop	{r7, pc}

08010e48 <wc_Sha256Final>:

        return 0;
    }

    int wc_Sha256Final(wc_Sha256* sha256, byte* hash)
    {
 8010e48:	b580      	push	{r7, lr}
 8010e4a:	b084      	sub	sp, #16
 8010e4c:	af00      	add	r7, sp, #0
 8010e4e:	6078      	str	r0, [r7, #4]
 8010e50:	6039      	str	r1, [r7, #0]
        int ret;

        if (sha256 == NULL || hash == NULL) {
 8010e52:	687b      	ldr	r3, [r7, #4]
 8010e54:	2b00      	cmp	r3, #0
 8010e56:	d002      	beq.n	8010e5e <wc_Sha256Final+0x16>
 8010e58:	683b      	ldr	r3, [r7, #0]
 8010e5a:	2b00      	cmp	r3, #0
 8010e5c:	d102      	bne.n	8010e64 <wc_Sha256Final+0x1c>
            return BAD_FUNC_ARG;
 8010e5e:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8010e62:	e018      	b.n	8010e96 <wc_Sha256Final+0x4e>
                                            WC_SHA256_DIGEST_SIZE);
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        ret = Sha256Final(sha256);
 8010e64:	6878      	ldr	r0, [r7, #4]
 8010e66:	f7ff ff77 	bl	8010d58 <Sha256Final>
 8010e6a:	60f8      	str	r0, [r7, #12]
        if (ret != 0)
 8010e6c:	68fb      	ldr	r3, [r7, #12]
 8010e6e:	2b00      	cmp	r3, #0
 8010e70:	d001      	beq.n	8010e76 <wc_Sha256Final+0x2e>
            return ret;
 8010e72:	68fb      	ldr	r3, [r7, #12]
 8010e74:	e00f      	b.n	8010e96 <wc_Sha256Final+0x4e>

    #if defined(LITTLE_ENDIAN_ORDER)
        ByteReverseWords(sha256->digest, sha256->digest, WC_SHA256_DIGEST_SIZE);
 8010e76:	687b      	ldr	r3, [r7, #4]
 8010e78:	6879      	ldr	r1, [r7, #4]
 8010e7a:	2220      	movs	r2, #32
 8010e7c:	4618      	mov	r0, r3
 8010e7e:	f7ff fa7a 	bl	8010376 <ByteReverseWords>
    #endif
        XMEMCPY(hash, sha256->digest, WC_SHA256_DIGEST_SIZE);
 8010e82:	687b      	ldr	r3, [r7, #4]
 8010e84:	2220      	movs	r2, #32
 8010e86:	4619      	mov	r1, r3
 8010e88:	6838      	ldr	r0, [r7, #0]
 8010e8a:	f008 fab4 	bl	80193f6 <memcpy>

        return InitSha256(sha256);  /* reset state */
 8010e8e:	6878      	ldr	r0, [r7, #4]
 8010e90:	f7ff faa6 	bl	80103e0 <InitSha256>
 8010e94:	4603      	mov	r3, r0
    }
 8010e96:	4618      	mov	r0, r3
 8010e98:	3710      	adds	r7, #16
 8010e9a:	46bd      	mov	sp, r7
 8010e9c:	bd80      	pop	{r7, pc}

08010e9e <wc_Sha256Free>:
{
    return wc_InitSha256_ex(sha256, NULL, INVALID_DEVID);
}

void wc_Sha256Free(wc_Sha256* sha256)
{
 8010e9e:	b480      	push	{r7}
 8010ea0:	b083      	sub	sp, #12
 8010ea2:	af00      	add	r7, sp, #0
 8010ea4:	6078      	str	r0, [r7, #4]
    if (sha256 == NULL)
 8010ea6:	687b      	ldr	r3, [r7, #4]
 8010ea8:	2b00      	cmp	r3, #0
    }
#endif
#ifdef WOLFSSL_IMXRT_DCP
    DCPSha256Free(sha256);
#endif
}
 8010eaa:	370c      	adds	r7, #12
 8010eac:	46bd      	mov	sp, r7
 8010eae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010eb2:	4770      	bx	lr

08010eb4 <sp_2048_from_bin>:
 * size  Maximum number of bytes to convert
 * a  Byte array.
 * n  Number of bytes in array to read.
 */
static void sp_2048_from_bin(sp_digit* r, int size, const byte* a, int n)
{
 8010eb4:	b480      	push	{r7}
 8010eb6:	b089      	sub	sp, #36	; 0x24
 8010eb8:	af00      	add	r7, sp, #0
 8010eba:	60f8      	str	r0, [r7, #12]
 8010ebc:	60b9      	str	r1, [r7, #8]
 8010ebe:	607a      	str	r2, [r7, #4]
 8010ec0:	603b      	str	r3, [r7, #0]
    int i, j = 0;
 8010ec2:	2300      	movs	r3, #0
 8010ec4:	61bb      	str	r3, [r7, #24]
    word32 s = 0;
 8010ec6:	2300      	movs	r3, #0
 8010ec8:	617b      	str	r3, [r7, #20]

    r[0] = 0;
 8010eca:	68fb      	ldr	r3, [r7, #12]
 8010ecc:	2200      	movs	r2, #0
 8010ece:	601a      	str	r2, [r3, #0]
    for (i = n-1; i >= 0; i--) {
 8010ed0:	683b      	ldr	r3, [r7, #0]
 8010ed2:	3b01      	subs	r3, #1
 8010ed4:	61fb      	str	r3, [r7, #28]
 8010ed6:	e042      	b.n	8010f5e <sp_2048_from_bin+0xaa>
        r[j] |= (((sp_digit)a[i]) << s);
 8010ed8:	69bb      	ldr	r3, [r7, #24]
 8010eda:	009b      	lsls	r3, r3, #2
 8010edc:	68fa      	ldr	r2, [r7, #12]
 8010ede:	4413      	add	r3, r2
 8010ee0:	6819      	ldr	r1, [r3, #0]
 8010ee2:	69fb      	ldr	r3, [r7, #28]
 8010ee4:	687a      	ldr	r2, [r7, #4]
 8010ee6:	4413      	add	r3, r2
 8010ee8:	781b      	ldrb	r3, [r3, #0]
 8010eea:	461a      	mov	r2, r3
 8010eec:	697b      	ldr	r3, [r7, #20]
 8010eee:	409a      	lsls	r2, r3
 8010ef0:	69bb      	ldr	r3, [r7, #24]
 8010ef2:	009b      	lsls	r3, r3, #2
 8010ef4:	68f8      	ldr	r0, [r7, #12]
 8010ef6:	4403      	add	r3, r0
 8010ef8:	430a      	orrs	r2, r1
 8010efa:	601a      	str	r2, [r3, #0]
        if (s >= 24U) {
 8010efc:	697b      	ldr	r3, [r7, #20]
 8010efe:	2b17      	cmp	r3, #23
 8010f00:	d927      	bls.n	8010f52 <sp_2048_from_bin+0x9e>
            r[j] &= 0xffffffff;
 8010f02:	69bb      	ldr	r3, [r7, #24]
 8010f04:	009b      	lsls	r3, r3, #2
 8010f06:	68fa      	ldr	r2, [r7, #12]
 8010f08:	441a      	add	r2, r3
 8010f0a:	69bb      	ldr	r3, [r7, #24]
 8010f0c:	009b      	lsls	r3, r3, #2
 8010f0e:	68f9      	ldr	r1, [r7, #12]
 8010f10:	440b      	add	r3, r1
 8010f12:	6812      	ldr	r2, [r2, #0]
 8010f14:	601a      	str	r2, [r3, #0]
            s = 32U - s;
 8010f16:	697b      	ldr	r3, [r7, #20]
 8010f18:	f1c3 0320 	rsb	r3, r3, #32
 8010f1c:	617b      	str	r3, [r7, #20]
            if (j + 1 >= size) {
 8010f1e:	69bb      	ldr	r3, [r7, #24]
 8010f20:	3301      	adds	r3, #1
 8010f22:	68ba      	ldr	r2, [r7, #8]
 8010f24:	429a      	cmp	r2, r3
 8010f26:	dd1e      	ble.n	8010f66 <sp_2048_from_bin+0xb2>
                break;
            }
            r[++j] = (sp_digit)a[i] >> s;
 8010f28:	69fb      	ldr	r3, [r7, #28]
 8010f2a:	687a      	ldr	r2, [r7, #4]
 8010f2c:	4413      	add	r3, r2
 8010f2e:	781b      	ldrb	r3, [r3, #0]
 8010f30:	4619      	mov	r1, r3
 8010f32:	69bb      	ldr	r3, [r7, #24]
 8010f34:	3301      	adds	r3, #1
 8010f36:	61bb      	str	r3, [r7, #24]
 8010f38:	69bb      	ldr	r3, [r7, #24]
 8010f3a:	009b      	lsls	r3, r3, #2
 8010f3c:	68fa      	ldr	r2, [r7, #12]
 8010f3e:	4413      	add	r3, r2
 8010f40:	697a      	ldr	r2, [r7, #20]
 8010f42:	fa21 f202 	lsr.w	r2, r1, r2
 8010f46:	601a      	str	r2, [r3, #0]
            s = 8U - s;
 8010f48:	697b      	ldr	r3, [r7, #20]
 8010f4a:	f1c3 0308 	rsb	r3, r3, #8
 8010f4e:	617b      	str	r3, [r7, #20]
 8010f50:	e002      	b.n	8010f58 <sp_2048_from_bin+0xa4>
        }
        else {
            s += 8U;
 8010f52:	697b      	ldr	r3, [r7, #20]
 8010f54:	3308      	adds	r3, #8
 8010f56:	617b      	str	r3, [r7, #20]
    for (i = n-1; i >= 0; i--) {
 8010f58:	69fb      	ldr	r3, [r7, #28]
 8010f5a:	3b01      	subs	r3, #1
 8010f5c:	61fb      	str	r3, [r7, #28]
 8010f5e:	69fb      	ldr	r3, [r7, #28]
 8010f60:	2b00      	cmp	r3, #0
 8010f62:	dab9      	bge.n	8010ed8 <sp_2048_from_bin+0x24>
 8010f64:	e000      	b.n	8010f68 <sp_2048_from_bin+0xb4>
                break;
 8010f66:	bf00      	nop
        }
    }

    for (j++; j < size; j++) {
 8010f68:	69bb      	ldr	r3, [r7, #24]
 8010f6a:	3301      	adds	r3, #1
 8010f6c:	61bb      	str	r3, [r7, #24]
 8010f6e:	e008      	b.n	8010f82 <sp_2048_from_bin+0xce>
        r[j] = 0;
 8010f70:	69bb      	ldr	r3, [r7, #24]
 8010f72:	009b      	lsls	r3, r3, #2
 8010f74:	68fa      	ldr	r2, [r7, #12]
 8010f76:	4413      	add	r3, r2
 8010f78:	2200      	movs	r2, #0
 8010f7a:	601a      	str	r2, [r3, #0]
    for (j++; j < size; j++) {
 8010f7c:	69bb      	ldr	r3, [r7, #24]
 8010f7e:	3301      	adds	r3, #1
 8010f80:	61bb      	str	r3, [r7, #24]
 8010f82:	69ba      	ldr	r2, [r7, #24]
 8010f84:	68bb      	ldr	r3, [r7, #8]
 8010f86:	429a      	cmp	r2, r3
 8010f88:	dbf2      	blt.n	8010f70 <sp_2048_from_bin+0xbc>
    }
}
 8010f8a:	bf00      	nop
 8010f8c:	3724      	adds	r7, #36	; 0x24
 8010f8e:	46bd      	mov	sp, r7
 8010f90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010f94:	4770      	bx	lr

08010f96 <sp_2048_from_mp>:
 * r  A single precision integer.
 * size  Maximum number of bytes to convert
 * a  A multi-precision integer.
 */
static void sp_2048_from_mp(sp_digit* r, int size, const mp_int* a)
{
 8010f96:	b580      	push	{r7, lr}
 8010f98:	b086      	sub	sp, #24
 8010f9a:	af00      	add	r7, sp, #0
 8010f9c:	60f8      	str	r0, [r7, #12]
 8010f9e:	60b9      	str	r1, [r7, #8]
 8010fa0:	607a      	str	r2, [r7, #4]
#if DIGIT_BIT == 32
    int j;

    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
 8010fa2:	687b      	ldr	r3, [r7, #4]
 8010fa4:	f103 0108 	add.w	r1, r3, #8
 8010fa8:	687b      	ldr	r3, [r7, #4]
 8010faa:	681b      	ldr	r3, [r3, #0]
 8010fac:	009b      	lsls	r3, r3, #2
 8010fae:	461a      	mov	r2, r3
 8010fb0:	68f8      	ldr	r0, [r7, #12]
 8010fb2:	f008 fa20 	bl	80193f6 <memcpy>

    for (j = a->used; j < size; j++) {
 8010fb6:	687b      	ldr	r3, [r7, #4]
 8010fb8:	681b      	ldr	r3, [r3, #0]
 8010fba:	617b      	str	r3, [r7, #20]
 8010fbc:	e008      	b.n	8010fd0 <sp_2048_from_mp+0x3a>
        r[j] = 0;
 8010fbe:	697b      	ldr	r3, [r7, #20]
 8010fc0:	009b      	lsls	r3, r3, #2
 8010fc2:	68fa      	ldr	r2, [r7, #12]
 8010fc4:	4413      	add	r3, r2
 8010fc6:	2200      	movs	r2, #0
 8010fc8:	601a      	str	r2, [r3, #0]
    for (j = a->used; j < size; j++) {
 8010fca:	697b      	ldr	r3, [r7, #20]
 8010fcc:	3301      	adds	r3, #1
 8010fce:	617b      	str	r3, [r7, #20]
 8010fd0:	697a      	ldr	r2, [r7, #20]
 8010fd2:	68bb      	ldr	r3, [r7, #8]
 8010fd4:	429a      	cmp	r2, r3
 8010fd6:	dbf2      	blt.n	8010fbe <sp_2048_from_mp+0x28>

    for (j++; j < size; j++) {
        r[j] = 0;
    }
#endif
}
 8010fd8:	bf00      	nop
 8010fda:	3718      	adds	r7, #24
 8010fdc:	46bd      	mov	sp, r7
 8010fde:	bd80      	pop	{r7, pc}

08010fe0 <sp_2048_to_bin>:
 *
 * r  A single precision integer.
 * a  Byte array.
 */
static void sp_2048_to_bin(sp_digit* r, byte* a)
{
 8010fe0:	b480      	push	{r7}
 8010fe2:	b087      	sub	sp, #28
 8010fe4:	af00      	add	r7, sp, #0
 8010fe6:	6078      	str	r0, [r7, #4]
 8010fe8:	6039      	str	r1, [r7, #0]
    int i, j, s = 0, b;
 8010fea:	2300      	movs	r3, #0
 8010fec:	60fb      	str	r3, [r7, #12]

    j = 2048 / 8 - 1;
 8010fee:	23ff      	movs	r3, #255	; 0xff
 8010ff0:	613b      	str	r3, [r7, #16]
    a[j] = 0;
 8010ff2:	693b      	ldr	r3, [r7, #16]
 8010ff4:	683a      	ldr	r2, [r7, #0]
 8010ff6:	4413      	add	r3, r2
 8010ff8:	2200      	movs	r2, #0
 8010ffa:	701a      	strb	r2, [r3, #0]
    for (i=0; i<64 && j>=0; i++) {
 8010ffc:	2300      	movs	r3, #0
 8010ffe:	617b      	str	r3, [r7, #20]
 8011000:	e051      	b.n	80110a6 <sp_2048_to_bin+0xc6>
        b = 0;
 8011002:	2300      	movs	r3, #0
 8011004:	60bb      	str	r3, [r7, #8]
        /* lint allow cast of mismatch sp_digit and int */
        a[j--] |= (byte)(r[i] << s); /*lint !e9033*/
 8011006:	693b      	ldr	r3, [r7, #16]
 8011008:	1e5a      	subs	r2, r3, #1
 801100a:	613a      	str	r2, [r7, #16]
 801100c:	4619      	mov	r1, r3
 801100e:	683a      	ldr	r2, [r7, #0]
 8011010:	440a      	add	r2, r1
 8011012:	7811      	ldrb	r1, [r2, #0]
 8011014:	697a      	ldr	r2, [r7, #20]
 8011016:	0092      	lsls	r2, r2, #2
 8011018:	6878      	ldr	r0, [r7, #4]
 801101a:	4402      	add	r2, r0
 801101c:	6810      	ldr	r0, [r2, #0]
 801101e:	68fa      	ldr	r2, [r7, #12]
 8011020:	fa00 f202 	lsl.w	r2, r0, r2
 8011024:	b2d2      	uxtb	r2, r2
 8011026:	4618      	mov	r0, r3
 8011028:	683b      	ldr	r3, [r7, #0]
 801102a:	4403      	add	r3, r0
 801102c:	430a      	orrs	r2, r1
 801102e:	b2d2      	uxtb	r2, r2
 8011030:	701a      	strb	r2, [r3, #0]
        b += 8 - s;
 8011032:	68fb      	ldr	r3, [r7, #12]
 8011034:	f1c3 0308 	rsb	r3, r3, #8
 8011038:	68ba      	ldr	r2, [r7, #8]
 801103a:	4413      	add	r3, r2
 801103c:	60bb      	str	r3, [r7, #8]
        if (j < 0) {
 801103e:	693b      	ldr	r3, [r7, #16]
 8011040:	2b00      	cmp	r3, #0
 8011042:	db37      	blt.n	80110b4 <sp_2048_to_bin+0xd4>
            break;
        }
        while (b < 32) {
 8011044:	e015      	b.n	8011072 <sp_2048_to_bin+0x92>
            a[j--] = (byte)(r[i] >> b);
 8011046:	697b      	ldr	r3, [r7, #20]
 8011048:	009b      	lsls	r3, r3, #2
 801104a:	687a      	ldr	r2, [r7, #4]
 801104c:	4413      	add	r3, r2
 801104e:	681a      	ldr	r2, [r3, #0]
 8011050:	68bb      	ldr	r3, [r7, #8]
 8011052:	fa22 f103 	lsr.w	r1, r2, r3
 8011056:	693b      	ldr	r3, [r7, #16]
 8011058:	1e5a      	subs	r2, r3, #1
 801105a:	613a      	str	r2, [r7, #16]
 801105c:	461a      	mov	r2, r3
 801105e:	683b      	ldr	r3, [r7, #0]
 8011060:	4413      	add	r3, r2
 8011062:	b2ca      	uxtb	r2, r1
 8011064:	701a      	strb	r2, [r3, #0]
            b += 8;
 8011066:	68bb      	ldr	r3, [r7, #8]
 8011068:	3308      	adds	r3, #8
 801106a:	60bb      	str	r3, [r7, #8]
            if (j < 0) {
 801106c:	693b      	ldr	r3, [r7, #16]
 801106e:	2b00      	cmp	r3, #0
 8011070:	db03      	blt.n	801107a <sp_2048_to_bin+0x9a>
        while (b < 32) {
 8011072:	68bb      	ldr	r3, [r7, #8]
 8011074:	2b1f      	cmp	r3, #31
 8011076:	dde6      	ble.n	8011046 <sp_2048_to_bin+0x66>
 8011078:	e000      	b.n	801107c <sp_2048_to_bin+0x9c>
                break;
 801107a:	bf00      	nop
            }
        }
        s = 8 - (b - 32);
 801107c:	68bb      	ldr	r3, [r7, #8]
 801107e:	f1c3 0328 	rsb	r3, r3, #40	; 0x28
 8011082:	60fb      	str	r3, [r7, #12]
        if (j >= 0) {
 8011084:	693b      	ldr	r3, [r7, #16]
 8011086:	2b00      	cmp	r3, #0
 8011088:	db04      	blt.n	8011094 <sp_2048_to_bin+0xb4>
            a[j] = 0;
 801108a:	693b      	ldr	r3, [r7, #16]
 801108c:	683a      	ldr	r2, [r7, #0]
 801108e:	4413      	add	r3, r2
 8011090:	2200      	movs	r2, #0
 8011092:	701a      	strb	r2, [r3, #0]
        }
        if (s != 0) {
 8011094:	68fb      	ldr	r3, [r7, #12]
 8011096:	2b00      	cmp	r3, #0
 8011098:	d002      	beq.n	80110a0 <sp_2048_to_bin+0xc0>
            j++;
 801109a:	693b      	ldr	r3, [r7, #16]
 801109c:	3301      	adds	r3, #1
 801109e:	613b      	str	r3, [r7, #16]
    for (i=0; i<64 && j>=0; i++) {
 80110a0:	697b      	ldr	r3, [r7, #20]
 80110a2:	3301      	adds	r3, #1
 80110a4:	617b      	str	r3, [r7, #20]
 80110a6:	697b      	ldr	r3, [r7, #20]
 80110a8:	2b3f      	cmp	r3, #63	; 0x3f
 80110aa:	dc04      	bgt.n	80110b6 <sp_2048_to_bin+0xd6>
 80110ac:	693b      	ldr	r3, [r7, #16]
 80110ae:	2b00      	cmp	r3, #0
 80110b0:	daa7      	bge.n	8011002 <sp_2048_to_bin+0x22>
        }
    }
}
 80110b2:	e000      	b.n	80110b6 <sp_2048_to_bin+0xd6>
            break;
 80110b4:	bf00      	nop
}
 80110b6:	bf00      	nop
 80110b8:	371c      	adds	r7, #28
 80110ba:	46bd      	mov	sp, r7
 80110bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80110c0:	4770      	bx	lr

080110c2 <sp_2048_add_64>:
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static sp_digit sp_2048_add_64(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
 80110c2:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 80110c6:	b087      	sub	sp, #28
 80110c8:	af00      	add	r7, sp, #0
 80110ca:	60f8      	str	r0, [r7, #12]
 80110cc:	60b9      	str	r1, [r7, #8]
 80110ce:	607a      	str	r2, [r7, #4]
    sp_digit c = 0;
 80110d0:	2300      	movs	r3, #0
 80110d2:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 80110d4:	6978      	ldr	r0, [r7, #20]
 80110d6:	68f9      	ldr	r1, [r7, #12]
 80110d8:	68ba      	ldr	r2, [r7, #8]
 80110da:	687b      	ldr	r3, [r7, #4]
 80110dc:	4616      	mov	r6, r2
 80110de:	f04f 0800 	mov.w	r8, #0
 80110e2:	f506 7680 	add.w	r6, r6, #256	; 0x100
 80110e6:	f1a8 0801 	sub.w	r8, r8, #1
 80110ea:	eb10 0008 	adds.w	r0, r0, r8
 80110ee:	6814      	ldr	r4, [r2, #0]
 80110f0:	681d      	ldr	r5, [r3, #0]
 80110f2:	416c      	adcs	r4, r5
 80110f4:	600c      	str	r4, [r1, #0]
 80110f6:	f04f 0000 	mov.w	r0, #0
 80110fa:	eb40 0000 	adc.w	r0, r0, r0
 80110fe:	f102 0204 	add.w	r2, r2, #4
 8011102:	f103 0304 	add.w	r3, r3, #4
 8011106:	f101 0104 	add.w	r1, r1, #4
 801110a:	42b2      	cmp	r2, r6
 801110c:	d1ed      	bne.n	80110ea <sp_2048_add_64+0x28>
 801110e:	6178      	str	r0, [r7, #20]
 8011110:	60f9      	str	r1, [r7, #12]
 8011112:	60ba      	str	r2, [r7, #8]
 8011114:	607b      	str	r3, [r7, #4]
        : [c] "+r" (c), [r] "+r" (r), [a] "+r" (a), [b] "+r" (b)
        :
        : "memory", "r4", "r5", "r6", "r8"
    );

    return c;
 8011116:	697b      	ldr	r3, [r7, #20]
}
 8011118:	4618      	mov	r0, r3
 801111a:	371c      	adds	r7, #28
 801111c:	46bd      	mov	sp, r7
 801111e:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8011122:	4770      	bx	lr

08011124 <sp_2048_sub_in_place_64>:
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static sp_digit sp_2048_sub_in_place_64(sp_digit* a,
        const sp_digit* b)
{
 8011124:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 8011128:	b085      	sub	sp, #20
 801112a:	af00      	add	r7, sp, #0
 801112c:	6078      	str	r0, [r7, #4]
 801112e:	6039      	str	r1, [r7, #0]
    sp_digit c = 0;
 8011130:	2300      	movs	r3, #0
 8011132:	60fb      	str	r3, [r7, #12]
    __asm__ __volatile__ (
 8011134:	68f9      	ldr	r1, [r7, #12]
 8011136:	687a      	ldr	r2, [r7, #4]
 8011138:	683b      	ldr	r3, [r7, #0]
 801113a:	4608      	mov	r0, r1
 801113c:	4611      	mov	r1, r2
 801113e:	461a      	mov	r2, r3
 8011140:	4688      	mov	r8, r1
 8011142:	f508 7880 	add.w	r8, r8, #256	; 0x100
 8011146:	f04f 0500 	mov.w	r5, #0
 801114a:	1a2d      	subs	r5, r5, r0
 801114c:	680b      	ldr	r3, [r1, #0]
 801114e:	684c      	ldr	r4, [r1, #4]
 8011150:	6815      	ldr	r5, [r2, #0]
 8011152:	6856      	ldr	r6, [r2, #4]
 8011154:	41ab      	sbcs	r3, r5
 8011156:	41b4      	sbcs	r4, r6
 8011158:	600b      	str	r3, [r1, #0]
 801115a:	604c      	str	r4, [r1, #4]
 801115c:	eb60 0000 	sbc.w	r0, r0, r0
 8011160:	f101 0108 	add.w	r1, r1, #8
 8011164:	f102 0208 	add.w	r2, r2, #8
 8011168:	4541      	cmp	r1, r8
 801116a:	d1ec      	bne.n	8011146 <sp_2048_sub_in_place_64+0x22>
 801116c:	60f8      	str	r0, [r7, #12]
 801116e:	6079      	str	r1, [r7, #4]
 8011170:	603a      	str	r2, [r7, #0]
        : [c] "+r" (c), [a] "+r" (a), [b] "+r" (b)
        :
        : "memory", "r3", "r4", "r5", "r6", "r8"
    );

    return c;
 8011172:	68fb      	ldr	r3, [r7, #12]
}
 8011174:	4618      	mov	r0, r3
 8011176:	3714      	adds	r7, #20
 8011178:	46bd      	mov	sp, r7
 801117a:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 801117e:	4770      	bx	lr

08011180 <sp_2048_mul_64>:
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_2048_mul_64(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
 8011180:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011184:	f5ad 7d07 	sub.w	sp, sp, #540	; 0x21c
 8011188:	af00      	add	r7, sp, #0
 801118a:	f107 030c 	add.w	r3, r7, #12
 801118e:	6018      	str	r0, [r3, #0]
 8011190:	f107 0308 	add.w	r3, r7, #8
 8011194:	6019      	str	r1, [r3, #0]
 8011196:	1d3b      	adds	r3, r7, #4
 8011198:	601a      	str	r2, [r3, #0]
    sp_digit tmp_arr[64 * 2];
    sp_digit* tmp = tmp_arr;
 801119a:	f107 0314 	add.w	r3, r7, #20
 801119e:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    __asm__ __volatile__ (
 80111a2:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 80111a6:	f107 0308 	add.w	r3, r7, #8
 80111aa:	6819      	ldr	r1, [r3, #0]
 80111ac:	1d3b      	adds	r3, r7, #4
 80111ae:	6818      	ldr	r0, [r3, #0]
 80111b0:	f04f 0300 	mov.w	r3, #0
 80111b4:	f04f 0400 	mov.w	r4, #0
 80111b8:	4699      	mov	r9, r3
 80111ba:	4694      	mov	ip, r2
 80111bc:	468a      	mov	sl, r1
 80111be:	4683      	mov	fp, r0
 80111c0:	f04f 0601 	mov.w	r6, #1
 80111c4:	ea4f 2606 	mov.w	r6, r6, lsl #8
 80111c8:	4456      	add	r6, sl
 80111ca:	46b6      	mov	lr, r6
 80111cc:	f04f 0200 	mov.w	r2, #0
 80111d0:	f04f 0500 	mov.w	r5, #0
 80111d4:	f04f 06fc 	mov.w	r6, #252	; 0xfc
 80111d8:	4649      	mov	r1, r9
 80111da:	1b89      	subs	r1, r1, r6
 80111dc:	eb66 0606 	sbc.w	r6, r6, r6
 80111e0:	ea6f 0606 	mvn.w	r6, r6
 80111e4:	ea01 0106 	and.w	r1, r1, r6
 80111e8:	4648      	mov	r0, r9
 80111ea:	eba0 0001 	sub.w	r0, r0, r1
 80111ee:	4451      	add	r1, sl
 80111f0:	4458      	add	r0, fp
 80111f2:	680e      	ldr	r6, [r1, #0]
 80111f4:	f8d0 8000 	ldr.w	r8, [r0]
 80111f8:	fba6 6808 	umull	r6, r8, r6, r8
 80111fc:	199b      	adds	r3, r3, r6
 80111fe:	eb54 0408 	adcs.w	r4, r4, r8
 8011202:	eb45 0502 	adc.w	r5, r5, r2
 8011206:	f101 0104 	add.w	r1, r1, #4
 801120a:	f1a0 0004 	sub.w	r0, r0, #4
 801120e:	4571      	cmp	r1, lr
 8011210:	d003      	beq.n	801121a <sp_2048_mul_64+0x9a>
 8011212:	464e      	mov	r6, r9
 8011214:	4456      	add	r6, sl
 8011216:	42b1      	cmp	r1, r6
 8011218:	ddeb      	ble.n	80111f2 <sp_2048_mul_64+0x72>
 801121a:	4662      	mov	r2, ip
 801121c:	46c8      	mov	r8, r9
 801121e:	f842 3008 	str.w	r3, [r2, r8]
 8011222:	4623      	mov	r3, r4
 8011224:	462c      	mov	r4, r5
 8011226:	f108 0804 	add.w	r8, r8, #4
 801122a:	46c1      	mov	r9, r8
 801122c:	f04f 0601 	mov.w	r6, #1
 8011230:	ea4f 2606 	mov.w	r6, r6, lsl #8
 8011234:	f106 06f8 	add.w	r6, r6, #248	; 0xf8
 8011238:	45b0      	cmp	r8, r6
 801123a:	ddc7      	ble.n	80111cc <sp_2048_mul_64+0x4c>
 801123c:	f842 3008 	str.w	r3, [r2, r8]
 8011240:	4651      	mov	r1, sl
 8011242:	4658      	mov	r0, fp
        :
        : [r] "r" (tmp), [a] "r" (a), [b] "r" (b)
        : "memory", "r3", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r12", "r14"
    );

    XMEMCPY(r, tmp_arr, sizeof(tmp_arr));
 8011244:	f107 0114 	add.w	r1, r7, #20
 8011248:	f107 030c 	add.w	r3, r7, #12
 801124c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8011250:	6818      	ldr	r0, [r3, #0]
 8011252:	f008 f8d0 	bl	80193f6 <memcpy>
}
 8011256:	bf00      	nop
 8011258:	f507 7707 	add.w	r7, r7, #540	; 0x21c
 801125c:	46bd      	mov	sp, r7
 801125e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08011262 <sp_2048_sqr_64>:
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_2048_sqr_64(sp_digit* r, const sp_digit* a)
{
 8011262:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8011266:	b082      	sub	sp, #8
 8011268:	af00      	add	r7, sp, #0
 801126a:	6078      	str	r0, [r7, #4]
 801126c:	6039      	str	r1, [r7, #0]
    __asm__ __volatile__ (
 801126e:	6879      	ldr	r1, [r7, #4]
 8011270:	6838      	ldr	r0, [r7, #0]
 8011272:	f04f 0300 	mov.w	r3, #0
 8011276:	f04f 0400 	mov.w	r4, #0
 801127a:	f04f 0500 	mov.w	r5, #0
 801127e:	4699      	mov	r9, r3
 8011280:	468c      	mov	ip, r1
 8011282:	f04f 0602 	mov.w	r6, #2
 8011286:	ea4f 2606 	mov.w	r6, r6, lsl #8
 801128a:	f1c6 0600 	rsb	r6, r6, #0
 801128e:	44b5      	add	sp, r6
 8011290:	46eb      	mov	fp, sp
 8011292:	4682      	mov	sl, r0
 8011294:	f04f 0100 	mov.w	r1, #0
 8011298:	f04f 06fc 	mov.w	r6, #252	; 0xfc
 801129c:	4648      	mov	r0, r9
 801129e:	1b80      	subs	r0, r0, r6
 80112a0:	eb66 0606 	sbc.w	r6, r6, r6
 80112a4:	ea6f 0606 	mvn.w	r6, r6
 80112a8:	ea00 0006 	and.w	r0, r0, r6
 80112ac:	464a      	mov	r2, r9
 80112ae:	eba2 0200 	sub.w	r2, r2, r0
 80112b2:	4450      	add	r0, sl
 80112b4:	4452      	add	r2, sl
 80112b6:	4282      	cmp	r2, r0
 80112b8:	d00f      	beq.n	80112da <sp_2048_sqr_64+0x78>
 80112ba:	6806      	ldr	r6, [r0, #0]
 80112bc:	f8d2 8000 	ldr.w	r8, [r2]
 80112c0:	fba6 6808 	umull	r6, r8, r6, r8
 80112c4:	199b      	adds	r3, r3, r6
 80112c6:	eb54 0408 	adcs.w	r4, r4, r8
 80112ca:	eb45 0501 	adc.w	r5, r5, r1
 80112ce:	199b      	adds	r3, r3, r6
 80112d0:	eb54 0408 	adcs.w	r4, r4, r8
 80112d4:	eb45 0501 	adc.w	r5, r5, r1
 80112d8:	e007      	b.n	80112ea <sp_2048_sqr_64+0x88>
 80112da:	6806      	ldr	r6, [r0, #0]
 80112dc:	fba6 6806 	umull	r6, r8, r6, r6
 80112e0:	199b      	adds	r3, r3, r6
 80112e2:	eb54 0408 	adcs.w	r4, r4, r8
 80112e6:	eb45 0501 	adc.w	r5, r5, r1
 80112ea:	f100 0004 	add.w	r0, r0, #4
 80112ee:	f1a2 0204 	sub.w	r2, r2, #4
 80112f2:	f04f 0601 	mov.w	r6, #1
 80112f6:	ea4f 2606 	mov.w	r6, r6, lsl #8
 80112fa:	4456      	add	r6, sl
 80112fc:	42b0      	cmp	r0, r6
 80112fe:	d005      	beq.n	801130c <sp_2048_sqr_64+0xaa>
 8011300:	4290      	cmp	r0, r2
 8011302:	dc03      	bgt.n	801130c <sp_2048_sqr_64+0xaa>
 8011304:	46c8      	mov	r8, r9
 8011306:	44d0      	add	r8, sl
 8011308:	4540      	cmp	r0, r8
 801130a:	ddd4      	ble.n	80112b6 <sp_2048_sqr_64+0x54>
 801130c:	4659      	mov	r1, fp
 801130e:	46c8      	mov	r8, r9
 8011310:	f841 3008 	str.w	r3, [r1, r8]
 8011314:	4623      	mov	r3, r4
 8011316:	462c      	mov	r4, r5
 8011318:	f04f 0500 	mov.w	r5, #0
 801131c:	f108 0804 	add.w	r8, r8, #4
 8011320:	46c1      	mov	r9, r8
 8011322:	f04f 0601 	mov.w	r6, #1
 8011326:	ea4f 2606 	mov.w	r6, r6, lsl #8
 801132a:	f106 06f8 	add.w	r6, r6, #248	; 0xf8
 801132e:	45b0      	cmp	r8, r6
 8011330:	ddb0      	ble.n	8011294 <sp_2048_sqr_64+0x32>
 8011332:	4650      	mov	r0, sl
 8011334:	f841 3008 	str.w	r3, [r1, r8]
 8011338:	4661      	mov	r1, ip
 801133a:	4658      	mov	r0, fp
 801133c:	f04f 0301 	mov.w	r3, #1
 8011340:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8011344:	f103 03fc 	add.w	r3, r3, #252	; 0xfc
 8011348:	58c6      	ldr	r6, [r0, r3]
 801134a:	50ce      	str	r6, [r1, r3]
 801134c:	3b04      	subs	r3, #4
 801134e:	dafb      	bge.n	8011348 <sp_2048_sqr_64+0xe6>
 8011350:	f04f 0602 	mov.w	r6, #2
 8011354:	ea4f 2606 	mov.w	r6, r6, lsl #8
 8011358:	44b5      	add	sp, r6
        "add	sp, sp, r6\n\t"
        :
        : [r] "r" (r), [a] "r" (a)
        : "memory", "r2", "r3", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r12"
    );
}
 801135a:	bf00      	nop
 801135c:	3708      	adds	r7, #8
 801135e:	46bd      	mov	sp, r7
 8011360:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8011364:	4770      	bx	lr

08011366 <sp_2048_mask_32>:
 * r  A single precision integer.
 * a  A single precision integer.
 * m  Mask to AND against each digit.
 */
static void sp_2048_mask_32(sp_digit* r, const sp_digit* a, sp_digit m)
{
 8011366:	b480      	push	{r7}
 8011368:	b087      	sub	sp, #28
 801136a:	af00      	add	r7, sp, #0
 801136c:	60f8      	str	r0, [r7, #12]
 801136e:	60b9      	str	r1, [r7, #8]
 8011370:	607a      	str	r2, [r7, #4]
    int i;

    for (i=0; i<32; i++) {
 8011372:	2300      	movs	r3, #0
 8011374:	617b      	str	r3, [r7, #20]
 8011376:	e00e      	b.n	8011396 <sp_2048_mask_32+0x30>
        r[i] = a[i] & m;
 8011378:	697b      	ldr	r3, [r7, #20]
 801137a:	009b      	lsls	r3, r3, #2
 801137c:	68ba      	ldr	r2, [r7, #8]
 801137e:	4413      	add	r3, r2
 8011380:	6819      	ldr	r1, [r3, #0]
 8011382:	697b      	ldr	r3, [r7, #20]
 8011384:	009b      	lsls	r3, r3, #2
 8011386:	68fa      	ldr	r2, [r7, #12]
 8011388:	4413      	add	r3, r2
 801138a:	687a      	ldr	r2, [r7, #4]
 801138c:	400a      	ands	r2, r1
 801138e:	601a      	str	r2, [r3, #0]
    for (i=0; i<32; i++) {
 8011390:	697b      	ldr	r3, [r7, #20]
 8011392:	3301      	adds	r3, #1
 8011394:	617b      	str	r3, [r7, #20]
 8011396:	697b      	ldr	r3, [r7, #20]
 8011398:	2b1f      	cmp	r3, #31
 801139a:	dded      	ble.n	8011378 <sp_2048_mask_32+0x12>
    }
}
 801139c:	bf00      	nop
 801139e:	371c      	adds	r7, #28
 80113a0:	46bd      	mov	sp, r7
 80113a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80113a6:	4770      	bx	lr

080113a8 <sp_2048_add_32>:
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static sp_digit sp_2048_add_32(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
 80113a8:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 80113ac:	b087      	sub	sp, #28
 80113ae:	af00      	add	r7, sp, #0
 80113b0:	60f8      	str	r0, [r7, #12]
 80113b2:	60b9      	str	r1, [r7, #8]
 80113b4:	607a      	str	r2, [r7, #4]
    sp_digit c = 0;
 80113b6:	2300      	movs	r3, #0
 80113b8:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 80113ba:	6978      	ldr	r0, [r7, #20]
 80113bc:	68f9      	ldr	r1, [r7, #12]
 80113be:	68ba      	ldr	r2, [r7, #8]
 80113c0:	687b      	ldr	r3, [r7, #4]
 80113c2:	4616      	mov	r6, r2
 80113c4:	f04f 0800 	mov.w	r8, #0
 80113c8:	f106 0680 	add.w	r6, r6, #128	; 0x80
 80113cc:	f1a8 0801 	sub.w	r8, r8, #1
 80113d0:	eb10 0008 	adds.w	r0, r0, r8
 80113d4:	6814      	ldr	r4, [r2, #0]
 80113d6:	681d      	ldr	r5, [r3, #0]
 80113d8:	416c      	adcs	r4, r5
 80113da:	600c      	str	r4, [r1, #0]
 80113dc:	f04f 0000 	mov.w	r0, #0
 80113e0:	eb40 0000 	adc.w	r0, r0, r0
 80113e4:	f102 0204 	add.w	r2, r2, #4
 80113e8:	f103 0304 	add.w	r3, r3, #4
 80113ec:	f101 0104 	add.w	r1, r1, #4
 80113f0:	42b2      	cmp	r2, r6
 80113f2:	d1ed      	bne.n	80113d0 <sp_2048_add_32+0x28>
 80113f4:	6178      	str	r0, [r7, #20]
 80113f6:	60f9      	str	r1, [r7, #12]
 80113f8:	60ba      	str	r2, [r7, #8]
 80113fa:	607b      	str	r3, [r7, #4]
        : [c] "+r" (c), [r] "+r" (r), [a] "+r" (a), [b] "+r" (b)
        :
        : "memory", "r4", "r5", "r6", "r8"
    );

    return c;
 80113fc:	697b      	ldr	r3, [r7, #20]
}
 80113fe:	4618      	mov	r0, r3
 8011400:	371c      	adds	r7, #28
 8011402:	46bd      	mov	sp, r7
 8011404:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8011408:	4770      	bx	lr

0801140a <sp_2048_sub_in_place_32>:
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static sp_digit sp_2048_sub_in_place_32(sp_digit* a,
        const sp_digit* b)
{
 801140a:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 801140e:	b085      	sub	sp, #20
 8011410:	af00      	add	r7, sp, #0
 8011412:	6078      	str	r0, [r7, #4]
 8011414:	6039      	str	r1, [r7, #0]
    sp_digit c = 0;
 8011416:	2300      	movs	r3, #0
 8011418:	60fb      	str	r3, [r7, #12]
    __asm__ __volatile__ (
 801141a:	68f9      	ldr	r1, [r7, #12]
 801141c:	687a      	ldr	r2, [r7, #4]
 801141e:	683b      	ldr	r3, [r7, #0]
 8011420:	4608      	mov	r0, r1
 8011422:	4611      	mov	r1, r2
 8011424:	461a      	mov	r2, r3
 8011426:	4688      	mov	r8, r1
 8011428:	f108 0880 	add.w	r8, r8, #128	; 0x80
 801142c:	f04f 0500 	mov.w	r5, #0
 8011430:	1a2d      	subs	r5, r5, r0
 8011432:	680b      	ldr	r3, [r1, #0]
 8011434:	684c      	ldr	r4, [r1, #4]
 8011436:	6815      	ldr	r5, [r2, #0]
 8011438:	6856      	ldr	r6, [r2, #4]
 801143a:	41ab      	sbcs	r3, r5
 801143c:	41b4      	sbcs	r4, r6
 801143e:	600b      	str	r3, [r1, #0]
 8011440:	604c      	str	r4, [r1, #4]
 8011442:	eb60 0000 	sbc.w	r0, r0, r0
 8011446:	f101 0108 	add.w	r1, r1, #8
 801144a:	f102 0208 	add.w	r2, r2, #8
 801144e:	4541      	cmp	r1, r8
 8011450:	d1ec      	bne.n	801142c <sp_2048_sub_in_place_32+0x22>
 8011452:	60f8      	str	r0, [r7, #12]
 8011454:	6079      	str	r1, [r7, #4]
 8011456:	603a      	str	r2, [r7, #0]
        : [c] "+r" (c), [a] "+r" (a), [b] "+r" (b)
        :
        : "memory", "r3", "r4", "r5", "r6", "r8"
    );

    return c;
 8011458:	68fb      	ldr	r3, [r7, #12]
}
 801145a:	4618      	mov	r0, r3
 801145c:	3714      	adds	r7, #20
 801145e:	46bd      	mov	sp, r7
 8011460:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8011464:	4770      	bx	lr

08011466 <sp_2048_mul_32>:
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_2048_mul_32(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
 8011466:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801146a:	b0c7      	sub	sp, #284	; 0x11c
 801146c:	af00      	add	r7, sp, #0
 801146e:	f107 030c 	add.w	r3, r7, #12
 8011472:	6018      	str	r0, [r3, #0]
 8011474:	f107 0308 	add.w	r3, r7, #8
 8011478:	6019      	str	r1, [r3, #0]
 801147a:	1d3b      	adds	r3, r7, #4
 801147c:	601a      	str	r2, [r3, #0]
    sp_digit tmp_arr[32 * 2];
    sp_digit* tmp = tmp_arr;
 801147e:	f107 0314 	add.w	r3, r7, #20
 8011482:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    __asm__ __volatile__ (
 8011486:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 801148a:	f107 0308 	add.w	r3, r7, #8
 801148e:	6819      	ldr	r1, [r3, #0]
 8011490:	1d3b      	adds	r3, r7, #4
 8011492:	6818      	ldr	r0, [r3, #0]
 8011494:	f04f 0300 	mov.w	r3, #0
 8011498:	f04f 0400 	mov.w	r4, #0
 801149c:	4699      	mov	r9, r3
 801149e:	4694      	mov	ip, r2
 80114a0:	468a      	mov	sl, r1
 80114a2:	4683      	mov	fp, r0
 80114a4:	f04f 0680 	mov.w	r6, #128	; 0x80
 80114a8:	4456      	add	r6, sl
 80114aa:	46b6      	mov	lr, r6
 80114ac:	f04f 0200 	mov.w	r2, #0
 80114b0:	f04f 0500 	mov.w	r5, #0
 80114b4:	f04f 067c 	mov.w	r6, #124	; 0x7c
 80114b8:	4649      	mov	r1, r9
 80114ba:	1b89      	subs	r1, r1, r6
 80114bc:	eb66 0606 	sbc.w	r6, r6, r6
 80114c0:	ea6f 0606 	mvn.w	r6, r6
 80114c4:	ea01 0106 	and.w	r1, r1, r6
 80114c8:	4648      	mov	r0, r9
 80114ca:	eba0 0001 	sub.w	r0, r0, r1
 80114ce:	4451      	add	r1, sl
 80114d0:	4458      	add	r0, fp
 80114d2:	680e      	ldr	r6, [r1, #0]
 80114d4:	f8d0 8000 	ldr.w	r8, [r0]
 80114d8:	fba6 6808 	umull	r6, r8, r6, r8
 80114dc:	199b      	adds	r3, r3, r6
 80114de:	eb54 0408 	adcs.w	r4, r4, r8
 80114e2:	eb45 0502 	adc.w	r5, r5, r2
 80114e6:	f101 0104 	add.w	r1, r1, #4
 80114ea:	f1a0 0004 	sub.w	r0, r0, #4
 80114ee:	4571      	cmp	r1, lr
 80114f0:	d003      	beq.n	80114fa <sp_2048_mul_32+0x94>
 80114f2:	464e      	mov	r6, r9
 80114f4:	4456      	add	r6, sl
 80114f6:	42b1      	cmp	r1, r6
 80114f8:	ddeb      	ble.n	80114d2 <sp_2048_mul_32+0x6c>
 80114fa:	4662      	mov	r2, ip
 80114fc:	46c8      	mov	r8, r9
 80114fe:	f842 3008 	str.w	r3, [r2, r8]
 8011502:	4623      	mov	r3, r4
 8011504:	462c      	mov	r4, r5
 8011506:	f108 0804 	add.w	r8, r8, #4
 801150a:	46c1      	mov	r9, r8
 801150c:	f04f 06f8 	mov.w	r6, #248	; 0xf8
 8011510:	45b0      	cmp	r8, r6
 8011512:	ddcb      	ble.n	80114ac <sp_2048_mul_32+0x46>
 8011514:	f842 3008 	str.w	r3, [r2, r8]
 8011518:	4651      	mov	r1, sl
 801151a:	4658      	mov	r0, fp
        :
        : [r] "r" (tmp), [a] "r" (a), [b] "r" (b)
        : "memory", "r3", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r12", "r14"
    );

    XMEMCPY(r, tmp_arr, sizeof(tmp_arr));
 801151c:	f107 0114 	add.w	r1, r7, #20
 8011520:	f107 030c 	add.w	r3, r7, #12
 8011524:	f44f 7280 	mov.w	r2, #256	; 0x100
 8011528:	6818      	ldr	r0, [r3, #0]
 801152a:	f007 ff64 	bl	80193f6 <memcpy>
}
 801152e:	bf00      	nop
 8011530:	f507 778e 	add.w	r7, r7, #284	; 0x11c
 8011534:	46bd      	mov	sp, r7
 8011536:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0801153a <sp_2048_sqr_32>:
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_2048_sqr_32(sp_digit* r, const sp_digit* a)
{
 801153a:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 801153e:	b082      	sub	sp, #8
 8011540:	af00      	add	r7, sp, #0
 8011542:	6078      	str	r0, [r7, #4]
 8011544:	6039      	str	r1, [r7, #0]
    __asm__ __volatile__ (
 8011546:	6879      	ldr	r1, [r7, #4]
 8011548:	6838      	ldr	r0, [r7, #0]
 801154a:	f04f 0300 	mov.w	r3, #0
 801154e:	f04f 0400 	mov.w	r4, #0
 8011552:	f04f 0500 	mov.w	r5, #0
 8011556:	4699      	mov	r9, r3
 8011558:	468c      	mov	ip, r1
 801155a:	f04f 0601 	mov.w	r6, #1
 801155e:	ea4f 2606 	mov.w	r6, r6, lsl #8
 8011562:	f1c6 0600 	rsb	r6, r6, #0
 8011566:	44b5      	add	sp, r6
 8011568:	46eb      	mov	fp, sp
 801156a:	4682      	mov	sl, r0
 801156c:	f04f 0100 	mov.w	r1, #0
 8011570:	f04f 067c 	mov.w	r6, #124	; 0x7c
 8011574:	4648      	mov	r0, r9
 8011576:	1b80      	subs	r0, r0, r6
 8011578:	eb66 0606 	sbc.w	r6, r6, r6
 801157c:	ea6f 0606 	mvn.w	r6, r6
 8011580:	ea00 0006 	and.w	r0, r0, r6
 8011584:	464a      	mov	r2, r9
 8011586:	eba2 0200 	sub.w	r2, r2, r0
 801158a:	4450      	add	r0, sl
 801158c:	4452      	add	r2, sl
 801158e:	4282      	cmp	r2, r0
 8011590:	d00f      	beq.n	80115b2 <sp_2048_sqr_32+0x78>
 8011592:	6806      	ldr	r6, [r0, #0]
 8011594:	f8d2 8000 	ldr.w	r8, [r2]
 8011598:	fba6 6808 	umull	r6, r8, r6, r8
 801159c:	199b      	adds	r3, r3, r6
 801159e:	eb54 0408 	adcs.w	r4, r4, r8
 80115a2:	eb45 0501 	adc.w	r5, r5, r1
 80115a6:	199b      	adds	r3, r3, r6
 80115a8:	eb54 0408 	adcs.w	r4, r4, r8
 80115ac:	eb45 0501 	adc.w	r5, r5, r1
 80115b0:	e007      	b.n	80115c2 <sp_2048_sqr_32+0x88>
 80115b2:	6806      	ldr	r6, [r0, #0]
 80115b4:	fba6 6806 	umull	r6, r8, r6, r6
 80115b8:	199b      	adds	r3, r3, r6
 80115ba:	eb54 0408 	adcs.w	r4, r4, r8
 80115be:	eb45 0501 	adc.w	r5, r5, r1
 80115c2:	f100 0004 	add.w	r0, r0, #4
 80115c6:	f1a2 0204 	sub.w	r2, r2, #4
 80115ca:	f04f 0680 	mov.w	r6, #128	; 0x80
 80115ce:	4456      	add	r6, sl
 80115d0:	42b0      	cmp	r0, r6
 80115d2:	d005      	beq.n	80115e0 <sp_2048_sqr_32+0xa6>
 80115d4:	4290      	cmp	r0, r2
 80115d6:	dc03      	bgt.n	80115e0 <sp_2048_sqr_32+0xa6>
 80115d8:	46c8      	mov	r8, r9
 80115da:	44d0      	add	r8, sl
 80115dc:	4540      	cmp	r0, r8
 80115de:	ddd6      	ble.n	801158e <sp_2048_sqr_32+0x54>
 80115e0:	4659      	mov	r1, fp
 80115e2:	46c8      	mov	r8, r9
 80115e4:	f841 3008 	str.w	r3, [r1, r8]
 80115e8:	4623      	mov	r3, r4
 80115ea:	462c      	mov	r4, r5
 80115ec:	f04f 0500 	mov.w	r5, #0
 80115f0:	f108 0804 	add.w	r8, r8, #4
 80115f4:	46c1      	mov	r9, r8
 80115f6:	f04f 06f8 	mov.w	r6, #248	; 0xf8
 80115fa:	45b0      	cmp	r8, r6
 80115fc:	ddb6      	ble.n	801156c <sp_2048_sqr_32+0x32>
 80115fe:	4650      	mov	r0, sl
 8011600:	f841 3008 	str.w	r3, [r1, r8]
 8011604:	4661      	mov	r1, ip
 8011606:	4658      	mov	r0, fp
 8011608:	f04f 03fc 	mov.w	r3, #252	; 0xfc
 801160c:	58c6      	ldr	r6, [r0, r3]
 801160e:	50ce      	str	r6, [r1, r3]
 8011610:	3b04      	subs	r3, #4
 8011612:	dafb      	bge.n	801160c <sp_2048_sqr_32+0xd2>
 8011614:	f04f 0601 	mov.w	r6, #1
 8011618:	ea4f 2606 	mov.w	r6, r6, lsl #8
 801161c:	44b5      	add	sp, r6
        "add	sp, sp, r6\n\t"
        :
        : [r] "r" (r), [a] "r" (a)
        : "memory", "r2", "r3", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r12"
    );
}
 801161e:	bf00      	nop
 8011620:	3708      	adds	r7, #8
 8011622:	46bd      	mov	sp, r7
 8011624:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8011628:	4770      	bx	lr

0801162a <sp_2048_mont_setup>:
 *
 * a    A single precision number.
 * rho  Bottom word of inverse.
 */
static void sp_2048_mont_setup(const sp_digit* a, sp_digit* rho)
{
 801162a:	b480      	push	{r7}
 801162c:	b085      	sub	sp, #20
 801162e:	af00      	add	r7, sp, #0
 8011630:	6078      	str	r0, [r7, #4]
 8011632:	6039      	str	r1, [r7, #0]
    sp_digit x, b;

    b = a[0];
 8011634:	687b      	ldr	r3, [r7, #4]
 8011636:	681b      	ldr	r3, [r3, #0]
 8011638:	60fb      	str	r3, [r7, #12]
    x = (((b + 2) & 4) << 1) + b; /* here x*a==1 mod 2**4 */
 801163a:	68fb      	ldr	r3, [r7, #12]
 801163c:	3302      	adds	r3, #2
 801163e:	005b      	lsls	r3, r3, #1
 8011640:	f003 0308 	and.w	r3, r3, #8
 8011644:	68fa      	ldr	r2, [r7, #12]
 8011646:	4413      	add	r3, r2
 8011648:	60bb      	str	r3, [r7, #8]
    x *= 2 - b * x;               /* here x*a==1 mod 2**8 */
 801164a:	68fb      	ldr	r3, [r7, #12]
 801164c:	68ba      	ldr	r2, [r7, #8]
 801164e:	fb02 f303 	mul.w	r3, r2, r3
 8011652:	f1c3 0202 	rsb	r2, r3, #2
 8011656:	68bb      	ldr	r3, [r7, #8]
 8011658:	fb02 f303 	mul.w	r3, r2, r3
 801165c:	60bb      	str	r3, [r7, #8]
    x *= 2 - b * x;               /* here x*a==1 mod 2**16 */
 801165e:	68fb      	ldr	r3, [r7, #12]
 8011660:	68ba      	ldr	r2, [r7, #8]
 8011662:	fb02 f303 	mul.w	r3, r2, r3
 8011666:	f1c3 0202 	rsb	r2, r3, #2
 801166a:	68bb      	ldr	r3, [r7, #8]
 801166c:	fb02 f303 	mul.w	r3, r2, r3
 8011670:	60bb      	str	r3, [r7, #8]
    x *= 2 - b * x;               /* here x*a==1 mod 2**32 */
 8011672:	68fb      	ldr	r3, [r7, #12]
 8011674:	68ba      	ldr	r2, [r7, #8]
 8011676:	fb02 f303 	mul.w	r3, r2, r3
 801167a:	f1c3 0202 	rsb	r2, r3, #2
 801167e:	68bb      	ldr	r3, [r7, #8]
 8011680:	fb02 f303 	mul.w	r3, r2, r3
 8011684:	60bb      	str	r3, [r7, #8]

    /* rho = -1/m mod b */
    *rho = -x;
 8011686:	68bb      	ldr	r3, [r7, #8]
 8011688:	425a      	negs	r2, r3
 801168a:	683b      	ldr	r3, [r7, #0]
 801168c:	601a      	str	r2, [r3, #0]
}
 801168e:	bf00      	nop
 8011690:	3714      	adds	r7, #20
 8011692:	46bd      	mov	sp, r7
 8011694:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011698:	4770      	bx	lr

0801169a <sp_2048_mul_d_64>:
 * a  A single precision integer.
 * b  A single precision digit.
 */
SP_NOINLINE static void sp_2048_mul_d_64(sp_digit* r, const sp_digit* a,
        sp_digit b)
{
 801169a:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 801169e:	b084      	sub	sp, #16
 80116a0:	af00      	add	r7, sp, #0
 80116a2:	60f8      	str	r0, [r7, #12]
 80116a4:	60b9      	str	r1, [r7, #8]
 80116a6:	607a      	str	r2, [r7, #4]
    __asm__ __volatile__ (
 80116a8:	6878      	ldr	r0, [r7, #4]
 80116aa:	68fa      	ldr	r2, [r7, #12]
 80116ac:	68bb      	ldr	r3, [r7, #8]
 80116ae:	4611      	mov	r1, r2
 80116b0:	461a      	mov	r2, r3
 80116b2:	f502 7980 	add.w	r9, r2, #256	; 0x100
 80116b6:	f852 6b04 	ldr.w	r6, [r2], #4
 80116ba:	fba6 5300 	umull	r5, r3, r6, r0
 80116be:	f04f 0400 	mov.w	r4, #0
 80116c2:	f841 5b04 	str.w	r5, [r1], #4
 80116c6:	f04f 0500 	mov.w	r5, #0
 80116ca:	f852 6b04 	ldr.w	r6, [r2], #4
 80116ce:	fba6 6800 	umull	r6, r8, r6, r0
 80116d2:	199b      	adds	r3, r3, r6
 80116d4:	eb54 0408 	adcs.w	r4, r4, r8
 80116d8:	f145 0500 	adc.w	r5, r5, #0
 80116dc:	f841 3b04 	str.w	r3, [r1], #4
 80116e0:	4623      	mov	r3, r4
 80116e2:	462c      	mov	r4, r5
 80116e4:	454a      	cmp	r2, r9
 80116e6:	dbee      	blt.n	80116c6 <sp_2048_mul_d_64+0x2c>
 80116e8:	600b      	str	r3, [r1, #0]
 80116ea:	60f9      	str	r1, [r7, #12]
 80116ec:	60ba      	str	r2, [r7, #8]
        "str	r3, [%[r]]\n\t"
        : [r] "+r" (r), [a] "+r" (a)
        : [b] "r" (b)
        : "memory", "r3", "r4", "r5", "r6", "r8", "r9"
    );
}
 80116ee:	bf00      	nop
 80116f0:	3710      	adds	r7, #16
 80116f2:	46bd      	mov	sp, r7
 80116f4:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 80116f8:	4770      	bx	lr

080116fa <sp_2048_mont_norm_32>:
 *
 * r  A single precision number.
 * m  A single precision number.
 */
static void sp_2048_mont_norm_32(sp_digit* r, const sp_digit* m)
{
 80116fa:	b580      	push	{r7, lr}
 80116fc:	b082      	sub	sp, #8
 80116fe:	af00      	add	r7, sp, #0
 8011700:	6078      	str	r0, [r7, #4]
 8011702:	6039      	str	r1, [r7, #0]
    XMEMSET(r, 0, sizeof(sp_digit) * 32);
 8011704:	2280      	movs	r2, #128	; 0x80
 8011706:	2100      	movs	r1, #0
 8011708:	6878      	ldr	r0, [r7, #4]
 801170a:	f007 fe98 	bl	801943e <memset>

    /* r = 2^n mod m */
    sp_2048_sub_in_place_32(r, m);
 801170e:	6839      	ldr	r1, [r7, #0]
 8011710:	6878      	ldr	r0, [r7, #4]
 8011712:	f7ff fe7a 	bl	801140a <sp_2048_sub_in_place_32>
}
 8011716:	bf00      	nop
 8011718:	3708      	adds	r7, #8
 801171a:	46bd      	mov	sp, r7
 801171c:	bd80      	pop	{r7, pc}

0801171e <sp_2048_cond_sub_32>:
 * b  A single precision number to subtract.
 * m  Mask value to apply.
 */
SP_NOINLINE static sp_digit sp_2048_cond_sub_32(sp_digit* r, const sp_digit* a,
        const sp_digit* b, sp_digit m)
{
 801171e:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 8011722:	b086      	sub	sp, #24
 8011724:	af00      	add	r7, sp, #0
 8011726:	60f8      	str	r0, [r7, #12]
 8011728:	60b9      	str	r1, [r7, #8]
 801172a:	607a      	str	r2, [r7, #4]
 801172c:	603b      	str	r3, [r7, #0]
    sp_digit c = 0;
 801172e:	2300      	movs	r3, #0
 8011730:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 8011732:	68fa      	ldr	r2, [r7, #12]
 8011734:	68b9      	ldr	r1, [r7, #8]
 8011736:	6878      	ldr	r0, [r7, #4]
 8011738:	683c      	ldr	r4, [r7, #0]
 801173a:	697b      	ldr	r3, [r7, #20]
 801173c:	f04f 0580 	mov.w	r5, #128	; 0x80
 8011740:	46a9      	mov	r9, r5
 8011742:	f04f 0800 	mov.w	r8, #0
 8011746:	f850 6008 	ldr.w	r6, [r0, r8]
 801174a:	ea06 0604 	and.w	r6, r6, r4
 801174e:	f04f 0500 	mov.w	r5, #0
 8011752:	1aed      	subs	r5, r5, r3
 8011754:	f851 5008 	ldr.w	r5, [r1, r8]
 8011758:	41b5      	sbcs	r5, r6
 801175a:	419b      	sbcs	r3, r3
 801175c:	f842 5008 	str.w	r5, [r2, r8]
 8011760:	f108 0804 	add.w	r8, r8, #4
 8011764:	45c8      	cmp	r8, r9
 8011766:	dbee      	blt.n	8011746 <sp_2048_cond_sub_32+0x28>
 8011768:	617b      	str	r3, [r7, #20]
        : [c] "+r" (c)
        : [r] "r" (r), [a] "r" (a), [b] "r" (b), [m] "r" (m)
        : "memory", "r5", "r6", "r8", "r9"
    );

    return c;
 801176a:	697b      	ldr	r3, [r7, #20]
}
 801176c:	4618      	mov	r0, r3
 801176e:	3718      	adds	r7, #24
 8011770:	46bd      	mov	sp, r7
 8011772:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8011776:	4770      	bx	lr

08011778 <sp_2048_mont_reduce_32>:
 * m   The single precision number representing the modulus.
 * mp  The digit representing the negative inverse of m mod 2^n.
 */
SP_NOINLINE static void sp_2048_mont_reduce_32(sp_digit* a, const sp_digit* m,
        sp_digit mp)
{
 8011778:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801177c:	b087      	sub	sp, #28
 801177e:	af00      	add	r7, sp, #0
 8011780:	60f8      	str	r0, [r7, #12]
 8011782:	60b9      	str	r1, [r7, #8]
 8011784:	607a      	str	r2, [r7, #4]
    sp_digit ca = 0;
 8011786:	2300      	movs	r3, #0
 8011788:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 801178a:	68b9      	ldr	r1, [r7, #8]
 801178c:	6878      	ldr	r0, [r7, #4]
 801178e:	697a      	ldr	r2, [r7, #20]
 8011790:	68fb      	ldr	r3, [r7, #12]
 8011792:	4681      	mov	r9, r0
 8011794:	468c      	mov	ip, r1
 8011796:	469a      	mov	sl, r3
 8011798:	f04f 0400 	mov.w	r4, #0
 801179c:	f10a 0b80 	add.w	fp, sl, #128	; 0x80
 80117a0:	4648      	mov	r0, r9
 80117a2:	f8da 3000 	ldr.w	r3, [sl]
 80117a6:	fb00 f003 	mul.w	r0, r0, r3
 80117aa:	4661      	mov	r1, ip
 80117ac:	f10a 0e78 	add.w	lr, sl, #120	; 0x78
 80117b0:	f8da 3000 	ldr.w	r3, [sl]
 80117b4:	f04f 0500 	mov.w	r5, #0
 80117b8:	f851 8b04 	ldr.w	r8, [r1], #4
 80117bc:	fba0 6808 	umull	r6, r8, r0, r8
 80117c0:	199b      	adds	r3, r3, r6
 80117c2:	eb45 0508 	adc.w	r5, r5, r8
 80117c6:	18e4      	adds	r4, r4, r3
 80117c8:	f145 0500 	adc.w	r5, r5, #0
 80117cc:	f84a 4b04 	str.w	r4, [sl], #4
 80117d0:	f8da 3000 	ldr.w	r3, [sl]
 80117d4:	f04f 0400 	mov.w	r4, #0
 80117d8:	f851 8b04 	ldr.w	r8, [r1], #4
 80117dc:	fba0 6808 	umull	r6, r8, r0, r8
 80117e0:	199b      	adds	r3, r3, r6
 80117e2:	eb44 0408 	adc.w	r4, r4, r8
 80117e6:	18ed      	adds	r5, r5, r3
 80117e8:	f144 0400 	adc.w	r4, r4, #0
 80117ec:	f84a 5b04 	str.w	r5, [sl], #4
 80117f0:	45f2      	cmp	sl, lr
 80117f2:	dbdd      	blt.n	80117b0 <sp_2048_mont_reduce_32+0x38>
 80117f4:	f8da 3000 	ldr.w	r3, [sl]
 80117f8:	f04f 0500 	mov.w	r5, #0
 80117fc:	f851 8b04 	ldr.w	r8, [r1], #4
 8011800:	fba0 6808 	umull	r6, r8, r0, r8
 8011804:	199b      	adds	r3, r3, r6
 8011806:	eb45 0508 	adc.w	r5, r5, r8
 801180a:	18e4      	adds	r4, r4, r3
 801180c:	f145 0500 	adc.w	r5, r5, #0
 8011810:	f84a 4b04 	str.w	r4, [sl], #4
 8011814:	4614      	mov	r4, r2
 8011816:	f04f 0200 	mov.w	r2, #0
 801181a:	f8d1 8000 	ldr.w	r8, [r1]
 801181e:	fba0 6808 	umull	r6, r8, r0, r8
 8011822:	19ad      	adds	r5, r5, r6
 8011824:	eb54 0408 	adcs.w	r4, r4, r8
 8011828:	f142 0200 	adc.w	r2, r2, #0
 801182c:	f8da 6000 	ldr.w	r6, [sl]
 8011830:	f8da 8004 	ldr.w	r8, [sl, #4]
 8011834:	1976      	adds	r6, r6, r5
 8011836:	eb58 0804 	adcs.w	r8, r8, r4
 801183a:	f142 0200 	adc.w	r2, r2, #0
 801183e:	f8ca 6000 	str.w	r6, [sl]
 8011842:	f8ca 8004 	str.w	r8, [sl, #4]
 8011846:	f1aa 0a78 	sub.w	sl, sl, #120	; 0x78
 801184a:	45da      	cmp	sl, fp
 801184c:	dba8      	blt.n	80117a0 <sp_2048_mont_reduce_32+0x28>
 801184e:	4653      	mov	r3, sl
 8011850:	4661      	mov	r1, ip
 8011852:	617a      	str	r2, [r7, #20]
 8011854:	60fb      	str	r3, [r7, #12]
        : [ca] "+r" (ca), [a] "+r" (a)
        : [m] "r" (m), [mp] "r" (mp)
        : "memory", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r12", "r14"
    );

    sp_2048_cond_sub_32(a - 32, a, m, (sp_digit)0 - ca);
 8011856:	68fb      	ldr	r3, [r7, #12]
 8011858:	f1a3 0080 	sub.w	r0, r3, #128	; 0x80
 801185c:	697b      	ldr	r3, [r7, #20]
 801185e:	425b      	negs	r3, r3
 8011860:	68ba      	ldr	r2, [r7, #8]
 8011862:	68f9      	ldr	r1, [r7, #12]
 8011864:	f7ff ff5b 	bl	801171e <sp_2048_cond_sub_32>
}
 8011868:	bf00      	nop
 801186a:	371c      	adds	r7, #28
 801186c:	46bd      	mov	sp, r7
 801186e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08011872 <sp_2048_mont_mul_32>:
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_2048_mont_mul_32(sp_digit* r, const sp_digit* a, const sp_digit* b,
        const sp_digit* m, sp_digit mp)
{
 8011872:	b580      	push	{r7, lr}
 8011874:	b084      	sub	sp, #16
 8011876:	af00      	add	r7, sp, #0
 8011878:	60f8      	str	r0, [r7, #12]
 801187a:	60b9      	str	r1, [r7, #8]
 801187c:	607a      	str	r2, [r7, #4]
 801187e:	603b      	str	r3, [r7, #0]
    sp_2048_mul_32(r, a, b);
 8011880:	687a      	ldr	r2, [r7, #4]
 8011882:	68b9      	ldr	r1, [r7, #8]
 8011884:	68f8      	ldr	r0, [r7, #12]
 8011886:	f7ff fdee 	bl	8011466 <sp_2048_mul_32>
    sp_2048_mont_reduce_32(r, m, mp);
 801188a:	69ba      	ldr	r2, [r7, #24]
 801188c:	6839      	ldr	r1, [r7, #0]
 801188e:	68f8      	ldr	r0, [r7, #12]
 8011890:	f7ff ff72 	bl	8011778 <sp_2048_mont_reduce_32>
}
 8011894:	bf00      	nop
 8011896:	3710      	adds	r7, #16
 8011898:	46bd      	mov	sp, r7
 801189a:	bd80      	pop	{r7, pc}

0801189c <sp_2048_mont_sqr_32>:
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_2048_mont_sqr_32(sp_digit* r, const sp_digit* a, const sp_digit* m,
        sp_digit mp)
{
 801189c:	b580      	push	{r7, lr}
 801189e:	b084      	sub	sp, #16
 80118a0:	af00      	add	r7, sp, #0
 80118a2:	60f8      	str	r0, [r7, #12]
 80118a4:	60b9      	str	r1, [r7, #8]
 80118a6:	607a      	str	r2, [r7, #4]
 80118a8:	603b      	str	r3, [r7, #0]
    sp_2048_sqr_32(r, a);
 80118aa:	68b9      	ldr	r1, [r7, #8]
 80118ac:	68f8      	ldr	r0, [r7, #12]
 80118ae:	f7ff fe44 	bl	801153a <sp_2048_sqr_32>
    sp_2048_mont_reduce_32(r, m, mp);
 80118b2:	683a      	ldr	r2, [r7, #0]
 80118b4:	6879      	ldr	r1, [r7, #4]
 80118b6:	68f8      	ldr	r0, [r7, #12]
 80118b8:	f7ff ff5e 	bl	8011778 <sp_2048_mont_reduce_32>
}
 80118bc:	bf00      	nop
 80118be:	3710      	adds	r7, #16
 80118c0:	46bd      	mov	sp, r7
 80118c2:	bd80      	pop	{r7, pc}

080118c4 <sp_2048_mul_d_32>:
 * a  A single precision integer.
 * b  A single precision digit.
 */
SP_NOINLINE static void sp_2048_mul_d_32(sp_digit* r, const sp_digit* a,
        sp_digit b)
{
 80118c4:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 80118c8:	b084      	sub	sp, #16
 80118ca:	af00      	add	r7, sp, #0
 80118cc:	60f8      	str	r0, [r7, #12]
 80118ce:	60b9      	str	r1, [r7, #8]
 80118d0:	607a      	str	r2, [r7, #4]
    __asm__ __volatile__ (
 80118d2:	6878      	ldr	r0, [r7, #4]
 80118d4:	68fa      	ldr	r2, [r7, #12]
 80118d6:	68bb      	ldr	r3, [r7, #8]
 80118d8:	4611      	mov	r1, r2
 80118da:	461a      	mov	r2, r3
 80118dc:	f102 0980 	add.w	r9, r2, #128	; 0x80
 80118e0:	f852 6b04 	ldr.w	r6, [r2], #4
 80118e4:	fba6 5300 	umull	r5, r3, r6, r0
 80118e8:	f04f 0400 	mov.w	r4, #0
 80118ec:	f841 5b04 	str.w	r5, [r1], #4
 80118f0:	f04f 0500 	mov.w	r5, #0
 80118f4:	f852 6b04 	ldr.w	r6, [r2], #4
 80118f8:	fba6 6800 	umull	r6, r8, r6, r0
 80118fc:	199b      	adds	r3, r3, r6
 80118fe:	eb54 0408 	adcs.w	r4, r4, r8
 8011902:	f145 0500 	adc.w	r5, r5, #0
 8011906:	f841 3b04 	str.w	r3, [r1], #4
 801190a:	4623      	mov	r3, r4
 801190c:	462c      	mov	r4, r5
 801190e:	454a      	cmp	r2, r9
 8011910:	dbee      	blt.n	80118f0 <sp_2048_mul_d_32+0x2c>
 8011912:	600b      	str	r3, [r1, #0]
 8011914:	60f9      	str	r1, [r7, #12]
 8011916:	60ba      	str	r2, [r7, #8]
        "str	r3, [%[r]]\n\t"
        : [r] "+r" (r), [a] "+r" (a)
        : [b] "r" (b)
        : "memory", "r3", "r4", "r5", "r6", "r8", "r9"
    );
}
 8011918:	bf00      	nop
 801191a:	3710      	adds	r7, #16
 801191c:	46bd      	mov	sp, r7
 801191e:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8011922:	4770      	bx	lr

08011924 <div_2048_word_32>:
 *
 * Note that this is an approximate div. It may give an answer 1 larger.
 */
SP_NOINLINE static sp_digit div_2048_word_32(sp_digit d1, sp_digit d0,
        sp_digit div)
{
 8011924:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 8011928:	b087      	sub	sp, #28
 801192a:	af00      	add	r7, sp, #0
 801192c:	60f8      	str	r0, [r7, #12]
 801192e:	60b9      	str	r1, [r7, #8]
 8011930:	607a      	str	r2, [r7, #4]
    sp_digit r = 0;
 8011932:	2300      	movs	r3, #0
 8011934:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 8011936:	68fa      	ldr	r2, [r7, #12]
 8011938:	68b9      	ldr	r1, [r7, #8]
 801193a:	6878      	ldr	r0, [r7, #4]
 801193c:	697b      	ldr	r3, [r7, #20]
 801193e:	ea4f 4610 	mov.w	r6, r0, lsr #16
 8011942:	f106 0601 	add.w	r6, r6, #1
 8011946:	fbb2 f4f6 	udiv	r4, r2, r6
 801194a:	ea4f 4804 	mov.w	r8, r4, lsl #16
 801194e:	fba0 4508 	umull	r4, r5, r0, r8
 8011952:	1b09      	subs	r1, r1, r4
 8011954:	eb62 0205 	sbc.w	r2, r2, r5
 8011958:	fbb2 f5f6 	udiv	r5, r2, r6
 801195c:	ea4f 4405 	mov.w	r4, r5, lsl #16
 8011960:	44a0      	add	r8, r4
 8011962:	fba0 4504 	umull	r4, r5, r0, r4
 8011966:	1b09      	subs	r1, r1, r4
 8011968:	eb62 0205 	sbc.w	r2, r2, r5
 801196c:	ea4f 4402 	mov.w	r4, r2, lsl #16
 8011970:	ea44 4411 	orr.w	r4, r4, r1, lsr #16
 8011974:	fbb4 f4f6 	udiv	r4, r4, r6
 8011978:	44a0      	add	r8, r4
 801197a:	fba0 4504 	umull	r4, r5, r0, r4
 801197e:	1b09      	subs	r1, r1, r4
 8011980:	eb62 0205 	sbc.w	r2, r2, r5
 8011984:	ea4f 4402 	mov.w	r4, r2, lsl #16
 8011988:	ea44 4411 	orr.w	r4, r4, r1, lsr #16
 801198c:	fbb4 f4f6 	udiv	r4, r4, r6
 8011990:	44a0      	add	r8, r4
 8011992:	fba0 4504 	umull	r4, r5, r0, r4
 8011996:	1b09      	subs	r1, r1, r4
 8011998:	eb62 0205 	sbc.w	r2, r2, r5
 801199c:	fbb1 f4f0 	udiv	r4, r1, r0
 80119a0:	44a0      	add	r8, r4
 80119a2:	4643      	mov	r3, r8
 80119a4:	617b      	str	r3, [r7, #20]
        "mov	%[r], r8\n\t"
        : [r] "+r" (r)
        : [d1] "r" (d1), [d0] "r" (d0), [div] "r" (div)
        : "r4", "r5", "r6", "r8"
    );
    return r;
 80119a6:	697b      	ldr	r3, [r7, #20]
}
 80119a8:	4618      	mov	r0, r3
 80119aa:	371c      	adds	r7, #28
 80119ac:	46bd      	mov	sp, r7
 80119ae:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 80119b2:	4770      	bx	lr

080119b4 <sp_2048_cmp_32>:
 * b  A single precision integer.
 * return -ve, 0 or +ve if a is less than, equal to or greater than b
 * respectively.
 */
SP_NOINLINE static int32_t sp_2048_cmp_32(const sp_digit* a, const sp_digit* b)
{
 80119b4:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 80119b8:	b085      	sub	sp, #20
 80119ba:	af00      	add	r7, sp, #0
 80119bc:	6078      	str	r0, [r7, #4]
 80119be:	6039      	str	r1, [r7, #0]
    sp_digit r = 0;
 80119c0:	2300      	movs	r3, #0
 80119c2:	60fb      	str	r3, [r7, #12]


    __asm__ __volatile__ (
 80119c4:	6879      	ldr	r1, [r7, #4]
 80119c6:	6838      	ldr	r0, [r7, #0]
 80119c8:	68fb      	ldr	r3, [r7, #12]
 80119ca:	461a      	mov	r2, r3
 80119cc:	f04f 0300 	mov.w	r3, #0
 80119d0:	ea6f 0303 	mvn.w	r3, r3
 80119d4:	f04f 067c 	mov.w	r6, #124	; 0x7c
 80119d8:	f851 8006 	ldr.w	r8, [r1, r6]
 80119dc:	5985      	ldr	r5, [r0, r6]
 80119de:	ea08 0803 	and.w	r8, r8, r3
 80119e2:	ea05 0503 	and.w	r5, r5, r3
 80119e6:	4644      	mov	r4, r8
 80119e8:	ebb8 0805 	subs.w	r8, r8, r5
 80119ec:	eb68 0808 	sbc.w	r8, r8, r8
 80119f0:	4442      	add	r2, r8
 80119f2:	ea6f 0808 	mvn.w	r8, r8
 80119f6:	ea03 0308 	and.w	r3, r3, r8
 80119fa:	1b2d      	subs	r5, r5, r4
 80119fc:	eb68 0808 	sbc.w	r8, r8, r8
 8011a00:	eba2 0208 	sub.w	r2, r2, r8
 8011a04:	ea6f 0808 	mvn.w	r8, r8
 8011a08:	ea03 0308 	and.w	r3, r3, r8
 8011a0c:	f1a6 0604 	sub.w	r6, r6, #4
 8011a10:	2e00      	cmp	r6, #0
 8011a12:	dae1      	bge.n	80119d8 <sp_2048_cmp_32+0x24>
 8011a14:	60fa      	str	r2, [r7, #12]
        : [r] "+r" (r)
        : [a] "r" (a), [b] "r" (b)
        : "r3", "r4", "r5", "r6", "r8"
    );

    return r;
 8011a16:	68fb      	ldr	r3, [r7, #12]
}
 8011a18:	4618      	mov	r0, r3
 8011a1a:	3714      	adds	r7, #20
 8011a1c:	46bd      	mov	sp, r7
 8011a1e:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8011a22:	4770      	bx	lr

08011a24 <sp_2048_div_32>:
 * r  Remainder from the division.
 * returns MP_OKAY indicating success.
 */
static WC_INLINE int sp_2048_div_32(const sp_digit* a, const sp_digit* d, sp_digit* m,
        sp_digit* r)
{
 8011a24:	b590      	push	{r4, r7, lr}
 8011a26:	b0eb      	sub	sp, #428	; 0x1ac
 8011a28:	af00      	add	r7, sp, #0
 8011a2a:	f107 040c 	add.w	r4, r7, #12
 8011a2e:	6020      	str	r0, [r4, #0]
 8011a30:	f107 0008 	add.w	r0, r7, #8
 8011a34:	6001      	str	r1, [r0, #0]
 8011a36:	1d39      	adds	r1, r7, #4
 8011a38:	600a      	str	r2, [r1, #0]
 8011a3a:	463a      	mov	r2, r7
 8011a3c:	6013      	str	r3, [r2, #0]
    sp_digit div, r1;
    int i;

    (void)m;

    div = d[31];
 8011a3e:	f107 0308 	add.w	r3, r7, #8
 8011a42:	681b      	ldr	r3, [r3, #0]
 8011a44:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8011a46:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
    XMEMCPY(t1, a, sizeof(*t1) * 2 * 32);
 8011a4a:	f107 030c 	add.w	r3, r7, #12
 8011a4e:	f107 0098 	add.w	r0, r7, #152	; 0x98
 8011a52:	f44f 7280 	mov.w	r2, #256	; 0x100
 8011a56:	6819      	ldr	r1, [r3, #0]
 8011a58:	f007 fccd 	bl	80193f6 <memcpy>
    for (i=31; i>=0; i--) {
 8011a5c:	231f      	movs	r3, #31
 8011a5e:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 8011a62:	e0cb      	b.n	8011bfc <sp_2048_div_32+0x1d8>
        sp_digit hi = t1[32 + i] - (t1[32 + i] == div);
 8011a64:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8011a68:	f103 0220 	add.w	r2, r3, #32
 8011a6c:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8011a70:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011a74:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 8011a78:	f102 0120 	add.w	r1, r2, #32
 8011a7c:	f107 0298 	add.w	r2, r7, #152	; 0x98
 8011a80:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8011a84:	f8d7 11a0 	ldr.w	r1, [r7, #416]	; 0x1a0
 8011a88:	4291      	cmp	r1, r2
 8011a8a:	bf0c      	ite	eq
 8011a8c:	2201      	moveq	r2, #1
 8011a8e:	2200      	movne	r2, #0
 8011a90:	b2d2      	uxtb	r2, r2
 8011a92:	1a9b      	subs	r3, r3, r2
 8011a94:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
        r1 = div_2048_word_32(hi, t1[32 + i - 1], div);
 8011a98:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8011a9c:	f103 021f 	add.w	r2, r3, #31
 8011aa0:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8011aa4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011aa8:	f8d7 21a0 	ldr.w	r2, [r7, #416]	; 0x1a0
 8011aac:	4619      	mov	r1, r3
 8011aae:	f8d7 0198 	ldr.w	r0, [r7, #408]	; 0x198
 8011ab2:	f7ff ff37 	bl	8011924 <div_2048_word_32>
 8011ab6:	f8c7 019c 	str.w	r0, [r7, #412]	; 0x19c

        sp_2048_mul_d_32(t2, d, r1);
 8011aba:	f107 0308 	add.w	r3, r7, #8
 8011abe:	f107 0014 	add.w	r0, r7, #20
 8011ac2:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 8011ac6:	6819      	ldr	r1, [r3, #0]
 8011ac8:	f7ff fefc 	bl	80118c4 <sp_2048_mul_d_32>
        t1[32 + i] += sp_2048_sub_in_place_32(&t1[i], t2);
 8011acc:	f107 0298 	add.w	r2, r7, #152	; 0x98
 8011ad0:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8011ad4:	009b      	lsls	r3, r3, #2
 8011ad6:	4413      	add	r3, r2
 8011ad8:	f107 0214 	add.w	r2, r7, #20
 8011adc:	4611      	mov	r1, r2
 8011ade:	4618      	mov	r0, r3
 8011ae0:	f7ff fc93 	bl	801140a <sp_2048_sub_in_place_32>
 8011ae4:	4601      	mov	r1, r0
 8011ae6:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8011aea:	f103 0220 	add.w	r2, r3, #32
 8011aee:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8011af2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011af6:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 8011afa:	3220      	adds	r2, #32
 8011afc:	4419      	add	r1, r3
 8011afe:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8011b02:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        t1[32 + i] -= t2[32];
 8011b06:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8011b0a:	f103 0220 	add.w	r2, r3, #32
 8011b0e:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8011b12:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8011b16:	f107 0314 	add.w	r3, r7, #20
 8011b1a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8011b1e:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 8011b22:	3220      	adds	r2, #32
 8011b24:	1ac9      	subs	r1, r1, r3
 8011b26:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8011b2a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        sp_2048_mask_32(t2, d, t1[32 + i]);
 8011b2e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8011b32:	f103 0220 	add.w	r2, r3, #32
 8011b36:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8011b3a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011b3e:	f107 0308 	add.w	r3, r7, #8
 8011b42:	f107 0014 	add.w	r0, r7, #20
 8011b46:	6819      	ldr	r1, [r3, #0]
 8011b48:	f7ff fc0d 	bl	8011366 <sp_2048_mask_32>
        t1[32 + i] += sp_2048_add_32(&t1[i], &t1[i], t2);
 8011b4c:	f107 0298 	add.w	r2, r7, #152	; 0x98
 8011b50:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8011b54:	009b      	lsls	r3, r3, #2
 8011b56:	18d0      	adds	r0, r2, r3
 8011b58:	f107 0298 	add.w	r2, r7, #152	; 0x98
 8011b5c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8011b60:	009b      	lsls	r3, r3, #2
 8011b62:	4413      	add	r3, r2
 8011b64:	f107 0214 	add.w	r2, r7, #20
 8011b68:	4619      	mov	r1, r3
 8011b6a:	f7ff fc1d 	bl	80113a8 <sp_2048_add_32>
 8011b6e:	4601      	mov	r1, r0
 8011b70:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8011b74:	f103 0220 	add.w	r2, r3, #32
 8011b78:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8011b7c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011b80:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 8011b84:	3220      	adds	r2, #32
 8011b86:	4419      	add	r1, r3
 8011b88:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8011b8c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        sp_2048_mask_32(t2, d, t1[32 + i]);
 8011b90:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8011b94:	f103 0220 	add.w	r2, r3, #32
 8011b98:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8011b9c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011ba0:	f107 0308 	add.w	r3, r7, #8
 8011ba4:	f107 0014 	add.w	r0, r7, #20
 8011ba8:	6819      	ldr	r1, [r3, #0]
 8011baa:	f7ff fbdc 	bl	8011366 <sp_2048_mask_32>
        t1[32 + i] += sp_2048_add_32(&t1[i], &t1[i], t2);
 8011bae:	f107 0298 	add.w	r2, r7, #152	; 0x98
 8011bb2:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8011bb6:	009b      	lsls	r3, r3, #2
 8011bb8:	18d0      	adds	r0, r2, r3
 8011bba:	f107 0298 	add.w	r2, r7, #152	; 0x98
 8011bbe:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8011bc2:	009b      	lsls	r3, r3, #2
 8011bc4:	4413      	add	r3, r2
 8011bc6:	f107 0214 	add.w	r2, r7, #20
 8011bca:	4619      	mov	r1, r3
 8011bcc:	f7ff fbec 	bl	80113a8 <sp_2048_add_32>
 8011bd0:	4601      	mov	r1, r0
 8011bd2:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8011bd6:	f103 0220 	add.w	r2, r3, #32
 8011bda:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8011bde:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011be2:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 8011be6:	3220      	adds	r2, #32
 8011be8:	4419      	add	r1, r3
 8011bea:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8011bee:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (i=31; i>=0; i--) {
 8011bf2:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8011bf6:	3b01      	subs	r3, #1
 8011bf8:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 8011bfc:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8011c00:	2b00      	cmp	r3, #0
 8011c02:	f6bf af2f 	bge.w	8011a64 <sp_2048_div_32+0x40>
    }

    r1 = sp_2048_cmp_32(t1, d) >= 0;
 8011c06:	f107 0308 	add.w	r3, r7, #8
 8011c0a:	f107 0298 	add.w	r2, r7, #152	; 0x98
 8011c0e:	6819      	ldr	r1, [r3, #0]
 8011c10:	4610      	mov	r0, r2
 8011c12:	f7ff fecf 	bl	80119b4 <sp_2048_cmp_32>
 8011c16:	4603      	mov	r3, r0
 8011c18:	43db      	mvns	r3, r3
 8011c1a:	0fdb      	lsrs	r3, r3, #31
 8011c1c:	b2db      	uxtb	r3, r3
 8011c1e:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
    sp_2048_cond_sub_32(r, t1, d, (sp_digit)0 - r1);
 8011c22:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 8011c26:	425b      	negs	r3, r3
 8011c28:	f107 0208 	add.w	r2, r7, #8
 8011c2c:	f107 0198 	add.w	r1, r7, #152	; 0x98
 8011c30:	4638      	mov	r0, r7
 8011c32:	6812      	ldr	r2, [r2, #0]
 8011c34:	6800      	ldr	r0, [r0, #0]
 8011c36:	f7ff fd72 	bl	801171e <sp_2048_cond_sub_32>

    return MP_OKAY;
 8011c3a:	2300      	movs	r3, #0
}
 8011c3c:	4618      	mov	r0, r3
 8011c3e:	f507 77d6 	add.w	r7, r7, #428	; 0x1ac
 8011c42:	46bd      	mov	sp, r7
 8011c44:	bd90      	pop	{r4, r7, pc}

08011c46 <sp_2048_mod_32>:
 * a  A single precision number that is to be reduced.
 * m  A single precision number that is the modulus to reduce with.
 * returns MP_OKAY indicating success.
 */
static WC_INLINE int sp_2048_mod_32(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
 8011c46:	b580      	push	{r7, lr}
 8011c48:	b084      	sub	sp, #16
 8011c4a:	af00      	add	r7, sp, #0
 8011c4c:	60f8      	str	r0, [r7, #12]
 8011c4e:	60b9      	str	r1, [r7, #8]
 8011c50:	607a      	str	r2, [r7, #4]
    return sp_2048_div_32(a, m, NULL, r);
 8011c52:	68fb      	ldr	r3, [r7, #12]
 8011c54:	2200      	movs	r2, #0
 8011c56:	6879      	ldr	r1, [r7, #4]
 8011c58:	68b8      	ldr	r0, [r7, #8]
 8011c5a:	f7ff fee3 	bl	8011a24 <sp_2048_div_32>
 8011c5e:	4603      	mov	r3, r0
}
 8011c60:	4618      	mov	r0, r3
 8011c62:	3710      	adds	r7, #16
 8011c64:	46bd      	mov	sp, r7
 8011c66:	bd80      	pop	{r7, pc}

08011c68 <sp_2048_mod_exp_32>:
 * m     A single precision number that is the modulus.
 * returns 0 on success and MEMORY_E on dynamic memory allocation failure.
 */
static int sp_2048_mod_exp_32(sp_digit* r, const sp_digit* a, const sp_digit* e,
        int bits, const sp_digit* m, int reduceA)
{
 8011c68:	b580      	push	{r7, lr}
 8011c6a:	b0a0      	sub	sp, #128	; 0x80
 8011c6c:	af02      	add	r7, sp, #8
 8011c6e:	60f8      	str	r0, [r7, #12]
 8011c70:	60b9      	str	r1, [r7, #8]
 8011c72:	607a      	str	r2, [r7, #4]
 8011c74:	603b      	str	r3, [r7, #0]
#else
    sp_digit td[16 * 64];
#endif
    sp_digit* t[16];
    sp_digit* norm;
    sp_digit mp = 1;
 8011c76:	2301      	movs	r3, #1
 8011c78:	613b      	str	r3, [r7, #16]
    sp_digit n;
    sp_digit mask;
    int i;
    int c, y;
    int err = MP_OKAY;
 8011c7a:	2300      	movs	r3, #0
 8011c7c:	667b      	str	r3, [r7, #100]	; 0x64

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * (16 * 64), NULL,
 8011c7e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8011c82:	f7fd f939 	bl	800eef8 <wolfSSL_Malloc>
 8011c86:	6638      	str	r0, [r7, #96]	; 0x60
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
 8011c88:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8011c8a:	2b00      	cmp	r3, #0
 8011c8c:	d102      	bne.n	8011c94 <sp_2048_mod_exp_32+0x2c>
        err = MEMORY_E;
 8011c8e:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 8011c92:	667b      	str	r3, [r7, #100]	; 0x64
    }
#endif

    if (err == MP_OKAY) {
 8011c94:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011c96:	2b00      	cmp	r3, #0
 8011c98:	d150      	bne.n	8011d3c <sp_2048_mod_exp_32+0xd4>
        norm = td;
 8011c9a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8011c9c:	65fb      	str	r3, [r7, #92]	; 0x5c
        for (i=0; i<16; i++) {
 8011c9e:	2300      	movs	r3, #0
 8011ca0:	673b      	str	r3, [r7, #112]	; 0x70
 8011ca2:	e00e      	b.n	8011cc2 <sp_2048_mod_exp_32+0x5a>
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
            t[i] = td + i * 64;
 8011ca4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8011ca6:	021b      	lsls	r3, r3, #8
 8011ca8:	461a      	mov	r2, r3
 8011caa:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8011cac:	441a      	add	r2, r3
 8011cae:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8011cb0:	009b      	lsls	r3, r3, #2
 8011cb2:	f107 0178 	add.w	r1, r7, #120	; 0x78
 8011cb6:	440b      	add	r3, r1
 8011cb8:	f843 2c64 	str.w	r2, [r3, #-100]
        for (i=0; i<16; i++) {
 8011cbc:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8011cbe:	3301      	adds	r3, #1
 8011cc0:	673b      	str	r3, [r7, #112]	; 0x70
 8011cc2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8011cc4:	2b0f      	cmp	r3, #15
 8011cc6:	dded      	ble.n	8011ca4 <sp_2048_mod_exp_32+0x3c>
#else
            t[i] = &td[i * 64];
#endif
        }

        sp_2048_mont_setup(m, &mp);
 8011cc8:	f107 0310 	add.w	r3, r7, #16
 8011ccc:	4619      	mov	r1, r3
 8011cce:	f8d7 0080 	ldr.w	r0, [r7, #128]	; 0x80
 8011cd2:	f7ff fcaa 	bl	801162a <sp_2048_mont_setup>
        sp_2048_mont_norm_32(norm, m);
 8011cd6:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 8011cda:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 8011cdc:	f7ff fd0d 	bl	80116fa <sp_2048_mont_norm_32>

        XMEMSET(t[1], 0, sizeof(sp_digit) * 32U);
 8011ce0:	69bb      	ldr	r3, [r7, #24]
 8011ce2:	2280      	movs	r2, #128	; 0x80
 8011ce4:	2100      	movs	r1, #0
 8011ce6:	4618      	mov	r0, r3
 8011ce8:	f007 fba9 	bl	801943e <memset>
        if (reduceA != 0) {
 8011cec:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8011cf0:	2b00      	cmp	r3, #0
 8011cf2:	d014      	beq.n	8011d1e <sp_2048_mod_exp_32+0xb6>
            err = sp_2048_mod_32(t[1] + 32, a, m);
 8011cf4:	69bb      	ldr	r3, [r7, #24]
 8011cf6:	3380      	adds	r3, #128	; 0x80
 8011cf8:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8011cfc:	68b9      	ldr	r1, [r7, #8]
 8011cfe:	4618      	mov	r0, r3
 8011d00:	f7ff ffa1 	bl	8011c46 <sp_2048_mod_32>
 8011d04:	6678      	str	r0, [r7, #100]	; 0x64
            if (err == MP_OKAY) {
 8011d06:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011d08:	2b00      	cmp	r3, #0
 8011d0a:	d117      	bne.n	8011d3c <sp_2048_mod_exp_32+0xd4>
                err = sp_2048_mod_32(t[1], t[1], m);
 8011d0c:	69bb      	ldr	r3, [r7, #24]
 8011d0e:	69b9      	ldr	r1, [r7, #24]
 8011d10:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8011d14:	4618      	mov	r0, r3
 8011d16:	f7ff ff96 	bl	8011c46 <sp_2048_mod_32>
 8011d1a:	6678      	str	r0, [r7, #100]	; 0x64
 8011d1c:	e00e      	b.n	8011d3c <sp_2048_mod_exp_32+0xd4>
            }
        }
        else {
            XMEMCPY(t[1] + 32, a, sizeof(sp_digit) * 32);
 8011d1e:	69bb      	ldr	r3, [r7, #24]
 8011d20:	3380      	adds	r3, #128	; 0x80
 8011d22:	2280      	movs	r2, #128	; 0x80
 8011d24:	68b9      	ldr	r1, [r7, #8]
 8011d26:	4618      	mov	r0, r3
 8011d28:	f007 fb65 	bl	80193f6 <memcpy>
            err = sp_2048_mod_32(t[1], t[1], m);
 8011d2c:	69bb      	ldr	r3, [r7, #24]
 8011d2e:	69b9      	ldr	r1, [r7, #24]
 8011d30:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8011d34:	4618      	mov	r0, r3
 8011d36:	f7ff ff86 	bl	8011c46 <sp_2048_mod_32>
 8011d3a:	6678      	str	r0, [r7, #100]	; 0x64
        }
    }

    if (err == MP_OKAY) {
 8011d3c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011d3e:	2b00      	cmp	r3, #0
 8011d40:	f040 816c 	bne.w	801201c <sp_2048_mod_exp_32+0x3b4>
        sp_2048_mont_sqr_32(t[ 2], t[ 1], m, mp);
 8011d44:	69f8      	ldr	r0, [r7, #28]
 8011d46:	69b9      	ldr	r1, [r7, #24]
 8011d48:	693b      	ldr	r3, [r7, #16]
 8011d4a:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8011d4e:	f7ff fda5 	bl	801189c <sp_2048_mont_sqr_32>
        sp_2048_mont_mul_32(t[ 3], t[ 2], t[ 1], m, mp);
 8011d52:	6a38      	ldr	r0, [r7, #32]
 8011d54:	69f9      	ldr	r1, [r7, #28]
 8011d56:	69ba      	ldr	r2, [r7, #24]
 8011d58:	693b      	ldr	r3, [r7, #16]
 8011d5a:	9300      	str	r3, [sp, #0]
 8011d5c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8011d60:	f7ff fd87 	bl	8011872 <sp_2048_mont_mul_32>
        sp_2048_mont_sqr_32(t[ 4], t[ 2], m, mp);
 8011d64:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8011d66:	69f9      	ldr	r1, [r7, #28]
 8011d68:	693b      	ldr	r3, [r7, #16]
 8011d6a:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8011d6e:	f7ff fd95 	bl	801189c <sp_2048_mont_sqr_32>
        sp_2048_mont_mul_32(t[ 5], t[ 3], t[ 2], m, mp);
 8011d72:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8011d74:	6a39      	ldr	r1, [r7, #32]
 8011d76:	69fa      	ldr	r2, [r7, #28]
 8011d78:	693b      	ldr	r3, [r7, #16]
 8011d7a:	9300      	str	r3, [sp, #0]
 8011d7c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8011d80:	f7ff fd77 	bl	8011872 <sp_2048_mont_mul_32>
        sp_2048_mont_sqr_32(t[ 6], t[ 3], m, mp);
 8011d84:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011d86:	6a39      	ldr	r1, [r7, #32]
 8011d88:	693b      	ldr	r3, [r7, #16]
 8011d8a:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8011d8e:	f7ff fd85 	bl	801189c <sp_2048_mont_sqr_32>
        sp_2048_mont_mul_32(t[ 7], t[ 4], t[ 3], m, mp);
 8011d92:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8011d94:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8011d96:	6a3a      	ldr	r2, [r7, #32]
 8011d98:	693b      	ldr	r3, [r7, #16]
 8011d9a:	9300      	str	r3, [sp, #0]
 8011d9c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8011da0:	f7ff fd67 	bl	8011872 <sp_2048_mont_mul_32>
        sp_2048_mont_sqr_32(t[ 8], t[ 4], m, mp);
 8011da4:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8011da6:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8011da8:	693b      	ldr	r3, [r7, #16]
 8011daa:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8011dae:	f7ff fd75 	bl	801189c <sp_2048_mont_sqr_32>
        sp_2048_mont_mul_32(t[ 9], t[ 5], t[ 4], m, mp);
 8011db2:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8011db4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8011db6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8011db8:	693b      	ldr	r3, [r7, #16]
 8011dba:	9300      	str	r3, [sp, #0]
 8011dbc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8011dc0:	f7ff fd57 	bl	8011872 <sp_2048_mont_mul_32>
        sp_2048_mont_sqr_32(t[10], t[ 5], m, mp);
 8011dc4:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8011dc6:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8011dc8:	693b      	ldr	r3, [r7, #16]
 8011dca:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8011dce:	f7ff fd65 	bl	801189c <sp_2048_mont_sqr_32>
        sp_2048_mont_mul_32(t[11], t[ 6], t[ 5], m, mp);
 8011dd2:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8011dd4:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8011dd6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011dd8:	693b      	ldr	r3, [r7, #16]
 8011dda:	9300      	str	r3, [sp, #0]
 8011ddc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8011de0:	f7ff fd47 	bl	8011872 <sp_2048_mont_mul_32>
        sp_2048_mont_sqr_32(t[12], t[ 6], m, mp);
 8011de4:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8011de6:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8011de8:	693b      	ldr	r3, [r7, #16]
 8011dea:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8011dee:	f7ff fd55 	bl	801189c <sp_2048_mont_sqr_32>
        sp_2048_mont_mul_32(t[13], t[ 7], t[ 6], m, mp);
 8011df2:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8011df4:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8011df6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011df8:	693b      	ldr	r3, [r7, #16]
 8011dfa:	9300      	str	r3, [sp, #0]
 8011dfc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8011e00:	f7ff fd37 	bl	8011872 <sp_2048_mont_mul_32>
        sp_2048_mont_sqr_32(t[14], t[ 7], m, mp);
 8011e04:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8011e06:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8011e08:	693b      	ldr	r3, [r7, #16]
 8011e0a:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8011e0e:	f7ff fd45 	bl	801189c <sp_2048_mont_sqr_32>
        sp_2048_mont_mul_32(t[15], t[ 8], t[ 7], m, mp);
 8011e12:	6d38      	ldr	r0, [r7, #80]	; 0x50
 8011e14:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8011e16:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011e18:	693b      	ldr	r3, [r7, #16]
 8011e1a:	9300      	str	r3, [sp, #0]
 8011e1c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8011e20:	f7ff fd27 	bl	8011872 <sp_2048_mont_mul_32>

        i = (bits - 1) / 32;
 8011e24:	683b      	ldr	r3, [r7, #0]
 8011e26:	3b01      	subs	r3, #1
 8011e28:	2b00      	cmp	r3, #0
 8011e2a:	da00      	bge.n	8011e2e <sp_2048_mod_exp_32+0x1c6>
 8011e2c:	331f      	adds	r3, #31
 8011e2e:	115b      	asrs	r3, r3, #5
 8011e30:	673b      	str	r3, [r7, #112]	; 0x70
        n = e[i--];
 8011e32:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8011e34:	1e5a      	subs	r2, r3, #1
 8011e36:	673a      	str	r2, [r7, #112]	; 0x70
 8011e38:	009b      	lsls	r3, r3, #2
 8011e3a:	687a      	ldr	r2, [r7, #4]
 8011e3c:	4413      	add	r3, r2
 8011e3e:	681b      	ldr	r3, [r3, #0]
 8011e40:	677b      	str	r3, [r7, #116]	; 0x74
        c = bits & 31;
 8011e42:	683b      	ldr	r3, [r7, #0]
 8011e44:	f003 031f 	and.w	r3, r3, #31
 8011e48:	66fb      	str	r3, [r7, #108]	; 0x6c
        if (c == 0) {
 8011e4a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011e4c:	2b00      	cmp	r3, #0
 8011e4e:	d101      	bne.n	8011e54 <sp_2048_mod_exp_32+0x1ec>
            c = 32;
 8011e50:	2320      	movs	r3, #32
 8011e52:	66fb      	str	r3, [r7, #108]	; 0x6c
        }
        c -= bits % 4;
 8011e54:	683b      	ldr	r3, [r7, #0]
 8011e56:	425a      	negs	r2, r3
 8011e58:	f003 0303 	and.w	r3, r3, #3
 8011e5c:	f002 0203 	and.w	r2, r2, #3
 8011e60:	bf58      	it	pl
 8011e62:	4253      	negpl	r3, r2
 8011e64:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8011e66:	1ad3      	subs	r3, r2, r3
 8011e68:	66fb      	str	r3, [r7, #108]	; 0x6c
        if (c == 32) {
 8011e6a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011e6c:	2b20      	cmp	r3, #32
 8011e6e:	d101      	bne.n	8011e74 <sp_2048_mod_exp_32+0x20c>
            c = 28;
 8011e70:	231c      	movs	r3, #28
 8011e72:	66fb      	str	r3, [r7, #108]	; 0x6c
        }
        if (c < 0) {
 8011e74:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011e76:	2b00      	cmp	r3, #0
 8011e78:	da23      	bge.n	8011ec2 <sp_2048_mod_exp_32+0x25a>
            /* Number of bits in top word is less than number needed. */
            c = -c;
 8011e7a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011e7c:	425b      	negs	r3, r3
 8011e7e:	66fb      	str	r3, [r7, #108]	; 0x6c
            y = (int)(n << c);
 8011e80:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8011e82:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011e84:	fa02 f303 	lsl.w	r3, r2, r3
 8011e88:	66bb      	str	r3, [r7, #104]	; 0x68
            n = e[i--];
 8011e8a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8011e8c:	1e5a      	subs	r2, r3, #1
 8011e8e:	673a      	str	r2, [r7, #112]	; 0x70
 8011e90:	009b      	lsls	r3, r3, #2
 8011e92:	687a      	ldr	r2, [r7, #4]
 8011e94:	4413      	add	r3, r2
 8011e96:	681b      	ldr	r3, [r3, #0]
 8011e98:	677b      	str	r3, [r7, #116]	; 0x74
            y |= (int)(n >> (64 - c));
 8011e9a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011e9c:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 8011ea0:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8011ea2:	fa22 f303 	lsr.w	r3, r2, r3
 8011ea6:	461a      	mov	r2, r3
 8011ea8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011eaa:	4313      	orrs	r3, r2
 8011eac:	66bb      	str	r3, [r7, #104]	; 0x68
            n <<= c;
 8011eae:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8011eb0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011eb2:	fa02 f303 	lsl.w	r3, r2, r3
 8011eb6:	677b      	str	r3, [r7, #116]	; 0x74
            c = 64 - c;
 8011eb8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011eba:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 8011ebe:	66fb      	str	r3, [r7, #108]	; 0x6c
 8011ec0:	e00b      	b.n	8011eda <sp_2048_mod_exp_32+0x272>
        }
        else {
            y = (int)(n >> c);
 8011ec2:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8011ec4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011ec6:	fa22 f303 	lsr.w	r3, r2, r3
 8011eca:	66bb      	str	r3, [r7, #104]	; 0x68
            n <<= 32 - c;
 8011ecc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011ece:	f1c3 0320 	rsb	r3, r3, #32
 8011ed2:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8011ed4:	fa02 f303 	lsl.w	r3, r2, r3
 8011ed8:	677b      	str	r3, [r7, #116]	; 0x74
        }
        XMEMCPY(r, t[y], sizeof(sp_digit) * 32);
 8011eda:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011edc:	009b      	lsls	r3, r3, #2
 8011ede:	f107 0278 	add.w	r2, r7, #120	; 0x78
 8011ee2:	4413      	add	r3, r2
 8011ee4:	f853 3c64 	ldr.w	r3, [r3, #-100]
 8011ee8:	2280      	movs	r2, #128	; 0x80
 8011eea:	4619      	mov	r1, r3
 8011eec:	68f8      	ldr	r0, [r7, #12]
 8011eee:	f007 fa82 	bl	80193f6 <memcpy>
        for (; i>=0 || c>=4; ) {
 8011ef2:	e06d      	b.n	8011fd0 <sp_2048_mod_exp_32+0x368>
            if (c == 0) {
 8011ef4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011ef6:	2b00      	cmp	r3, #0
 8011ef8:	d110      	bne.n	8011f1c <sp_2048_mod_exp_32+0x2b4>
                n = e[i--];
 8011efa:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8011efc:	1e5a      	subs	r2, r3, #1
 8011efe:	673a      	str	r2, [r7, #112]	; 0x70
 8011f00:	009b      	lsls	r3, r3, #2
 8011f02:	687a      	ldr	r2, [r7, #4]
 8011f04:	4413      	add	r3, r2
 8011f06:	681b      	ldr	r3, [r3, #0]
 8011f08:	677b      	str	r3, [r7, #116]	; 0x74
                y = (int)(n >> 28);
 8011f0a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8011f0c:	0f1b      	lsrs	r3, r3, #28
 8011f0e:	66bb      	str	r3, [r7, #104]	; 0x68
                n <<= 4;
 8011f10:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8011f12:	011b      	lsls	r3, r3, #4
 8011f14:	677b      	str	r3, [r7, #116]	; 0x74
                c = 28;
 8011f16:	231c      	movs	r3, #28
 8011f18:	66fb      	str	r3, [r7, #108]	; 0x6c
 8011f1a:	e02e      	b.n	8011f7a <sp_2048_mod_exp_32+0x312>
            }
            else if (c < 4) {
 8011f1c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011f1e:	2b03      	cmp	r3, #3
 8011f20:	dc22      	bgt.n	8011f68 <sp_2048_mod_exp_32+0x300>
                y = (int)(n >> 28);
 8011f22:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8011f24:	0f1b      	lsrs	r3, r3, #28
 8011f26:	66bb      	str	r3, [r7, #104]	; 0x68
                n = e[i--];
 8011f28:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8011f2a:	1e5a      	subs	r2, r3, #1
 8011f2c:	673a      	str	r2, [r7, #112]	; 0x70
 8011f2e:	009b      	lsls	r3, r3, #2
 8011f30:	687a      	ldr	r2, [r7, #4]
 8011f32:	4413      	add	r3, r2
 8011f34:	681b      	ldr	r3, [r3, #0]
 8011f36:	677b      	str	r3, [r7, #116]	; 0x74
                c = 4 - c;
 8011f38:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011f3a:	f1c3 0304 	rsb	r3, r3, #4
 8011f3e:	66fb      	str	r3, [r7, #108]	; 0x6c
                y |= (int)(n >> (32 - c));
 8011f40:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011f42:	f1c3 0320 	rsb	r3, r3, #32
 8011f46:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8011f48:	fa22 f303 	lsr.w	r3, r2, r3
 8011f4c:	461a      	mov	r2, r3
 8011f4e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011f50:	4313      	orrs	r3, r2
 8011f52:	66bb      	str	r3, [r7, #104]	; 0x68
                n <<= c;
 8011f54:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8011f56:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011f58:	fa02 f303 	lsl.w	r3, r2, r3
 8011f5c:	677b      	str	r3, [r7, #116]	; 0x74
                c = 32 - c;
 8011f5e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011f60:	f1c3 0320 	rsb	r3, r3, #32
 8011f64:	66fb      	str	r3, [r7, #108]	; 0x6c
 8011f66:	e008      	b.n	8011f7a <sp_2048_mod_exp_32+0x312>
            }
            else {
                y = (int)((n >> 28) & 0xf);
 8011f68:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8011f6a:	0f1b      	lsrs	r3, r3, #28
 8011f6c:	66bb      	str	r3, [r7, #104]	; 0x68
                n <<= 4;
 8011f6e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8011f70:	011b      	lsls	r3, r3, #4
 8011f72:	677b      	str	r3, [r7, #116]	; 0x74
                c -= 4;
 8011f74:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011f76:	3b04      	subs	r3, #4
 8011f78:	66fb      	str	r3, [r7, #108]	; 0x6c
            }

            sp_2048_mont_sqr_32(r, r, m, mp);
 8011f7a:	693b      	ldr	r3, [r7, #16]
 8011f7c:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8011f80:	68f9      	ldr	r1, [r7, #12]
 8011f82:	68f8      	ldr	r0, [r7, #12]
 8011f84:	f7ff fc8a 	bl	801189c <sp_2048_mont_sqr_32>
            sp_2048_mont_sqr_32(r, r, m, mp);
 8011f88:	693b      	ldr	r3, [r7, #16]
 8011f8a:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8011f8e:	68f9      	ldr	r1, [r7, #12]
 8011f90:	68f8      	ldr	r0, [r7, #12]
 8011f92:	f7ff fc83 	bl	801189c <sp_2048_mont_sqr_32>
            sp_2048_mont_sqr_32(r, r, m, mp);
 8011f96:	693b      	ldr	r3, [r7, #16]
 8011f98:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8011f9c:	68f9      	ldr	r1, [r7, #12]
 8011f9e:	68f8      	ldr	r0, [r7, #12]
 8011fa0:	f7ff fc7c 	bl	801189c <sp_2048_mont_sqr_32>
            sp_2048_mont_sqr_32(r, r, m, mp);
 8011fa4:	693b      	ldr	r3, [r7, #16]
 8011fa6:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8011faa:	68f9      	ldr	r1, [r7, #12]
 8011fac:	68f8      	ldr	r0, [r7, #12]
 8011fae:	f7ff fc75 	bl	801189c <sp_2048_mont_sqr_32>

            sp_2048_mont_mul_32(r, r, t[y], m, mp);
 8011fb2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011fb4:	009b      	lsls	r3, r3, #2
 8011fb6:	f107 0278 	add.w	r2, r7, #120	; 0x78
 8011fba:	4413      	add	r3, r2
 8011fbc:	f853 2c64 	ldr.w	r2, [r3, #-100]
 8011fc0:	693b      	ldr	r3, [r7, #16]
 8011fc2:	9300      	str	r3, [sp, #0]
 8011fc4:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8011fc8:	68f9      	ldr	r1, [r7, #12]
 8011fca:	68f8      	ldr	r0, [r7, #12]
 8011fcc:	f7ff fc51 	bl	8011872 <sp_2048_mont_mul_32>
        for (; i>=0 || c>=4; ) {
 8011fd0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8011fd2:	2b00      	cmp	r3, #0
 8011fd4:	da8e      	bge.n	8011ef4 <sp_2048_mod_exp_32+0x28c>
 8011fd6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011fd8:	2b03      	cmp	r3, #3
 8011fda:	dc8b      	bgt.n	8011ef4 <sp_2048_mod_exp_32+0x28c>
        }

        XMEMSET(&r[32], 0, sizeof(sp_digit) * 32U);
 8011fdc:	68fb      	ldr	r3, [r7, #12]
 8011fde:	3380      	adds	r3, #128	; 0x80
 8011fe0:	2280      	movs	r2, #128	; 0x80
 8011fe2:	2100      	movs	r1, #0
 8011fe4:	4618      	mov	r0, r3
 8011fe6:	f007 fa2a 	bl	801943e <memset>
        sp_2048_mont_reduce_32(r, m, mp);
 8011fea:	693b      	ldr	r3, [r7, #16]
 8011fec:	461a      	mov	r2, r3
 8011fee:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 8011ff2:	68f8      	ldr	r0, [r7, #12]
 8011ff4:	f7ff fbc0 	bl	8011778 <sp_2048_mont_reduce_32>

        mask = 0 - (sp_2048_cmp_32(r, m) >= 0);
 8011ff8:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 8011ffc:	68f8      	ldr	r0, [r7, #12]
 8011ffe:	f7ff fcd9 	bl	80119b4 <sp_2048_cmp_32>
 8012002:	4603      	mov	r3, r0
 8012004:	43db      	mvns	r3, r3
 8012006:	0fdb      	lsrs	r3, r3, #31
 8012008:	b2db      	uxtb	r3, r3
 801200a:	425b      	negs	r3, r3
 801200c:	65bb      	str	r3, [r7, #88]	; 0x58
        sp_2048_cond_sub_32(r, r, m, mask);
 801200e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8012010:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8012014:	68f9      	ldr	r1, [r7, #12]
 8012016:	68f8      	ldr	r0, [r7, #12]
 8012018:	f7ff fb81 	bl	801171e <sp_2048_cond_sub_32>
    }

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
 801201c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801201e:	2b00      	cmp	r3, #0
 8012020:	d007      	beq.n	8012032 <sp_2048_mod_exp_32+0x3ca>
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8012022:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8012024:	657b      	str	r3, [r7, #84]	; 0x54
 8012026:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8012028:	2b00      	cmp	r3, #0
 801202a:	d002      	beq.n	8012032 <sp_2048_mod_exp_32+0x3ca>
 801202c:	6d78      	ldr	r0, [r7, #84]	; 0x54
 801202e:	f7fc ff7f 	bl	800ef30 <wolfSSL_Free>
    }
#endif

    return err;
 8012032:	6e7b      	ldr	r3, [r7, #100]	; 0x64
}
 8012034:	4618      	mov	r0, r3
 8012036:	3778      	adds	r7, #120	; 0x78
 8012038:	46bd      	mov	sp, r7
 801203a:	bd80      	pop	{r7, pc}

0801203c <sp_2048_cond_sub_64>:
 * b  A single precision number to subtract.
 * m  Mask value to apply.
 */
SP_NOINLINE static sp_digit sp_2048_cond_sub_64(sp_digit* r, const sp_digit* a,
        const sp_digit* b, sp_digit m)
{
 801203c:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 8012040:	b086      	sub	sp, #24
 8012042:	af00      	add	r7, sp, #0
 8012044:	60f8      	str	r0, [r7, #12]
 8012046:	60b9      	str	r1, [r7, #8]
 8012048:	607a      	str	r2, [r7, #4]
 801204a:	603b      	str	r3, [r7, #0]
    sp_digit c = 0;
 801204c:	2300      	movs	r3, #0
 801204e:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 8012050:	68fa      	ldr	r2, [r7, #12]
 8012052:	68b9      	ldr	r1, [r7, #8]
 8012054:	6878      	ldr	r0, [r7, #4]
 8012056:	683c      	ldr	r4, [r7, #0]
 8012058:	697b      	ldr	r3, [r7, #20]
 801205a:	f04f 0501 	mov.w	r5, #1
 801205e:	ea4f 2505 	mov.w	r5, r5, lsl #8
 8012062:	46a9      	mov	r9, r5
 8012064:	f04f 0800 	mov.w	r8, #0
 8012068:	f850 6008 	ldr.w	r6, [r0, r8]
 801206c:	ea06 0604 	and.w	r6, r6, r4
 8012070:	f04f 0500 	mov.w	r5, #0
 8012074:	1aed      	subs	r5, r5, r3
 8012076:	f851 5008 	ldr.w	r5, [r1, r8]
 801207a:	41b5      	sbcs	r5, r6
 801207c:	419b      	sbcs	r3, r3
 801207e:	f842 5008 	str.w	r5, [r2, r8]
 8012082:	f108 0804 	add.w	r8, r8, #4
 8012086:	45c8      	cmp	r8, r9
 8012088:	dbee      	blt.n	8012068 <sp_2048_cond_sub_64+0x2c>
 801208a:	617b      	str	r3, [r7, #20]
        : [c] "+r" (c)
        : [r] "r" (r), [a] "r" (a), [b] "r" (b), [m] "r" (m)
        : "memory", "r5", "r6", "r8", "r9"
    );

    return c;
 801208c:	697b      	ldr	r3, [r7, #20]
}
 801208e:	4618      	mov	r0, r3
 8012090:	3718      	adds	r7, #24
 8012092:	46bd      	mov	sp, r7
 8012094:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8012098:	4770      	bx	lr

0801209a <sp_2048_mont_reduce_64>:
 * m   The single precision number representing the modulus.
 * mp  The digit representing the negative inverse of m mod 2^n.
 */
SP_NOINLINE static void sp_2048_mont_reduce_64(sp_digit* a, const sp_digit* m,
        sp_digit mp)
{
 801209a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801209e:	b087      	sub	sp, #28
 80120a0:	af00      	add	r7, sp, #0
 80120a2:	60f8      	str	r0, [r7, #12]
 80120a4:	60b9      	str	r1, [r7, #8]
 80120a6:	607a      	str	r2, [r7, #4]
    sp_digit ca = 0;
 80120a8:	2300      	movs	r3, #0
 80120aa:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 80120ac:	68b9      	ldr	r1, [r7, #8]
 80120ae:	6878      	ldr	r0, [r7, #4]
 80120b0:	697a      	ldr	r2, [r7, #20]
 80120b2:	68fb      	ldr	r3, [r7, #12]
 80120b4:	4681      	mov	r9, r0
 80120b6:	468c      	mov	ip, r1
 80120b8:	469a      	mov	sl, r3
 80120ba:	f04f 0400 	mov.w	r4, #0
 80120be:	f50a 7b80 	add.w	fp, sl, #256	; 0x100
 80120c2:	4648      	mov	r0, r9
 80120c4:	f8da 3000 	ldr.w	r3, [sl]
 80120c8:	fb00 f003 	mul.w	r0, r0, r3
 80120cc:	4661      	mov	r1, ip
 80120ce:	f10a 0ef8 	add.w	lr, sl, #248	; 0xf8
 80120d2:	f8da 3000 	ldr.w	r3, [sl]
 80120d6:	f04f 0500 	mov.w	r5, #0
 80120da:	f851 8b04 	ldr.w	r8, [r1], #4
 80120de:	fba0 6808 	umull	r6, r8, r0, r8
 80120e2:	199b      	adds	r3, r3, r6
 80120e4:	eb45 0508 	adc.w	r5, r5, r8
 80120e8:	18e4      	adds	r4, r4, r3
 80120ea:	f145 0500 	adc.w	r5, r5, #0
 80120ee:	f84a 4b04 	str.w	r4, [sl], #4
 80120f2:	f8da 3000 	ldr.w	r3, [sl]
 80120f6:	f04f 0400 	mov.w	r4, #0
 80120fa:	f851 8b04 	ldr.w	r8, [r1], #4
 80120fe:	fba0 6808 	umull	r6, r8, r0, r8
 8012102:	199b      	adds	r3, r3, r6
 8012104:	eb44 0408 	adc.w	r4, r4, r8
 8012108:	18ed      	adds	r5, r5, r3
 801210a:	f144 0400 	adc.w	r4, r4, #0
 801210e:	f84a 5b04 	str.w	r5, [sl], #4
 8012112:	45f2      	cmp	sl, lr
 8012114:	dbdd      	blt.n	80120d2 <sp_2048_mont_reduce_64+0x38>
 8012116:	f8da 3000 	ldr.w	r3, [sl]
 801211a:	f04f 0500 	mov.w	r5, #0
 801211e:	f851 8b04 	ldr.w	r8, [r1], #4
 8012122:	fba0 6808 	umull	r6, r8, r0, r8
 8012126:	199b      	adds	r3, r3, r6
 8012128:	eb45 0508 	adc.w	r5, r5, r8
 801212c:	18e4      	adds	r4, r4, r3
 801212e:	f145 0500 	adc.w	r5, r5, #0
 8012132:	f84a 4b04 	str.w	r4, [sl], #4
 8012136:	4614      	mov	r4, r2
 8012138:	f04f 0200 	mov.w	r2, #0
 801213c:	f8d1 8000 	ldr.w	r8, [r1]
 8012140:	fba0 6808 	umull	r6, r8, r0, r8
 8012144:	19ad      	adds	r5, r5, r6
 8012146:	eb54 0408 	adcs.w	r4, r4, r8
 801214a:	f142 0200 	adc.w	r2, r2, #0
 801214e:	f8da 6000 	ldr.w	r6, [sl]
 8012152:	f8da 8004 	ldr.w	r8, [sl, #4]
 8012156:	1976      	adds	r6, r6, r5
 8012158:	eb58 0804 	adcs.w	r8, r8, r4
 801215c:	f142 0200 	adc.w	r2, r2, #0
 8012160:	f8ca 6000 	str.w	r6, [sl]
 8012164:	f8ca 8004 	str.w	r8, [sl, #4]
 8012168:	f1aa 0af8 	sub.w	sl, sl, #248	; 0xf8
 801216c:	45da      	cmp	sl, fp
 801216e:	dba8      	blt.n	80120c2 <sp_2048_mont_reduce_64+0x28>
 8012170:	4653      	mov	r3, sl
 8012172:	4661      	mov	r1, ip
 8012174:	617a      	str	r2, [r7, #20]
 8012176:	60fb      	str	r3, [r7, #12]
        : [ca] "+r" (ca), [a] "+r" (a)
        : [m] "r" (m), [mp] "r" (mp)
        : "memory", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r12", "r14"
    );

    sp_2048_cond_sub_64(a - 64, a, m, (sp_digit)0 - ca);
 8012178:	68fb      	ldr	r3, [r7, #12]
 801217a:	f5a3 7080 	sub.w	r0, r3, #256	; 0x100
 801217e:	697b      	ldr	r3, [r7, #20]
 8012180:	425b      	negs	r3, r3
 8012182:	68ba      	ldr	r2, [r7, #8]
 8012184:	68f9      	ldr	r1, [r7, #12]
 8012186:	f7ff ff59 	bl	801203c <sp_2048_cond_sub_64>
}
 801218a:	bf00      	nop
 801218c:	371c      	adds	r7, #28
 801218e:	46bd      	mov	sp, r7
 8012190:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08012194 <sp_2048_mont_mul_64>:
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_2048_mont_mul_64(sp_digit* r, const sp_digit* a, const sp_digit* b,
        const sp_digit* m, sp_digit mp)
{
 8012194:	b580      	push	{r7, lr}
 8012196:	b084      	sub	sp, #16
 8012198:	af00      	add	r7, sp, #0
 801219a:	60f8      	str	r0, [r7, #12]
 801219c:	60b9      	str	r1, [r7, #8]
 801219e:	607a      	str	r2, [r7, #4]
 80121a0:	603b      	str	r3, [r7, #0]
    sp_2048_mul_64(r, a, b);
 80121a2:	687a      	ldr	r2, [r7, #4]
 80121a4:	68b9      	ldr	r1, [r7, #8]
 80121a6:	68f8      	ldr	r0, [r7, #12]
 80121a8:	f7fe ffea 	bl	8011180 <sp_2048_mul_64>
    sp_2048_mont_reduce_64(r, m, mp);
 80121ac:	69ba      	ldr	r2, [r7, #24]
 80121ae:	6839      	ldr	r1, [r7, #0]
 80121b0:	68f8      	ldr	r0, [r7, #12]
 80121b2:	f7ff ff72 	bl	801209a <sp_2048_mont_reduce_64>
}
 80121b6:	bf00      	nop
 80121b8:	3710      	adds	r7, #16
 80121ba:	46bd      	mov	sp, r7
 80121bc:	bd80      	pop	{r7, pc}

080121be <sp_2048_mont_sqr_64>:
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_2048_mont_sqr_64(sp_digit* r, const sp_digit* a, const sp_digit* m,
        sp_digit mp)
{
 80121be:	b580      	push	{r7, lr}
 80121c0:	b084      	sub	sp, #16
 80121c2:	af00      	add	r7, sp, #0
 80121c4:	60f8      	str	r0, [r7, #12]
 80121c6:	60b9      	str	r1, [r7, #8]
 80121c8:	607a      	str	r2, [r7, #4]
 80121ca:	603b      	str	r3, [r7, #0]
    sp_2048_sqr_64(r, a);
 80121cc:	68b9      	ldr	r1, [r7, #8]
 80121ce:	68f8      	ldr	r0, [r7, #12]
 80121d0:	f7ff f847 	bl	8011262 <sp_2048_sqr_64>
    sp_2048_mont_reduce_64(r, m, mp);
 80121d4:	683a      	ldr	r2, [r7, #0]
 80121d6:	6879      	ldr	r1, [r7, #4]
 80121d8:	68f8      	ldr	r0, [r7, #12]
 80121da:	f7ff ff5e 	bl	801209a <sp_2048_mont_reduce_64>
}
 80121de:	bf00      	nop
 80121e0:	3710      	adds	r7, #16
 80121e2:	46bd      	mov	sp, r7
 80121e4:	bd80      	pop	{r7, pc}

080121e6 <div_2048_word_64>:
 *
 * Note that this is an approximate div. It may give an answer 1 larger.
 */
SP_NOINLINE static sp_digit div_2048_word_64(sp_digit d1, sp_digit d0,
        sp_digit div)
{
 80121e6:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 80121ea:	b087      	sub	sp, #28
 80121ec:	af00      	add	r7, sp, #0
 80121ee:	60f8      	str	r0, [r7, #12]
 80121f0:	60b9      	str	r1, [r7, #8]
 80121f2:	607a      	str	r2, [r7, #4]
    sp_digit r = 0;
 80121f4:	2300      	movs	r3, #0
 80121f6:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 80121f8:	68fa      	ldr	r2, [r7, #12]
 80121fa:	68b9      	ldr	r1, [r7, #8]
 80121fc:	6878      	ldr	r0, [r7, #4]
 80121fe:	697b      	ldr	r3, [r7, #20]
 8012200:	ea4f 4610 	mov.w	r6, r0, lsr #16
 8012204:	f106 0601 	add.w	r6, r6, #1
 8012208:	fbb2 f4f6 	udiv	r4, r2, r6
 801220c:	ea4f 4804 	mov.w	r8, r4, lsl #16
 8012210:	fba0 4508 	umull	r4, r5, r0, r8
 8012214:	1b09      	subs	r1, r1, r4
 8012216:	eb62 0205 	sbc.w	r2, r2, r5
 801221a:	fbb2 f5f6 	udiv	r5, r2, r6
 801221e:	ea4f 4405 	mov.w	r4, r5, lsl #16
 8012222:	44a0      	add	r8, r4
 8012224:	fba0 4504 	umull	r4, r5, r0, r4
 8012228:	1b09      	subs	r1, r1, r4
 801222a:	eb62 0205 	sbc.w	r2, r2, r5
 801222e:	ea4f 4402 	mov.w	r4, r2, lsl #16
 8012232:	ea44 4411 	orr.w	r4, r4, r1, lsr #16
 8012236:	fbb4 f4f6 	udiv	r4, r4, r6
 801223a:	44a0      	add	r8, r4
 801223c:	fba0 4504 	umull	r4, r5, r0, r4
 8012240:	1b09      	subs	r1, r1, r4
 8012242:	eb62 0205 	sbc.w	r2, r2, r5
 8012246:	ea4f 4402 	mov.w	r4, r2, lsl #16
 801224a:	ea44 4411 	orr.w	r4, r4, r1, lsr #16
 801224e:	fbb4 f4f6 	udiv	r4, r4, r6
 8012252:	44a0      	add	r8, r4
 8012254:	fba0 4504 	umull	r4, r5, r0, r4
 8012258:	1b09      	subs	r1, r1, r4
 801225a:	eb62 0205 	sbc.w	r2, r2, r5
 801225e:	fbb1 f4f0 	udiv	r4, r1, r0
 8012262:	44a0      	add	r8, r4
 8012264:	4643      	mov	r3, r8
 8012266:	617b      	str	r3, [r7, #20]
        "mov	%[r], r8\n\t"
        : [r] "+r" (r)
        : [d1] "r" (d1), [d0] "r" (d0), [div] "r" (div)
        : "r4", "r5", "r6", "r8"
    );
    return r;
 8012268:	697b      	ldr	r3, [r7, #20]
}
 801226a:	4618      	mov	r0, r3
 801226c:	371c      	adds	r7, #28
 801226e:	46bd      	mov	sp, r7
 8012270:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8012274:	4770      	bx	lr

08012276 <sp_2048_cmp_64>:
 * b  A single precision integer.
 * return -ve, 0 or +ve if a is less than, equal to or greater than b
 * respectively.
 */
SP_NOINLINE static int32_t sp_2048_cmp_64(const sp_digit* a, const sp_digit* b)
{
 8012276:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 801227a:	b085      	sub	sp, #20
 801227c:	af00      	add	r7, sp, #0
 801227e:	6078      	str	r0, [r7, #4]
 8012280:	6039      	str	r1, [r7, #0]
    sp_digit r = 0;
 8012282:	2300      	movs	r3, #0
 8012284:	60fb      	str	r3, [r7, #12]


    __asm__ __volatile__ (
 8012286:	6879      	ldr	r1, [r7, #4]
 8012288:	6838      	ldr	r0, [r7, #0]
 801228a:	68fb      	ldr	r3, [r7, #12]
 801228c:	461a      	mov	r2, r3
 801228e:	f04f 0300 	mov.w	r3, #0
 8012292:	ea6f 0303 	mvn.w	r3, r3
 8012296:	f04f 06fc 	mov.w	r6, #252	; 0xfc
 801229a:	f851 8006 	ldr.w	r8, [r1, r6]
 801229e:	5985      	ldr	r5, [r0, r6]
 80122a0:	ea08 0803 	and.w	r8, r8, r3
 80122a4:	ea05 0503 	and.w	r5, r5, r3
 80122a8:	4644      	mov	r4, r8
 80122aa:	ebb8 0805 	subs.w	r8, r8, r5
 80122ae:	eb68 0808 	sbc.w	r8, r8, r8
 80122b2:	4442      	add	r2, r8
 80122b4:	ea6f 0808 	mvn.w	r8, r8
 80122b8:	ea03 0308 	and.w	r3, r3, r8
 80122bc:	1b2d      	subs	r5, r5, r4
 80122be:	eb68 0808 	sbc.w	r8, r8, r8
 80122c2:	eba2 0208 	sub.w	r2, r2, r8
 80122c6:	ea6f 0808 	mvn.w	r8, r8
 80122ca:	ea03 0308 	and.w	r3, r3, r8
 80122ce:	f1a6 0604 	sub.w	r6, r6, #4
 80122d2:	2e00      	cmp	r6, #0
 80122d4:	dae1      	bge.n	801229a <sp_2048_cmp_64+0x24>
 80122d6:	60fa      	str	r2, [r7, #12]
        : [r] "+r" (r)
        : [a] "r" (a), [b] "r" (b)
        : "r3", "r4", "r5", "r6", "r8"
    );

    return r;
 80122d8:	68fb      	ldr	r3, [r7, #12]
}
 80122da:	4618      	mov	r0, r3
 80122dc:	3714      	adds	r7, #20
 80122de:	46bd      	mov	sp, r7
 80122e0:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 80122e4:	4770      	bx	lr

080122e6 <sp_2048_div_64_cond>:
 * r  Remainder from the division.
 * returns MP_OKAY indicating success.
 */
static WC_INLINE int sp_2048_div_64_cond(const sp_digit* a, const sp_digit* d, sp_digit* m,
        sp_digit* r)
{
 80122e6:	b590      	push	{r4, r7, lr}
 80122e8:	f5ad 7d4b 	sub.w	sp, sp, #812	; 0x32c
 80122ec:	af00      	add	r7, sp, #0
 80122ee:	f107 040c 	add.w	r4, r7, #12
 80122f2:	6020      	str	r0, [r4, #0]
 80122f4:	f107 0008 	add.w	r0, r7, #8
 80122f8:	6001      	str	r1, [r0, #0]
 80122fa:	1d39      	adds	r1, r7, #4
 80122fc:	600a      	str	r2, [r1, #0]
 80122fe:	463a      	mov	r2, r7
 8012300:	6013      	str	r3, [r2, #0]
    sp_digit div, r1;
    int i;

    (void)m;

    div = d[63];
 8012302:	f107 0308 	add.w	r3, r7, #8
 8012306:	681b      	ldr	r3, [r3, #0]
 8012308:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801230c:	f8c7 3320 	str.w	r3, [r7, #800]	; 0x320
    XMEMCPY(t1, a, sizeof(*t1) * 2 * 64);
 8012310:	f107 030c 	add.w	r3, r7, #12
 8012314:	f507 708c 	add.w	r0, r7, #280	; 0x118
 8012318:	f44f 7200 	mov.w	r2, #512	; 0x200
 801231c:	6819      	ldr	r1, [r3, #0]
 801231e:	f007 f86a 	bl	80193f6 <memcpy>
    for (i=63; i>=0; i--) {
 8012322:	233f      	movs	r3, #63	; 0x3f
 8012324:	f8c7 3324 	str.w	r3, [r7, #804]	; 0x324
 8012328:	e0c1      	b.n	80124ae <sp_2048_div_64_cond+0x1c8>
        sp_digit hi = t1[64 + i] - (t1[64 + i] == div);
 801232a:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 801232e:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8012332:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8012336:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801233a:	f8d7 2324 	ldr.w	r2, [r7, #804]	; 0x324
 801233e:	f102 0140 	add.w	r1, r2, #64	; 0x40
 8012342:	f507 728c 	add.w	r2, r7, #280	; 0x118
 8012346:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 801234a:	f8d7 1320 	ldr.w	r1, [r7, #800]	; 0x320
 801234e:	4291      	cmp	r1, r2
 8012350:	bf0c      	ite	eq
 8012352:	2201      	moveq	r2, #1
 8012354:	2200      	movne	r2, #0
 8012356:	b2d2      	uxtb	r2, r2
 8012358:	1a9b      	subs	r3, r3, r2
 801235a:	f8c7 3318 	str.w	r3, [r7, #792]	; 0x318
        r1 = div_2048_word_64(hi, t1[64 + i - 1], div);
 801235e:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 8012362:	f103 023f 	add.w	r2, r3, #63	; 0x3f
 8012366:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801236a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801236e:	f8d7 2320 	ldr.w	r2, [r7, #800]	; 0x320
 8012372:	4619      	mov	r1, r3
 8012374:	f8d7 0318 	ldr.w	r0, [r7, #792]	; 0x318
 8012378:	f7ff ff35 	bl	80121e6 <div_2048_word_64>
 801237c:	f8c7 031c 	str.w	r0, [r7, #796]	; 0x31c

        sp_2048_mul_d_64(t2, d, r1);
 8012380:	f107 0308 	add.w	r3, r7, #8
 8012384:	f107 0014 	add.w	r0, r7, #20
 8012388:	f8d7 231c 	ldr.w	r2, [r7, #796]	; 0x31c
 801238c:	6819      	ldr	r1, [r3, #0]
 801238e:	f7ff f984 	bl	801169a <sp_2048_mul_d_64>
        t1[64 + i] += sp_2048_sub_in_place_64(&t1[i], t2);
 8012392:	f507 728c 	add.w	r2, r7, #280	; 0x118
 8012396:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 801239a:	009b      	lsls	r3, r3, #2
 801239c:	4413      	add	r3, r2
 801239e:	f107 0214 	add.w	r2, r7, #20
 80123a2:	4611      	mov	r1, r2
 80123a4:	4618      	mov	r0, r3
 80123a6:	f7fe febd 	bl	8011124 <sp_2048_sub_in_place_64>
 80123aa:	4601      	mov	r1, r0
 80123ac:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 80123b0:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80123b4:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80123b8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80123bc:	f8d7 2324 	ldr.w	r2, [r7, #804]	; 0x324
 80123c0:	3240      	adds	r2, #64	; 0x40
 80123c2:	4419      	add	r1, r3
 80123c4:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80123c8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        t1[64 + i] -= t2[64];
 80123cc:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 80123d0:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80123d4:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80123d8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80123dc:	f107 0314 	add.w	r3, r7, #20
 80123e0:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 80123e4:	f8d7 2324 	ldr.w	r2, [r7, #804]	; 0x324
 80123e8:	3240      	adds	r2, #64	; 0x40
 80123ea:	1ac9      	subs	r1, r1, r3
 80123ec:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80123f0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        if (t1[64 + i] != 0) {
 80123f4:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 80123f8:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80123fc:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8012400:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8012404:	2b00      	cmp	r3, #0
 8012406:	d04d      	beq.n	80124a4 <sp_2048_div_64_cond+0x1be>
            t1[64 + i] += sp_2048_add_64(&t1[i], &t1[i], d);
 8012408:	f507 728c 	add.w	r2, r7, #280	; 0x118
 801240c:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 8012410:	009b      	lsls	r3, r3, #2
 8012412:	18d0      	adds	r0, r2, r3
 8012414:	f507 728c 	add.w	r2, r7, #280	; 0x118
 8012418:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 801241c:	009b      	lsls	r3, r3, #2
 801241e:	18d1      	adds	r1, r2, r3
 8012420:	f107 0308 	add.w	r3, r7, #8
 8012424:	681a      	ldr	r2, [r3, #0]
 8012426:	f7fe fe4c 	bl	80110c2 <sp_2048_add_64>
 801242a:	4601      	mov	r1, r0
 801242c:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 8012430:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8012434:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8012438:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801243c:	f8d7 2324 	ldr.w	r2, [r7, #804]	; 0x324
 8012440:	3240      	adds	r2, #64	; 0x40
 8012442:	4419      	add	r1, r3
 8012444:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8012448:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            if (t1[64 + i] != 0)
 801244c:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 8012450:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8012454:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8012458:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801245c:	2b00      	cmp	r3, #0
 801245e:	d021      	beq.n	80124a4 <sp_2048_div_64_cond+0x1be>
                t1[64 + i] += sp_2048_add_64(&t1[i], &t1[i], d);
 8012460:	f507 728c 	add.w	r2, r7, #280	; 0x118
 8012464:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 8012468:	009b      	lsls	r3, r3, #2
 801246a:	18d0      	adds	r0, r2, r3
 801246c:	f507 728c 	add.w	r2, r7, #280	; 0x118
 8012470:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 8012474:	009b      	lsls	r3, r3, #2
 8012476:	18d1      	adds	r1, r2, r3
 8012478:	f107 0308 	add.w	r3, r7, #8
 801247c:	681a      	ldr	r2, [r3, #0]
 801247e:	f7fe fe20 	bl	80110c2 <sp_2048_add_64>
 8012482:	4601      	mov	r1, r0
 8012484:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 8012488:	f103 0240 	add.w	r2, r3, #64	; 0x40
 801248c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8012490:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8012494:	f8d7 2324 	ldr.w	r2, [r7, #804]	; 0x324
 8012498:	3240      	adds	r2, #64	; 0x40
 801249a:	4419      	add	r1, r3
 801249c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80124a0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (i=63; i>=0; i--) {
 80124a4:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 80124a8:	3b01      	subs	r3, #1
 80124aa:	f8c7 3324 	str.w	r3, [r7, #804]	; 0x324
 80124ae:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 80124b2:	2b00      	cmp	r3, #0
 80124b4:	f6bf af39 	bge.w	801232a <sp_2048_div_64_cond+0x44>
        }
    }

    r1 = sp_2048_cmp_64(t1, d) >= 0;
 80124b8:	f107 0308 	add.w	r3, r7, #8
 80124bc:	f507 728c 	add.w	r2, r7, #280	; 0x118
 80124c0:	6819      	ldr	r1, [r3, #0]
 80124c2:	4610      	mov	r0, r2
 80124c4:	f7ff fed7 	bl	8012276 <sp_2048_cmp_64>
 80124c8:	4603      	mov	r3, r0
 80124ca:	43db      	mvns	r3, r3
 80124cc:	0fdb      	lsrs	r3, r3, #31
 80124ce:	b2db      	uxtb	r3, r3
 80124d0:	f8c7 331c 	str.w	r3, [r7, #796]	; 0x31c
    sp_2048_cond_sub_64(r, t1, d, (sp_digit)0 - r1);
 80124d4:	f8d7 331c 	ldr.w	r3, [r7, #796]	; 0x31c
 80124d8:	425b      	negs	r3, r3
 80124da:	f107 0208 	add.w	r2, r7, #8
 80124de:	f507 718c 	add.w	r1, r7, #280	; 0x118
 80124e2:	4638      	mov	r0, r7
 80124e4:	6812      	ldr	r2, [r2, #0]
 80124e6:	6800      	ldr	r0, [r0, #0]
 80124e8:	f7ff fda8 	bl	801203c <sp_2048_cond_sub_64>

    return MP_OKAY;
 80124ec:	2300      	movs	r3, #0
}
 80124ee:	4618      	mov	r0, r3
 80124f0:	f507 774b 	add.w	r7, r7, #812	; 0x32c
 80124f4:	46bd      	mov	sp, r7
 80124f6:	bd90      	pop	{r4, r7, pc}

080124f8 <sp_2048_mod_64_cond>:
 * a  A single precision number that is to be reduced.
 * m  A single precision number that is the modulus to reduce with.
 * returns MP_OKAY indicating success.
 */
static WC_INLINE int sp_2048_mod_64_cond(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
 80124f8:	b580      	push	{r7, lr}
 80124fa:	b084      	sub	sp, #16
 80124fc:	af00      	add	r7, sp, #0
 80124fe:	60f8      	str	r0, [r7, #12]
 8012500:	60b9      	str	r1, [r7, #8]
 8012502:	607a      	str	r2, [r7, #4]
    return sp_2048_div_64_cond(a, m, NULL, r);
 8012504:	68fb      	ldr	r3, [r7, #12]
 8012506:	2200      	movs	r2, #0
 8012508:	6879      	ldr	r1, [r7, #4]
 801250a:	68b8      	ldr	r0, [r7, #8]
 801250c:	f7ff feeb 	bl	80122e6 <sp_2048_div_64_cond>
 8012510:	4603      	mov	r3, r0
}
 8012512:	4618      	mov	r0, r3
 8012514:	3710      	adds	r7, #16
 8012516:	46bd      	mov	sp, r7
 8012518:	bd80      	pop	{r7, pc}

0801251a <sp_RsaPublic_2048>:
 * returns 0 on success, MP_TO_E when the outLen is too small, MP_READ_E when
 * an array is too long and MEMORY_E when dynamic memory allocation fails.
 */
int sp_RsaPublic_2048(const byte* in, word32 inLen, mp_int* em, mp_int* mm,
    byte* out, word32* outLen)
{
 801251a:	b580      	push	{r7, lr}
 801251c:	b090      	sub	sp, #64	; 0x40
 801251e:	af02      	add	r7, sp, #8
 8012520:	60f8      	str	r0, [r7, #12]
 8012522:	60b9      	str	r1, [r7, #8]
 8012524:	607a      	str	r2, [r7, #4]
 8012526:	603b      	str	r3, [r7, #0]
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit a[128], m[64], r[128];
#else
    sp_digit* d = NULL;
 8012528:	2300      	movs	r3, #0
 801252a:	637b      	str	r3, [r7, #52]	; 0x34
    sp_digit* a = NULL;
 801252c:	2300      	movs	r3, #0
 801252e:	633b      	str	r3, [r7, #48]	; 0x30
    sp_digit* m = NULL;
 8012530:	2300      	movs	r3, #0
 8012532:	62fb      	str	r3, [r7, #44]	; 0x2c
    sp_digit* r = NULL;
 8012534:	2300      	movs	r3, #0
 8012536:	62bb      	str	r3, [r7, #40]	; 0x28
#endif
    sp_digit *ah = NULL;
 8012538:	2300      	movs	r3, #0
 801253a:	627b      	str	r3, [r7, #36]	; 0x24
    sp_digit e[1];
    int err = MP_OKAY;
 801253c:	2300      	movs	r3, #0
 801253e:	623b      	str	r3, [r7, #32]

    if (*outLen < 256) {
 8012540:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8012542:	681b      	ldr	r3, [r3, #0]
 8012544:	2bff      	cmp	r3, #255	; 0xff
 8012546:	d803      	bhi.n	8012550 <sp_RsaPublic_2048+0x36>
        err = MP_TO_E;
 8012548:	f06f 0370 	mvn.w	r3, #112	; 0x70
 801254c:	623b      	str	r3, [r7, #32]
 801254e:	e021      	b.n	8012594 <sp_RsaPublic_2048+0x7a>
    }
    else if (mp_count_bits(em) > 32 || inLen > 256 ||
 8012550:	6878      	ldr	r0, [r7, #4]
 8012552:	f006 fb3f 	bl	8018bd4 <sp_count_bits>
 8012556:	4603      	mov	r3, r0
 8012558:	2b20      	cmp	r3, #32
 801255a:	dc0a      	bgt.n	8012572 <sp_RsaPublic_2048+0x58>
 801255c:	68bb      	ldr	r3, [r7, #8]
 801255e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8012562:	d806      	bhi.n	8012572 <sp_RsaPublic_2048+0x58>
                                                     mp_count_bits(mm) != 2048) {
 8012564:	6838      	ldr	r0, [r7, #0]
 8012566:	f006 fb35 	bl	8018bd4 <sp_count_bits>
 801256a:	4603      	mov	r3, r0
    else if (mp_count_bits(em) > 32 || inLen > 256 ||
 801256c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8012570:	d003      	beq.n	801257a <sp_RsaPublic_2048+0x60>
        err = MP_READ_E;
 8012572:	f06f 036e 	mvn.w	r3, #110	; 0x6e
 8012576:	623b      	str	r3, [r7, #32]
 8012578:	e00c      	b.n	8012594 <sp_RsaPublic_2048+0x7a>
    }
    else if (mp_iseven(mm)) {
 801257a:	683b      	ldr	r3, [r7, #0]
 801257c:	681b      	ldr	r3, [r3, #0]
 801257e:	2b00      	cmp	r3, #0
 8012580:	d008      	beq.n	8012594 <sp_RsaPublic_2048+0x7a>
 8012582:	683b      	ldr	r3, [r7, #0]
 8012584:	689b      	ldr	r3, [r3, #8]
 8012586:	f003 0301 	and.w	r3, r3, #1
 801258a:	2b00      	cmp	r3, #0
 801258c:	d102      	bne.n	8012594 <sp_RsaPublic_2048+0x7a>
        err = MP_VAL;
 801258e:	f06f 0302 	mvn.w	r3, #2
 8012592:	623b      	str	r3, [r7, #32]
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
 8012594:	6a3b      	ldr	r3, [r7, #32]
 8012596:	2b00      	cmp	r3, #0
 8012598:	d10a      	bne.n	80125b0 <sp_RsaPublic_2048+0x96>
        d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 64 * 5, NULL,
 801259a:	f44f 60a0 	mov.w	r0, #1280	; 0x500
 801259e:	f7fc fcab 	bl	800eef8 <wolfSSL_Malloc>
 80125a2:	6378      	str	r0, [r7, #52]	; 0x34
                                                              DYNAMIC_TYPE_RSA);
        if (d == NULL)
 80125a4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80125a6:	2b00      	cmp	r3, #0
 80125a8:	d102      	bne.n	80125b0 <sp_RsaPublic_2048+0x96>
            err = MEMORY_E;
 80125aa:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 80125ae:	623b      	str	r3, [r7, #32]
    }

    if (err == MP_OKAY) {
 80125b0:	6a3b      	ldr	r3, [r7, #32]
 80125b2:	2b00      	cmp	r3, #0
 80125b4:	d109      	bne.n	80125ca <sp_RsaPublic_2048+0xb0>
        a = d;
 80125b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80125b8:	633b      	str	r3, [r7, #48]	; 0x30
        r = a + 64 * 2;
 80125ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80125bc:	f503 7300 	add.w	r3, r3, #512	; 0x200
 80125c0:	62bb      	str	r3, [r7, #40]	; 0x28
        m = r + 64 * 2;
 80125c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80125c4:	f503 7300 	add.w	r3, r3, #512	; 0x200
 80125c8:	62fb      	str	r3, [r7, #44]	; 0x2c
    }
#endif

    if (err == MP_OKAY) {
 80125ca:	6a3b      	ldr	r3, [r7, #32]
 80125cc:	2b00      	cmp	r3, #0
 80125ce:	d112      	bne.n	80125f6 <sp_RsaPublic_2048+0xdc>
        ah = a + 64;
 80125d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80125d2:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80125d6:	627b      	str	r3, [r7, #36]	; 0x24

        sp_2048_from_bin(ah, 64, in, inLen);
 80125d8:	68bb      	ldr	r3, [r7, #8]
 80125da:	68fa      	ldr	r2, [r7, #12]
 80125dc:	2140      	movs	r1, #64	; 0x40
 80125de:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80125e0:	f7fe fc68 	bl	8010eb4 <sp_2048_from_bin>
#if DIGIT_BIT >= 32
        e[0] = em->dp[0];
 80125e4:	687b      	ldr	r3, [r7, #4]
 80125e6:	689b      	ldr	r3, [r3, #8]
 80125e8:	617b      	str	r3, [r7, #20]
        e[0] = em->dp[0];
        if (em->used > 1) {
            e[0] |= ((sp_digit)em->dp[1]) << DIGIT_BIT;
        }
#endif
        if (e[0] == 0) {
 80125ea:	697b      	ldr	r3, [r7, #20]
 80125ec:	2b00      	cmp	r3, #0
 80125ee:	d102      	bne.n	80125f6 <sp_RsaPublic_2048+0xdc>
            err = MP_EXPTMOD_E;
 80125f0:	f06f 036f 	mvn.w	r3, #111	; 0x6f
 80125f4:	623b      	str	r3, [r7, #32]
        }
    }
    if (err == MP_OKAY) {
 80125f6:	6a3b      	ldr	r3, [r7, #32]
 80125f8:	2b00      	cmp	r3, #0
 80125fa:	f040 80a7 	bne.w	801274c <sp_RsaPublic_2048+0x232>
        sp_2048_from_mp(m, 64, mm);
 80125fe:	683a      	ldr	r2, [r7, #0]
 8012600:	2140      	movs	r1, #64	; 0x40
 8012602:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8012604:	f7fe fcc7 	bl	8010f96 <sp_2048_from_mp>

        if (e[0] == 0x3) {
 8012608:	697b      	ldr	r3, [r7, #20]
 801260a:	2b03      	cmp	r3, #3
 801260c:	d11c      	bne.n	8012648 <sp_RsaPublic_2048+0x12e>
            if (err == MP_OKAY) {
 801260e:	6a3b      	ldr	r3, [r7, #32]
 8012610:	2b00      	cmp	r3, #0
 8012612:	d109      	bne.n	8012628 <sp_RsaPublic_2048+0x10e>
                sp_2048_sqr_64(r, ah);
 8012614:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8012616:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8012618:	f7fe fe23 	bl	8011262 <sp_2048_sqr_64>
                err = sp_2048_mod_64_cond(r, r, m);
 801261c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801261e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8012620:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8012622:	f7ff ff69 	bl	80124f8 <sp_2048_mod_64_cond>
 8012626:	6238      	str	r0, [r7, #32]
            }
            if (err == MP_OKAY) {
 8012628:	6a3b      	ldr	r3, [r7, #32]
 801262a:	2b00      	cmp	r3, #0
 801262c:	f040 808e 	bne.w	801274c <sp_RsaPublic_2048+0x232>
                sp_2048_mul_64(r, ah, r);
 8012630:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8012632:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8012634:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8012636:	f7fe fda3 	bl	8011180 <sp_2048_mul_64>
                err = sp_2048_mod_64_cond(r, r, m);
 801263a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801263c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801263e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8012640:	f7ff ff5a 	bl	80124f8 <sp_2048_mod_64_cond>
 8012644:	6238      	str	r0, [r7, #32]
 8012646:	e081      	b.n	801274c <sp_RsaPublic_2048+0x232>
        }
        else {
            int i;
            sp_digit mp;

            sp_2048_mont_setup(m, &mp);
 8012648:	f107 0310 	add.w	r3, r7, #16
 801264c:	4619      	mov	r1, r3
 801264e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8012650:	f7fe ffeb 	bl	801162a <sp_2048_mont_setup>

            /* Convert to Montgomery form. */
            XMEMSET(a, 0, sizeof(sp_digit) * 64);
 8012654:	f44f 7280 	mov.w	r2, #256	; 0x100
 8012658:	2100      	movs	r1, #0
 801265a:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801265c:	f006 feef 	bl	801943e <memset>
            err = sp_2048_mod_64_cond(a, a, m);
 8012660:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8012662:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8012664:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8012666:	f7ff ff47 	bl	80124f8 <sp_2048_mod_64_cond>
 801266a:	6238      	str	r0, [r7, #32]

            if (err == MP_OKAY) {
 801266c:	6a3b      	ldr	r3, [r7, #32]
 801266e:	2b00      	cmp	r3, #0
 8012670:	d16c      	bne.n	801274c <sp_RsaPublic_2048+0x232>
                for (i = 31; i >= 0; i--) {
 8012672:	231f      	movs	r3, #31
 8012674:	61fb      	str	r3, [r7, #28]
 8012676:	e008      	b.n	801268a <sp_RsaPublic_2048+0x170>
                    if (e[0] >> i) {
 8012678:	697a      	ldr	r2, [r7, #20]
 801267a:	69fb      	ldr	r3, [r7, #28]
 801267c:	fa22 f303 	lsr.w	r3, r2, r3
 8012680:	2b00      	cmp	r3, #0
 8012682:	d106      	bne.n	8012692 <sp_RsaPublic_2048+0x178>
                for (i = 31; i >= 0; i--) {
 8012684:	69fb      	ldr	r3, [r7, #28]
 8012686:	3b01      	subs	r3, #1
 8012688:	61fb      	str	r3, [r7, #28]
 801268a:	69fb      	ldr	r3, [r7, #28]
 801268c:	2b00      	cmp	r3, #0
 801268e:	daf3      	bge.n	8012678 <sp_RsaPublic_2048+0x15e>
 8012690:	e000      	b.n	8012694 <sp_RsaPublic_2048+0x17a>
                        break;
 8012692:	bf00      	nop
                    }
                }

                XMEMCPY(r, a, sizeof(sp_digit) * 64);
 8012694:	f44f 7280 	mov.w	r2, #256	; 0x100
 8012698:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801269a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801269c:	f006 feab 	bl	80193f6 <memcpy>
                for (i--; i>=0; i--) {
 80126a0:	69fb      	ldr	r3, [r7, #28]
 80126a2:	3b01      	subs	r3, #1
 80126a4:	61fb      	str	r3, [r7, #28]
 80126a6:	e018      	b.n	80126da <sp_RsaPublic_2048+0x1c0>
                    sp_2048_mont_sqr_64(r, r, m, mp);
 80126a8:	693b      	ldr	r3, [r7, #16]
 80126aa:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80126ac:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80126ae:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80126b0:	f7ff fd85 	bl	80121be <sp_2048_mont_sqr_64>
                    if (((e[0] >> i) & 1) == 1) {
 80126b4:	697a      	ldr	r2, [r7, #20]
 80126b6:	69fb      	ldr	r3, [r7, #28]
 80126b8:	fa22 f303 	lsr.w	r3, r2, r3
 80126bc:	f003 0301 	and.w	r3, r3, #1
 80126c0:	2b00      	cmp	r3, #0
 80126c2:	d007      	beq.n	80126d4 <sp_RsaPublic_2048+0x1ba>
                        sp_2048_mont_mul_64(r, r, a, m, mp);
 80126c4:	693b      	ldr	r3, [r7, #16]
 80126c6:	9300      	str	r3, [sp, #0]
 80126c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80126ca:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80126cc:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80126ce:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80126d0:	f7ff fd60 	bl	8012194 <sp_2048_mont_mul_64>
                for (i--; i>=0; i--) {
 80126d4:	69fb      	ldr	r3, [r7, #28]
 80126d6:	3b01      	subs	r3, #1
 80126d8:	61fb      	str	r3, [r7, #28]
 80126da:	69fb      	ldr	r3, [r7, #28]
 80126dc:	2b00      	cmp	r3, #0
 80126de:	dae3      	bge.n	80126a8 <sp_RsaPublic_2048+0x18e>
                    }
                }
                XMEMSET(&r[64], 0, sizeof(sp_digit) * 64);
 80126e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80126e2:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80126e6:	f44f 7280 	mov.w	r2, #256	; 0x100
 80126ea:	2100      	movs	r1, #0
 80126ec:	4618      	mov	r0, r3
 80126ee:	f006 fea6 	bl	801943e <memset>
                sp_2048_mont_reduce_64(r, m, mp);
 80126f2:	693b      	ldr	r3, [r7, #16]
 80126f4:	461a      	mov	r2, r3
 80126f6:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80126f8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80126fa:	f7ff fcce 	bl	801209a <sp_2048_mont_reduce_64>

                for (i = 63; i > 0; i--) {
 80126fe:	233f      	movs	r3, #63	; 0x3f
 8012700:	61fb      	str	r3, [r7, #28]
 8012702:	e00e      	b.n	8012722 <sp_RsaPublic_2048+0x208>
                    if (r[i] != m[i]) {
 8012704:	69fb      	ldr	r3, [r7, #28]
 8012706:	009b      	lsls	r3, r3, #2
 8012708:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801270a:	4413      	add	r3, r2
 801270c:	681a      	ldr	r2, [r3, #0]
 801270e:	69fb      	ldr	r3, [r7, #28]
 8012710:	009b      	lsls	r3, r3, #2
 8012712:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8012714:	440b      	add	r3, r1
 8012716:	681b      	ldr	r3, [r3, #0]
 8012718:	429a      	cmp	r2, r3
 801271a:	d106      	bne.n	801272a <sp_RsaPublic_2048+0x210>
                for (i = 63; i > 0; i--) {
 801271c:	69fb      	ldr	r3, [r7, #28]
 801271e:	3b01      	subs	r3, #1
 8012720:	61fb      	str	r3, [r7, #28]
 8012722:	69fb      	ldr	r3, [r7, #28]
 8012724:	2b00      	cmp	r3, #0
 8012726:	dced      	bgt.n	8012704 <sp_RsaPublic_2048+0x1ea>
 8012728:	e000      	b.n	801272c <sp_RsaPublic_2048+0x212>
                        break;
 801272a:	bf00      	nop
                    }
                }
                if (r[i] >= m[i]) {
 801272c:	69fb      	ldr	r3, [r7, #28]
 801272e:	009b      	lsls	r3, r3, #2
 8012730:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8012732:	4413      	add	r3, r2
 8012734:	681a      	ldr	r2, [r3, #0]
 8012736:	69fb      	ldr	r3, [r7, #28]
 8012738:	009b      	lsls	r3, r3, #2
 801273a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 801273c:	440b      	add	r3, r1
 801273e:	681b      	ldr	r3, [r3, #0]
 8012740:	429a      	cmp	r2, r3
 8012742:	d303      	bcc.n	801274c <sp_RsaPublic_2048+0x232>
                    sp_2048_sub_in_place_64(r, m);
 8012744:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8012746:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8012748:	f7fe fcec 	bl	8011124 <sp_2048_sub_in_place_64>
                }
            }
        }
    }

    if (err == MP_OKAY) {
 801274c:	6a3b      	ldr	r3, [r7, #32]
 801274e:	2b00      	cmp	r3, #0
 8012750:	d107      	bne.n	8012762 <sp_RsaPublic_2048+0x248>
        sp_2048_to_bin(r, out);
 8012752:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8012754:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8012756:	f7fe fc43 	bl	8010fe0 <sp_2048_to_bin>
        *outLen = 256;
 801275a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801275c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8012760:	601a      	str	r2, [r3, #0]
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (d != NULL) {
 8012762:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012764:	2b00      	cmp	r3, #0
 8012766:	d007      	beq.n	8012778 <sp_RsaPublic_2048+0x25e>
        XFREE(d, NULL, DYNAMIC_TYPE_RSA);
 8012768:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801276a:	61bb      	str	r3, [r7, #24]
 801276c:	69bb      	ldr	r3, [r7, #24]
 801276e:	2b00      	cmp	r3, #0
 8012770:	d002      	beq.n	8012778 <sp_RsaPublic_2048+0x25e>
 8012772:	69b8      	ldr	r0, [r7, #24]
 8012774:	f7fc fbdc 	bl	800ef30 <wolfSSL_Free>
    }
#endif

    return err;
 8012778:	6a3b      	ldr	r3, [r7, #32]
}
 801277a:	4618      	mov	r0, r3
 801277c:	3738      	adds	r7, #56	; 0x38
 801277e:	46bd      	mov	sp, r7
 8012780:	bd80      	pop	{r7, pc}

08012782 <sp_2048_cond_add_32>:
 * b  A single precision number to add.
 * m  Mask value to apply.
 */
SP_NOINLINE static sp_digit sp_2048_cond_add_32(sp_digit* r, const sp_digit* a, const sp_digit* b,
        sp_digit m)
{
 8012782:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 8012786:	b086      	sub	sp, #24
 8012788:	af00      	add	r7, sp, #0
 801278a:	60f8      	str	r0, [r7, #12]
 801278c:	60b9      	str	r1, [r7, #8]
 801278e:	607a      	str	r2, [r7, #4]
 8012790:	603b      	str	r3, [r7, #0]
    sp_digit c = 0;
 8012792:	2300      	movs	r3, #0
 8012794:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 8012796:	68fa      	ldr	r2, [r7, #12]
 8012798:	68b9      	ldr	r1, [r7, #8]
 801279a:	6878      	ldr	r0, [r7, #4]
 801279c:	683c      	ldr	r4, [r7, #0]
 801279e:	697b      	ldr	r3, [r7, #20]
 80127a0:	f04f 0580 	mov.w	r5, #128	; 0x80
 80127a4:	46a9      	mov	r9, r5
 80127a6:	f04f 0800 	mov.w	r8, #0
 80127aa:	f850 6008 	ldr.w	r6, [r0, r8]
 80127ae:	ea06 0604 	and.w	r6, r6, r4
 80127b2:	f113 35ff 	adds.w	r5, r3, #4294967295
 80127b6:	f851 5008 	ldr.w	r5, [r1, r8]
 80127ba:	4175      	adcs	r5, r6
 80127bc:	f04f 0300 	mov.w	r3, #0
 80127c0:	415b      	adcs	r3, r3
 80127c2:	f842 5008 	str.w	r5, [r2, r8]
 80127c6:	f108 0804 	add.w	r8, r8, #4
 80127ca:	45c8      	cmp	r8, r9
 80127cc:	dbed      	blt.n	80127aa <sp_2048_cond_add_32+0x28>
 80127ce:	617b      	str	r3, [r7, #20]
        : [c] "+r" (c)
        : [r] "r" (r), [a] "r" (a), [b] "r" (b), [m] "r" (m)
        : "memory", "r5", "r6", "r8", "r9"
    );

    return c;
 80127d0:	697b      	ldr	r3, [r7, #20]
}
 80127d2:	4618      	mov	r0, r3
 80127d4:	3718      	adds	r7, #24
 80127d6:	46bd      	mov	sp, r7
 80127d8:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 80127dc:	4770      	bx	lr

080127de <sp_RsaPrivate_2048>:
 * an array is too long and MEMORY_E when dynamic memory allocation fails.
 */
int sp_RsaPrivate_2048(const byte* in, word32 inLen, mp_int* dm,
    mp_int* pm, mp_int* qm, mp_int* dpm, mp_int* dqm, mp_int* qim, mp_int* mm,
    byte* out, word32* outLen)
{
 80127de:	b580      	push	{r7, lr}
 80127e0:	b094      	sub	sp, #80	; 0x50
 80127e2:	af02      	add	r7, sp, #8
 80127e4:	60f8      	str	r0, [r7, #12]
 80127e6:	60b9      	str	r1, [r7, #8]
 80127e8:	607a      	str	r2, [r7, #4]
 80127ea:	603b      	str	r3, [r7, #0]
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit a[64 * 2];
    sp_digit p[32], q[32], dp[32];
    sp_digit tmpa[64], tmpb[64];
#else
    sp_digit* t = NULL;
 80127ec:	2300      	movs	r3, #0
 80127ee:	647b      	str	r3, [r7, #68]	; 0x44
    sp_digit* a = NULL;
 80127f0:	2300      	movs	r3, #0
 80127f2:	643b      	str	r3, [r7, #64]	; 0x40
    sp_digit* p = NULL;
 80127f4:	2300      	movs	r3, #0
 80127f6:	63fb      	str	r3, [r7, #60]	; 0x3c
    sp_digit* q = NULL;
 80127f8:	2300      	movs	r3, #0
 80127fa:	63bb      	str	r3, [r7, #56]	; 0x38
    sp_digit* dp = NULL;
 80127fc:	2300      	movs	r3, #0
 80127fe:	637b      	str	r3, [r7, #52]	; 0x34
    sp_digit* tmpa = NULL;
 8012800:	2300      	movs	r3, #0
 8012802:	633b      	str	r3, [r7, #48]	; 0x30
    sp_digit* tmpb = NULL;
 8012804:	2300      	movs	r3, #0
 8012806:	62fb      	str	r3, [r7, #44]	; 0x2c
#endif
    sp_digit* r = NULL;
 8012808:	2300      	movs	r3, #0
 801280a:	62bb      	str	r3, [r7, #40]	; 0x28
    sp_digit* qi = NULL;
 801280c:	2300      	movs	r3, #0
 801280e:	627b      	str	r3, [r7, #36]	; 0x24
    sp_digit* dq = NULL;
 8012810:	2300      	movs	r3, #0
 8012812:	623b      	str	r3, [r7, #32]
    sp_digit c;
    int err = MP_OKAY;
 8012814:	2300      	movs	r3, #0
 8012816:	61fb      	str	r3, [r7, #28]

    (void)dm;
    (void)mm;

    if (*outLen < 256) {
 8012818:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801281a:	681b      	ldr	r3, [r3, #0]
 801281c:	2bff      	cmp	r3, #255	; 0xff
 801281e:	d803      	bhi.n	8012828 <sp_RsaPrivate_2048+0x4a>
        err = MP_TO_E;
 8012820:	f06f 0370 	mvn.w	r3, #112	; 0x70
 8012824:	61fb      	str	r3, [r7, #28]
 8012826:	e01b      	b.n	8012860 <sp_RsaPrivate_2048+0x82>
    }
    else if (inLen > 256 || mp_count_bits(mm) != 2048) {
 8012828:	68bb      	ldr	r3, [r7, #8]
 801282a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 801282e:	d806      	bhi.n	801283e <sp_RsaPrivate_2048+0x60>
 8012830:	6e38      	ldr	r0, [r7, #96]	; 0x60
 8012832:	f006 f9cf 	bl	8018bd4 <sp_count_bits>
 8012836:	4603      	mov	r3, r0
 8012838:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 801283c:	d003      	beq.n	8012846 <sp_RsaPrivate_2048+0x68>
        err = MP_READ_E;
 801283e:	f06f 036e 	mvn.w	r3, #110	; 0x6e
 8012842:	61fb      	str	r3, [r7, #28]
 8012844:	e00c      	b.n	8012860 <sp_RsaPrivate_2048+0x82>
    }
    else if (mp_iseven(mm)) {
 8012846:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8012848:	681b      	ldr	r3, [r3, #0]
 801284a:	2b00      	cmp	r3, #0
 801284c:	d008      	beq.n	8012860 <sp_RsaPrivate_2048+0x82>
 801284e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8012850:	689b      	ldr	r3, [r3, #8]
 8012852:	f003 0301 	and.w	r3, r3, #1
 8012856:	2b00      	cmp	r3, #0
 8012858:	d102      	bne.n	8012860 <sp_RsaPrivate_2048+0x82>
        err = MP_VAL;
 801285a:	f06f 0302 	mvn.w	r3, #2
 801285e:	61fb      	str	r3, [r7, #28]
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
 8012860:	69fb      	ldr	r3, [r7, #28]
 8012862:	2b00      	cmp	r3, #0
 8012864:	d10a      	bne.n	801287c <sp_RsaPrivate_2048+0x9e>
        t = (sp_digit*)XMALLOC(sizeof(sp_digit) * 32 * 11, NULL,
 8012866:	f44f 60b0 	mov.w	r0, #1408	; 0x580
 801286a:	f7fc fb45 	bl	800eef8 <wolfSSL_Malloc>
 801286e:	6478      	str	r0, [r7, #68]	; 0x44
                                                              DYNAMIC_TYPE_RSA);
        if (t == NULL)
 8012870:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8012872:	2b00      	cmp	r3, #0
 8012874:	d102      	bne.n	801287c <sp_RsaPrivate_2048+0x9e>
            err = MEMORY_E;
 8012876:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 801287a:	61fb      	str	r3, [r7, #28]
    }
    if (err == MP_OKAY) {
 801287c:	69fb      	ldr	r3, [r7, #28]
 801287e:	2b00      	cmp	r3, #0
 8012880:	d11a      	bne.n	80128b8 <sp_RsaPrivate_2048+0xda>
        a = t;
 8012882:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8012884:	643b      	str	r3, [r7, #64]	; 0x40
        p = a + 64 * 2;
 8012886:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012888:	f503 7300 	add.w	r3, r3, #512	; 0x200
 801288c:	63fb      	str	r3, [r7, #60]	; 0x3c
        q = p + 32;
 801288e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012890:	3380      	adds	r3, #128	; 0x80
 8012892:	63bb      	str	r3, [r7, #56]	; 0x38
        qi = dq = dp = q + 32;
 8012894:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012896:	3380      	adds	r3, #128	; 0x80
 8012898:	637b      	str	r3, [r7, #52]	; 0x34
 801289a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801289c:	623b      	str	r3, [r7, #32]
 801289e:	6a3b      	ldr	r3, [r7, #32]
 80128a0:	627b      	str	r3, [r7, #36]	; 0x24
        tmpa = qi + 32;
 80128a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80128a4:	3380      	adds	r3, #128	; 0x80
 80128a6:	633b      	str	r3, [r7, #48]	; 0x30
        tmpb = tmpa + 64;
 80128a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80128aa:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80128ae:	62fb      	str	r3, [r7, #44]	; 0x2c

        r = t + 64;
 80128b0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80128b2:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80128b6:	62bb      	str	r3, [r7, #40]	; 0x28
    }
#else
#endif

    if (err == MP_OKAY) {
 80128b8:	69fb      	ldr	r3, [r7, #28]
 80128ba:	2b00      	cmp	r3, #0
 80128bc:	d120      	bne.n	8012900 <sp_RsaPrivate_2048+0x122>
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
        r = a;
        qi = dq = dp;
#endif
        sp_2048_from_bin(a, 64, in, inLen);
 80128be:	68bb      	ldr	r3, [r7, #8]
 80128c0:	68fa      	ldr	r2, [r7, #12]
 80128c2:	2140      	movs	r1, #64	; 0x40
 80128c4:	6c38      	ldr	r0, [r7, #64]	; 0x40
 80128c6:	f7fe faf5 	bl	8010eb4 <sp_2048_from_bin>
        sp_2048_from_mp(p, 32, pm);
 80128ca:	683a      	ldr	r2, [r7, #0]
 80128cc:	2120      	movs	r1, #32
 80128ce:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80128d0:	f7fe fb61 	bl	8010f96 <sp_2048_from_mp>
        sp_2048_from_mp(q, 32, qm);
 80128d4:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80128d6:	2120      	movs	r1, #32
 80128d8:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80128da:	f7fe fb5c 	bl	8010f96 <sp_2048_from_mp>
        sp_2048_from_mp(dp, 32, dpm);
 80128de:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80128e0:	2120      	movs	r1, #32
 80128e2:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80128e4:	f7fe fb57 	bl	8010f96 <sp_2048_from_mp>

        err = sp_2048_mod_exp_32(tmpa, a, dp, 1024, p, 1);
 80128e8:	2301      	movs	r3, #1
 80128ea:	9301      	str	r3, [sp, #4]
 80128ec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80128ee:	9300      	str	r3, [sp, #0]
 80128f0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80128f4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80128f6:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80128f8:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80128fa:	f7ff f9b5 	bl	8011c68 <sp_2048_mod_exp_32>
 80128fe:	61f8      	str	r0, [r7, #28]
    }
    if (err == MP_OKAY) {
 8012900:	69fb      	ldr	r3, [r7, #28]
 8012902:	2b00      	cmp	r3, #0
 8012904:	d110      	bne.n	8012928 <sp_RsaPrivate_2048+0x14a>
        sp_2048_from_mp(dq, 32, dqm);
 8012906:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8012908:	2120      	movs	r1, #32
 801290a:	6a38      	ldr	r0, [r7, #32]
 801290c:	f7fe fb43 	bl	8010f96 <sp_2048_from_mp>
        err = sp_2048_mod_exp_32(tmpb, a, dq, 1024, q, 1);
 8012910:	2301      	movs	r3, #1
 8012912:	9301      	str	r3, [sp, #4]
 8012914:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012916:	9300      	str	r3, [sp, #0]
 8012918:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801291c:	6a3a      	ldr	r2, [r7, #32]
 801291e:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8012920:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8012922:	f7ff f9a1 	bl	8011c68 <sp_2048_mod_exp_32>
 8012926:	61f8      	str	r0, [r7, #28]
    }

    if (err == MP_OKAY) {
 8012928:	69fb      	ldr	r3, [r7, #28]
 801292a:	2b00      	cmp	r3, #0
 801292c:	d124      	bne.n	8012978 <sp_RsaPrivate_2048+0x19a>
        c = sp_2048_sub_in_place_32(tmpa, tmpb);
 801292e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8012930:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8012932:	f7fe fd6a 	bl	801140a <sp_2048_sub_in_place_32>
 8012936:	61b8      	str	r0, [r7, #24]
        c += sp_2048_cond_add_32(tmpa, tmpa, p, c);
 8012938:	69bb      	ldr	r3, [r7, #24]
 801293a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801293c:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801293e:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8012940:	f7ff ff1f 	bl	8012782 <sp_2048_cond_add_32>
 8012944:	4602      	mov	r2, r0
 8012946:	69bb      	ldr	r3, [r7, #24]
 8012948:	4413      	add	r3, r2
 801294a:	61bb      	str	r3, [r7, #24]
        sp_2048_cond_add_32(tmpa, tmpa, p, c);
 801294c:	69bb      	ldr	r3, [r7, #24]
 801294e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8012950:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8012952:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8012954:	f7ff ff15 	bl	8012782 <sp_2048_cond_add_32>

        sp_2048_from_mp(qi, 32, qim);
 8012958:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801295a:	2120      	movs	r1, #32
 801295c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801295e:	f7fe fb1a 	bl	8010f96 <sp_2048_from_mp>
        sp_2048_mul_32(tmpa, tmpa, qi);
 8012962:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8012964:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8012966:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8012968:	f7fe fd7d 	bl	8011466 <sp_2048_mul_32>
        err = sp_2048_mod_32(tmpa, tmpa, p);
 801296c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801296e:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8012970:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8012972:	f7ff f968 	bl	8011c46 <sp_2048_mod_32>
 8012976:	61f8      	str	r0, [r7, #28]
    }

    if (err == MP_OKAY) {
 8012978:	69fb      	ldr	r3, [r7, #28]
 801297a:	2b00      	cmp	r3, #0
 801297c:	d118      	bne.n	80129b0 <sp_RsaPrivate_2048+0x1d2>
        sp_2048_mul_32(tmpa, q, tmpa);
 801297e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8012980:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8012982:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8012984:	f7fe fd6f 	bl	8011466 <sp_2048_mul_32>
        XMEMSET(&tmpb[32], 0, sizeof(sp_digit) * 32);
 8012988:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801298a:	3380      	adds	r3, #128	; 0x80
 801298c:	2280      	movs	r2, #128	; 0x80
 801298e:	2100      	movs	r1, #0
 8012990:	4618      	mov	r0, r3
 8012992:	f006 fd54 	bl	801943e <memset>
        sp_2048_add_64(r, tmpb, tmpa);
 8012996:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8012998:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 801299a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801299c:	f7fe fb91 	bl	80110c2 <sp_2048_add_64>

        sp_2048_to_bin(r, out);
 80129a0:	6e79      	ldr	r1, [r7, #100]	; 0x64
 80129a2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80129a4:	f7fe fb1c 	bl	8010fe0 <sp_2048_to_bin>
        *outLen = 256;
 80129a8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80129aa:	f44f 7280 	mov.w	r2, #256	; 0x100
 80129ae:	601a      	str	r2, [r3, #0]
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (t != NULL) {
 80129b0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80129b2:	2b00      	cmp	r3, #0
 80129b4:	d00d      	beq.n	80129d2 <sp_RsaPrivate_2048+0x1f4>
        XMEMSET(t, 0, sizeof(sp_digit) * 32 * 11);
 80129b6:	f44f 62b0 	mov.w	r2, #1408	; 0x580
 80129ba:	2100      	movs	r1, #0
 80129bc:	6c78      	ldr	r0, [r7, #68]	; 0x44
 80129be:	f006 fd3e 	bl	801943e <memset>
        XFREE(t, NULL, DYNAMIC_TYPE_RSA);
 80129c2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80129c4:	617b      	str	r3, [r7, #20]
 80129c6:	697b      	ldr	r3, [r7, #20]
 80129c8:	2b00      	cmp	r3, #0
 80129ca:	d002      	beq.n	80129d2 <sp_RsaPrivate_2048+0x1f4>
 80129cc:	6978      	ldr	r0, [r7, #20]
 80129ce:	f7fc faaf 	bl	800ef30 <wolfSSL_Free>
    XMEMSET(p,    0, sizeof(p));
    XMEMSET(q,    0, sizeof(q));
    XMEMSET(dp,   0, sizeof(dp));
#endif
#endif /* SP_RSA_PRIVATE_EXP_D || RSA_LOW_MEM */
    return err;
 80129d2:	69fb      	ldr	r3, [r7, #28]
}
 80129d4:	4618      	mov	r0, r3
 80129d6:	3748      	adds	r7, #72	; 0x48
 80129d8:	46bd      	mov	sp, r7
 80129da:	bd80      	pop	{r7, pc}

080129dc <sp_3072_from_bin>:
 * size  Maximum number of bytes to convert
 * a  Byte array.
 * n  Number of bytes in array to read.
 */
static void sp_3072_from_bin(sp_digit* r, int size, const byte* a, int n)
{
 80129dc:	b480      	push	{r7}
 80129de:	b089      	sub	sp, #36	; 0x24
 80129e0:	af00      	add	r7, sp, #0
 80129e2:	60f8      	str	r0, [r7, #12]
 80129e4:	60b9      	str	r1, [r7, #8]
 80129e6:	607a      	str	r2, [r7, #4]
 80129e8:	603b      	str	r3, [r7, #0]
    int i, j = 0;
 80129ea:	2300      	movs	r3, #0
 80129ec:	61bb      	str	r3, [r7, #24]
    word32 s = 0;
 80129ee:	2300      	movs	r3, #0
 80129f0:	617b      	str	r3, [r7, #20]

    r[0] = 0;
 80129f2:	68fb      	ldr	r3, [r7, #12]
 80129f4:	2200      	movs	r2, #0
 80129f6:	601a      	str	r2, [r3, #0]
    for (i = n-1; i >= 0; i--) {
 80129f8:	683b      	ldr	r3, [r7, #0]
 80129fa:	3b01      	subs	r3, #1
 80129fc:	61fb      	str	r3, [r7, #28]
 80129fe:	e042      	b.n	8012a86 <sp_3072_from_bin+0xaa>
        r[j] |= (((sp_digit)a[i]) << s);
 8012a00:	69bb      	ldr	r3, [r7, #24]
 8012a02:	009b      	lsls	r3, r3, #2
 8012a04:	68fa      	ldr	r2, [r7, #12]
 8012a06:	4413      	add	r3, r2
 8012a08:	6819      	ldr	r1, [r3, #0]
 8012a0a:	69fb      	ldr	r3, [r7, #28]
 8012a0c:	687a      	ldr	r2, [r7, #4]
 8012a0e:	4413      	add	r3, r2
 8012a10:	781b      	ldrb	r3, [r3, #0]
 8012a12:	461a      	mov	r2, r3
 8012a14:	697b      	ldr	r3, [r7, #20]
 8012a16:	409a      	lsls	r2, r3
 8012a18:	69bb      	ldr	r3, [r7, #24]
 8012a1a:	009b      	lsls	r3, r3, #2
 8012a1c:	68f8      	ldr	r0, [r7, #12]
 8012a1e:	4403      	add	r3, r0
 8012a20:	430a      	orrs	r2, r1
 8012a22:	601a      	str	r2, [r3, #0]
        if (s >= 24U) {
 8012a24:	697b      	ldr	r3, [r7, #20]
 8012a26:	2b17      	cmp	r3, #23
 8012a28:	d927      	bls.n	8012a7a <sp_3072_from_bin+0x9e>
            r[j] &= 0xffffffff;
 8012a2a:	69bb      	ldr	r3, [r7, #24]
 8012a2c:	009b      	lsls	r3, r3, #2
 8012a2e:	68fa      	ldr	r2, [r7, #12]
 8012a30:	441a      	add	r2, r3
 8012a32:	69bb      	ldr	r3, [r7, #24]
 8012a34:	009b      	lsls	r3, r3, #2
 8012a36:	68f9      	ldr	r1, [r7, #12]
 8012a38:	440b      	add	r3, r1
 8012a3a:	6812      	ldr	r2, [r2, #0]
 8012a3c:	601a      	str	r2, [r3, #0]
            s = 32U - s;
 8012a3e:	697b      	ldr	r3, [r7, #20]
 8012a40:	f1c3 0320 	rsb	r3, r3, #32
 8012a44:	617b      	str	r3, [r7, #20]
            if (j + 1 >= size) {
 8012a46:	69bb      	ldr	r3, [r7, #24]
 8012a48:	3301      	adds	r3, #1
 8012a4a:	68ba      	ldr	r2, [r7, #8]
 8012a4c:	429a      	cmp	r2, r3
 8012a4e:	dd1e      	ble.n	8012a8e <sp_3072_from_bin+0xb2>
                break;
            }
            r[++j] = (sp_digit)a[i] >> s;
 8012a50:	69fb      	ldr	r3, [r7, #28]
 8012a52:	687a      	ldr	r2, [r7, #4]
 8012a54:	4413      	add	r3, r2
 8012a56:	781b      	ldrb	r3, [r3, #0]
 8012a58:	4619      	mov	r1, r3
 8012a5a:	69bb      	ldr	r3, [r7, #24]
 8012a5c:	3301      	adds	r3, #1
 8012a5e:	61bb      	str	r3, [r7, #24]
 8012a60:	69bb      	ldr	r3, [r7, #24]
 8012a62:	009b      	lsls	r3, r3, #2
 8012a64:	68fa      	ldr	r2, [r7, #12]
 8012a66:	4413      	add	r3, r2
 8012a68:	697a      	ldr	r2, [r7, #20]
 8012a6a:	fa21 f202 	lsr.w	r2, r1, r2
 8012a6e:	601a      	str	r2, [r3, #0]
            s = 8U - s;
 8012a70:	697b      	ldr	r3, [r7, #20]
 8012a72:	f1c3 0308 	rsb	r3, r3, #8
 8012a76:	617b      	str	r3, [r7, #20]
 8012a78:	e002      	b.n	8012a80 <sp_3072_from_bin+0xa4>
        }
        else {
            s += 8U;
 8012a7a:	697b      	ldr	r3, [r7, #20]
 8012a7c:	3308      	adds	r3, #8
 8012a7e:	617b      	str	r3, [r7, #20]
    for (i = n-1; i >= 0; i--) {
 8012a80:	69fb      	ldr	r3, [r7, #28]
 8012a82:	3b01      	subs	r3, #1
 8012a84:	61fb      	str	r3, [r7, #28]
 8012a86:	69fb      	ldr	r3, [r7, #28]
 8012a88:	2b00      	cmp	r3, #0
 8012a8a:	dab9      	bge.n	8012a00 <sp_3072_from_bin+0x24>
 8012a8c:	e000      	b.n	8012a90 <sp_3072_from_bin+0xb4>
                break;
 8012a8e:	bf00      	nop
        }
    }

    for (j++; j < size; j++) {
 8012a90:	69bb      	ldr	r3, [r7, #24]
 8012a92:	3301      	adds	r3, #1
 8012a94:	61bb      	str	r3, [r7, #24]
 8012a96:	e008      	b.n	8012aaa <sp_3072_from_bin+0xce>
        r[j] = 0;
 8012a98:	69bb      	ldr	r3, [r7, #24]
 8012a9a:	009b      	lsls	r3, r3, #2
 8012a9c:	68fa      	ldr	r2, [r7, #12]
 8012a9e:	4413      	add	r3, r2
 8012aa0:	2200      	movs	r2, #0
 8012aa2:	601a      	str	r2, [r3, #0]
    for (j++; j < size; j++) {
 8012aa4:	69bb      	ldr	r3, [r7, #24]
 8012aa6:	3301      	adds	r3, #1
 8012aa8:	61bb      	str	r3, [r7, #24]
 8012aaa:	69ba      	ldr	r2, [r7, #24]
 8012aac:	68bb      	ldr	r3, [r7, #8]
 8012aae:	429a      	cmp	r2, r3
 8012ab0:	dbf2      	blt.n	8012a98 <sp_3072_from_bin+0xbc>
    }
}
 8012ab2:	bf00      	nop
 8012ab4:	3724      	adds	r7, #36	; 0x24
 8012ab6:	46bd      	mov	sp, r7
 8012ab8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012abc:	4770      	bx	lr

08012abe <sp_3072_from_mp>:
 * r  A single precision integer.
 * size  Maximum number of bytes to convert
 * a  A multi-precision integer.
 */
static void sp_3072_from_mp(sp_digit* r, int size, const mp_int* a)
{
 8012abe:	b580      	push	{r7, lr}
 8012ac0:	b086      	sub	sp, #24
 8012ac2:	af00      	add	r7, sp, #0
 8012ac4:	60f8      	str	r0, [r7, #12]
 8012ac6:	60b9      	str	r1, [r7, #8]
 8012ac8:	607a      	str	r2, [r7, #4]
#if DIGIT_BIT == 32
    int j;

    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
 8012aca:	687b      	ldr	r3, [r7, #4]
 8012acc:	f103 0108 	add.w	r1, r3, #8
 8012ad0:	687b      	ldr	r3, [r7, #4]
 8012ad2:	681b      	ldr	r3, [r3, #0]
 8012ad4:	009b      	lsls	r3, r3, #2
 8012ad6:	461a      	mov	r2, r3
 8012ad8:	68f8      	ldr	r0, [r7, #12]
 8012ada:	f006 fc8c 	bl	80193f6 <memcpy>

    for (j = a->used; j < size; j++) {
 8012ade:	687b      	ldr	r3, [r7, #4]
 8012ae0:	681b      	ldr	r3, [r3, #0]
 8012ae2:	617b      	str	r3, [r7, #20]
 8012ae4:	e008      	b.n	8012af8 <sp_3072_from_mp+0x3a>
        r[j] = 0;
 8012ae6:	697b      	ldr	r3, [r7, #20]
 8012ae8:	009b      	lsls	r3, r3, #2
 8012aea:	68fa      	ldr	r2, [r7, #12]
 8012aec:	4413      	add	r3, r2
 8012aee:	2200      	movs	r2, #0
 8012af0:	601a      	str	r2, [r3, #0]
    for (j = a->used; j < size; j++) {
 8012af2:	697b      	ldr	r3, [r7, #20]
 8012af4:	3301      	adds	r3, #1
 8012af6:	617b      	str	r3, [r7, #20]
 8012af8:	697a      	ldr	r2, [r7, #20]
 8012afa:	68bb      	ldr	r3, [r7, #8]
 8012afc:	429a      	cmp	r2, r3
 8012afe:	dbf2      	blt.n	8012ae6 <sp_3072_from_mp+0x28>

    for (j++; j < size; j++) {
        r[j] = 0;
    }
#endif
}
 8012b00:	bf00      	nop
 8012b02:	3718      	adds	r7, #24
 8012b04:	46bd      	mov	sp, r7
 8012b06:	bd80      	pop	{r7, pc}

08012b08 <sp_3072_to_bin>:
 *
 * r  A single precision integer.
 * a  Byte array.
 */
static void sp_3072_to_bin(sp_digit* r, byte* a)
{
 8012b08:	b480      	push	{r7}
 8012b0a:	b087      	sub	sp, #28
 8012b0c:	af00      	add	r7, sp, #0
 8012b0e:	6078      	str	r0, [r7, #4]
 8012b10:	6039      	str	r1, [r7, #0]
    int i, j, s = 0, b;
 8012b12:	2300      	movs	r3, #0
 8012b14:	60fb      	str	r3, [r7, #12]

    j = 3072 / 8 - 1;
 8012b16:	f240 137f 	movw	r3, #383	; 0x17f
 8012b1a:	613b      	str	r3, [r7, #16]
    a[j] = 0;
 8012b1c:	693b      	ldr	r3, [r7, #16]
 8012b1e:	683a      	ldr	r2, [r7, #0]
 8012b20:	4413      	add	r3, r2
 8012b22:	2200      	movs	r2, #0
 8012b24:	701a      	strb	r2, [r3, #0]
    for (i=0; i<96 && j>=0; i++) {
 8012b26:	2300      	movs	r3, #0
 8012b28:	617b      	str	r3, [r7, #20]
 8012b2a:	e051      	b.n	8012bd0 <sp_3072_to_bin+0xc8>
        b = 0;
 8012b2c:	2300      	movs	r3, #0
 8012b2e:	60bb      	str	r3, [r7, #8]
        /* lint allow cast of mismatch sp_digit and int */
        a[j--] |= (byte)(r[i] << s); /*lint !e9033*/
 8012b30:	693b      	ldr	r3, [r7, #16]
 8012b32:	1e5a      	subs	r2, r3, #1
 8012b34:	613a      	str	r2, [r7, #16]
 8012b36:	4619      	mov	r1, r3
 8012b38:	683a      	ldr	r2, [r7, #0]
 8012b3a:	440a      	add	r2, r1
 8012b3c:	7811      	ldrb	r1, [r2, #0]
 8012b3e:	697a      	ldr	r2, [r7, #20]
 8012b40:	0092      	lsls	r2, r2, #2
 8012b42:	6878      	ldr	r0, [r7, #4]
 8012b44:	4402      	add	r2, r0
 8012b46:	6810      	ldr	r0, [r2, #0]
 8012b48:	68fa      	ldr	r2, [r7, #12]
 8012b4a:	fa00 f202 	lsl.w	r2, r0, r2
 8012b4e:	b2d2      	uxtb	r2, r2
 8012b50:	4618      	mov	r0, r3
 8012b52:	683b      	ldr	r3, [r7, #0]
 8012b54:	4403      	add	r3, r0
 8012b56:	430a      	orrs	r2, r1
 8012b58:	b2d2      	uxtb	r2, r2
 8012b5a:	701a      	strb	r2, [r3, #0]
        b += 8 - s;
 8012b5c:	68fb      	ldr	r3, [r7, #12]
 8012b5e:	f1c3 0308 	rsb	r3, r3, #8
 8012b62:	68ba      	ldr	r2, [r7, #8]
 8012b64:	4413      	add	r3, r2
 8012b66:	60bb      	str	r3, [r7, #8]
        if (j < 0) {
 8012b68:	693b      	ldr	r3, [r7, #16]
 8012b6a:	2b00      	cmp	r3, #0
 8012b6c:	db37      	blt.n	8012bde <sp_3072_to_bin+0xd6>
            break;
        }
        while (b < 32) {
 8012b6e:	e015      	b.n	8012b9c <sp_3072_to_bin+0x94>
            a[j--] = (byte)(r[i] >> b);
 8012b70:	697b      	ldr	r3, [r7, #20]
 8012b72:	009b      	lsls	r3, r3, #2
 8012b74:	687a      	ldr	r2, [r7, #4]
 8012b76:	4413      	add	r3, r2
 8012b78:	681a      	ldr	r2, [r3, #0]
 8012b7a:	68bb      	ldr	r3, [r7, #8]
 8012b7c:	fa22 f103 	lsr.w	r1, r2, r3
 8012b80:	693b      	ldr	r3, [r7, #16]
 8012b82:	1e5a      	subs	r2, r3, #1
 8012b84:	613a      	str	r2, [r7, #16]
 8012b86:	461a      	mov	r2, r3
 8012b88:	683b      	ldr	r3, [r7, #0]
 8012b8a:	4413      	add	r3, r2
 8012b8c:	b2ca      	uxtb	r2, r1
 8012b8e:	701a      	strb	r2, [r3, #0]
            b += 8;
 8012b90:	68bb      	ldr	r3, [r7, #8]
 8012b92:	3308      	adds	r3, #8
 8012b94:	60bb      	str	r3, [r7, #8]
            if (j < 0) {
 8012b96:	693b      	ldr	r3, [r7, #16]
 8012b98:	2b00      	cmp	r3, #0
 8012b9a:	db03      	blt.n	8012ba4 <sp_3072_to_bin+0x9c>
        while (b < 32) {
 8012b9c:	68bb      	ldr	r3, [r7, #8]
 8012b9e:	2b1f      	cmp	r3, #31
 8012ba0:	dde6      	ble.n	8012b70 <sp_3072_to_bin+0x68>
 8012ba2:	e000      	b.n	8012ba6 <sp_3072_to_bin+0x9e>
                break;
 8012ba4:	bf00      	nop
            }
        }
        s = 8 - (b - 32);
 8012ba6:	68bb      	ldr	r3, [r7, #8]
 8012ba8:	f1c3 0328 	rsb	r3, r3, #40	; 0x28
 8012bac:	60fb      	str	r3, [r7, #12]
        if (j >= 0) {
 8012bae:	693b      	ldr	r3, [r7, #16]
 8012bb0:	2b00      	cmp	r3, #0
 8012bb2:	db04      	blt.n	8012bbe <sp_3072_to_bin+0xb6>
            a[j] = 0;
 8012bb4:	693b      	ldr	r3, [r7, #16]
 8012bb6:	683a      	ldr	r2, [r7, #0]
 8012bb8:	4413      	add	r3, r2
 8012bba:	2200      	movs	r2, #0
 8012bbc:	701a      	strb	r2, [r3, #0]
        }
        if (s != 0) {
 8012bbe:	68fb      	ldr	r3, [r7, #12]
 8012bc0:	2b00      	cmp	r3, #0
 8012bc2:	d002      	beq.n	8012bca <sp_3072_to_bin+0xc2>
            j++;
 8012bc4:	693b      	ldr	r3, [r7, #16]
 8012bc6:	3301      	adds	r3, #1
 8012bc8:	613b      	str	r3, [r7, #16]
    for (i=0; i<96 && j>=0; i++) {
 8012bca:	697b      	ldr	r3, [r7, #20]
 8012bcc:	3301      	adds	r3, #1
 8012bce:	617b      	str	r3, [r7, #20]
 8012bd0:	697b      	ldr	r3, [r7, #20]
 8012bd2:	2b5f      	cmp	r3, #95	; 0x5f
 8012bd4:	dc04      	bgt.n	8012be0 <sp_3072_to_bin+0xd8>
 8012bd6:	693b      	ldr	r3, [r7, #16]
 8012bd8:	2b00      	cmp	r3, #0
 8012bda:	daa7      	bge.n	8012b2c <sp_3072_to_bin+0x24>
        }
    }
}
 8012bdc:	e000      	b.n	8012be0 <sp_3072_to_bin+0xd8>
            break;
 8012bde:	bf00      	nop
}
 8012be0:	bf00      	nop
 8012be2:	371c      	adds	r7, #28
 8012be4:	46bd      	mov	sp, r7
 8012be6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012bea:	4770      	bx	lr

08012bec <sp_3072_add_96>:
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static sp_digit sp_3072_add_96(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
 8012bec:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 8012bf0:	b087      	sub	sp, #28
 8012bf2:	af00      	add	r7, sp, #0
 8012bf4:	60f8      	str	r0, [r7, #12]
 8012bf6:	60b9      	str	r1, [r7, #8]
 8012bf8:	607a      	str	r2, [r7, #4]
    sp_digit c = 0;
 8012bfa:	2300      	movs	r3, #0
 8012bfc:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 8012bfe:	6978      	ldr	r0, [r7, #20]
 8012c00:	68f9      	ldr	r1, [r7, #12]
 8012c02:	68ba      	ldr	r2, [r7, #8]
 8012c04:	687b      	ldr	r3, [r7, #4]
 8012c06:	4616      	mov	r6, r2
 8012c08:	f04f 0800 	mov.w	r8, #0
 8012c0c:	f506 76c0 	add.w	r6, r6, #384	; 0x180
 8012c10:	f1a8 0801 	sub.w	r8, r8, #1
 8012c14:	eb10 0008 	adds.w	r0, r0, r8
 8012c18:	6814      	ldr	r4, [r2, #0]
 8012c1a:	681d      	ldr	r5, [r3, #0]
 8012c1c:	416c      	adcs	r4, r5
 8012c1e:	600c      	str	r4, [r1, #0]
 8012c20:	f04f 0000 	mov.w	r0, #0
 8012c24:	eb40 0000 	adc.w	r0, r0, r0
 8012c28:	f102 0204 	add.w	r2, r2, #4
 8012c2c:	f103 0304 	add.w	r3, r3, #4
 8012c30:	f101 0104 	add.w	r1, r1, #4
 8012c34:	42b2      	cmp	r2, r6
 8012c36:	d1ed      	bne.n	8012c14 <sp_3072_add_96+0x28>
 8012c38:	6178      	str	r0, [r7, #20]
 8012c3a:	60f9      	str	r1, [r7, #12]
 8012c3c:	60ba      	str	r2, [r7, #8]
 8012c3e:	607b      	str	r3, [r7, #4]
        : [c] "+r" (c), [r] "+r" (r), [a] "+r" (a), [b] "+r" (b)
        :
        : "memory", "r4", "r5", "r6", "r8"
    );

    return c;
 8012c40:	697b      	ldr	r3, [r7, #20]
}
 8012c42:	4618      	mov	r0, r3
 8012c44:	371c      	adds	r7, #28
 8012c46:	46bd      	mov	sp, r7
 8012c48:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8012c4c:	4770      	bx	lr

08012c4e <sp_3072_sub_in_place_96>:
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static sp_digit sp_3072_sub_in_place_96(sp_digit* a,
        const sp_digit* b)
{
 8012c4e:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 8012c52:	b085      	sub	sp, #20
 8012c54:	af00      	add	r7, sp, #0
 8012c56:	6078      	str	r0, [r7, #4]
 8012c58:	6039      	str	r1, [r7, #0]
    sp_digit c = 0;
 8012c5a:	2300      	movs	r3, #0
 8012c5c:	60fb      	str	r3, [r7, #12]
    __asm__ __volatile__ (
 8012c5e:	68f9      	ldr	r1, [r7, #12]
 8012c60:	687a      	ldr	r2, [r7, #4]
 8012c62:	683b      	ldr	r3, [r7, #0]
 8012c64:	4608      	mov	r0, r1
 8012c66:	4611      	mov	r1, r2
 8012c68:	461a      	mov	r2, r3
 8012c6a:	4688      	mov	r8, r1
 8012c6c:	f508 78c0 	add.w	r8, r8, #384	; 0x180
 8012c70:	f04f 0500 	mov.w	r5, #0
 8012c74:	1a2d      	subs	r5, r5, r0
 8012c76:	680b      	ldr	r3, [r1, #0]
 8012c78:	684c      	ldr	r4, [r1, #4]
 8012c7a:	6815      	ldr	r5, [r2, #0]
 8012c7c:	6856      	ldr	r6, [r2, #4]
 8012c7e:	41ab      	sbcs	r3, r5
 8012c80:	41b4      	sbcs	r4, r6
 8012c82:	600b      	str	r3, [r1, #0]
 8012c84:	604c      	str	r4, [r1, #4]
 8012c86:	eb60 0000 	sbc.w	r0, r0, r0
 8012c8a:	f101 0108 	add.w	r1, r1, #8
 8012c8e:	f102 0208 	add.w	r2, r2, #8
 8012c92:	4541      	cmp	r1, r8
 8012c94:	d1ec      	bne.n	8012c70 <sp_3072_sub_in_place_96+0x22>
 8012c96:	60f8      	str	r0, [r7, #12]
 8012c98:	6079      	str	r1, [r7, #4]
 8012c9a:	603a      	str	r2, [r7, #0]
        : [c] "+r" (c), [a] "+r" (a), [b] "+r" (b)
        :
        : "memory", "r3", "r4", "r5", "r6", "r8"
    );

    return c;
 8012c9c:	68fb      	ldr	r3, [r7, #12]
}
 8012c9e:	4618      	mov	r0, r3
 8012ca0:	3714      	adds	r7, #20
 8012ca2:	46bd      	mov	sp, r7
 8012ca4:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8012ca8:	4770      	bx	lr

08012caa <sp_3072_mul_96>:
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_3072_mul_96(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
 8012caa:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012cae:	f5ad 7d47 	sub.w	sp, sp, #796	; 0x31c
 8012cb2:	af00      	add	r7, sp, #0
 8012cb4:	f107 030c 	add.w	r3, r7, #12
 8012cb8:	6018      	str	r0, [r3, #0]
 8012cba:	f107 0308 	add.w	r3, r7, #8
 8012cbe:	6019      	str	r1, [r3, #0]
 8012cc0:	1d3b      	adds	r3, r7, #4
 8012cc2:	601a      	str	r2, [r3, #0]
    sp_digit tmp_arr[96 * 2];
    sp_digit* tmp = tmp_arr;
 8012cc4:	f107 0314 	add.w	r3, r7, #20
 8012cc8:	f8c7 3314 	str.w	r3, [r7, #788]	; 0x314
    __asm__ __volatile__ (
 8012ccc:	f8d7 2314 	ldr.w	r2, [r7, #788]	; 0x314
 8012cd0:	f107 0308 	add.w	r3, r7, #8
 8012cd4:	6819      	ldr	r1, [r3, #0]
 8012cd6:	1d3b      	adds	r3, r7, #4
 8012cd8:	6818      	ldr	r0, [r3, #0]
 8012cda:	f04f 0300 	mov.w	r3, #0
 8012cde:	f04f 0400 	mov.w	r4, #0
 8012ce2:	4699      	mov	r9, r3
 8012ce4:	4694      	mov	ip, r2
 8012ce6:	468a      	mov	sl, r1
 8012ce8:	4683      	mov	fp, r0
 8012cea:	f04f 0601 	mov.w	r6, #1
 8012cee:	ea4f 2606 	mov.w	r6, r6, lsl #8
 8012cf2:	f106 0680 	add.w	r6, r6, #128	; 0x80
 8012cf6:	4456      	add	r6, sl
 8012cf8:	46b6      	mov	lr, r6
 8012cfa:	f04f 0200 	mov.w	r2, #0
 8012cfe:	f04f 0500 	mov.w	r5, #0
 8012d02:	f04f 0601 	mov.w	r6, #1
 8012d06:	ea4f 2606 	mov.w	r6, r6, lsl #8
 8012d0a:	f106 067c 	add.w	r6, r6, #124	; 0x7c
 8012d0e:	4649      	mov	r1, r9
 8012d10:	1b89      	subs	r1, r1, r6
 8012d12:	eb66 0606 	sbc.w	r6, r6, r6
 8012d16:	ea6f 0606 	mvn.w	r6, r6
 8012d1a:	ea01 0106 	and.w	r1, r1, r6
 8012d1e:	4648      	mov	r0, r9
 8012d20:	eba0 0001 	sub.w	r0, r0, r1
 8012d24:	4451      	add	r1, sl
 8012d26:	4458      	add	r0, fp
 8012d28:	680e      	ldr	r6, [r1, #0]
 8012d2a:	f8d0 8000 	ldr.w	r8, [r0]
 8012d2e:	fba6 6808 	umull	r6, r8, r6, r8
 8012d32:	199b      	adds	r3, r3, r6
 8012d34:	eb54 0408 	adcs.w	r4, r4, r8
 8012d38:	eb45 0502 	adc.w	r5, r5, r2
 8012d3c:	f101 0104 	add.w	r1, r1, #4
 8012d40:	f1a0 0004 	sub.w	r0, r0, #4
 8012d44:	4571      	cmp	r1, lr
 8012d46:	d003      	beq.n	8012d50 <sp_3072_mul_96+0xa6>
 8012d48:	464e      	mov	r6, r9
 8012d4a:	4456      	add	r6, sl
 8012d4c:	42b1      	cmp	r1, r6
 8012d4e:	ddeb      	ble.n	8012d28 <sp_3072_mul_96+0x7e>
 8012d50:	4662      	mov	r2, ip
 8012d52:	46c8      	mov	r8, r9
 8012d54:	f842 3008 	str.w	r3, [r2, r8]
 8012d58:	4623      	mov	r3, r4
 8012d5a:	462c      	mov	r4, r5
 8012d5c:	f108 0804 	add.w	r8, r8, #4
 8012d60:	46c1      	mov	r9, r8
 8012d62:	f04f 0602 	mov.w	r6, #2
 8012d66:	ea4f 2606 	mov.w	r6, r6, lsl #8
 8012d6a:	f106 06f8 	add.w	r6, r6, #248	; 0xf8
 8012d6e:	45b0      	cmp	r8, r6
 8012d70:	ddc3      	ble.n	8012cfa <sp_3072_mul_96+0x50>
 8012d72:	f842 3008 	str.w	r3, [r2, r8]
 8012d76:	4651      	mov	r1, sl
 8012d78:	4658      	mov	r0, fp
        :
        : [r] "r" (tmp), [a] "r" (a), [b] "r" (b)
        : "memory", "r3", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r12", "r14"
    );

    XMEMCPY(r, tmp_arr, sizeof(tmp_arr));
 8012d7a:	f107 0114 	add.w	r1, r7, #20
 8012d7e:	f107 030c 	add.w	r3, r7, #12
 8012d82:	f44f 7240 	mov.w	r2, #768	; 0x300
 8012d86:	6818      	ldr	r0, [r3, #0]
 8012d88:	f006 fb35 	bl	80193f6 <memcpy>
}
 8012d8c:	bf00      	nop
 8012d8e:	f507 7747 	add.w	r7, r7, #796	; 0x31c
 8012d92:	46bd      	mov	sp, r7
 8012d94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08012d98 <sp_3072_sqr_96>:
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_3072_sqr_96(sp_digit* r, const sp_digit* a)
{
 8012d98:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8012d9c:	b082      	sub	sp, #8
 8012d9e:	af00      	add	r7, sp, #0
 8012da0:	6078      	str	r0, [r7, #4]
 8012da2:	6039      	str	r1, [r7, #0]
    __asm__ __volatile__ (
 8012da4:	6879      	ldr	r1, [r7, #4]
 8012da6:	6838      	ldr	r0, [r7, #0]
 8012da8:	f04f 0300 	mov.w	r3, #0
 8012dac:	f04f 0400 	mov.w	r4, #0
 8012db0:	f04f 0500 	mov.w	r5, #0
 8012db4:	4699      	mov	r9, r3
 8012db6:	468c      	mov	ip, r1
 8012db8:	f04f 0603 	mov.w	r6, #3
 8012dbc:	ea4f 2606 	mov.w	r6, r6, lsl #8
 8012dc0:	f1c6 0600 	rsb	r6, r6, #0
 8012dc4:	44b5      	add	sp, r6
 8012dc6:	46eb      	mov	fp, sp
 8012dc8:	4682      	mov	sl, r0
 8012dca:	f04f 0100 	mov.w	r1, #0
 8012dce:	f04f 0601 	mov.w	r6, #1
 8012dd2:	ea4f 2606 	mov.w	r6, r6, lsl #8
 8012dd6:	f106 067c 	add.w	r6, r6, #124	; 0x7c
 8012dda:	4648      	mov	r0, r9
 8012ddc:	1b80      	subs	r0, r0, r6
 8012dde:	eb66 0606 	sbc.w	r6, r6, r6
 8012de2:	ea6f 0606 	mvn.w	r6, r6
 8012de6:	ea00 0006 	and.w	r0, r0, r6
 8012dea:	464a      	mov	r2, r9
 8012dec:	eba2 0200 	sub.w	r2, r2, r0
 8012df0:	4450      	add	r0, sl
 8012df2:	4452      	add	r2, sl
 8012df4:	4282      	cmp	r2, r0
 8012df6:	d00f      	beq.n	8012e18 <sp_3072_sqr_96+0x80>
 8012df8:	6806      	ldr	r6, [r0, #0]
 8012dfa:	f8d2 8000 	ldr.w	r8, [r2]
 8012dfe:	fba6 6808 	umull	r6, r8, r6, r8
 8012e02:	199b      	adds	r3, r3, r6
 8012e04:	eb54 0408 	adcs.w	r4, r4, r8
 8012e08:	eb45 0501 	adc.w	r5, r5, r1
 8012e0c:	199b      	adds	r3, r3, r6
 8012e0e:	eb54 0408 	adcs.w	r4, r4, r8
 8012e12:	eb45 0501 	adc.w	r5, r5, r1
 8012e16:	e007      	b.n	8012e28 <sp_3072_sqr_96+0x90>
 8012e18:	6806      	ldr	r6, [r0, #0]
 8012e1a:	fba6 6806 	umull	r6, r8, r6, r6
 8012e1e:	199b      	adds	r3, r3, r6
 8012e20:	eb54 0408 	adcs.w	r4, r4, r8
 8012e24:	eb45 0501 	adc.w	r5, r5, r1
 8012e28:	f100 0004 	add.w	r0, r0, #4
 8012e2c:	f1a2 0204 	sub.w	r2, r2, #4
 8012e30:	f04f 0601 	mov.w	r6, #1
 8012e34:	ea4f 2606 	mov.w	r6, r6, lsl #8
 8012e38:	f106 0680 	add.w	r6, r6, #128	; 0x80
 8012e3c:	4456      	add	r6, sl
 8012e3e:	42b0      	cmp	r0, r6
 8012e40:	d005      	beq.n	8012e4e <sp_3072_sqr_96+0xb6>
 8012e42:	4290      	cmp	r0, r2
 8012e44:	dc03      	bgt.n	8012e4e <sp_3072_sqr_96+0xb6>
 8012e46:	46c8      	mov	r8, r9
 8012e48:	44d0      	add	r8, sl
 8012e4a:	4540      	cmp	r0, r8
 8012e4c:	ddd2      	ble.n	8012df4 <sp_3072_sqr_96+0x5c>
 8012e4e:	4659      	mov	r1, fp
 8012e50:	46c8      	mov	r8, r9
 8012e52:	f841 3008 	str.w	r3, [r1, r8]
 8012e56:	4623      	mov	r3, r4
 8012e58:	462c      	mov	r4, r5
 8012e5a:	f04f 0500 	mov.w	r5, #0
 8012e5e:	f108 0804 	add.w	r8, r8, #4
 8012e62:	46c1      	mov	r9, r8
 8012e64:	f04f 0602 	mov.w	r6, #2
 8012e68:	ea4f 2606 	mov.w	r6, r6, lsl #8
 8012e6c:	f106 06f8 	add.w	r6, r6, #248	; 0xf8
 8012e70:	45b0      	cmp	r8, r6
 8012e72:	ddaa      	ble.n	8012dca <sp_3072_sqr_96+0x32>
 8012e74:	4650      	mov	r0, sl
 8012e76:	f841 3008 	str.w	r3, [r1, r8]
 8012e7a:	4661      	mov	r1, ip
 8012e7c:	4658      	mov	r0, fp
 8012e7e:	f04f 0302 	mov.w	r3, #2
 8012e82:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8012e86:	f103 03fc 	add.w	r3, r3, #252	; 0xfc
 8012e8a:	58c6      	ldr	r6, [r0, r3]
 8012e8c:	50ce      	str	r6, [r1, r3]
 8012e8e:	3b04      	subs	r3, #4
 8012e90:	dafb      	bge.n	8012e8a <sp_3072_sqr_96+0xf2>
 8012e92:	f04f 0603 	mov.w	r6, #3
 8012e96:	ea4f 2606 	mov.w	r6, r6, lsl #8
 8012e9a:	44b5      	add	sp, r6
        "add	sp, sp, r6\n\t"
        :
        : [r] "r" (r), [a] "r" (a)
        : "memory", "r2", "r3", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r12"
    );
}
 8012e9c:	bf00      	nop
 8012e9e:	3708      	adds	r7, #8
 8012ea0:	46bd      	mov	sp, r7
 8012ea2:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8012ea6:	4770      	bx	lr

08012ea8 <sp_3072_mask_48>:
 * r  A single precision integer.
 * a  A single precision integer.
 * m  Mask to AND against each digit.
 */
static void sp_3072_mask_48(sp_digit* r, const sp_digit* a, sp_digit m)
{
 8012ea8:	b480      	push	{r7}
 8012eaa:	b087      	sub	sp, #28
 8012eac:	af00      	add	r7, sp, #0
 8012eae:	60f8      	str	r0, [r7, #12]
 8012eb0:	60b9      	str	r1, [r7, #8]
 8012eb2:	607a      	str	r2, [r7, #4]
    int i;

    for (i=0; i<48; i++) {
 8012eb4:	2300      	movs	r3, #0
 8012eb6:	617b      	str	r3, [r7, #20]
 8012eb8:	e00e      	b.n	8012ed8 <sp_3072_mask_48+0x30>
        r[i] = a[i] & m;
 8012eba:	697b      	ldr	r3, [r7, #20]
 8012ebc:	009b      	lsls	r3, r3, #2
 8012ebe:	68ba      	ldr	r2, [r7, #8]
 8012ec0:	4413      	add	r3, r2
 8012ec2:	6819      	ldr	r1, [r3, #0]
 8012ec4:	697b      	ldr	r3, [r7, #20]
 8012ec6:	009b      	lsls	r3, r3, #2
 8012ec8:	68fa      	ldr	r2, [r7, #12]
 8012eca:	4413      	add	r3, r2
 8012ecc:	687a      	ldr	r2, [r7, #4]
 8012ece:	400a      	ands	r2, r1
 8012ed0:	601a      	str	r2, [r3, #0]
    for (i=0; i<48; i++) {
 8012ed2:	697b      	ldr	r3, [r7, #20]
 8012ed4:	3301      	adds	r3, #1
 8012ed6:	617b      	str	r3, [r7, #20]
 8012ed8:	697b      	ldr	r3, [r7, #20]
 8012eda:	2b2f      	cmp	r3, #47	; 0x2f
 8012edc:	dded      	ble.n	8012eba <sp_3072_mask_48+0x12>
    }
}
 8012ede:	bf00      	nop
 8012ee0:	371c      	adds	r7, #28
 8012ee2:	46bd      	mov	sp, r7
 8012ee4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012ee8:	4770      	bx	lr

08012eea <sp_3072_add_48>:
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static sp_digit sp_3072_add_48(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
 8012eea:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 8012eee:	b087      	sub	sp, #28
 8012ef0:	af00      	add	r7, sp, #0
 8012ef2:	60f8      	str	r0, [r7, #12]
 8012ef4:	60b9      	str	r1, [r7, #8]
 8012ef6:	607a      	str	r2, [r7, #4]
    sp_digit c = 0;
 8012ef8:	2300      	movs	r3, #0
 8012efa:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 8012efc:	6978      	ldr	r0, [r7, #20]
 8012efe:	68f9      	ldr	r1, [r7, #12]
 8012f00:	68ba      	ldr	r2, [r7, #8]
 8012f02:	687b      	ldr	r3, [r7, #4]
 8012f04:	4616      	mov	r6, r2
 8012f06:	f04f 0800 	mov.w	r8, #0
 8012f0a:	f106 06c0 	add.w	r6, r6, #192	; 0xc0
 8012f0e:	f1a8 0801 	sub.w	r8, r8, #1
 8012f12:	eb10 0008 	adds.w	r0, r0, r8
 8012f16:	6814      	ldr	r4, [r2, #0]
 8012f18:	681d      	ldr	r5, [r3, #0]
 8012f1a:	416c      	adcs	r4, r5
 8012f1c:	600c      	str	r4, [r1, #0]
 8012f1e:	f04f 0000 	mov.w	r0, #0
 8012f22:	eb40 0000 	adc.w	r0, r0, r0
 8012f26:	f102 0204 	add.w	r2, r2, #4
 8012f2a:	f103 0304 	add.w	r3, r3, #4
 8012f2e:	f101 0104 	add.w	r1, r1, #4
 8012f32:	42b2      	cmp	r2, r6
 8012f34:	d1ed      	bne.n	8012f12 <sp_3072_add_48+0x28>
 8012f36:	6178      	str	r0, [r7, #20]
 8012f38:	60f9      	str	r1, [r7, #12]
 8012f3a:	60ba      	str	r2, [r7, #8]
 8012f3c:	607b      	str	r3, [r7, #4]
        : [c] "+r" (c), [r] "+r" (r), [a] "+r" (a), [b] "+r" (b)
        :
        : "memory", "r4", "r5", "r6", "r8"
    );

    return c;
 8012f3e:	697b      	ldr	r3, [r7, #20]
}
 8012f40:	4618      	mov	r0, r3
 8012f42:	371c      	adds	r7, #28
 8012f44:	46bd      	mov	sp, r7
 8012f46:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8012f4a:	4770      	bx	lr

08012f4c <sp_3072_sub_in_place_48>:
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static sp_digit sp_3072_sub_in_place_48(sp_digit* a,
        const sp_digit* b)
{
 8012f4c:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 8012f50:	b085      	sub	sp, #20
 8012f52:	af00      	add	r7, sp, #0
 8012f54:	6078      	str	r0, [r7, #4]
 8012f56:	6039      	str	r1, [r7, #0]
    sp_digit c = 0;
 8012f58:	2300      	movs	r3, #0
 8012f5a:	60fb      	str	r3, [r7, #12]
    __asm__ __volatile__ (
 8012f5c:	68f9      	ldr	r1, [r7, #12]
 8012f5e:	687a      	ldr	r2, [r7, #4]
 8012f60:	683b      	ldr	r3, [r7, #0]
 8012f62:	4608      	mov	r0, r1
 8012f64:	4611      	mov	r1, r2
 8012f66:	461a      	mov	r2, r3
 8012f68:	4688      	mov	r8, r1
 8012f6a:	f108 08c0 	add.w	r8, r8, #192	; 0xc0
 8012f6e:	f04f 0500 	mov.w	r5, #0
 8012f72:	1a2d      	subs	r5, r5, r0
 8012f74:	680b      	ldr	r3, [r1, #0]
 8012f76:	684c      	ldr	r4, [r1, #4]
 8012f78:	6815      	ldr	r5, [r2, #0]
 8012f7a:	6856      	ldr	r6, [r2, #4]
 8012f7c:	41ab      	sbcs	r3, r5
 8012f7e:	41b4      	sbcs	r4, r6
 8012f80:	600b      	str	r3, [r1, #0]
 8012f82:	604c      	str	r4, [r1, #4]
 8012f84:	eb60 0000 	sbc.w	r0, r0, r0
 8012f88:	f101 0108 	add.w	r1, r1, #8
 8012f8c:	f102 0208 	add.w	r2, r2, #8
 8012f90:	4541      	cmp	r1, r8
 8012f92:	d1ec      	bne.n	8012f6e <sp_3072_sub_in_place_48+0x22>
 8012f94:	60f8      	str	r0, [r7, #12]
 8012f96:	6079      	str	r1, [r7, #4]
 8012f98:	603a      	str	r2, [r7, #0]
        : [c] "+r" (c), [a] "+r" (a), [b] "+r" (b)
        :
        : "memory", "r3", "r4", "r5", "r6", "r8"
    );

    return c;
 8012f9a:	68fb      	ldr	r3, [r7, #12]
}
 8012f9c:	4618      	mov	r0, r3
 8012f9e:	3714      	adds	r7, #20
 8012fa0:	46bd      	mov	sp, r7
 8012fa2:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8012fa6:	4770      	bx	lr

08012fa8 <sp_3072_mul_48>:
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_3072_mul_48(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
 8012fa8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012fac:	b0e7      	sub	sp, #412	; 0x19c
 8012fae:	af00      	add	r7, sp, #0
 8012fb0:	f107 030c 	add.w	r3, r7, #12
 8012fb4:	6018      	str	r0, [r3, #0]
 8012fb6:	f107 0308 	add.w	r3, r7, #8
 8012fba:	6019      	str	r1, [r3, #0]
 8012fbc:	1d3b      	adds	r3, r7, #4
 8012fbe:	601a      	str	r2, [r3, #0]
    sp_digit tmp_arr[48 * 2];
    sp_digit* tmp = tmp_arr;
 8012fc0:	f107 0314 	add.w	r3, r7, #20
 8012fc4:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
    __asm__ __volatile__ (
 8012fc8:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 8012fcc:	f107 0308 	add.w	r3, r7, #8
 8012fd0:	6819      	ldr	r1, [r3, #0]
 8012fd2:	1d3b      	adds	r3, r7, #4
 8012fd4:	6818      	ldr	r0, [r3, #0]
 8012fd6:	f04f 0300 	mov.w	r3, #0
 8012fda:	f04f 0400 	mov.w	r4, #0
 8012fde:	4699      	mov	r9, r3
 8012fe0:	4694      	mov	ip, r2
 8012fe2:	468a      	mov	sl, r1
 8012fe4:	4683      	mov	fp, r0
 8012fe6:	f04f 06c0 	mov.w	r6, #192	; 0xc0
 8012fea:	4456      	add	r6, sl
 8012fec:	46b6      	mov	lr, r6
 8012fee:	f04f 0200 	mov.w	r2, #0
 8012ff2:	f04f 0500 	mov.w	r5, #0
 8012ff6:	f04f 06bc 	mov.w	r6, #188	; 0xbc
 8012ffa:	4649      	mov	r1, r9
 8012ffc:	1b89      	subs	r1, r1, r6
 8012ffe:	eb66 0606 	sbc.w	r6, r6, r6
 8013002:	ea6f 0606 	mvn.w	r6, r6
 8013006:	ea01 0106 	and.w	r1, r1, r6
 801300a:	4648      	mov	r0, r9
 801300c:	eba0 0001 	sub.w	r0, r0, r1
 8013010:	4451      	add	r1, sl
 8013012:	4458      	add	r0, fp
 8013014:	680e      	ldr	r6, [r1, #0]
 8013016:	f8d0 8000 	ldr.w	r8, [r0]
 801301a:	fba6 6808 	umull	r6, r8, r6, r8
 801301e:	199b      	adds	r3, r3, r6
 8013020:	eb54 0408 	adcs.w	r4, r4, r8
 8013024:	eb45 0502 	adc.w	r5, r5, r2
 8013028:	f101 0104 	add.w	r1, r1, #4
 801302c:	f1a0 0004 	sub.w	r0, r0, #4
 8013030:	4571      	cmp	r1, lr
 8013032:	d003      	beq.n	801303c <sp_3072_mul_48+0x94>
 8013034:	464e      	mov	r6, r9
 8013036:	4456      	add	r6, sl
 8013038:	42b1      	cmp	r1, r6
 801303a:	ddeb      	ble.n	8013014 <sp_3072_mul_48+0x6c>
 801303c:	4662      	mov	r2, ip
 801303e:	46c8      	mov	r8, r9
 8013040:	f842 3008 	str.w	r3, [r2, r8]
 8013044:	4623      	mov	r3, r4
 8013046:	462c      	mov	r4, r5
 8013048:	f108 0804 	add.w	r8, r8, #4
 801304c:	46c1      	mov	r9, r8
 801304e:	f04f 0601 	mov.w	r6, #1
 8013052:	ea4f 2606 	mov.w	r6, r6, lsl #8
 8013056:	f106 0678 	add.w	r6, r6, #120	; 0x78
 801305a:	45b0      	cmp	r8, r6
 801305c:	ddc7      	ble.n	8012fee <sp_3072_mul_48+0x46>
 801305e:	f842 3008 	str.w	r3, [r2, r8]
 8013062:	4651      	mov	r1, sl
 8013064:	4658      	mov	r0, fp
        :
        : [r] "r" (tmp), [a] "r" (a), [b] "r" (b)
        : "memory", "r3", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r12", "r14"
    );

    XMEMCPY(r, tmp_arr, sizeof(tmp_arr));
 8013066:	f107 0114 	add.w	r1, r7, #20
 801306a:	f107 030c 	add.w	r3, r7, #12
 801306e:	f44f 72c0 	mov.w	r2, #384	; 0x180
 8013072:	6818      	ldr	r0, [r3, #0]
 8013074:	f006 f9bf 	bl	80193f6 <memcpy>
}
 8013078:	bf00      	nop
 801307a:	f507 77ce 	add.w	r7, r7, #412	; 0x19c
 801307e:	46bd      	mov	sp, r7
 8013080:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08013084 <sp_3072_sqr_48>:
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_3072_sqr_48(sp_digit* r, const sp_digit* a)
{
 8013084:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8013088:	b082      	sub	sp, #8
 801308a:	af00      	add	r7, sp, #0
 801308c:	6078      	str	r0, [r7, #4]
 801308e:	6039      	str	r1, [r7, #0]
    __asm__ __volatile__ (
 8013090:	6879      	ldr	r1, [r7, #4]
 8013092:	6838      	ldr	r0, [r7, #0]
 8013094:	f04f 0300 	mov.w	r3, #0
 8013098:	f04f 0400 	mov.w	r4, #0
 801309c:	f04f 0500 	mov.w	r5, #0
 80130a0:	4699      	mov	r9, r3
 80130a2:	468c      	mov	ip, r1
 80130a4:	f04f 0601 	mov.w	r6, #1
 80130a8:	ea4f 2606 	mov.w	r6, r6, lsl #8
 80130ac:	f106 0680 	add.w	r6, r6, #128	; 0x80
 80130b0:	f1c6 0600 	rsb	r6, r6, #0
 80130b4:	44b5      	add	sp, r6
 80130b6:	46eb      	mov	fp, sp
 80130b8:	4682      	mov	sl, r0
 80130ba:	f04f 0100 	mov.w	r1, #0
 80130be:	f04f 06bc 	mov.w	r6, #188	; 0xbc
 80130c2:	4648      	mov	r0, r9
 80130c4:	1b80      	subs	r0, r0, r6
 80130c6:	eb66 0606 	sbc.w	r6, r6, r6
 80130ca:	ea6f 0606 	mvn.w	r6, r6
 80130ce:	ea00 0006 	and.w	r0, r0, r6
 80130d2:	464a      	mov	r2, r9
 80130d4:	eba2 0200 	sub.w	r2, r2, r0
 80130d8:	4450      	add	r0, sl
 80130da:	4452      	add	r2, sl
 80130dc:	4282      	cmp	r2, r0
 80130de:	d00f      	beq.n	8013100 <sp_3072_sqr_48+0x7c>
 80130e0:	6806      	ldr	r6, [r0, #0]
 80130e2:	f8d2 8000 	ldr.w	r8, [r2]
 80130e6:	fba6 6808 	umull	r6, r8, r6, r8
 80130ea:	199b      	adds	r3, r3, r6
 80130ec:	eb54 0408 	adcs.w	r4, r4, r8
 80130f0:	eb45 0501 	adc.w	r5, r5, r1
 80130f4:	199b      	adds	r3, r3, r6
 80130f6:	eb54 0408 	adcs.w	r4, r4, r8
 80130fa:	eb45 0501 	adc.w	r5, r5, r1
 80130fe:	e007      	b.n	8013110 <sp_3072_sqr_48+0x8c>
 8013100:	6806      	ldr	r6, [r0, #0]
 8013102:	fba6 6806 	umull	r6, r8, r6, r6
 8013106:	199b      	adds	r3, r3, r6
 8013108:	eb54 0408 	adcs.w	r4, r4, r8
 801310c:	eb45 0501 	adc.w	r5, r5, r1
 8013110:	f100 0004 	add.w	r0, r0, #4
 8013114:	f1a2 0204 	sub.w	r2, r2, #4
 8013118:	f04f 06c0 	mov.w	r6, #192	; 0xc0
 801311c:	4456      	add	r6, sl
 801311e:	42b0      	cmp	r0, r6
 8013120:	d005      	beq.n	801312e <sp_3072_sqr_48+0xaa>
 8013122:	4290      	cmp	r0, r2
 8013124:	dc03      	bgt.n	801312e <sp_3072_sqr_48+0xaa>
 8013126:	46c8      	mov	r8, r9
 8013128:	44d0      	add	r8, sl
 801312a:	4540      	cmp	r0, r8
 801312c:	ddd6      	ble.n	80130dc <sp_3072_sqr_48+0x58>
 801312e:	4659      	mov	r1, fp
 8013130:	46c8      	mov	r8, r9
 8013132:	f841 3008 	str.w	r3, [r1, r8]
 8013136:	4623      	mov	r3, r4
 8013138:	462c      	mov	r4, r5
 801313a:	f04f 0500 	mov.w	r5, #0
 801313e:	f108 0804 	add.w	r8, r8, #4
 8013142:	46c1      	mov	r9, r8
 8013144:	f04f 0601 	mov.w	r6, #1
 8013148:	ea4f 2606 	mov.w	r6, r6, lsl #8
 801314c:	f106 0678 	add.w	r6, r6, #120	; 0x78
 8013150:	45b0      	cmp	r8, r6
 8013152:	ddb2      	ble.n	80130ba <sp_3072_sqr_48+0x36>
 8013154:	4650      	mov	r0, sl
 8013156:	f841 3008 	str.w	r3, [r1, r8]
 801315a:	4661      	mov	r1, ip
 801315c:	4658      	mov	r0, fp
 801315e:	f04f 0301 	mov.w	r3, #1
 8013162:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8013166:	f103 037c 	add.w	r3, r3, #124	; 0x7c
 801316a:	58c6      	ldr	r6, [r0, r3]
 801316c:	50ce      	str	r6, [r1, r3]
 801316e:	3b04      	subs	r3, #4
 8013170:	dafb      	bge.n	801316a <sp_3072_sqr_48+0xe6>
 8013172:	f04f 0601 	mov.w	r6, #1
 8013176:	ea4f 2606 	mov.w	r6, r6, lsl #8
 801317a:	f106 0680 	add.w	r6, r6, #128	; 0x80
 801317e:	44b5      	add	sp, r6
        "add	sp, sp, r6\n\t"
        :
        : [r] "r" (r), [a] "r" (a)
        : "memory", "r2", "r3", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r12"
    );
}
 8013180:	bf00      	nop
 8013182:	3708      	adds	r7, #8
 8013184:	46bd      	mov	sp, r7
 8013186:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 801318a:	4770      	bx	lr

0801318c <sp_3072_mont_setup>:
 *
 * a    A single precision number.
 * rho  Bottom word of inverse.
 */
static void sp_3072_mont_setup(const sp_digit* a, sp_digit* rho)
{
 801318c:	b480      	push	{r7}
 801318e:	b085      	sub	sp, #20
 8013190:	af00      	add	r7, sp, #0
 8013192:	6078      	str	r0, [r7, #4]
 8013194:	6039      	str	r1, [r7, #0]
    sp_digit x, b;

    b = a[0];
 8013196:	687b      	ldr	r3, [r7, #4]
 8013198:	681b      	ldr	r3, [r3, #0]
 801319a:	60fb      	str	r3, [r7, #12]
    x = (((b + 2) & 4) << 1) + b; /* here x*a==1 mod 2**4 */
 801319c:	68fb      	ldr	r3, [r7, #12]
 801319e:	3302      	adds	r3, #2
 80131a0:	005b      	lsls	r3, r3, #1
 80131a2:	f003 0308 	and.w	r3, r3, #8
 80131a6:	68fa      	ldr	r2, [r7, #12]
 80131a8:	4413      	add	r3, r2
 80131aa:	60bb      	str	r3, [r7, #8]
    x *= 2 - b * x;               /* here x*a==1 mod 2**8 */
 80131ac:	68fb      	ldr	r3, [r7, #12]
 80131ae:	68ba      	ldr	r2, [r7, #8]
 80131b0:	fb02 f303 	mul.w	r3, r2, r3
 80131b4:	f1c3 0202 	rsb	r2, r3, #2
 80131b8:	68bb      	ldr	r3, [r7, #8]
 80131ba:	fb02 f303 	mul.w	r3, r2, r3
 80131be:	60bb      	str	r3, [r7, #8]
    x *= 2 - b * x;               /* here x*a==1 mod 2**16 */
 80131c0:	68fb      	ldr	r3, [r7, #12]
 80131c2:	68ba      	ldr	r2, [r7, #8]
 80131c4:	fb02 f303 	mul.w	r3, r2, r3
 80131c8:	f1c3 0202 	rsb	r2, r3, #2
 80131cc:	68bb      	ldr	r3, [r7, #8]
 80131ce:	fb02 f303 	mul.w	r3, r2, r3
 80131d2:	60bb      	str	r3, [r7, #8]
    x *= 2 - b * x;               /* here x*a==1 mod 2**32 */
 80131d4:	68fb      	ldr	r3, [r7, #12]
 80131d6:	68ba      	ldr	r2, [r7, #8]
 80131d8:	fb02 f303 	mul.w	r3, r2, r3
 80131dc:	f1c3 0202 	rsb	r2, r3, #2
 80131e0:	68bb      	ldr	r3, [r7, #8]
 80131e2:	fb02 f303 	mul.w	r3, r2, r3
 80131e6:	60bb      	str	r3, [r7, #8]

    /* rho = -1/m mod b */
    *rho = -x;
 80131e8:	68bb      	ldr	r3, [r7, #8]
 80131ea:	425a      	negs	r2, r3
 80131ec:	683b      	ldr	r3, [r7, #0]
 80131ee:	601a      	str	r2, [r3, #0]
}
 80131f0:	bf00      	nop
 80131f2:	3714      	adds	r7, #20
 80131f4:	46bd      	mov	sp, r7
 80131f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80131fa:	4770      	bx	lr

080131fc <sp_3072_mul_d_96>:
 * a  A single precision integer.
 * b  A single precision digit.
 */
SP_NOINLINE static void sp_3072_mul_d_96(sp_digit* r, const sp_digit* a,
        sp_digit b)
{
 80131fc:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 8013200:	b084      	sub	sp, #16
 8013202:	af00      	add	r7, sp, #0
 8013204:	60f8      	str	r0, [r7, #12]
 8013206:	60b9      	str	r1, [r7, #8]
 8013208:	607a      	str	r2, [r7, #4]
    __asm__ __volatile__ (
 801320a:	6878      	ldr	r0, [r7, #4]
 801320c:	68fa      	ldr	r2, [r7, #12]
 801320e:	68bb      	ldr	r3, [r7, #8]
 8013210:	4611      	mov	r1, r2
 8013212:	461a      	mov	r2, r3
 8013214:	f502 79c0 	add.w	r9, r2, #384	; 0x180
 8013218:	f852 6b04 	ldr.w	r6, [r2], #4
 801321c:	fba6 5300 	umull	r5, r3, r6, r0
 8013220:	f04f 0400 	mov.w	r4, #0
 8013224:	f841 5b04 	str.w	r5, [r1], #4
 8013228:	f04f 0500 	mov.w	r5, #0
 801322c:	f852 6b04 	ldr.w	r6, [r2], #4
 8013230:	fba6 6800 	umull	r6, r8, r6, r0
 8013234:	199b      	adds	r3, r3, r6
 8013236:	eb54 0408 	adcs.w	r4, r4, r8
 801323a:	f145 0500 	adc.w	r5, r5, #0
 801323e:	f841 3b04 	str.w	r3, [r1], #4
 8013242:	4623      	mov	r3, r4
 8013244:	462c      	mov	r4, r5
 8013246:	454a      	cmp	r2, r9
 8013248:	dbee      	blt.n	8013228 <sp_3072_mul_d_96+0x2c>
 801324a:	600b      	str	r3, [r1, #0]
 801324c:	60f9      	str	r1, [r7, #12]
 801324e:	60ba      	str	r2, [r7, #8]
        "str	r3, [%[r]]\n\t"
        : [r] "+r" (r), [a] "+r" (a)
        : [b] "r" (b)
        : "memory", "r3", "r4", "r5", "r6", "r8", "r9"
    );
}
 8013250:	bf00      	nop
 8013252:	3710      	adds	r7, #16
 8013254:	46bd      	mov	sp, r7
 8013256:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 801325a:	4770      	bx	lr

0801325c <sp_3072_mont_norm_48>:
 *
 * r  A single precision number.
 * m  A single precision number.
 */
static void sp_3072_mont_norm_48(sp_digit* r, const sp_digit* m)
{
 801325c:	b580      	push	{r7, lr}
 801325e:	b082      	sub	sp, #8
 8013260:	af00      	add	r7, sp, #0
 8013262:	6078      	str	r0, [r7, #4]
 8013264:	6039      	str	r1, [r7, #0]
    XMEMSET(r, 0, sizeof(sp_digit) * 48);
 8013266:	22c0      	movs	r2, #192	; 0xc0
 8013268:	2100      	movs	r1, #0
 801326a:	6878      	ldr	r0, [r7, #4]
 801326c:	f006 f8e7 	bl	801943e <memset>

    /* r = 2^n mod m */
    sp_3072_sub_in_place_48(r, m);
 8013270:	6839      	ldr	r1, [r7, #0]
 8013272:	6878      	ldr	r0, [r7, #4]
 8013274:	f7ff fe6a 	bl	8012f4c <sp_3072_sub_in_place_48>
}
 8013278:	bf00      	nop
 801327a:	3708      	adds	r7, #8
 801327c:	46bd      	mov	sp, r7
 801327e:	bd80      	pop	{r7, pc}

08013280 <sp_3072_cond_sub_48>:
 * b  A single precision number to subtract.
 * m  Mask value to apply.
 */
SP_NOINLINE static sp_digit sp_3072_cond_sub_48(sp_digit* r, const sp_digit* a,
        const sp_digit* b, sp_digit m)
{
 8013280:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 8013284:	b086      	sub	sp, #24
 8013286:	af00      	add	r7, sp, #0
 8013288:	60f8      	str	r0, [r7, #12]
 801328a:	60b9      	str	r1, [r7, #8]
 801328c:	607a      	str	r2, [r7, #4]
 801328e:	603b      	str	r3, [r7, #0]
    sp_digit c = 0;
 8013290:	2300      	movs	r3, #0
 8013292:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 8013294:	68fa      	ldr	r2, [r7, #12]
 8013296:	68b9      	ldr	r1, [r7, #8]
 8013298:	6878      	ldr	r0, [r7, #4]
 801329a:	683c      	ldr	r4, [r7, #0]
 801329c:	697b      	ldr	r3, [r7, #20]
 801329e:	f04f 05c0 	mov.w	r5, #192	; 0xc0
 80132a2:	46a9      	mov	r9, r5
 80132a4:	f04f 0800 	mov.w	r8, #0
 80132a8:	f850 6008 	ldr.w	r6, [r0, r8]
 80132ac:	ea06 0604 	and.w	r6, r6, r4
 80132b0:	f04f 0500 	mov.w	r5, #0
 80132b4:	1aed      	subs	r5, r5, r3
 80132b6:	f851 5008 	ldr.w	r5, [r1, r8]
 80132ba:	41b5      	sbcs	r5, r6
 80132bc:	419b      	sbcs	r3, r3
 80132be:	f842 5008 	str.w	r5, [r2, r8]
 80132c2:	f108 0804 	add.w	r8, r8, #4
 80132c6:	45c8      	cmp	r8, r9
 80132c8:	dbee      	blt.n	80132a8 <sp_3072_cond_sub_48+0x28>
 80132ca:	617b      	str	r3, [r7, #20]
        : [c] "+r" (c)
        : [r] "r" (r), [a] "r" (a), [b] "r" (b), [m] "r" (m)
        : "memory", "r5", "r6", "r8", "r9"
    );

    return c;
 80132cc:	697b      	ldr	r3, [r7, #20]
}
 80132ce:	4618      	mov	r0, r3
 80132d0:	3718      	adds	r7, #24
 80132d2:	46bd      	mov	sp, r7
 80132d4:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 80132d8:	4770      	bx	lr

080132da <sp_3072_mont_reduce_48>:
 * m   The single precision number representing the modulus.
 * mp  The digit representing the negative inverse of m mod 2^n.
 */
SP_NOINLINE static void sp_3072_mont_reduce_48(sp_digit* a, const sp_digit* m,
        sp_digit mp)
{
 80132da:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80132de:	b087      	sub	sp, #28
 80132e0:	af00      	add	r7, sp, #0
 80132e2:	60f8      	str	r0, [r7, #12]
 80132e4:	60b9      	str	r1, [r7, #8]
 80132e6:	607a      	str	r2, [r7, #4]
    sp_digit ca = 0;
 80132e8:	2300      	movs	r3, #0
 80132ea:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 80132ec:	68b9      	ldr	r1, [r7, #8]
 80132ee:	6878      	ldr	r0, [r7, #4]
 80132f0:	697a      	ldr	r2, [r7, #20]
 80132f2:	68fb      	ldr	r3, [r7, #12]
 80132f4:	4681      	mov	r9, r0
 80132f6:	468c      	mov	ip, r1
 80132f8:	469a      	mov	sl, r3
 80132fa:	f04f 0400 	mov.w	r4, #0
 80132fe:	f10a 0bc0 	add.w	fp, sl, #192	; 0xc0
 8013302:	4648      	mov	r0, r9
 8013304:	f8da 3000 	ldr.w	r3, [sl]
 8013308:	fb00 f003 	mul.w	r0, r0, r3
 801330c:	4661      	mov	r1, ip
 801330e:	f10a 0eb8 	add.w	lr, sl, #184	; 0xb8
 8013312:	f8da 3000 	ldr.w	r3, [sl]
 8013316:	f04f 0500 	mov.w	r5, #0
 801331a:	f851 8b04 	ldr.w	r8, [r1], #4
 801331e:	fba0 6808 	umull	r6, r8, r0, r8
 8013322:	199b      	adds	r3, r3, r6
 8013324:	eb45 0508 	adc.w	r5, r5, r8
 8013328:	18e4      	adds	r4, r4, r3
 801332a:	f145 0500 	adc.w	r5, r5, #0
 801332e:	f84a 4b04 	str.w	r4, [sl], #4
 8013332:	f8da 3000 	ldr.w	r3, [sl]
 8013336:	f04f 0400 	mov.w	r4, #0
 801333a:	f851 8b04 	ldr.w	r8, [r1], #4
 801333e:	fba0 6808 	umull	r6, r8, r0, r8
 8013342:	199b      	adds	r3, r3, r6
 8013344:	eb44 0408 	adc.w	r4, r4, r8
 8013348:	18ed      	adds	r5, r5, r3
 801334a:	f144 0400 	adc.w	r4, r4, #0
 801334e:	f84a 5b04 	str.w	r5, [sl], #4
 8013352:	45f2      	cmp	sl, lr
 8013354:	dbdd      	blt.n	8013312 <sp_3072_mont_reduce_48+0x38>
 8013356:	f8da 3000 	ldr.w	r3, [sl]
 801335a:	f04f 0500 	mov.w	r5, #0
 801335e:	f851 8b04 	ldr.w	r8, [r1], #4
 8013362:	fba0 6808 	umull	r6, r8, r0, r8
 8013366:	199b      	adds	r3, r3, r6
 8013368:	eb45 0508 	adc.w	r5, r5, r8
 801336c:	18e4      	adds	r4, r4, r3
 801336e:	f145 0500 	adc.w	r5, r5, #0
 8013372:	f84a 4b04 	str.w	r4, [sl], #4
 8013376:	4614      	mov	r4, r2
 8013378:	f04f 0200 	mov.w	r2, #0
 801337c:	f8d1 8000 	ldr.w	r8, [r1]
 8013380:	fba0 6808 	umull	r6, r8, r0, r8
 8013384:	19ad      	adds	r5, r5, r6
 8013386:	eb54 0408 	adcs.w	r4, r4, r8
 801338a:	f142 0200 	adc.w	r2, r2, #0
 801338e:	f8da 6000 	ldr.w	r6, [sl]
 8013392:	f8da 8004 	ldr.w	r8, [sl, #4]
 8013396:	1976      	adds	r6, r6, r5
 8013398:	eb58 0804 	adcs.w	r8, r8, r4
 801339c:	f142 0200 	adc.w	r2, r2, #0
 80133a0:	f8ca 6000 	str.w	r6, [sl]
 80133a4:	f8ca 8004 	str.w	r8, [sl, #4]
 80133a8:	f1aa 0ab8 	sub.w	sl, sl, #184	; 0xb8
 80133ac:	45da      	cmp	sl, fp
 80133ae:	dba8      	blt.n	8013302 <sp_3072_mont_reduce_48+0x28>
 80133b0:	4653      	mov	r3, sl
 80133b2:	4661      	mov	r1, ip
 80133b4:	617a      	str	r2, [r7, #20]
 80133b6:	60fb      	str	r3, [r7, #12]
        : [ca] "+r" (ca), [a] "+r" (a)
        : [m] "r" (m), [mp] "r" (mp)
        : "memory", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r12", "r14"
    );

    sp_3072_cond_sub_48(a - 48, a, m, (sp_digit)0 - ca);
 80133b8:	68fb      	ldr	r3, [r7, #12]
 80133ba:	f1a3 00c0 	sub.w	r0, r3, #192	; 0xc0
 80133be:	697b      	ldr	r3, [r7, #20]
 80133c0:	425b      	negs	r3, r3
 80133c2:	68ba      	ldr	r2, [r7, #8]
 80133c4:	68f9      	ldr	r1, [r7, #12]
 80133c6:	f7ff ff5b 	bl	8013280 <sp_3072_cond_sub_48>
}
 80133ca:	bf00      	nop
 80133cc:	371c      	adds	r7, #28
 80133ce:	46bd      	mov	sp, r7
 80133d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080133d4 <sp_3072_mont_mul_48>:
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_3072_mont_mul_48(sp_digit* r, const sp_digit* a, const sp_digit* b,
        const sp_digit* m, sp_digit mp)
{
 80133d4:	b580      	push	{r7, lr}
 80133d6:	b084      	sub	sp, #16
 80133d8:	af00      	add	r7, sp, #0
 80133da:	60f8      	str	r0, [r7, #12]
 80133dc:	60b9      	str	r1, [r7, #8]
 80133de:	607a      	str	r2, [r7, #4]
 80133e0:	603b      	str	r3, [r7, #0]
    sp_3072_mul_48(r, a, b);
 80133e2:	687a      	ldr	r2, [r7, #4]
 80133e4:	68b9      	ldr	r1, [r7, #8]
 80133e6:	68f8      	ldr	r0, [r7, #12]
 80133e8:	f7ff fdde 	bl	8012fa8 <sp_3072_mul_48>
    sp_3072_mont_reduce_48(r, m, mp);
 80133ec:	69ba      	ldr	r2, [r7, #24]
 80133ee:	6839      	ldr	r1, [r7, #0]
 80133f0:	68f8      	ldr	r0, [r7, #12]
 80133f2:	f7ff ff72 	bl	80132da <sp_3072_mont_reduce_48>
}
 80133f6:	bf00      	nop
 80133f8:	3710      	adds	r7, #16
 80133fa:	46bd      	mov	sp, r7
 80133fc:	bd80      	pop	{r7, pc}

080133fe <sp_3072_mont_sqr_48>:
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_3072_mont_sqr_48(sp_digit* r, const sp_digit* a, const sp_digit* m,
        sp_digit mp)
{
 80133fe:	b580      	push	{r7, lr}
 8013400:	b084      	sub	sp, #16
 8013402:	af00      	add	r7, sp, #0
 8013404:	60f8      	str	r0, [r7, #12]
 8013406:	60b9      	str	r1, [r7, #8]
 8013408:	607a      	str	r2, [r7, #4]
 801340a:	603b      	str	r3, [r7, #0]
    sp_3072_sqr_48(r, a);
 801340c:	68b9      	ldr	r1, [r7, #8]
 801340e:	68f8      	ldr	r0, [r7, #12]
 8013410:	f7ff fe38 	bl	8013084 <sp_3072_sqr_48>
    sp_3072_mont_reduce_48(r, m, mp);
 8013414:	683a      	ldr	r2, [r7, #0]
 8013416:	6879      	ldr	r1, [r7, #4]
 8013418:	68f8      	ldr	r0, [r7, #12]
 801341a:	f7ff ff5e 	bl	80132da <sp_3072_mont_reduce_48>
}
 801341e:	bf00      	nop
 8013420:	3710      	adds	r7, #16
 8013422:	46bd      	mov	sp, r7
 8013424:	bd80      	pop	{r7, pc}

08013426 <sp_3072_mul_d_48>:
 * a  A single precision integer.
 * b  A single precision digit.
 */
SP_NOINLINE static void sp_3072_mul_d_48(sp_digit* r, const sp_digit* a,
        sp_digit b)
{
 8013426:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 801342a:	b084      	sub	sp, #16
 801342c:	af00      	add	r7, sp, #0
 801342e:	60f8      	str	r0, [r7, #12]
 8013430:	60b9      	str	r1, [r7, #8]
 8013432:	607a      	str	r2, [r7, #4]
    __asm__ __volatile__ (
 8013434:	6878      	ldr	r0, [r7, #4]
 8013436:	68fa      	ldr	r2, [r7, #12]
 8013438:	68bb      	ldr	r3, [r7, #8]
 801343a:	4611      	mov	r1, r2
 801343c:	461a      	mov	r2, r3
 801343e:	f102 09c0 	add.w	r9, r2, #192	; 0xc0
 8013442:	f852 6b04 	ldr.w	r6, [r2], #4
 8013446:	fba6 5300 	umull	r5, r3, r6, r0
 801344a:	f04f 0400 	mov.w	r4, #0
 801344e:	f841 5b04 	str.w	r5, [r1], #4
 8013452:	f04f 0500 	mov.w	r5, #0
 8013456:	f852 6b04 	ldr.w	r6, [r2], #4
 801345a:	fba6 6800 	umull	r6, r8, r6, r0
 801345e:	199b      	adds	r3, r3, r6
 8013460:	eb54 0408 	adcs.w	r4, r4, r8
 8013464:	f145 0500 	adc.w	r5, r5, #0
 8013468:	f841 3b04 	str.w	r3, [r1], #4
 801346c:	4623      	mov	r3, r4
 801346e:	462c      	mov	r4, r5
 8013470:	454a      	cmp	r2, r9
 8013472:	dbee      	blt.n	8013452 <sp_3072_mul_d_48+0x2c>
 8013474:	600b      	str	r3, [r1, #0]
 8013476:	60f9      	str	r1, [r7, #12]
 8013478:	60ba      	str	r2, [r7, #8]
        "str	r3, [%[r]]\n\t"
        : [r] "+r" (r), [a] "+r" (a)
        : [b] "r" (b)
        : "memory", "r3", "r4", "r5", "r6", "r8", "r9"
    );
}
 801347a:	bf00      	nop
 801347c:	3710      	adds	r7, #16
 801347e:	46bd      	mov	sp, r7
 8013480:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8013484:	4770      	bx	lr

08013486 <div_3072_word_48>:
 *
 * Note that this is an approximate div. It may give an answer 1 larger.
 */
SP_NOINLINE static sp_digit div_3072_word_48(sp_digit d1, sp_digit d0,
        sp_digit div)
{
 8013486:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 801348a:	b087      	sub	sp, #28
 801348c:	af00      	add	r7, sp, #0
 801348e:	60f8      	str	r0, [r7, #12]
 8013490:	60b9      	str	r1, [r7, #8]
 8013492:	607a      	str	r2, [r7, #4]
    sp_digit r = 0;
 8013494:	2300      	movs	r3, #0
 8013496:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 8013498:	68fa      	ldr	r2, [r7, #12]
 801349a:	68b9      	ldr	r1, [r7, #8]
 801349c:	6878      	ldr	r0, [r7, #4]
 801349e:	697b      	ldr	r3, [r7, #20]
 80134a0:	ea4f 4610 	mov.w	r6, r0, lsr #16
 80134a4:	f106 0601 	add.w	r6, r6, #1
 80134a8:	fbb2 f4f6 	udiv	r4, r2, r6
 80134ac:	ea4f 4804 	mov.w	r8, r4, lsl #16
 80134b0:	fba0 4508 	umull	r4, r5, r0, r8
 80134b4:	1b09      	subs	r1, r1, r4
 80134b6:	eb62 0205 	sbc.w	r2, r2, r5
 80134ba:	fbb2 f5f6 	udiv	r5, r2, r6
 80134be:	ea4f 4405 	mov.w	r4, r5, lsl #16
 80134c2:	44a0      	add	r8, r4
 80134c4:	fba0 4504 	umull	r4, r5, r0, r4
 80134c8:	1b09      	subs	r1, r1, r4
 80134ca:	eb62 0205 	sbc.w	r2, r2, r5
 80134ce:	ea4f 4402 	mov.w	r4, r2, lsl #16
 80134d2:	ea44 4411 	orr.w	r4, r4, r1, lsr #16
 80134d6:	fbb4 f4f6 	udiv	r4, r4, r6
 80134da:	44a0      	add	r8, r4
 80134dc:	fba0 4504 	umull	r4, r5, r0, r4
 80134e0:	1b09      	subs	r1, r1, r4
 80134e2:	eb62 0205 	sbc.w	r2, r2, r5
 80134e6:	ea4f 4402 	mov.w	r4, r2, lsl #16
 80134ea:	ea44 4411 	orr.w	r4, r4, r1, lsr #16
 80134ee:	fbb4 f4f6 	udiv	r4, r4, r6
 80134f2:	44a0      	add	r8, r4
 80134f4:	fba0 4504 	umull	r4, r5, r0, r4
 80134f8:	1b09      	subs	r1, r1, r4
 80134fa:	eb62 0205 	sbc.w	r2, r2, r5
 80134fe:	fbb1 f4f0 	udiv	r4, r1, r0
 8013502:	44a0      	add	r8, r4
 8013504:	4643      	mov	r3, r8
 8013506:	617b      	str	r3, [r7, #20]
        "mov	%[r], r8\n\t"
        : [r] "+r" (r)
        : [d1] "r" (d1), [d0] "r" (d0), [div] "r" (div)
        : "r4", "r5", "r6", "r8"
    );
    return r;
 8013508:	697b      	ldr	r3, [r7, #20]
}
 801350a:	4618      	mov	r0, r3
 801350c:	371c      	adds	r7, #28
 801350e:	46bd      	mov	sp, r7
 8013510:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8013514:	4770      	bx	lr

08013516 <sp_3072_cmp_48>:
 * b  A single precision integer.
 * return -ve, 0 or +ve if a is less than, equal to or greater than b
 * respectively.
 */
SP_NOINLINE static int32_t sp_3072_cmp_48(const sp_digit* a, const sp_digit* b)
{
 8013516:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 801351a:	b085      	sub	sp, #20
 801351c:	af00      	add	r7, sp, #0
 801351e:	6078      	str	r0, [r7, #4]
 8013520:	6039      	str	r1, [r7, #0]
    sp_digit r = 0;
 8013522:	2300      	movs	r3, #0
 8013524:	60fb      	str	r3, [r7, #12]


    __asm__ __volatile__ (
 8013526:	6879      	ldr	r1, [r7, #4]
 8013528:	6838      	ldr	r0, [r7, #0]
 801352a:	68fb      	ldr	r3, [r7, #12]
 801352c:	461a      	mov	r2, r3
 801352e:	f04f 0300 	mov.w	r3, #0
 8013532:	ea6f 0303 	mvn.w	r3, r3
 8013536:	f04f 06bc 	mov.w	r6, #188	; 0xbc
 801353a:	f851 8006 	ldr.w	r8, [r1, r6]
 801353e:	5985      	ldr	r5, [r0, r6]
 8013540:	ea08 0803 	and.w	r8, r8, r3
 8013544:	ea05 0503 	and.w	r5, r5, r3
 8013548:	4644      	mov	r4, r8
 801354a:	ebb8 0805 	subs.w	r8, r8, r5
 801354e:	eb68 0808 	sbc.w	r8, r8, r8
 8013552:	4442      	add	r2, r8
 8013554:	ea6f 0808 	mvn.w	r8, r8
 8013558:	ea03 0308 	and.w	r3, r3, r8
 801355c:	1b2d      	subs	r5, r5, r4
 801355e:	eb68 0808 	sbc.w	r8, r8, r8
 8013562:	eba2 0208 	sub.w	r2, r2, r8
 8013566:	ea6f 0808 	mvn.w	r8, r8
 801356a:	ea03 0308 	and.w	r3, r3, r8
 801356e:	f1a6 0604 	sub.w	r6, r6, #4
 8013572:	2e00      	cmp	r6, #0
 8013574:	dae1      	bge.n	801353a <sp_3072_cmp_48+0x24>
 8013576:	60fa      	str	r2, [r7, #12]
        : [r] "+r" (r)
        : [a] "r" (a), [b] "r" (b)
        : "r3", "r4", "r5", "r6", "r8"
    );

    return r;
 8013578:	68fb      	ldr	r3, [r7, #12]
}
 801357a:	4618      	mov	r0, r3
 801357c:	3714      	adds	r7, #20
 801357e:	46bd      	mov	sp, r7
 8013580:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8013584:	4770      	bx	lr

08013586 <sp_3072_div_48>:
 * r  Remainder from the division.
 * returns MP_OKAY indicating success.
 */
static WC_INLINE int sp_3072_div_48(const sp_digit* a, const sp_digit* d, sp_digit* m,
        sp_digit* r)
{
 8013586:	b590      	push	{r4, r7, lr}
 8013588:	f5ad 7d1b 	sub.w	sp, sp, #620	; 0x26c
 801358c:	af00      	add	r7, sp, #0
 801358e:	f107 040c 	add.w	r4, r7, #12
 8013592:	6020      	str	r0, [r4, #0]
 8013594:	f107 0008 	add.w	r0, r7, #8
 8013598:	6001      	str	r1, [r0, #0]
 801359a:	1d39      	adds	r1, r7, #4
 801359c:	600a      	str	r2, [r1, #0]
 801359e:	463a      	mov	r2, r7
 80135a0:	6013      	str	r3, [r2, #0]
    sp_digit div, r1;
    int i;

    (void)m;

    div = d[47];
 80135a2:	f107 0308 	add.w	r3, r7, #8
 80135a6:	681b      	ldr	r3, [r3, #0]
 80135a8:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 80135ac:	f8c7 3260 	str.w	r3, [r7, #608]	; 0x260
    XMEMCPY(t1, a, sizeof(*t1) * 2 * 48);
 80135b0:	f107 030c 	add.w	r3, r7, #12
 80135b4:	f107 00d8 	add.w	r0, r7, #216	; 0xd8
 80135b8:	f44f 72c0 	mov.w	r2, #384	; 0x180
 80135bc:	6819      	ldr	r1, [r3, #0]
 80135be:	f005 ff1a 	bl	80193f6 <memcpy>
    for (i=47; i>=0; i--) {
 80135c2:	232f      	movs	r3, #47	; 0x2f
 80135c4:	f8c7 3264 	str.w	r3, [r7, #612]	; 0x264
 80135c8:	e0cb      	b.n	8013762 <sp_3072_div_48+0x1dc>
        sp_digit hi = t1[48 + i] - (t1[48 + i] == div);
 80135ca:	f8d7 3264 	ldr.w	r3, [r7, #612]	; 0x264
 80135ce:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80135d2:	f107 03d8 	add.w	r3, r7, #216	; 0xd8
 80135d6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80135da:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 80135de:	f102 0130 	add.w	r1, r2, #48	; 0x30
 80135e2:	f107 02d8 	add.w	r2, r7, #216	; 0xd8
 80135e6:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 80135ea:	f8d7 1260 	ldr.w	r1, [r7, #608]	; 0x260
 80135ee:	4291      	cmp	r1, r2
 80135f0:	bf0c      	ite	eq
 80135f2:	2201      	moveq	r2, #1
 80135f4:	2200      	movne	r2, #0
 80135f6:	b2d2      	uxtb	r2, r2
 80135f8:	1a9b      	subs	r3, r3, r2
 80135fa:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
        r1 = div_3072_word_48(hi, t1[48 + i - 1], div);
 80135fe:	f8d7 3264 	ldr.w	r3, [r7, #612]	; 0x264
 8013602:	f103 022f 	add.w	r2, r3, #47	; 0x2f
 8013606:	f107 03d8 	add.w	r3, r7, #216	; 0xd8
 801360a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801360e:	f8d7 2260 	ldr.w	r2, [r7, #608]	; 0x260
 8013612:	4619      	mov	r1, r3
 8013614:	f8d7 0258 	ldr.w	r0, [r7, #600]	; 0x258
 8013618:	f7ff ff35 	bl	8013486 <div_3072_word_48>
 801361c:	f8c7 025c 	str.w	r0, [r7, #604]	; 0x25c

        sp_3072_mul_d_48(t2, d, r1);
 8013620:	f107 0308 	add.w	r3, r7, #8
 8013624:	f107 0014 	add.w	r0, r7, #20
 8013628:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 801362c:	6819      	ldr	r1, [r3, #0]
 801362e:	f7ff fefa 	bl	8013426 <sp_3072_mul_d_48>
        t1[48 + i] += sp_3072_sub_in_place_48(&t1[i], t2);
 8013632:	f107 02d8 	add.w	r2, r7, #216	; 0xd8
 8013636:	f8d7 3264 	ldr.w	r3, [r7, #612]	; 0x264
 801363a:	009b      	lsls	r3, r3, #2
 801363c:	4413      	add	r3, r2
 801363e:	f107 0214 	add.w	r2, r7, #20
 8013642:	4611      	mov	r1, r2
 8013644:	4618      	mov	r0, r3
 8013646:	f7ff fc81 	bl	8012f4c <sp_3072_sub_in_place_48>
 801364a:	4601      	mov	r1, r0
 801364c:	f8d7 3264 	ldr.w	r3, [r7, #612]	; 0x264
 8013650:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8013654:	f107 03d8 	add.w	r3, r7, #216	; 0xd8
 8013658:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801365c:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 8013660:	3230      	adds	r2, #48	; 0x30
 8013662:	4419      	add	r1, r3
 8013664:	f107 03d8 	add.w	r3, r7, #216	; 0xd8
 8013668:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        t1[48 + i] -= t2[48];
 801366c:	f8d7 3264 	ldr.w	r3, [r7, #612]	; 0x264
 8013670:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8013674:	f107 03d8 	add.w	r3, r7, #216	; 0xd8
 8013678:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 801367c:	f107 0314 	add.w	r3, r7, #20
 8013680:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8013684:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 8013688:	3230      	adds	r2, #48	; 0x30
 801368a:	1ac9      	subs	r1, r1, r3
 801368c:	f107 03d8 	add.w	r3, r7, #216	; 0xd8
 8013690:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        sp_3072_mask_48(t2, d, t1[48 + i]);
 8013694:	f8d7 3264 	ldr.w	r3, [r7, #612]	; 0x264
 8013698:	f103 0230 	add.w	r2, r3, #48	; 0x30
 801369c:	f107 03d8 	add.w	r3, r7, #216	; 0xd8
 80136a0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80136a4:	f107 0308 	add.w	r3, r7, #8
 80136a8:	f107 0014 	add.w	r0, r7, #20
 80136ac:	6819      	ldr	r1, [r3, #0]
 80136ae:	f7ff fbfb 	bl	8012ea8 <sp_3072_mask_48>
        t1[48 + i] += sp_3072_add_48(&t1[i], &t1[i], t2);
 80136b2:	f107 02d8 	add.w	r2, r7, #216	; 0xd8
 80136b6:	f8d7 3264 	ldr.w	r3, [r7, #612]	; 0x264
 80136ba:	009b      	lsls	r3, r3, #2
 80136bc:	18d0      	adds	r0, r2, r3
 80136be:	f107 02d8 	add.w	r2, r7, #216	; 0xd8
 80136c2:	f8d7 3264 	ldr.w	r3, [r7, #612]	; 0x264
 80136c6:	009b      	lsls	r3, r3, #2
 80136c8:	4413      	add	r3, r2
 80136ca:	f107 0214 	add.w	r2, r7, #20
 80136ce:	4619      	mov	r1, r3
 80136d0:	f7ff fc0b 	bl	8012eea <sp_3072_add_48>
 80136d4:	4601      	mov	r1, r0
 80136d6:	f8d7 3264 	ldr.w	r3, [r7, #612]	; 0x264
 80136da:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80136de:	f107 03d8 	add.w	r3, r7, #216	; 0xd8
 80136e2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80136e6:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 80136ea:	3230      	adds	r2, #48	; 0x30
 80136ec:	4419      	add	r1, r3
 80136ee:	f107 03d8 	add.w	r3, r7, #216	; 0xd8
 80136f2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        sp_3072_mask_48(t2, d, t1[48 + i]);
 80136f6:	f8d7 3264 	ldr.w	r3, [r7, #612]	; 0x264
 80136fa:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80136fe:	f107 03d8 	add.w	r3, r7, #216	; 0xd8
 8013702:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8013706:	f107 0308 	add.w	r3, r7, #8
 801370a:	f107 0014 	add.w	r0, r7, #20
 801370e:	6819      	ldr	r1, [r3, #0]
 8013710:	f7ff fbca 	bl	8012ea8 <sp_3072_mask_48>
        t1[48 + i] += sp_3072_add_48(&t1[i], &t1[i], t2);
 8013714:	f107 02d8 	add.w	r2, r7, #216	; 0xd8
 8013718:	f8d7 3264 	ldr.w	r3, [r7, #612]	; 0x264
 801371c:	009b      	lsls	r3, r3, #2
 801371e:	18d0      	adds	r0, r2, r3
 8013720:	f107 02d8 	add.w	r2, r7, #216	; 0xd8
 8013724:	f8d7 3264 	ldr.w	r3, [r7, #612]	; 0x264
 8013728:	009b      	lsls	r3, r3, #2
 801372a:	4413      	add	r3, r2
 801372c:	f107 0214 	add.w	r2, r7, #20
 8013730:	4619      	mov	r1, r3
 8013732:	f7ff fbda 	bl	8012eea <sp_3072_add_48>
 8013736:	4601      	mov	r1, r0
 8013738:	f8d7 3264 	ldr.w	r3, [r7, #612]	; 0x264
 801373c:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8013740:	f107 03d8 	add.w	r3, r7, #216	; 0xd8
 8013744:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8013748:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801374c:	3230      	adds	r2, #48	; 0x30
 801374e:	4419      	add	r1, r3
 8013750:	f107 03d8 	add.w	r3, r7, #216	; 0xd8
 8013754:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (i=47; i>=0; i--) {
 8013758:	f8d7 3264 	ldr.w	r3, [r7, #612]	; 0x264
 801375c:	3b01      	subs	r3, #1
 801375e:	f8c7 3264 	str.w	r3, [r7, #612]	; 0x264
 8013762:	f8d7 3264 	ldr.w	r3, [r7, #612]	; 0x264
 8013766:	2b00      	cmp	r3, #0
 8013768:	f6bf af2f 	bge.w	80135ca <sp_3072_div_48+0x44>
    }

    r1 = sp_3072_cmp_48(t1, d) >= 0;
 801376c:	f107 0308 	add.w	r3, r7, #8
 8013770:	f107 02d8 	add.w	r2, r7, #216	; 0xd8
 8013774:	6819      	ldr	r1, [r3, #0]
 8013776:	4610      	mov	r0, r2
 8013778:	f7ff fecd 	bl	8013516 <sp_3072_cmp_48>
 801377c:	4603      	mov	r3, r0
 801377e:	43db      	mvns	r3, r3
 8013780:	0fdb      	lsrs	r3, r3, #31
 8013782:	b2db      	uxtb	r3, r3
 8013784:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    sp_3072_cond_sub_48(r, t1, d, (sp_digit)0 - r1);
 8013788:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 801378c:	425b      	negs	r3, r3
 801378e:	f107 0208 	add.w	r2, r7, #8
 8013792:	f107 01d8 	add.w	r1, r7, #216	; 0xd8
 8013796:	4638      	mov	r0, r7
 8013798:	6812      	ldr	r2, [r2, #0]
 801379a:	6800      	ldr	r0, [r0, #0]
 801379c:	f7ff fd70 	bl	8013280 <sp_3072_cond_sub_48>

    return MP_OKAY;
 80137a0:	2300      	movs	r3, #0
}
 80137a2:	4618      	mov	r0, r3
 80137a4:	f507 771b 	add.w	r7, r7, #620	; 0x26c
 80137a8:	46bd      	mov	sp, r7
 80137aa:	bd90      	pop	{r4, r7, pc}

080137ac <sp_3072_mod_48>:
 * a  A single precision number that is to be reduced.
 * m  A single precision number that is the modulus to reduce with.
 * returns MP_OKAY indicating success.
 */
static WC_INLINE int sp_3072_mod_48(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
 80137ac:	b580      	push	{r7, lr}
 80137ae:	b084      	sub	sp, #16
 80137b0:	af00      	add	r7, sp, #0
 80137b2:	60f8      	str	r0, [r7, #12]
 80137b4:	60b9      	str	r1, [r7, #8]
 80137b6:	607a      	str	r2, [r7, #4]
    return sp_3072_div_48(a, m, NULL, r);
 80137b8:	68fb      	ldr	r3, [r7, #12]
 80137ba:	2200      	movs	r2, #0
 80137bc:	6879      	ldr	r1, [r7, #4]
 80137be:	68b8      	ldr	r0, [r7, #8]
 80137c0:	f7ff fee1 	bl	8013586 <sp_3072_div_48>
 80137c4:	4603      	mov	r3, r0
}
 80137c6:	4618      	mov	r0, r3
 80137c8:	3710      	adds	r7, #16
 80137ca:	46bd      	mov	sp, r7
 80137cc:	bd80      	pop	{r7, pc}

080137ce <sp_3072_mod_exp_48>:
 * m     A single precision number that is the modulus.
 * returns 0 on success and MEMORY_E on dynamic memory allocation failure.
 */
static int sp_3072_mod_exp_48(sp_digit* r, const sp_digit* a, const sp_digit* e,
        int bits, const sp_digit* m, int reduceA)
{
 80137ce:	b580      	push	{r7, lr}
 80137d0:	b0a0      	sub	sp, #128	; 0x80
 80137d2:	af02      	add	r7, sp, #8
 80137d4:	60f8      	str	r0, [r7, #12]
 80137d6:	60b9      	str	r1, [r7, #8]
 80137d8:	607a      	str	r2, [r7, #4]
 80137da:	603b      	str	r3, [r7, #0]
#else
    sp_digit td[16 * 96];
#endif
    sp_digit* t[16];
    sp_digit* norm;
    sp_digit mp = 1;
 80137dc:	2301      	movs	r3, #1
 80137de:	613b      	str	r3, [r7, #16]
    sp_digit n;
    sp_digit mask;
    int i;
    int c, y;
    int err = MP_OKAY;
 80137e0:	2300      	movs	r3, #0
 80137e2:	667b      	str	r3, [r7, #100]	; 0x64

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * (16 * 96), NULL,
 80137e4:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
 80137e8:	f7fb fb86 	bl	800eef8 <wolfSSL_Malloc>
 80137ec:	6638      	str	r0, [r7, #96]	; 0x60
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
 80137ee:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80137f0:	2b00      	cmp	r3, #0
 80137f2:	d102      	bne.n	80137fa <sp_3072_mod_exp_48+0x2c>
        err = MEMORY_E;
 80137f4:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 80137f8:	667b      	str	r3, [r7, #100]	; 0x64
    }
#endif

    if (err == MP_OKAY) {
 80137fa:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80137fc:	2b00      	cmp	r3, #0
 80137fe:	d153      	bne.n	80138a8 <sp_3072_mod_exp_48+0xda>
        norm = td;
 8013800:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8013802:	65fb      	str	r3, [r7, #92]	; 0x5c
        for (i=0; i<16; i++) {
 8013804:	2300      	movs	r3, #0
 8013806:	673b      	str	r3, [r7, #112]	; 0x70
 8013808:	e011      	b.n	801382e <sp_3072_mod_exp_48+0x60>
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
            t[i] = td + i * 96;
 801380a:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 801380c:	4613      	mov	r3, r2
 801380e:	005b      	lsls	r3, r3, #1
 8013810:	4413      	add	r3, r2
 8013812:	01db      	lsls	r3, r3, #7
 8013814:	461a      	mov	r2, r3
 8013816:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8013818:	441a      	add	r2, r3
 801381a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801381c:	009b      	lsls	r3, r3, #2
 801381e:	f107 0178 	add.w	r1, r7, #120	; 0x78
 8013822:	440b      	add	r3, r1
 8013824:	f843 2c64 	str.w	r2, [r3, #-100]
        for (i=0; i<16; i++) {
 8013828:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801382a:	3301      	adds	r3, #1
 801382c:	673b      	str	r3, [r7, #112]	; 0x70
 801382e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8013830:	2b0f      	cmp	r3, #15
 8013832:	ddea      	ble.n	801380a <sp_3072_mod_exp_48+0x3c>
#else
            t[i] = &td[i * 96];
#endif
        }

        sp_3072_mont_setup(m, &mp);
 8013834:	f107 0310 	add.w	r3, r7, #16
 8013838:	4619      	mov	r1, r3
 801383a:	f8d7 0080 	ldr.w	r0, [r7, #128]	; 0x80
 801383e:	f7ff fca5 	bl	801318c <sp_3072_mont_setup>
        sp_3072_mont_norm_48(norm, m);
 8013842:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 8013846:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 8013848:	f7ff fd08 	bl	801325c <sp_3072_mont_norm_48>

        XMEMSET(t[1], 0, sizeof(sp_digit) * 48U);
 801384c:	69bb      	ldr	r3, [r7, #24]
 801384e:	22c0      	movs	r2, #192	; 0xc0
 8013850:	2100      	movs	r1, #0
 8013852:	4618      	mov	r0, r3
 8013854:	f005 fdf3 	bl	801943e <memset>
        if (reduceA != 0) {
 8013858:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 801385c:	2b00      	cmp	r3, #0
 801385e:	d014      	beq.n	801388a <sp_3072_mod_exp_48+0xbc>
            err = sp_3072_mod_48(t[1] + 48, a, m);
 8013860:	69bb      	ldr	r3, [r7, #24]
 8013862:	33c0      	adds	r3, #192	; 0xc0
 8013864:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8013868:	68b9      	ldr	r1, [r7, #8]
 801386a:	4618      	mov	r0, r3
 801386c:	f7ff ff9e 	bl	80137ac <sp_3072_mod_48>
 8013870:	6678      	str	r0, [r7, #100]	; 0x64
            if (err == MP_OKAY) {
 8013872:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013874:	2b00      	cmp	r3, #0
 8013876:	d117      	bne.n	80138a8 <sp_3072_mod_exp_48+0xda>
                err = sp_3072_mod_48(t[1], t[1], m);
 8013878:	69bb      	ldr	r3, [r7, #24]
 801387a:	69b9      	ldr	r1, [r7, #24]
 801387c:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8013880:	4618      	mov	r0, r3
 8013882:	f7ff ff93 	bl	80137ac <sp_3072_mod_48>
 8013886:	6678      	str	r0, [r7, #100]	; 0x64
 8013888:	e00e      	b.n	80138a8 <sp_3072_mod_exp_48+0xda>
            }
        }
        else {
            XMEMCPY(t[1] + 48, a, sizeof(sp_digit) * 48);
 801388a:	69bb      	ldr	r3, [r7, #24]
 801388c:	33c0      	adds	r3, #192	; 0xc0
 801388e:	22c0      	movs	r2, #192	; 0xc0
 8013890:	68b9      	ldr	r1, [r7, #8]
 8013892:	4618      	mov	r0, r3
 8013894:	f005 fdaf 	bl	80193f6 <memcpy>
            err = sp_3072_mod_48(t[1], t[1], m);
 8013898:	69bb      	ldr	r3, [r7, #24]
 801389a:	69b9      	ldr	r1, [r7, #24]
 801389c:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 80138a0:	4618      	mov	r0, r3
 80138a2:	f7ff ff83 	bl	80137ac <sp_3072_mod_48>
 80138a6:	6678      	str	r0, [r7, #100]	; 0x64
        }
    }

    if (err == MP_OKAY) {
 80138a8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80138aa:	2b00      	cmp	r3, #0
 80138ac:	f040 816c 	bne.w	8013b88 <sp_3072_mod_exp_48+0x3ba>
        sp_3072_mont_sqr_48(t[ 2], t[ 1], m, mp);
 80138b0:	69f8      	ldr	r0, [r7, #28]
 80138b2:	69b9      	ldr	r1, [r7, #24]
 80138b4:	693b      	ldr	r3, [r7, #16]
 80138b6:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 80138ba:	f7ff fda0 	bl	80133fe <sp_3072_mont_sqr_48>
        sp_3072_mont_mul_48(t[ 3], t[ 2], t[ 1], m, mp);
 80138be:	6a38      	ldr	r0, [r7, #32]
 80138c0:	69f9      	ldr	r1, [r7, #28]
 80138c2:	69ba      	ldr	r2, [r7, #24]
 80138c4:	693b      	ldr	r3, [r7, #16]
 80138c6:	9300      	str	r3, [sp, #0]
 80138c8:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80138cc:	f7ff fd82 	bl	80133d4 <sp_3072_mont_mul_48>
        sp_3072_mont_sqr_48(t[ 4], t[ 2], m, mp);
 80138d0:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80138d2:	69f9      	ldr	r1, [r7, #28]
 80138d4:	693b      	ldr	r3, [r7, #16]
 80138d6:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 80138da:	f7ff fd90 	bl	80133fe <sp_3072_mont_sqr_48>
        sp_3072_mont_mul_48(t[ 5], t[ 3], t[ 2], m, mp);
 80138de:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80138e0:	6a39      	ldr	r1, [r7, #32]
 80138e2:	69fa      	ldr	r2, [r7, #28]
 80138e4:	693b      	ldr	r3, [r7, #16]
 80138e6:	9300      	str	r3, [sp, #0]
 80138e8:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80138ec:	f7ff fd72 	bl	80133d4 <sp_3072_mont_mul_48>
        sp_3072_mont_sqr_48(t[ 6], t[ 3], m, mp);
 80138f0:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80138f2:	6a39      	ldr	r1, [r7, #32]
 80138f4:	693b      	ldr	r3, [r7, #16]
 80138f6:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 80138fa:	f7ff fd80 	bl	80133fe <sp_3072_mont_sqr_48>
        sp_3072_mont_mul_48(t[ 7], t[ 4], t[ 3], m, mp);
 80138fe:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8013900:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8013902:	6a3a      	ldr	r2, [r7, #32]
 8013904:	693b      	ldr	r3, [r7, #16]
 8013906:	9300      	str	r3, [sp, #0]
 8013908:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801390c:	f7ff fd62 	bl	80133d4 <sp_3072_mont_mul_48>
        sp_3072_mont_sqr_48(t[ 8], t[ 4], m, mp);
 8013910:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8013912:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8013914:	693b      	ldr	r3, [r7, #16]
 8013916:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 801391a:	f7ff fd70 	bl	80133fe <sp_3072_mont_sqr_48>
        sp_3072_mont_mul_48(t[ 9], t[ 5], t[ 4], m, mp);
 801391e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8013920:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8013922:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013924:	693b      	ldr	r3, [r7, #16]
 8013926:	9300      	str	r3, [sp, #0]
 8013928:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801392c:	f7ff fd52 	bl	80133d4 <sp_3072_mont_mul_48>
        sp_3072_mont_sqr_48(t[10], t[ 5], m, mp);
 8013930:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8013932:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8013934:	693b      	ldr	r3, [r7, #16]
 8013936:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 801393a:	f7ff fd60 	bl	80133fe <sp_3072_mont_sqr_48>
        sp_3072_mont_mul_48(t[11], t[ 6], t[ 5], m, mp);
 801393e:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8013940:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8013942:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013944:	693b      	ldr	r3, [r7, #16]
 8013946:	9300      	str	r3, [sp, #0]
 8013948:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801394c:	f7ff fd42 	bl	80133d4 <sp_3072_mont_mul_48>
        sp_3072_mont_sqr_48(t[12], t[ 6], m, mp);
 8013950:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8013952:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8013954:	693b      	ldr	r3, [r7, #16]
 8013956:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 801395a:	f7ff fd50 	bl	80133fe <sp_3072_mont_sqr_48>
        sp_3072_mont_mul_48(t[13], t[ 7], t[ 6], m, mp);
 801395e:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8013960:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8013962:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013964:	693b      	ldr	r3, [r7, #16]
 8013966:	9300      	str	r3, [sp, #0]
 8013968:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801396c:	f7ff fd32 	bl	80133d4 <sp_3072_mont_mul_48>
        sp_3072_mont_sqr_48(t[14], t[ 7], m, mp);
 8013970:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8013972:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8013974:	693b      	ldr	r3, [r7, #16]
 8013976:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 801397a:	f7ff fd40 	bl	80133fe <sp_3072_mont_sqr_48>
        sp_3072_mont_mul_48(t[15], t[ 8], t[ 7], m, mp);
 801397e:	6d38      	ldr	r0, [r7, #80]	; 0x50
 8013980:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8013982:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8013984:	693b      	ldr	r3, [r7, #16]
 8013986:	9300      	str	r3, [sp, #0]
 8013988:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801398c:	f7ff fd22 	bl	80133d4 <sp_3072_mont_mul_48>

        i = (bits - 1) / 32;
 8013990:	683b      	ldr	r3, [r7, #0]
 8013992:	3b01      	subs	r3, #1
 8013994:	2b00      	cmp	r3, #0
 8013996:	da00      	bge.n	801399a <sp_3072_mod_exp_48+0x1cc>
 8013998:	331f      	adds	r3, #31
 801399a:	115b      	asrs	r3, r3, #5
 801399c:	673b      	str	r3, [r7, #112]	; 0x70
        n = e[i--];
 801399e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80139a0:	1e5a      	subs	r2, r3, #1
 80139a2:	673a      	str	r2, [r7, #112]	; 0x70
 80139a4:	009b      	lsls	r3, r3, #2
 80139a6:	687a      	ldr	r2, [r7, #4]
 80139a8:	4413      	add	r3, r2
 80139aa:	681b      	ldr	r3, [r3, #0]
 80139ac:	677b      	str	r3, [r7, #116]	; 0x74
        c = bits & 31;
 80139ae:	683b      	ldr	r3, [r7, #0]
 80139b0:	f003 031f 	and.w	r3, r3, #31
 80139b4:	66fb      	str	r3, [r7, #108]	; 0x6c
        if (c == 0) {
 80139b6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80139b8:	2b00      	cmp	r3, #0
 80139ba:	d101      	bne.n	80139c0 <sp_3072_mod_exp_48+0x1f2>
            c = 32;
 80139bc:	2320      	movs	r3, #32
 80139be:	66fb      	str	r3, [r7, #108]	; 0x6c
        }
        c -= bits % 4;
 80139c0:	683b      	ldr	r3, [r7, #0]
 80139c2:	425a      	negs	r2, r3
 80139c4:	f003 0303 	and.w	r3, r3, #3
 80139c8:	f002 0203 	and.w	r2, r2, #3
 80139cc:	bf58      	it	pl
 80139ce:	4253      	negpl	r3, r2
 80139d0:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80139d2:	1ad3      	subs	r3, r2, r3
 80139d4:	66fb      	str	r3, [r7, #108]	; 0x6c
        if (c == 32) {
 80139d6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80139d8:	2b20      	cmp	r3, #32
 80139da:	d101      	bne.n	80139e0 <sp_3072_mod_exp_48+0x212>
            c = 28;
 80139dc:	231c      	movs	r3, #28
 80139de:	66fb      	str	r3, [r7, #108]	; 0x6c
        }
        if (c < 0) {
 80139e0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80139e2:	2b00      	cmp	r3, #0
 80139e4:	da23      	bge.n	8013a2e <sp_3072_mod_exp_48+0x260>
            /* Number of bits in top word is less than number needed. */
            c = -c;
 80139e6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80139e8:	425b      	negs	r3, r3
 80139ea:	66fb      	str	r3, [r7, #108]	; 0x6c
            y = (int)(n << c);
 80139ec:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 80139ee:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80139f0:	fa02 f303 	lsl.w	r3, r2, r3
 80139f4:	66bb      	str	r3, [r7, #104]	; 0x68
            n = e[i--];
 80139f6:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80139f8:	1e5a      	subs	r2, r3, #1
 80139fa:	673a      	str	r2, [r7, #112]	; 0x70
 80139fc:	009b      	lsls	r3, r3, #2
 80139fe:	687a      	ldr	r2, [r7, #4]
 8013a00:	4413      	add	r3, r2
 8013a02:	681b      	ldr	r3, [r3, #0]
 8013a04:	677b      	str	r3, [r7, #116]	; 0x74
            y |= (int)(n >> (64 - c));
 8013a06:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8013a08:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 8013a0c:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8013a0e:	fa22 f303 	lsr.w	r3, r2, r3
 8013a12:	461a      	mov	r2, r3
 8013a14:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8013a16:	4313      	orrs	r3, r2
 8013a18:	66bb      	str	r3, [r7, #104]	; 0x68
            n <<= c;
 8013a1a:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8013a1c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8013a1e:	fa02 f303 	lsl.w	r3, r2, r3
 8013a22:	677b      	str	r3, [r7, #116]	; 0x74
            c = 64 - c;
 8013a24:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8013a26:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 8013a2a:	66fb      	str	r3, [r7, #108]	; 0x6c
 8013a2c:	e00b      	b.n	8013a46 <sp_3072_mod_exp_48+0x278>
        }
        else {
            y = (int)(n >> c);
 8013a2e:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8013a30:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8013a32:	fa22 f303 	lsr.w	r3, r2, r3
 8013a36:	66bb      	str	r3, [r7, #104]	; 0x68
            n <<= 32 - c;
 8013a38:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8013a3a:	f1c3 0320 	rsb	r3, r3, #32
 8013a3e:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8013a40:	fa02 f303 	lsl.w	r3, r2, r3
 8013a44:	677b      	str	r3, [r7, #116]	; 0x74
        }
        XMEMCPY(r, t[y], sizeof(sp_digit) * 48);
 8013a46:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8013a48:	009b      	lsls	r3, r3, #2
 8013a4a:	f107 0278 	add.w	r2, r7, #120	; 0x78
 8013a4e:	4413      	add	r3, r2
 8013a50:	f853 3c64 	ldr.w	r3, [r3, #-100]
 8013a54:	22c0      	movs	r2, #192	; 0xc0
 8013a56:	4619      	mov	r1, r3
 8013a58:	68f8      	ldr	r0, [r7, #12]
 8013a5a:	f005 fccc 	bl	80193f6 <memcpy>
        for (; i>=0 || c>=4; ) {
 8013a5e:	e06d      	b.n	8013b3c <sp_3072_mod_exp_48+0x36e>
            if (c == 0) {
 8013a60:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8013a62:	2b00      	cmp	r3, #0
 8013a64:	d110      	bne.n	8013a88 <sp_3072_mod_exp_48+0x2ba>
                n = e[i--];
 8013a66:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8013a68:	1e5a      	subs	r2, r3, #1
 8013a6a:	673a      	str	r2, [r7, #112]	; 0x70
 8013a6c:	009b      	lsls	r3, r3, #2
 8013a6e:	687a      	ldr	r2, [r7, #4]
 8013a70:	4413      	add	r3, r2
 8013a72:	681b      	ldr	r3, [r3, #0]
 8013a74:	677b      	str	r3, [r7, #116]	; 0x74
                y = (int)(n >> 28);
 8013a76:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8013a78:	0f1b      	lsrs	r3, r3, #28
 8013a7a:	66bb      	str	r3, [r7, #104]	; 0x68
                n <<= 4;
 8013a7c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8013a7e:	011b      	lsls	r3, r3, #4
 8013a80:	677b      	str	r3, [r7, #116]	; 0x74
                c = 28;
 8013a82:	231c      	movs	r3, #28
 8013a84:	66fb      	str	r3, [r7, #108]	; 0x6c
 8013a86:	e02e      	b.n	8013ae6 <sp_3072_mod_exp_48+0x318>
            }
            else if (c < 4) {
 8013a88:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8013a8a:	2b03      	cmp	r3, #3
 8013a8c:	dc22      	bgt.n	8013ad4 <sp_3072_mod_exp_48+0x306>
                y = (int)(n >> 28);
 8013a8e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8013a90:	0f1b      	lsrs	r3, r3, #28
 8013a92:	66bb      	str	r3, [r7, #104]	; 0x68
                n = e[i--];
 8013a94:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8013a96:	1e5a      	subs	r2, r3, #1
 8013a98:	673a      	str	r2, [r7, #112]	; 0x70
 8013a9a:	009b      	lsls	r3, r3, #2
 8013a9c:	687a      	ldr	r2, [r7, #4]
 8013a9e:	4413      	add	r3, r2
 8013aa0:	681b      	ldr	r3, [r3, #0]
 8013aa2:	677b      	str	r3, [r7, #116]	; 0x74
                c = 4 - c;
 8013aa4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8013aa6:	f1c3 0304 	rsb	r3, r3, #4
 8013aaa:	66fb      	str	r3, [r7, #108]	; 0x6c
                y |= (int)(n >> (32 - c));
 8013aac:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8013aae:	f1c3 0320 	rsb	r3, r3, #32
 8013ab2:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8013ab4:	fa22 f303 	lsr.w	r3, r2, r3
 8013ab8:	461a      	mov	r2, r3
 8013aba:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8013abc:	4313      	orrs	r3, r2
 8013abe:	66bb      	str	r3, [r7, #104]	; 0x68
                n <<= c;
 8013ac0:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8013ac2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8013ac4:	fa02 f303 	lsl.w	r3, r2, r3
 8013ac8:	677b      	str	r3, [r7, #116]	; 0x74
                c = 32 - c;
 8013aca:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8013acc:	f1c3 0320 	rsb	r3, r3, #32
 8013ad0:	66fb      	str	r3, [r7, #108]	; 0x6c
 8013ad2:	e008      	b.n	8013ae6 <sp_3072_mod_exp_48+0x318>
            }
            else {
                y = (int)((n >> 28) & 0xf);
 8013ad4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8013ad6:	0f1b      	lsrs	r3, r3, #28
 8013ad8:	66bb      	str	r3, [r7, #104]	; 0x68
                n <<= 4;
 8013ada:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8013adc:	011b      	lsls	r3, r3, #4
 8013ade:	677b      	str	r3, [r7, #116]	; 0x74
                c -= 4;
 8013ae0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8013ae2:	3b04      	subs	r3, #4
 8013ae4:	66fb      	str	r3, [r7, #108]	; 0x6c
            }

            sp_3072_mont_sqr_48(r, r, m, mp);
 8013ae6:	693b      	ldr	r3, [r7, #16]
 8013ae8:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8013aec:	68f9      	ldr	r1, [r7, #12]
 8013aee:	68f8      	ldr	r0, [r7, #12]
 8013af0:	f7ff fc85 	bl	80133fe <sp_3072_mont_sqr_48>
            sp_3072_mont_sqr_48(r, r, m, mp);
 8013af4:	693b      	ldr	r3, [r7, #16]
 8013af6:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8013afa:	68f9      	ldr	r1, [r7, #12]
 8013afc:	68f8      	ldr	r0, [r7, #12]
 8013afe:	f7ff fc7e 	bl	80133fe <sp_3072_mont_sqr_48>
            sp_3072_mont_sqr_48(r, r, m, mp);
 8013b02:	693b      	ldr	r3, [r7, #16]
 8013b04:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8013b08:	68f9      	ldr	r1, [r7, #12]
 8013b0a:	68f8      	ldr	r0, [r7, #12]
 8013b0c:	f7ff fc77 	bl	80133fe <sp_3072_mont_sqr_48>
            sp_3072_mont_sqr_48(r, r, m, mp);
 8013b10:	693b      	ldr	r3, [r7, #16]
 8013b12:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8013b16:	68f9      	ldr	r1, [r7, #12]
 8013b18:	68f8      	ldr	r0, [r7, #12]
 8013b1a:	f7ff fc70 	bl	80133fe <sp_3072_mont_sqr_48>

            sp_3072_mont_mul_48(r, r, t[y], m, mp);
 8013b1e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8013b20:	009b      	lsls	r3, r3, #2
 8013b22:	f107 0278 	add.w	r2, r7, #120	; 0x78
 8013b26:	4413      	add	r3, r2
 8013b28:	f853 2c64 	ldr.w	r2, [r3, #-100]
 8013b2c:	693b      	ldr	r3, [r7, #16]
 8013b2e:	9300      	str	r3, [sp, #0]
 8013b30:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8013b34:	68f9      	ldr	r1, [r7, #12]
 8013b36:	68f8      	ldr	r0, [r7, #12]
 8013b38:	f7ff fc4c 	bl	80133d4 <sp_3072_mont_mul_48>
        for (; i>=0 || c>=4; ) {
 8013b3c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8013b3e:	2b00      	cmp	r3, #0
 8013b40:	da8e      	bge.n	8013a60 <sp_3072_mod_exp_48+0x292>
 8013b42:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8013b44:	2b03      	cmp	r3, #3
 8013b46:	dc8b      	bgt.n	8013a60 <sp_3072_mod_exp_48+0x292>
        }

        XMEMSET(&r[48], 0, sizeof(sp_digit) * 48U);
 8013b48:	68fb      	ldr	r3, [r7, #12]
 8013b4a:	33c0      	adds	r3, #192	; 0xc0
 8013b4c:	22c0      	movs	r2, #192	; 0xc0
 8013b4e:	2100      	movs	r1, #0
 8013b50:	4618      	mov	r0, r3
 8013b52:	f005 fc74 	bl	801943e <memset>
        sp_3072_mont_reduce_48(r, m, mp);
 8013b56:	693b      	ldr	r3, [r7, #16]
 8013b58:	461a      	mov	r2, r3
 8013b5a:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 8013b5e:	68f8      	ldr	r0, [r7, #12]
 8013b60:	f7ff fbbb 	bl	80132da <sp_3072_mont_reduce_48>

        mask = 0 - (sp_3072_cmp_48(r, m) >= 0);
 8013b64:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 8013b68:	68f8      	ldr	r0, [r7, #12]
 8013b6a:	f7ff fcd4 	bl	8013516 <sp_3072_cmp_48>
 8013b6e:	4603      	mov	r3, r0
 8013b70:	43db      	mvns	r3, r3
 8013b72:	0fdb      	lsrs	r3, r3, #31
 8013b74:	b2db      	uxtb	r3, r3
 8013b76:	425b      	negs	r3, r3
 8013b78:	65bb      	str	r3, [r7, #88]	; 0x58
        sp_3072_cond_sub_48(r, r, m, mask);
 8013b7a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8013b7c:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8013b80:	68f9      	ldr	r1, [r7, #12]
 8013b82:	68f8      	ldr	r0, [r7, #12]
 8013b84:	f7ff fb7c 	bl	8013280 <sp_3072_cond_sub_48>
    }

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
 8013b88:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8013b8a:	2b00      	cmp	r3, #0
 8013b8c:	d007      	beq.n	8013b9e <sp_3072_mod_exp_48+0x3d0>
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8013b8e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8013b90:	657b      	str	r3, [r7, #84]	; 0x54
 8013b92:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8013b94:	2b00      	cmp	r3, #0
 8013b96:	d002      	beq.n	8013b9e <sp_3072_mod_exp_48+0x3d0>
 8013b98:	6d78      	ldr	r0, [r7, #84]	; 0x54
 8013b9a:	f7fb f9c9 	bl	800ef30 <wolfSSL_Free>
    }
#endif

    return err;
 8013b9e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
}
 8013ba0:	4618      	mov	r0, r3
 8013ba2:	3778      	adds	r7, #120	; 0x78
 8013ba4:	46bd      	mov	sp, r7
 8013ba6:	bd80      	pop	{r7, pc}

08013ba8 <sp_3072_cond_sub_96>:
 * b  A single precision number to subtract.
 * m  Mask value to apply.
 */
SP_NOINLINE static sp_digit sp_3072_cond_sub_96(sp_digit* r, const sp_digit* a,
        const sp_digit* b, sp_digit m)
{
 8013ba8:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 8013bac:	b086      	sub	sp, #24
 8013bae:	af00      	add	r7, sp, #0
 8013bb0:	60f8      	str	r0, [r7, #12]
 8013bb2:	60b9      	str	r1, [r7, #8]
 8013bb4:	607a      	str	r2, [r7, #4]
 8013bb6:	603b      	str	r3, [r7, #0]
    sp_digit c = 0;
 8013bb8:	2300      	movs	r3, #0
 8013bba:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 8013bbc:	68fa      	ldr	r2, [r7, #12]
 8013bbe:	68b9      	ldr	r1, [r7, #8]
 8013bc0:	6878      	ldr	r0, [r7, #4]
 8013bc2:	683c      	ldr	r4, [r7, #0]
 8013bc4:	697b      	ldr	r3, [r7, #20]
 8013bc6:	f04f 0501 	mov.w	r5, #1
 8013bca:	ea4f 2505 	mov.w	r5, r5, lsl #8
 8013bce:	f105 0580 	add.w	r5, r5, #128	; 0x80
 8013bd2:	46a9      	mov	r9, r5
 8013bd4:	f04f 0800 	mov.w	r8, #0
 8013bd8:	f850 6008 	ldr.w	r6, [r0, r8]
 8013bdc:	ea06 0604 	and.w	r6, r6, r4
 8013be0:	f04f 0500 	mov.w	r5, #0
 8013be4:	1aed      	subs	r5, r5, r3
 8013be6:	f851 5008 	ldr.w	r5, [r1, r8]
 8013bea:	41b5      	sbcs	r5, r6
 8013bec:	419b      	sbcs	r3, r3
 8013bee:	f842 5008 	str.w	r5, [r2, r8]
 8013bf2:	f108 0804 	add.w	r8, r8, #4
 8013bf6:	45c8      	cmp	r8, r9
 8013bf8:	dbee      	blt.n	8013bd8 <sp_3072_cond_sub_96+0x30>
 8013bfa:	617b      	str	r3, [r7, #20]
        : [c] "+r" (c)
        : [r] "r" (r), [a] "r" (a), [b] "r" (b), [m] "r" (m)
        : "memory", "r5", "r6", "r8", "r9"
    );

    return c;
 8013bfc:	697b      	ldr	r3, [r7, #20]
}
 8013bfe:	4618      	mov	r0, r3
 8013c00:	3718      	adds	r7, #24
 8013c02:	46bd      	mov	sp, r7
 8013c04:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8013c08:	4770      	bx	lr

08013c0a <sp_3072_mont_reduce_96>:
 * m   The single precision number representing the modulus.
 * mp  The digit representing the negative inverse of m mod 2^n.
 */
SP_NOINLINE static void sp_3072_mont_reduce_96(sp_digit* a, const sp_digit* m,
        sp_digit mp)
{
 8013c0a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013c0e:	b087      	sub	sp, #28
 8013c10:	af00      	add	r7, sp, #0
 8013c12:	60f8      	str	r0, [r7, #12]
 8013c14:	60b9      	str	r1, [r7, #8]
 8013c16:	607a      	str	r2, [r7, #4]
    sp_digit ca = 0;
 8013c18:	2300      	movs	r3, #0
 8013c1a:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 8013c1c:	68b9      	ldr	r1, [r7, #8]
 8013c1e:	6878      	ldr	r0, [r7, #4]
 8013c20:	697a      	ldr	r2, [r7, #20]
 8013c22:	68fb      	ldr	r3, [r7, #12]
 8013c24:	4681      	mov	r9, r0
 8013c26:	468c      	mov	ip, r1
 8013c28:	469a      	mov	sl, r3
 8013c2a:	f04f 0400 	mov.w	r4, #0
 8013c2e:	f50a 7bc0 	add.w	fp, sl, #384	; 0x180
 8013c32:	4648      	mov	r0, r9
 8013c34:	f8da 3000 	ldr.w	r3, [sl]
 8013c38:	fb00 f003 	mul.w	r0, r0, r3
 8013c3c:	4661      	mov	r1, ip
 8013c3e:	f50a 7ebc 	add.w	lr, sl, #376	; 0x178
 8013c42:	f8da 3000 	ldr.w	r3, [sl]
 8013c46:	f04f 0500 	mov.w	r5, #0
 8013c4a:	f851 8b04 	ldr.w	r8, [r1], #4
 8013c4e:	fba0 6808 	umull	r6, r8, r0, r8
 8013c52:	199b      	adds	r3, r3, r6
 8013c54:	eb45 0508 	adc.w	r5, r5, r8
 8013c58:	18e4      	adds	r4, r4, r3
 8013c5a:	f145 0500 	adc.w	r5, r5, #0
 8013c5e:	f84a 4b04 	str.w	r4, [sl], #4
 8013c62:	f8da 3000 	ldr.w	r3, [sl]
 8013c66:	f04f 0400 	mov.w	r4, #0
 8013c6a:	f851 8b04 	ldr.w	r8, [r1], #4
 8013c6e:	fba0 6808 	umull	r6, r8, r0, r8
 8013c72:	199b      	adds	r3, r3, r6
 8013c74:	eb44 0408 	adc.w	r4, r4, r8
 8013c78:	18ed      	adds	r5, r5, r3
 8013c7a:	f144 0400 	adc.w	r4, r4, #0
 8013c7e:	f84a 5b04 	str.w	r5, [sl], #4
 8013c82:	45f2      	cmp	sl, lr
 8013c84:	dbdd      	blt.n	8013c42 <sp_3072_mont_reduce_96+0x38>
 8013c86:	f8da 3000 	ldr.w	r3, [sl]
 8013c8a:	f04f 0500 	mov.w	r5, #0
 8013c8e:	f851 8b04 	ldr.w	r8, [r1], #4
 8013c92:	fba0 6808 	umull	r6, r8, r0, r8
 8013c96:	199b      	adds	r3, r3, r6
 8013c98:	eb45 0508 	adc.w	r5, r5, r8
 8013c9c:	18e4      	adds	r4, r4, r3
 8013c9e:	f145 0500 	adc.w	r5, r5, #0
 8013ca2:	f84a 4b04 	str.w	r4, [sl], #4
 8013ca6:	4614      	mov	r4, r2
 8013ca8:	f04f 0200 	mov.w	r2, #0
 8013cac:	f8d1 8000 	ldr.w	r8, [r1]
 8013cb0:	fba0 6808 	umull	r6, r8, r0, r8
 8013cb4:	19ad      	adds	r5, r5, r6
 8013cb6:	eb54 0408 	adcs.w	r4, r4, r8
 8013cba:	f142 0200 	adc.w	r2, r2, #0
 8013cbe:	f8da 6000 	ldr.w	r6, [sl]
 8013cc2:	f8da 8004 	ldr.w	r8, [sl, #4]
 8013cc6:	1976      	adds	r6, r6, r5
 8013cc8:	eb58 0804 	adcs.w	r8, r8, r4
 8013ccc:	f142 0200 	adc.w	r2, r2, #0
 8013cd0:	f8ca 6000 	str.w	r6, [sl]
 8013cd4:	f8ca 8004 	str.w	r8, [sl, #4]
 8013cd8:	f5aa 7abc 	sub.w	sl, sl, #376	; 0x178
 8013cdc:	45da      	cmp	sl, fp
 8013cde:	dba8      	blt.n	8013c32 <sp_3072_mont_reduce_96+0x28>
 8013ce0:	4653      	mov	r3, sl
 8013ce2:	4661      	mov	r1, ip
 8013ce4:	617a      	str	r2, [r7, #20]
 8013ce6:	60fb      	str	r3, [r7, #12]
        : [ca] "+r" (ca), [a] "+r" (a)
        : [m] "r" (m), [mp] "r" (mp)
        : "memory", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r12", "r14"
    );

    sp_3072_cond_sub_96(a - 96, a, m, (sp_digit)0 - ca);
 8013ce8:	68fb      	ldr	r3, [r7, #12]
 8013cea:	f5a3 70c0 	sub.w	r0, r3, #384	; 0x180
 8013cee:	697b      	ldr	r3, [r7, #20]
 8013cf0:	425b      	negs	r3, r3
 8013cf2:	68ba      	ldr	r2, [r7, #8]
 8013cf4:	68f9      	ldr	r1, [r7, #12]
 8013cf6:	f7ff ff57 	bl	8013ba8 <sp_3072_cond_sub_96>
}
 8013cfa:	bf00      	nop
 8013cfc:	371c      	adds	r7, #28
 8013cfe:	46bd      	mov	sp, r7
 8013d00:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08013d04 <sp_3072_mont_mul_96>:
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_3072_mont_mul_96(sp_digit* r, const sp_digit* a, const sp_digit* b,
        const sp_digit* m, sp_digit mp)
{
 8013d04:	b580      	push	{r7, lr}
 8013d06:	b084      	sub	sp, #16
 8013d08:	af00      	add	r7, sp, #0
 8013d0a:	60f8      	str	r0, [r7, #12]
 8013d0c:	60b9      	str	r1, [r7, #8]
 8013d0e:	607a      	str	r2, [r7, #4]
 8013d10:	603b      	str	r3, [r7, #0]
    sp_3072_mul_96(r, a, b);
 8013d12:	687a      	ldr	r2, [r7, #4]
 8013d14:	68b9      	ldr	r1, [r7, #8]
 8013d16:	68f8      	ldr	r0, [r7, #12]
 8013d18:	f7fe ffc7 	bl	8012caa <sp_3072_mul_96>
    sp_3072_mont_reduce_96(r, m, mp);
 8013d1c:	69ba      	ldr	r2, [r7, #24]
 8013d1e:	6839      	ldr	r1, [r7, #0]
 8013d20:	68f8      	ldr	r0, [r7, #12]
 8013d22:	f7ff ff72 	bl	8013c0a <sp_3072_mont_reduce_96>
}
 8013d26:	bf00      	nop
 8013d28:	3710      	adds	r7, #16
 8013d2a:	46bd      	mov	sp, r7
 8013d2c:	bd80      	pop	{r7, pc}

08013d2e <sp_3072_mont_sqr_96>:
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_3072_mont_sqr_96(sp_digit* r, const sp_digit* a, const sp_digit* m,
        sp_digit mp)
{
 8013d2e:	b580      	push	{r7, lr}
 8013d30:	b084      	sub	sp, #16
 8013d32:	af00      	add	r7, sp, #0
 8013d34:	60f8      	str	r0, [r7, #12]
 8013d36:	60b9      	str	r1, [r7, #8]
 8013d38:	607a      	str	r2, [r7, #4]
 8013d3a:	603b      	str	r3, [r7, #0]
    sp_3072_sqr_96(r, a);
 8013d3c:	68b9      	ldr	r1, [r7, #8]
 8013d3e:	68f8      	ldr	r0, [r7, #12]
 8013d40:	f7ff f82a 	bl	8012d98 <sp_3072_sqr_96>
    sp_3072_mont_reduce_96(r, m, mp);
 8013d44:	683a      	ldr	r2, [r7, #0]
 8013d46:	6879      	ldr	r1, [r7, #4]
 8013d48:	68f8      	ldr	r0, [r7, #12]
 8013d4a:	f7ff ff5e 	bl	8013c0a <sp_3072_mont_reduce_96>
}
 8013d4e:	bf00      	nop
 8013d50:	3710      	adds	r7, #16
 8013d52:	46bd      	mov	sp, r7
 8013d54:	bd80      	pop	{r7, pc}

08013d56 <div_3072_word_96>:
 *
 * Note that this is an approximate div. It may give an answer 1 larger.
 */
SP_NOINLINE static sp_digit div_3072_word_96(sp_digit d1, sp_digit d0,
        sp_digit div)
{
 8013d56:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 8013d5a:	b087      	sub	sp, #28
 8013d5c:	af00      	add	r7, sp, #0
 8013d5e:	60f8      	str	r0, [r7, #12]
 8013d60:	60b9      	str	r1, [r7, #8]
 8013d62:	607a      	str	r2, [r7, #4]
    sp_digit r = 0;
 8013d64:	2300      	movs	r3, #0
 8013d66:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 8013d68:	68fa      	ldr	r2, [r7, #12]
 8013d6a:	68b9      	ldr	r1, [r7, #8]
 8013d6c:	6878      	ldr	r0, [r7, #4]
 8013d6e:	697b      	ldr	r3, [r7, #20]
 8013d70:	ea4f 4610 	mov.w	r6, r0, lsr #16
 8013d74:	f106 0601 	add.w	r6, r6, #1
 8013d78:	fbb2 f4f6 	udiv	r4, r2, r6
 8013d7c:	ea4f 4804 	mov.w	r8, r4, lsl #16
 8013d80:	fba0 4508 	umull	r4, r5, r0, r8
 8013d84:	1b09      	subs	r1, r1, r4
 8013d86:	eb62 0205 	sbc.w	r2, r2, r5
 8013d8a:	fbb2 f5f6 	udiv	r5, r2, r6
 8013d8e:	ea4f 4405 	mov.w	r4, r5, lsl #16
 8013d92:	44a0      	add	r8, r4
 8013d94:	fba0 4504 	umull	r4, r5, r0, r4
 8013d98:	1b09      	subs	r1, r1, r4
 8013d9a:	eb62 0205 	sbc.w	r2, r2, r5
 8013d9e:	ea4f 4402 	mov.w	r4, r2, lsl #16
 8013da2:	ea44 4411 	orr.w	r4, r4, r1, lsr #16
 8013da6:	fbb4 f4f6 	udiv	r4, r4, r6
 8013daa:	44a0      	add	r8, r4
 8013dac:	fba0 4504 	umull	r4, r5, r0, r4
 8013db0:	1b09      	subs	r1, r1, r4
 8013db2:	eb62 0205 	sbc.w	r2, r2, r5
 8013db6:	ea4f 4402 	mov.w	r4, r2, lsl #16
 8013dba:	ea44 4411 	orr.w	r4, r4, r1, lsr #16
 8013dbe:	fbb4 f4f6 	udiv	r4, r4, r6
 8013dc2:	44a0      	add	r8, r4
 8013dc4:	fba0 4504 	umull	r4, r5, r0, r4
 8013dc8:	1b09      	subs	r1, r1, r4
 8013dca:	eb62 0205 	sbc.w	r2, r2, r5
 8013dce:	fbb1 f4f0 	udiv	r4, r1, r0
 8013dd2:	44a0      	add	r8, r4
 8013dd4:	4643      	mov	r3, r8
 8013dd6:	617b      	str	r3, [r7, #20]
        "mov	%[r], r8\n\t"
        : [r] "+r" (r)
        : [d1] "r" (d1), [d0] "r" (d0), [div] "r" (div)
        : "r4", "r5", "r6", "r8"
    );
    return r;
 8013dd8:	697b      	ldr	r3, [r7, #20]
}
 8013dda:	4618      	mov	r0, r3
 8013ddc:	371c      	adds	r7, #28
 8013dde:	46bd      	mov	sp, r7
 8013de0:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8013de4:	4770      	bx	lr

08013de6 <sp_3072_cmp_96>:
 * b  A single precision integer.
 * return -ve, 0 or +ve if a is less than, equal to or greater than b
 * respectively.
 */
SP_NOINLINE static int32_t sp_3072_cmp_96(const sp_digit* a, const sp_digit* b)
{
 8013de6:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 8013dea:	b085      	sub	sp, #20
 8013dec:	af00      	add	r7, sp, #0
 8013dee:	6078      	str	r0, [r7, #4]
 8013df0:	6039      	str	r1, [r7, #0]
    sp_digit r = 0;
 8013df2:	2300      	movs	r3, #0
 8013df4:	60fb      	str	r3, [r7, #12]


    __asm__ __volatile__ (
 8013df6:	6879      	ldr	r1, [r7, #4]
 8013df8:	6838      	ldr	r0, [r7, #0]
 8013dfa:	68fb      	ldr	r3, [r7, #12]
 8013dfc:	461a      	mov	r2, r3
 8013dfe:	f04f 0300 	mov.w	r3, #0
 8013e02:	ea6f 0303 	mvn.w	r3, r3
 8013e06:	f04f 0601 	mov.w	r6, #1
 8013e0a:	ea4f 2606 	mov.w	r6, r6, lsl #8
 8013e0e:	f106 067c 	add.w	r6, r6, #124	; 0x7c
 8013e12:	f851 8006 	ldr.w	r8, [r1, r6]
 8013e16:	5985      	ldr	r5, [r0, r6]
 8013e18:	ea08 0803 	and.w	r8, r8, r3
 8013e1c:	ea05 0503 	and.w	r5, r5, r3
 8013e20:	4644      	mov	r4, r8
 8013e22:	ebb8 0805 	subs.w	r8, r8, r5
 8013e26:	eb68 0808 	sbc.w	r8, r8, r8
 8013e2a:	4442      	add	r2, r8
 8013e2c:	ea6f 0808 	mvn.w	r8, r8
 8013e30:	ea03 0308 	and.w	r3, r3, r8
 8013e34:	1b2d      	subs	r5, r5, r4
 8013e36:	eb68 0808 	sbc.w	r8, r8, r8
 8013e3a:	eba2 0208 	sub.w	r2, r2, r8
 8013e3e:	ea6f 0808 	mvn.w	r8, r8
 8013e42:	ea03 0308 	and.w	r3, r3, r8
 8013e46:	f1a6 0604 	sub.w	r6, r6, #4
 8013e4a:	2e00      	cmp	r6, #0
 8013e4c:	dae1      	bge.n	8013e12 <sp_3072_cmp_96+0x2c>
 8013e4e:	60fa      	str	r2, [r7, #12]
        : [r] "+r" (r)
        : [a] "r" (a), [b] "r" (b)
        : "r3", "r4", "r5", "r6", "r8"
    );

    return r;
 8013e50:	68fb      	ldr	r3, [r7, #12]
}
 8013e52:	4618      	mov	r0, r3
 8013e54:	3714      	adds	r7, #20
 8013e56:	46bd      	mov	sp, r7
 8013e58:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8013e5c:	4770      	bx	lr

08013e5e <sp_3072_div_96_cond>:
 * r  Remainder from the division.
 * returns MP_OKAY indicating success.
 */
static WC_INLINE int sp_3072_div_96_cond(const sp_digit* a, const sp_digit* d, sp_digit* m,
        sp_digit* r)
{
 8013e5e:	b590      	push	{r4, r7, lr}
 8013e60:	f2ad 4dac 	subw	sp, sp, #1196	; 0x4ac
 8013e64:	af00      	add	r7, sp, #0
 8013e66:	f107 040c 	add.w	r4, r7, #12
 8013e6a:	6020      	str	r0, [r4, #0]
 8013e6c:	f107 0008 	add.w	r0, r7, #8
 8013e70:	6001      	str	r1, [r0, #0]
 8013e72:	1d39      	adds	r1, r7, #4
 8013e74:	600a      	str	r2, [r1, #0]
 8013e76:	463a      	mov	r2, r7
 8013e78:	6013      	str	r3, [r2, #0]
    sp_digit div, r1;
    int i;

    (void)m;

    div = d[95];
 8013e7a:	f107 0308 	add.w	r3, r7, #8
 8013e7e:	681b      	ldr	r3, [r3, #0]
 8013e80:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
 8013e84:	f8c7 34a0 	str.w	r3, [r7, #1184]	; 0x4a0
    XMEMCPY(t1, a, sizeof(*t1) * 2 * 96);
 8013e88:	f107 030c 	add.w	r3, r7, #12
 8013e8c:	f507 70cc 	add.w	r0, r7, #408	; 0x198
 8013e90:	f44f 7240 	mov.w	r2, #768	; 0x300
 8013e94:	6819      	ldr	r1, [r3, #0]
 8013e96:	f005 faae 	bl	80193f6 <memcpy>
    for (i=95; i>=0; i--) {
 8013e9a:	235f      	movs	r3, #95	; 0x5f
 8013e9c:	f8c7 34a4 	str.w	r3, [r7, #1188]	; 0x4a4
 8013ea0:	e0c1      	b.n	8014026 <sp_3072_div_96_cond+0x1c8>
        sp_digit hi = t1[96 + i] - (t1[96 + i] == div);
 8013ea2:	f8d7 34a4 	ldr.w	r3, [r7, #1188]	; 0x4a4
 8013ea6:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8013eaa:	f507 73cc 	add.w	r3, r7, #408	; 0x198
 8013eae:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8013eb2:	f8d7 24a4 	ldr.w	r2, [r7, #1188]	; 0x4a4
 8013eb6:	f102 0160 	add.w	r1, r2, #96	; 0x60
 8013eba:	f507 72cc 	add.w	r2, r7, #408	; 0x198
 8013ebe:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8013ec2:	f8d7 14a0 	ldr.w	r1, [r7, #1184]	; 0x4a0
 8013ec6:	4291      	cmp	r1, r2
 8013ec8:	bf0c      	ite	eq
 8013eca:	2201      	moveq	r2, #1
 8013ecc:	2200      	movne	r2, #0
 8013ece:	b2d2      	uxtb	r2, r2
 8013ed0:	1a9b      	subs	r3, r3, r2
 8013ed2:	f8c7 3498 	str.w	r3, [r7, #1176]	; 0x498
        r1 = div_3072_word_96(hi, t1[96 + i - 1], div);
 8013ed6:	f8d7 34a4 	ldr.w	r3, [r7, #1188]	; 0x4a4
 8013eda:	f103 025f 	add.w	r2, r3, #95	; 0x5f
 8013ede:	f507 73cc 	add.w	r3, r7, #408	; 0x198
 8013ee2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8013ee6:	f8d7 24a0 	ldr.w	r2, [r7, #1184]	; 0x4a0
 8013eea:	4619      	mov	r1, r3
 8013eec:	f8d7 0498 	ldr.w	r0, [r7, #1176]	; 0x498
 8013ef0:	f7ff ff31 	bl	8013d56 <div_3072_word_96>
 8013ef4:	f8c7 049c 	str.w	r0, [r7, #1180]	; 0x49c

        sp_3072_mul_d_96(t2, d, r1);
 8013ef8:	f107 0308 	add.w	r3, r7, #8
 8013efc:	f107 0014 	add.w	r0, r7, #20
 8013f00:	f8d7 249c 	ldr.w	r2, [r7, #1180]	; 0x49c
 8013f04:	6819      	ldr	r1, [r3, #0]
 8013f06:	f7ff f979 	bl	80131fc <sp_3072_mul_d_96>
        t1[96 + i] += sp_3072_sub_in_place_96(&t1[i], t2);
 8013f0a:	f507 72cc 	add.w	r2, r7, #408	; 0x198
 8013f0e:	f8d7 34a4 	ldr.w	r3, [r7, #1188]	; 0x4a4
 8013f12:	009b      	lsls	r3, r3, #2
 8013f14:	4413      	add	r3, r2
 8013f16:	f107 0214 	add.w	r2, r7, #20
 8013f1a:	4611      	mov	r1, r2
 8013f1c:	4618      	mov	r0, r3
 8013f1e:	f7fe fe96 	bl	8012c4e <sp_3072_sub_in_place_96>
 8013f22:	4601      	mov	r1, r0
 8013f24:	f8d7 34a4 	ldr.w	r3, [r7, #1188]	; 0x4a4
 8013f28:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8013f2c:	f507 73cc 	add.w	r3, r7, #408	; 0x198
 8013f30:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8013f34:	f8d7 24a4 	ldr.w	r2, [r7, #1188]	; 0x4a4
 8013f38:	3260      	adds	r2, #96	; 0x60
 8013f3a:	4419      	add	r1, r3
 8013f3c:	f507 73cc 	add.w	r3, r7, #408	; 0x198
 8013f40:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        t1[96 + i] -= t2[96];
 8013f44:	f8d7 34a4 	ldr.w	r3, [r7, #1188]	; 0x4a4
 8013f48:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8013f4c:	f507 73cc 	add.w	r3, r7, #408	; 0x198
 8013f50:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8013f54:	f107 0314 	add.w	r3, r7, #20
 8013f58:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 8013f5c:	f8d7 24a4 	ldr.w	r2, [r7, #1188]	; 0x4a4
 8013f60:	3260      	adds	r2, #96	; 0x60
 8013f62:	1ac9      	subs	r1, r1, r3
 8013f64:	f507 73cc 	add.w	r3, r7, #408	; 0x198
 8013f68:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        if (t1[96 + i] != 0) {
 8013f6c:	f8d7 34a4 	ldr.w	r3, [r7, #1188]	; 0x4a4
 8013f70:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8013f74:	f507 73cc 	add.w	r3, r7, #408	; 0x198
 8013f78:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8013f7c:	2b00      	cmp	r3, #0
 8013f7e:	d04d      	beq.n	801401c <sp_3072_div_96_cond+0x1be>
            t1[96 + i] += sp_3072_add_96(&t1[i], &t1[i], d);
 8013f80:	f507 72cc 	add.w	r2, r7, #408	; 0x198
 8013f84:	f8d7 34a4 	ldr.w	r3, [r7, #1188]	; 0x4a4
 8013f88:	009b      	lsls	r3, r3, #2
 8013f8a:	18d0      	adds	r0, r2, r3
 8013f8c:	f507 72cc 	add.w	r2, r7, #408	; 0x198
 8013f90:	f8d7 34a4 	ldr.w	r3, [r7, #1188]	; 0x4a4
 8013f94:	009b      	lsls	r3, r3, #2
 8013f96:	18d1      	adds	r1, r2, r3
 8013f98:	f107 0308 	add.w	r3, r7, #8
 8013f9c:	681a      	ldr	r2, [r3, #0]
 8013f9e:	f7fe fe25 	bl	8012bec <sp_3072_add_96>
 8013fa2:	4601      	mov	r1, r0
 8013fa4:	f8d7 34a4 	ldr.w	r3, [r7, #1188]	; 0x4a4
 8013fa8:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8013fac:	f507 73cc 	add.w	r3, r7, #408	; 0x198
 8013fb0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8013fb4:	f8d7 24a4 	ldr.w	r2, [r7, #1188]	; 0x4a4
 8013fb8:	3260      	adds	r2, #96	; 0x60
 8013fba:	4419      	add	r1, r3
 8013fbc:	f507 73cc 	add.w	r3, r7, #408	; 0x198
 8013fc0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            if (t1[96 + i] != 0)
 8013fc4:	f8d7 34a4 	ldr.w	r3, [r7, #1188]	; 0x4a4
 8013fc8:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8013fcc:	f507 73cc 	add.w	r3, r7, #408	; 0x198
 8013fd0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8013fd4:	2b00      	cmp	r3, #0
 8013fd6:	d021      	beq.n	801401c <sp_3072_div_96_cond+0x1be>
                t1[96 + i] += sp_3072_add_96(&t1[i], &t1[i], d);
 8013fd8:	f507 72cc 	add.w	r2, r7, #408	; 0x198
 8013fdc:	f8d7 34a4 	ldr.w	r3, [r7, #1188]	; 0x4a4
 8013fe0:	009b      	lsls	r3, r3, #2
 8013fe2:	18d0      	adds	r0, r2, r3
 8013fe4:	f507 72cc 	add.w	r2, r7, #408	; 0x198
 8013fe8:	f8d7 34a4 	ldr.w	r3, [r7, #1188]	; 0x4a4
 8013fec:	009b      	lsls	r3, r3, #2
 8013fee:	18d1      	adds	r1, r2, r3
 8013ff0:	f107 0308 	add.w	r3, r7, #8
 8013ff4:	681a      	ldr	r2, [r3, #0]
 8013ff6:	f7fe fdf9 	bl	8012bec <sp_3072_add_96>
 8013ffa:	4601      	mov	r1, r0
 8013ffc:	f8d7 34a4 	ldr.w	r3, [r7, #1188]	; 0x4a4
 8014000:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8014004:	f507 73cc 	add.w	r3, r7, #408	; 0x198
 8014008:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801400c:	f8d7 24a4 	ldr.w	r2, [r7, #1188]	; 0x4a4
 8014010:	3260      	adds	r2, #96	; 0x60
 8014012:	4419      	add	r1, r3
 8014014:	f507 73cc 	add.w	r3, r7, #408	; 0x198
 8014018:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (i=95; i>=0; i--) {
 801401c:	f8d7 34a4 	ldr.w	r3, [r7, #1188]	; 0x4a4
 8014020:	3b01      	subs	r3, #1
 8014022:	f8c7 34a4 	str.w	r3, [r7, #1188]	; 0x4a4
 8014026:	f8d7 34a4 	ldr.w	r3, [r7, #1188]	; 0x4a4
 801402a:	2b00      	cmp	r3, #0
 801402c:	f6bf af39 	bge.w	8013ea2 <sp_3072_div_96_cond+0x44>
        }
    }

    r1 = sp_3072_cmp_96(t1, d) >= 0;
 8014030:	f107 0308 	add.w	r3, r7, #8
 8014034:	f507 72cc 	add.w	r2, r7, #408	; 0x198
 8014038:	6819      	ldr	r1, [r3, #0]
 801403a:	4610      	mov	r0, r2
 801403c:	f7ff fed3 	bl	8013de6 <sp_3072_cmp_96>
 8014040:	4603      	mov	r3, r0
 8014042:	43db      	mvns	r3, r3
 8014044:	0fdb      	lsrs	r3, r3, #31
 8014046:	b2db      	uxtb	r3, r3
 8014048:	f8c7 349c 	str.w	r3, [r7, #1180]	; 0x49c
    sp_3072_cond_sub_96(r, t1, d, (sp_digit)0 - r1);
 801404c:	f8d7 349c 	ldr.w	r3, [r7, #1180]	; 0x49c
 8014050:	425b      	negs	r3, r3
 8014052:	f107 0208 	add.w	r2, r7, #8
 8014056:	f507 71cc 	add.w	r1, r7, #408	; 0x198
 801405a:	4638      	mov	r0, r7
 801405c:	6812      	ldr	r2, [r2, #0]
 801405e:	6800      	ldr	r0, [r0, #0]
 8014060:	f7ff fda2 	bl	8013ba8 <sp_3072_cond_sub_96>

    return MP_OKAY;
 8014064:	2300      	movs	r3, #0
}
 8014066:	4618      	mov	r0, r3
 8014068:	f207 47ac 	addw	r7, r7, #1196	; 0x4ac
 801406c:	46bd      	mov	sp, r7
 801406e:	bd90      	pop	{r4, r7, pc}

08014070 <sp_3072_mod_96_cond>:
 * a  A single precision number that is to be reduced.
 * m  A single precision number that is the modulus to reduce with.
 * returns MP_OKAY indicating success.
 */
static WC_INLINE int sp_3072_mod_96_cond(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
 8014070:	b580      	push	{r7, lr}
 8014072:	b084      	sub	sp, #16
 8014074:	af00      	add	r7, sp, #0
 8014076:	60f8      	str	r0, [r7, #12]
 8014078:	60b9      	str	r1, [r7, #8]
 801407a:	607a      	str	r2, [r7, #4]
    return sp_3072_div_96_cond(a, m, NULL, r);
 801407c:	68fb      	ldr	r3, [r7, #12]
 801407e:	2200      	movs	r2, #0
 8014080:	6879      	ldr	r1, [r7, #4]
 8014082:	68b8      	ldr	r0, [r7, #8]
 8014084:	f7ff feeb 	bl	8013e5e <sp_3072_div_96_cond>
 8014088:	4603      	mov	r3, r0
}
 801408a:	4618      	mov	r0, r3
 801408c:	3710      	adds	r7, #16
 801408e:	46bd      	mov	sp, r7
 8014090:	bd80      	pop	{r7, pc}

08014092 <sp_RsaPublic_3072>:
 * returns 0 on success, MP_TO_E when the outLen is too small, MP_READ_E when
 * an array is too long and MEMORY_E when dynamic memory allocation fails.
 */
int sp_RsaPublic_3072(const byte* in, word32 inLen, mp_int* em, mp_int* mm,
    byte* out, word32* outLen)
{
 8014092:	b580      	push	{r7, lr}
 8014094:	b090      	sub	sp, #64	; 0x40
 8014096:	af02      	add	r7, sp, #8
 8014098:	60f8      	str	r0, [r7, #12]
 801409a:	60b9      	str	r1, [r7, #8]
 801409c:	607a      	str	r2, [r7, #4]
 801409e:	603b      	str	r3, [r7, #0]
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit a[192], m[96], r[192];
#else
    sp_digit* d = NULL;
 80140a0:	2300      	movs	r3, #0
 80140a2:	637b      	str	r3, [r7, #52]	; 0x34
    sp_digit* a = NULL;
 80140a4:	2300      	movs	r3, #0
 80140a6:	633b      	str	r3, [r7, #48]	; 0x30
    sp_digit* m = NULL;
 80140a8:	2300      	movs	r3, #0
 80140aa:	62fb      	str	r3, [r7, #44]	; 0x2c
    sp_digit* r = NULL;
 80140ac:	2300      	movs	r3, #0
 80140ae:	62bb      	str	r3, [r7, #40]	; 0x28
#endif
    sp_digit *ah = NULL;
 80140b0:	2300      	movs	r3, #0
 80140b2:	627b      	str	r3, [r7, #36]	; 0x24
    sp_digit e[1];
    int err = MP_OKAY;
 80140b4:	2300      	movs	r3, #0
 80140b6:	623b      	str	r3, [r7, #32]

    if (*outLen < 384) {
 80140b8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80140ba:	681b      	ldr	r3, [r3, #0]
 80140bc:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
 80140c0:	d203      	bcs.n	80140ca <sp_RsaPublic_3072+0x38>
        err = MP_TO_E;
 80140c2:	f06f 0370 	mvn.w	r3, #112	; 0x70
 80140c6:	623b      	str	r3, [r7, #32]
 80140c8:	e021      	b.n	801410e <sp_RsaPublic_3072+0x7c>
    }
    else if (mp_count_bits(em) > 32 || inLen > 384 ||
 80140ca:	6878      	ldr	r0, [r7, #4]
 80140cc:	f004 fd82 	bl	8018bd4 <sp_count_bits>
 80140d0:	4603      	mov	r3, r0
 80140d2:	2b20      	cmp	r3, #32
 80140d4:	dc0a      	bgt.n	80140ec <sp_RsaPublic_3072+0x5a>
 80140d6:	68bb      	ldr	r3, [r7, #8]
 80140d8:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
 80140dc:	d806      	bhi.n	80140ec <sp_RsaPublic_3072+0x5a>
                                                     mp_count_bits(mm) != 3072) {
 80140de:	6838      	ldr	r0, [r7, #0]
 80140e0:	f004 fd78 	bl	8018bd4 <sp_count_bits>
 80140e4:	4603      	mov	r3, r0
    else if (mp_count_bits(em) > 32 || inLen > 384 ||
 80140e6:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 80140ea:	d003      	beq.n	80140f4 <sp_RsaPublic_3072+0x62>
        err = MP_READ_E;
 80140ec:	f06f 036e 	mvn.w	r3, #110	; 0x6e
 80140f0:	623b      	str	r3, [r7, #32]
 80140f2:	e00c      	b.n	801410e <sp_RsaPublic_3072+0x7c>
    }
    else if (mp_iseven(mm)) {
 80140f4:	683b      	ldr	r3, [r7, #0]
 80140f6:	681b      	ldr	r3, [r3, #0]
 80140f8:	2b00      	cmp	r3, #0
 80140fa:	d008      	beq.n	801410e <sp_RsaPublic_3072+0x7c>
 80140fc:	683b      	ldr	r3, [r7, #0]
 80140fe:	689b      	ldr	r3, [r3, #8]
 8014100:	f003 0301 	and.w	r3, r3, #1
 8014104:	2b00      	cmp	r3, #0
 8014106:	d102      	bne.n	801410e <sp_RsaPublic_3072+0x7c>
        err = MP_VAL;
 8014108:	f06f 0302 	mvn.w	r3, #2
 801410c:	623b      	str	r3, [r7, #32]
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
 801410e:	6a3b      	ldr	r3, [r7, #32]
 8014110:	2b00      	cmp	r3, #0
 8014112:	d10a      	bne.n	801412a <sp_RsaPublic_3072+0x98>
        d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 96 * 5, NULL,
 8014114:	f44f 60f0 	mov.w	r0, #1920	; 0x780
 8014118:	f7fa feee 	bl	800eef8 <wolfSSL_Malloc>
 801411c:	6378      	str	r0, [r7, #52]	; 0x34
                                                              DYNAMIC_TYPE_RSA);
        if (d == NULL)
 801411e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014120:	2b00      	cmp	r3, #0
 8014122:	d102      	bne.n	801412a <sp_RsaPublic_3072+0x98>
            err = MEMORY_E;
 8014124:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 8014128:	623b      	str	r3, [r7, #32]
    }

    if (err == MP_OKAY) {
 801412a:	6a3b      	ldr	r3, [r7, #32]
 801412c:	2b00      	cmp	r3, #0
 801412e:	d109      	bne.n	8014144 <sp_RsaPublic_3072+0xb2>
        a = d;
 8014130:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014132:	633b      	str	r3, [r7, #48]	; 0x30
        r = a + 96 * 2;
 8014134:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014136:	f503 7340 	add.w	r3, r3, #768	; 0x300
 801413a:	62bb      	str	r3, [r7, #40]	; 0x28
        m = r + 96 * 2;
 801413c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801413e:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8014142:	62fb      	str	r3, [r7, #44]	; 0x2c
    }
#endif

    if (err == MP_OKAY) {
 8014144:	6a3b      	ldr	r3, [r7, #32]
 8014146:	2b00      	cmp	r3, #0
 8014148:	d112      	bne.n	8014170 <sp_RsaPublic_3072+0xde>
        ah = a + 96;
 801414a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801414c:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 8014150:	627b      	str	r3, [r7, #36]	; 0x24

        sp_3072_from_bin(ah, 96, in, inLen);
 8014152:	68bb      	ldr	r3, [r7, #8]
 8014154:	68fa      	ldr	r2, [r7, #12]
 8014156:	2160      	movs	r1, #96	; 0x60
 8014158:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801415a:	f7fe fc3f 	bl	80129dc <sp_3072_from_bin>
#if DIGIT_BIT >= 32
        e[0] = em->dp[0];
 801415e:	687b      	ldr	r3, [r7, #4]
 8014160:	689b      	ldr	r3, [r3, #8]
 8014162:	617b      	str	r3, [r7, #20]
        e[0] = em->dp[0];
        if (em->used > 1) {
            e[0] |= ((sp_digit)em->dp[1]) << DIGIT_BIT;
        }
#endif
        if (e[0] == 0) {
 8014164:	697b      	ldr	r3, [r7, #20]
 8014166:	2b00      	cmp	r3, #0
 8014168:	d102      	bne.n	8014170 <sp_RsaPublic_3072+0xde>
            err = MP_EXPTMOD_E;
 801416a:	f06f 036f 	mvn.w	r3, #111	; 0x6f
 801416e:	623b      	str	r3, [r7, #32]
        }
    }
    if (err == MP_OKAY) {
 8014170:	6a3b      	ldr	r3, [r7, #32]
 8014172:	2b00      	cmp	r3, #0
 8014174:	f040 80a7 	bne.w	80142c6 <sp_RsaPublic_3072+0x234>
        sp_3072_from_mp(m, 96, mm);
 8014178:	683a      	ldr	r2, [r7, #0]
 801417a:	2160      	movs	r1, #96	; 0x60
 801417c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801417e:	f7fe fc9e 	bl	8012abe <sp_3072_from_mp>

        if (e[0] == 0x3) {
 8014182:	697b      	ldr	r3, [r7, #20]
 8014184:	2b03      	cmp	r3, #3
 8014186:	d11c      	bne.n	80141c2 <sp_RsaPublic_3072+0x130>
            if (err == MP_OKAY) {
 8014188:	6a3b      	ldr	r3, [r7, #32]
 801418a:	2b00      	cmp	r3, #0
 801418c:	d109      	bne.n	80141a2 <sp_RsaPublic_3072+0x110>
                sp_3072_sqr_96(r, ah);
 801418e:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8014190:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8014192:	f7fe fe01 	bl	8012d98 <sp_3072_sqr_96>
                err = sp_3072_mod_96_cond(r, r, m);
 8014196:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8014198:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801419a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801419c:	f7ff ff68 	bl	8014070 <sp_3072_mod_96_cond>
 80141a0:	6238      	str	r0, [r7, #32]
            }
            if (err == MP_OKAY) {
 80141a2:	6a3b      	ldr	r3, [r7, #32]
 80141a4:	2b00      	cmp	r3, #0
 80141a6:	f040 808e 	bne.w	80142c6 <sp_RsaPublic_3072+0x234>
                sp_3072_mul_96(r, ah, r);
 80141aa:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80141ac:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80141ae:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80141b0:	f7fe fd7b 	bl	8012caa <sp_3072_mul_96>
                err = sp_3072_mod_96_cond(r, r, m);
 80141b4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80141b6:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80141b8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80141ba:	f7ff ff59 	bl	8014070 <sp_3072_mod_96_cond>
 80141be:	6238      	str	r0, [r7, #32]
 80141c0:	e081      	b.n	80142c6 <sp_RsaPublic_3072+0x234>
        }
        else {
            int i;
            sp_digit mp;

            sp_3072_mont_setup(m, &mp);
 80141c2:	f107 0310 	add.w	r3, r7, #16
 80141c6:	4619      	mov	r1, r3
 80141c8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80141ca:	f7fe ffdf 	bl	801318c <sp_3072_mont_setup>

            /* Convert to Montgomery form. */
            XMEMSET(a, 0, sizeof(sp_digit) * 96);
 80141ce:	f44f 72c0 	mov.w	r2, #384	; 0x180
 80141d2:	2100      	movs	r1, #0
 80141d4:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80141d6:	f005 f932 	bl	801943e <memset>
            err = sp_3072_mod_96_cond(a, a, m);
 80141da:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80141dc:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80141de:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80141e0:	f7ff ff46 	bl	8014070 <sp_3072_mod_96_cond>
 80141e4:	6238      	str	r0, [r7, #32]

            if (err == MP_OKAY) {
 80141e6:	6a3b      	ldr	r3, [r7, #32]
 80141e8:	2b00      	cmp	r3, #0
 80141ea:	d16c      	bne.n	80142c6 <sp_RsaPublic_3072+0x234>
                for (i = 31; i >= 0; i--) {
 80141ec:	231f      	movs	r3, #31
 80141ee:	61fb      	str	r3, [r7, #28]
 80141f0:	e008      	b.n	8014204 <sp_RsaPublic_3072+0x172>
                    if (e[0] >> i) {
 80141f2:	697a      	ldr	r2, [r7, #20]
 80141f4:	69fb      	ldr	r3, [r7, #28]
 80141f6:	fa22 f303 	lsr.w	r3, r2, r3
 80141fa:	2b00      	cmp	r3, #0
 80141fc:	d106      	bne.n	801420c <sp_RsaPublic_3072+0x17a>
                for (i = 31; i >= 0; i--) {
 80141fe:	69fb      	ldr	r3, [r7, #28]
 8014200:	3b01      	subs	r3, #1
 8014202:	61fb      	str	r3, [r7, #28]
 8014204:	69fb      	ldr	r3, [r7, #28]
 8014206:	2b00      	cmp	r3, #0
 8014208:	daf3      	bge.n	80141f2 <sp_RsaPublic_3072+0x160>
 801420a:	e000      	b.n	801420e <sp_RsaPublic_3072+0x17c>
                        break;
 801420c:	bf00      	nop
                    }
                }

                XMEMCPY(r, a, sizeof(sp_digit) * 96);
 801420e:	f44f 72c0 	mov.w	r2, #384	; 0x180
 8014212:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8014214:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8014216:	f005 f8ee 	bl	80193f6 <memcpy>
                for (i--; i>=0; i--) {
 801421a:	69fb      	ldr	r3, [r7, #28]
 801421c:	3b01      	subs	r3, #1
 801421e:	61fb      	str	r3, [r7, #28]
 8014220:	e018      	b.n	8014254 <sp_RsaPublic_3072+0x1c2>
                    sp_3072_mont_sqr_96(r, r, m, mp);
 8014222:	693b      	ldr	r3, [r7, #16]
 8014224:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8014226:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8014228:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801422a:	f7ff fd80 	bl	8013d2e <sp_3072_mont_sqr_96>
                    if (((e[0] >> i) & 1) == 1) {
 801422e:	697a      	ldr	r2, [r7, #20]
 8014230:	69fb      	ldr	r3, [r7, #28]
 8014232:	fa22 f303 	lsr.w	r3, r2, r3
 8014236:	f003 0301 	and.w	r3, r3, #1
 801423a:	2b00      	cmp	r3, #0
 801423c:	d007      	beq.n	801424e <sp_RsaPublic_3072+0x1bc>
                        sp_3072_mont_mul_96(r, r, a, m, mp);
 801423e:	693b      	ldr	r3, [r7, #16]
 8014240:	9300      	str	r3, [sp, #0]
 8014242:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014244:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8014246:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8014248:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801424a:	f7ff fd5b 	bl	8013d04 <sp_3072_mont_mul_96>
                for (i--; i>=0; i--) {
 801424e:	69fb      	ldr	r3, [r7, #28]
 8014250:	3b01      	subs	r3, #1
 8014252:	61fb      	str	r3, [r7, #28]
 8014254:	69fb      	ldr	r3, [r7, #28]
 8014256:	2b00      	cmp	r3, #0
 8014258:	dae3      	bge.n	8014222 <sp_RsaPublic_3072+0x190>
                    }
                }
                XMEMSET(&r[96], 0, sizeof(sp_digit) * 96);
 801425a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801425c:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 8014260:	f44f 72c0 	mov.w	r2, #384	; 0x180
 8014264:	2100      	movs	r1, #0
 8014266:	4618      	mov	r0, r3
 8014268:	f005 f8e9 	bl	801943e <memset>
                sp_3072_mont_reduce_96(r, m, mp);
 801426c:	693b      	ldr	r3, [r7, #16]
 801426e:	461a      	mov	r2, r3
 8014270:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8014272:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8014274:	f7ff fcc9 	bl	8013c0a <sp_3072_mont_reduce_96>

                for (i = 95; i > 0; i--) {
 8014278:	235f      	movs	r3, #95	; 0x5f
 801427a:	61fb      	str	r3, [r7, #28]
 801427c:	e00e      	b.n	801429c <sp_RsaPublic_3072+0x20a>
                    if (r[i] != m[i]) {
 801427e:	69fb      	ldr	r3, [r7, #28]
 8014280:	009b      	lsls	r3, r3, #2
 8014282:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014284:	4413      	add	r3, r2
 8014286:	681a      	ldr	r2, [r3, #0]
 8014288:	69fb      	ldr	r3, [r7, #28]
 801428a:	009b      	lsls	r3, r3, #2
 801428c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 801428e:	440b      	add	r3, r1
 8014290:	681b      	ldr	r3, [r3, #0]
 8014292:	429a      	cmp	r2, r3
 8014294:	d106      	bne.n	80142a4 <sp_RsaPublic_3072+0x212>
                for (i = 95; i > 0; i--) {
 8014296:	69fb      	ldr	r3, [r7, #28]
 8014298:	3b01      	subs	r3, #1
 801429a:	61fb      	str	r3, [r7, #28]
 801429c:	69fb      	ldr	r3, [r7, #28]
 801429e:	2b00      	cmp	r3, #0
 80142a0:	dced      	bgt.n	801427e <sp_RsaPublic_3072+0x1ec>
 80142a2:	e000      	b.n	80142a6 <sp_RsaPublic_3072+0x214>
                        break;
 80142a4:	bf00      	nop
                    }
                }
                if (r[i] >= m[i]) {
 80142a6:	69fb      	ldr	r3, [r7, #28]
 80142a8:	009b      	lsls	r3, r3, #2
 80142aa:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80142ac:	4413      	add	r3, r2
 80142ae:	681a      	ldr	r2, [r3, #0]
 80142b0:	69fb      	ldr	r3, [r7, #28]
 80142b2:	009b      	lsls	r3, r3, #2
 80142b4:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80142b6:	440b      	add	r3, r1
 80142b8:	681b      	ldr	r3, [r3, #0]
 80142ba:	429a      	cmp	r2, r3
 80142bc:	d303      	bcc.n	80142c6 <sp_RsaPublic_3072+0x234>
                    sp_3072_sub_in_place_96(r, m);
 80142be:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80142c0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80142c2:	f7fe fcc4 	bl	8012c4e <sp_3072_sub_in_place_96>
                }
            }
        }
    }

    if (err == MP_OKAY) {
 80142c6:	6a3b      	ldr	r3, [r7, #32]
 80142c8:	2b00      	cmp	r3, #0
 80142ca:	d107      	bne.n	80142dc <sp_RsaPublic_3072+0x24a>
        sp_3072_to_bin(r, out);
 80142cc:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80142ce:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80142d0:	f7fe fc1a 	bl	8012b08 <sp_3072_to_bin>
        *outLen = 384;
 80142d4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80142d6:	f44f 72c0 	mov.w	r2, #384	; 0x180
 80142da:	601a      	str	r2, [r3, #0]
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (d != NULL) {
 80142dc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80142de:	2b00      	cmp	r3, #0
 80142e0:	d007      	beq.n	80142f2 <sp_RsaPublic_3072+0x260>
        XFREE(d, NULL, DYNAMIC_TYPE_RSA);
 80142e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80142e4:	61bb      	str	r3, [r7, #24]
 80142e6:	69bb      	ldr	r3, [r7, #24]
 80142e8:	2b00      	cmp	r3, #0
 80142ea:	d002      	beq.n	80142f2 <sp_RsaPublic_3072+0x260>
 80142ec:	69b8      	ldr	r0, [r7, #24]
 80142ee:	f7fa fe1f 	bl	800ef30 <wolfSSL_Free>
    }
#endif

    return err;
 80142f2:	6a3b      	ldr	r3, [r7, #32]
}
 80142f4:	4618      	mov	r0, r3
 80142f6:	3738      	adds	r7, #56	; 0x38
 80142f8:	46bd      	mov	sp, r7
 80142fa:	bd80      	pop	{r7, pc}

080142fc <sp_3072_cond_add_48>:
 * b  A single precision number to add.
 * m  Mask value to apply.
 */
SP_NOINLINE static sp_digit sp_3072_cond_add_48(sp_digit* r, const sp_digit* a, const sp_digit* b,
        sp_digit m)
{
 80142fc:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 8014300:	b086      	sub	sp, #24
 8014302:	af00      	add	r7, sp, #0
 8014304:	60f8      	str	r0, [r7, #12]
 8014306:	60b9      	str	r1, [r7, #8]
 8014308:	607a      	str	r2, [r7, #4]
 801430a:	603b      	str	r3, [r7, #0]
    sp_digit c = 0;
 801430c:	2300      	movs	r3, #0
 801430e:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 8014310:	68fa      	ldr	r2, [r7, #12]
 8014312:	68b9      	ldr	r1, [r7, #8]
 8014314:	6878      	ldr	r0, [r7, #4]
 8014316:	683c      	ldr	r4, [r7, #0]
 8014318:	697b      	ldr	r3, [r7, #20]
 801431a:	f04f 05c0 	mov.w	r5, #192	; 0xc0
 801431e:	46a9      	mov	r9, r5
 8014320:	f04f 0800 	mov.w	r8, #0
 8014324:	f850 6008 	ldr.w	r6, [r0, r8]
 8014328:	ea06 0604 	and.w	r6, r6, r4
 801432c:	f113 35ff 	adds.w	r5, r3, #4294967295
 8014330:	f851 5008 	ldr.w	r5, [r1, r8]
 8014334:	4175      	adcs	r5, r6
 8014336:	f04f 0300 	mov.w	r3, #0
 801433a:	415b      	adcs	r3, r3
 801433c:	f842 5008 	str.w	r5, [r2, r8]
 8014340:	f108 0804 	add.w	r8, r8, #4
 8014344:	45c8      	cmp	r8, r9
 8014346:	dbed      	blt.n	8014324 <sp_3072_cond_add_48+0x28>
 8014348:	617b      	str	r3, [r7, #20]
        : [c] "+r" (c)
        : [r] "r" (r), [a] "r" (a), [b] "r" (b), [m] "r" (m)
        : "memory", "r5", "r6", "r8", "r9"
    );

    return c;
 801434a:	697b      	ldr	r3, [r7, #20]
}
 801434c:	4618      	mov	r0, r3
 801434e:	3718      	adds	r7, #24
 8014350:	46bd      	mov	sp, r7
 8014352:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8014356:	4770      	bx	lr

08014358 <sp_RsaPrivate_3072>:
 * an array is too long and MEMORY_E when dynamic memory allocation fails.
 */
int sp_RsaPrivate_3072(const byte* in, word32 inLen, mp_int* dm,
    mp_int* pm, mp_int* qm, mp_int* dpm, mp_int* dqm, mp_int* qim, mp_int* mm,
    byte* out, word32* outLen)
{
 8014358:	b580      	push	{r7, lr}
 801435a:	b094      	sub	sp, #80	; 0x50
 801435c:	af02      	add	r7, sp, #8
 801435e:	60f8      	str	r0, [r7, #12]
 8014360:	60b9      	str	r1, [r7, #8]
 8014362:	607a      	str	r2, [r7, #4]
 8014364:	603b      	str	r3, [r7, #0]
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit a[96 * 2];
    sp_digit p[48], q[48], dp[48];
    sp_digit tmpa[96], tmpb[96];
#else
    sp_digit* t = NULL;
 8014366:	2300      	movs	r3, #0
 8014368:	647b      	str	r3, [r7, #68]	; 0x44
    sp_digit* a = NULL;
 801436a:	2300      	movs	r3, #0
 801436c:	643b      	str	r3, [r7, #64]	; 0x40
    sp_digit* p = NULL;
 801436e:	2300      	movs	r3, #0
 8014370:	63fb      	str	r3, [r7, #60]	; 0x3c
    sp_digit* q = NULL;
 8014372:	2300      	movs	r3, #0
 8014374:	63bb      	str	r3, [r7, #56]	; 0x38
    sp_digit* dp = NULL;
 8014376:	2300      	movs	r3, #0
 8014378:	637b      	str	r3, [r7, #52]	; 0x34
    sp_digit* tmpa = NULL;
 801437a:	2300      	movs	r3, #0
 801437c:	633b      	str	r3, [r7, #48]	; 0x30
    sp_digit* tmpb = NULL;
 801437e:	2300      	movs	r3, #0
 8014380:	62fb      	str	r3, [r7, #44]	; 0x2c
#endif
    sp_digit* r = NULL;
 8014382:	2300      	movs	r3, #0
 8014384:	62bb      	str	r3, [r7, #40]	; 0x28
    sp_digit* qi = NULL;
 8014386:	2300      	movs	r3, #0
 8014388:	627b      	str	r3, [r7, #36]	; 0x24
    sp_digit* dq = NULL;
 801438a:	2300      	movs	r3, #0
 801438c:	623b      	str	r3, [r7, #32]
    sp_digit c;
    int err = MP_OKAY;
 801438e:	2300      	movs	r3, #0
 8014390:	61fb      	str	r3, [r7, #28]

    (void)dm;
    (void)mm;

    if (*outLen < 384) {
 8014392:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8014394:	681b      	ldr	r3, [r3, #0]
 8014396:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
 801439a:	d203      	bcs.n	80143a4 <sp_RsaPrivate_3072+0x4c>
        err = MP_TO_E;
 801439c:	f06f 0370 	mvn.w	r3, #112	; 0x70
 80143a0:	61fb      	str	r3, [r7, #28]
 80143a2:	e01b      	b.n	80143dc <sp_RsaPrivate_3072+0x84>
    }
    else if (inLen > 384 || mp_count_bits(mm) != 3072) {
 80143a4:	68bb      	ldr	r3, [r7, #8]
 80143a6:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
 80143aa:	d806      	bhi.n	80143ba <sp_RsaPrivate_3072+0x62>
 80143ac:	6e38      	ldr	r0, [r7, #96]	; 0x60
 80143ae:	f004 fc11 	bl	8018bd4 <sp_count_bits>
 80143b2:	4603      	mov	r3, r0
 80143b4:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 80143b8:	d003      	beq.n	80143c2 <sp_RsaPrivate_3072+0x6a>
        err = MP_READ_E;
 80143ba:	f06f 036e 	mvn.w	r3, #110	; 0x6e
 80143be:	61fb      	str	r3, [r7, #28]
 80143c0:	e00c      	b.n	80143dc <sp_RsaPrivate_3072+0x84>
    }
    else if (mp_iseven(mm)) {
 80143c2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80143c4:	681b      	ldr	r3, [r3, #0]
 80143c6:	2b00      	cmp	r3, #0
 80143c8:	d008      	beq.n	80143dc <sp_RsaPrivate_3072+0x84>
 80143ca:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80143cc:	689b      	ldr	r3, [r3, #8]
 80143ce:	f003 0301 	and.w	r3, r3, #1
 80143d2:	2b00      	cmp	r3, #0
 80143d4:	d102      	bne.n	80143dc <sp_RsaPrivate_3072+0x84>
        err = MP_VAL;
 80143d6:	f06f 0302 	mvn.w	r3, #2
 80143da:	61fb      	str	r3, [r7, #28]
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
 80143dc:	69fb      	ldr	r3, [r7, #28]
 80143de:	2b00      	cmp	r3, #0
 80143e0:	d10a      	bne.n	80143f8 <sp_RsaPrivate_3072+0xa0>
        t = (sp_digit*)XMALLOC(sizeof(sp_digit) * 48 * 11, NULL,
 80143e2:	f44f 6004 	mov.w	r0, #2112	; 0x840
 80143e6:	f7fa fd87 	bl	800eef8 <wolfSSL_Malloc>
 80143ea:	6478      	str	r0, [r7, #68]	; 0x44
                                                              DYNAMIC_TYPE_RSA);
        if (t == NULL)
 80143ec:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80143ee:	2b00      	cmp	r3, #0
 80143f0:	d102      	bne.n	80143f8 <sp_RsaPrivate_3072+0xa0>
            err = MEMORY_E;
 80143f2:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 80143f6:	61fb      	str	r3, [r7, #28]
    }
    if (err == MP_OKAY) {
 80143f8:	69fb      	ldr	r3, [r7, #28]
 80143fa:	2b00      	cmp	r3, #0
 80143fc:	d11a      	bne.n	8014434 <sp_RsaPrivate_3072+0xdc>
        a = t;
 80143fe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8014400:	643b      	str	r3, [r7, #64]	; 0x40
        p = a + 96 * 2;
 8014402:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014404:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8014408:	63fb      	str	r3, [r7, #60]	; 0x3c
        q = p + 48;
 801440a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801440c:	33c0      	adds	r3, #192	; 0xc0
 801440e:	63bb      	str	r3, [r7, #56]	; 0x38
        qi = dq = dp = q + 48;
 8014410:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8014412:	33c0      	adds	r3, #192	; 0xc0
 8014414:	637b      	str	r3, [r7, #52]	; 0x34
 8014416:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014418:	623b      	str	r3, [r7, #32]
 801441a:	6a3b      	ldr	r3, [r7, #32]
 801441c:	627b      	str	r3, [r7, #36]	; 0x24
        tmpa = qi + 48;
 801441e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014420:	33c0      	adds	r3, #192	; 0xc0
 8014422:	633b      	str	r3, [r7, #48]	; 0x30
        tmpb = tmpa + 96;
 8014424:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014426:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 801442a:	62fb      	str	r3, [r7, #44]	; 0x2c

        r = t + 96;
 801442c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801442e:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 8014432:	62bb      	str	r3, [r7, #40]	; 0x28
    }
#else
#endif

    if (err == MP_OKAY) {
 8014434:	69fb      	ldr	r3, [r7, #28]
 8014436:	2b00      	cmp	r3, #0
 8014438:	d120      	bne.n	801447c <sp_RsaPrivate_3072+0x124>
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
        r = a;
        qi = dq = dp;
#endif
        sp_3072_from_bin(a, 96, in, inLen);
 801443a:	68bb      	ldr	r3, [r7, #8]
 801443c:	68fa      	ldr	r2, [r7, #12]
 801443e:	2160      	movs	r1, #96	; 0x60
 8014440:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8014442:	f7fe facb 	bl	80129dc <sp_3072_from_bin>
        sp_3072_from_mp(p, 48, pm);
 8014446:	683a      	ldr	r2, [r7, #0]
 8014448:	2130      	movs	r1, #48	; 0x30
 801444a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801444c:	f7fe fb37 	bl	8012abe <sp_3072_from_mp>
        sp_3072_from_mp(q, 48, qm);
 8014450:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8014452:	2130      	movs	r1, #48	; 0x30
 8014454:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8014456:	f7fe fb32 	bl	8012abe <sp_3072_from_mp>
        sp_3072_from_mp(dp, 48, dpm);
 801445a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801445c:	2130      	movs	r1, #48	; 0x30
 801445e:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8014460:	f7fe fb2d 	bl	8012abe <sp_3072_from_mp>

        err = sp_3072_mod_exp_48(tmpa, a, dp, 1536, p, 1);
 8014464:	2301      	movs	r3, #1
 8014466:	9301      	str	r3, [sp, #4]
 8014468:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801446a:	9300      	str	r3, [sp, #0]
 801446c:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8014470:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8014472:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8014474:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8014476:	f7ff f9aa 	bl	80137ce <sp_3072_mod_exp_48>
 801447a:	61f8      	str	r0, [r7, #28]
    }
    if (err == MP_OKAY) {
 801447c:	69fb      	ldr	r3, [r7, #28]
 801447e:	2b00      	cmp	r3, #0
 8014480:	d110      	bne.n	80144a4 <sp_RsaPrivate_3072+0x14c>
        sp_3072_from_mp(dq, 48, dqm);
 8014482:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8014484:	2130      	movs	r1, #48	; 0x30
 8014486:	6a38      	ldr	r0, [r7, #32]
 8014488:	f7fe fb19 	bl	8012abe <sp_3072_from_mp>
        err = sp_3072_mod_exp_48(tmpb, a, dq, 1536, q, 1);
 801448c:	2301      	movs	r3, #1
 801448e:	9301      	str	r3, [sp, #4]
 8014490:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8014492:	9300      	str	r3, [sp, #0]
 8014494:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8014498:	6a3a      	ldr	r2, [r7, #32]
 801449a:	6c39      	ldr	r1, [r7, #64]	; 0x40
 801449c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801449e:	f7ff f996 	bl	80137ce <sp_3072_mod_exp_48>
 80144a2:	61f8      	str	r0, [r7, #28]
    }

    if (err == MP_OKAY) {
 80144a4:	69fb      	ldr	r3, [r7, #28]
 80144a6:	2b00      	cmp	r3, #0
 80144a8:	d124      	bne.n	80144f4 <sp_RsaPrivate_3072+0x19c>
        c = sp_3072_sub_in_place_48(tmpa, tmpb);
 80144aa:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80144ac:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80144ae:	f7fe fd4d 	bl	8012f4c <sp_3072_sub_in_place_48>
 80144b2:	61b8      	str	r0, [r7, #24]
        c += sp_3072_cond_add_48(tmpa, tmpa, p, c);
 80144b4:	69bb      	ldr	r3, [r7, #24]
 80144b6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80144b8:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80144ba:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80144bc:	f7ff ff1e 	bl	80142fc <sp_3072_cond_add_48>
 80144c0:	4602      	mov	r2, r0
 80144c2:	69bb      	ldr	r3, [r7, #24]
 80144c4:	4413      	add	r3, r2
 80144c6:	61bb      	str	r3, [r7, #24]
        sp_3072_cond_add_48(tmpa, tmpa, p, c);
 80144c8:	69bb      	ldr	r3, [r7, #24]
 80144ca:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80144cc:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80144ce:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80144d0:	f7ff ff14 	bl	80142fc <sp_3072_cond_add_48>

        sp_3072_from_mp(qi, 48, qim);
 80144d4:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 80144d6:	2130      	movs	r1, #48	; 0x30
 80144d8:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80144da:	f7fe faf0 	bl	8012abe <sp_3072_from_mp>
        sp_3072_mul_48(tmpa, tmpa, qi);
 80144de:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80144e0:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80144e2:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80144e4:	f7fe fd60 	bl	8012fa8 <sp_3072_mul_48>
        err = sp_3072_mod_48(tmpa, tmpa, p);
 80144e8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80144ea:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80144ec:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80144ee:	f7ff f95d 	bl	80137ac <sp_3072_mod_48>
 80144f2:	61f8      	str	r0, [r7, #28]
    }

    if (err == MP_OKAY) {
 80144f4:	69fb      	ldr	r3, [r7, #28]
 80144f6:	2b00      	cmp	r3, #0
 80144f8:	d118      	bne.n	801452c <sp_RsaPrivate_3072+0x1d4>
        sp_3072_mul_48(tmpa, q, tmpa);
 80144fa:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80144fc:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 80144fe:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8014500:	f7fe fd52 	bl	8012fa8 <sp_3072_mul_48>
        XMEMSET(&tmpb[48], 0, sizeof(sp_digit) * 48);
 8014504:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014506:	33c0      	adds	r3, #192	; 0xc0
 8014508:	22c0      	movs	r2, #192	; 0xc0
 801450a:	2100      	movs	r1, #0
 801450c:	4618      	mov	r0, r3
 801450e:	f004 ff96 	bl	801943e <memset>
        sp_3072_add_96(r, tmpb, tmpa);
 8014512:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8014514:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8014516:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8014518:	f7fe fb68 	bl	8012bec <sp_3072_add_96>

        sp_3072_to_bin(r, out);
 801451c:	6e79      	ldr	r1, [r7, #100]	; 0x64
 801451e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8014520:	f7fe faf2 	bl	8012b08 <sp_3072_to_bin>
        *outLen = 384;
 8014524:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8014526:	f44f 72c0 	mov.w	r2, #384	; 0x180
 801452a:	601a      	str	r2, [r3, #0]
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (t != NULL) {
 801452c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801452e:	2b00      	cmp	r3, #0
 8014530:	d00d      	beq.n	801454e <sp_RsaPrivate_3072+0x1f6>
        XMEMSET(t, 0, sizeof(sp_digit) * 48 * 11);
 8014532:	f44f 6204 	mov.w	r2, #2112	; 0x840
 8014536:	2100      	movs	r1, #0
 8014538:	6c78      	ldr	r0, [r7, #68]	; 0x44
 801453a:	f004 ff80 	bl	801943e <memset>
        XFREE(t, NULL, DYNAMIC_TYPE_RSA);
 801453e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8014540:	617b      	str	r3, [r7, #20]
 8014542:	697b      	ldr	r3, [r7, #20]
 8014544:	2b00      	cmp	r3, #0
 8014546:	d002      	beq.n	801454e <sp_RsaPrivate_3072+0x1f6>
 8014548:	6978      	ldr	r0, [r7, #20]
 801454a:	f7fa fcf1 	bl	800ef30 <wolfSSL_Free>
    XMEMSET(p,    0, sizeof(p));
    XMEMSET(q,    0, sizeof(q));
    XMEMSET(dp,   0, sizeof(dp));
#endif
#endif /* SP_RSA_PRIVATE_EXP_D || RSA_LOW_MEM */
    return err;
 801454e:	69fb      	ldr	r3, [r7, #28]
}
 8014550:	4618      	mov	r0, r3
 8014552:	3748      	adds	r7, #72	; 0x48
 8014554:	46bd      	mov	sp, r7
 8014556:	bd80      	pop	{r7, pc}

08014558 <sp_256_point_new_ex_8>:
    0xaa3a93e7,0x5ac635d8
};
#endif

static int sp_256_point_new_ex_8(void* heap, sp_point_256* sp, sp_point_256** p)
{
 8014558:	b580      	push	{r7, lr}
 801455a:	b086      	sub	sp, #24
 801455c:	af00      	add	r7, sp, #0
 801455e:	60f8      	str	r0, [r7, #12]
 8014560:	60b9      	str	r1, [r7, #8]
 8014562:	607a      	str	r2, [r7, #4]
    int ret = MP_OKAY;
 8014564:	2300      	movs	r3, #0
 8014566:	617b      	str	r3, [r7, #20]
    (void)heap;
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    (void)sp;
    *p = (sp_point_256*)XMALLOC(sizeof(sp_point_256), heap, DYNAMIC_TYPE_ECC);
 8014568:	20c4      	movs	r0, #196	; 0xc4
 801456a:	f7fa fcc5 	bl	800eef8 <wolfSSL_Malloc>
 801456e:	4602      	mov	r2, r0
 8014570:	687b      	ldr	r3, [r7, #4]
 8014572:	601a      	str	r2, [r3, #0]
#else
    *p = sp;
#endif
    if (*p == NULL) {
 8014574:	687b      	ldr	r3, [r7, #4]
 8014576:	681b      	ldr	r3, [r3, #0]
 8014578:	2b00      	cmp	r3, #0
 801457a:	d102      	bne.n	8014582 <sp_256_point_new_ex_8+0x2a>
        ret = MEMORY_E;
 801457c:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 8014580:	617b      	str	r3, [r7, #20]
    }
    return ret;
 8014582:	697b      	ldr	r3, [r7, #20]
}
 8014584:	4618      	mov	r0, r3
 8014586:	3718      	adds	r7, #24
 8014588:	46bd      	mov	sp, r7
 801458a:	bd80      	pop	{r7, pc}

0801458c <sp_256_point_free_8>:
#define sp_256_point_new_8(heap, sp, p) sp_256_point_new_ex_8((heap), &(sp), &(p))
#endif


static void sp_256_point_free_8(sp_point_256* p, int clear, void* heap)
{
 801458c:	b580      	push	{r7, lr}
 801458e:	b086      	sub	sp, #24
 8014590:	af00      	add	r7, sp, #0
 8014592:	60f8      	str	r0, [r7, #12]
 8014594:	60b9      	str	r1, [r7, #8]
 8014596:	607a      	str	r2, [r7, #4]
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
/* If valid pointer then clear point data if requested and free data. */
    if (p != NULL) {
 8014598:	68fb      	ldr	r3, [r7, #12]
 801459a:	2b00      	cmp	r3, #0
 801459c:	d00f      	beq.n	80145be <sp_256_point_free_8+0x32>
        if (clear != 0) {
 801459e:	68bb      	ldr	r3, [r7, #8]
 80145a0:	2b00      	cmp	r3, #0
 80145a2:	d004      	beq.n	80145ae <sp_256_point_free_8+0x22>
            XMEMSET(p, 0, sizeof(*p));
 80145a4:	22c4      	movs	r2, #196	; 0xc4
 80145a6:	2100      	movs	r1, #0
 80145a8:	68f8      	ldr	r0, [r7, #12]
 80145aa:	f004 ff48 	bl	801943e <memset>
        }
        XFREE(p, heap, DYNAMIC_TYPE_ECC);
 80145ae:	68fb      	ldr	r3, [r7, #12]
 80145b0:	617b      	str	r3, [r7, #20]
 80145b2:	697b      	ldr	r3, [r7, #20]
 80145b4:	2b00      	cmp	r3, #0
 80145b6:	d002      	beq.n	80145be <sp_256_point_free_8+0x32>
 80145b8:	6978      	ldr	r0, [r7, #20]
 80145ba:	f7fa fcb9 	bl	800ef30 <wolfSSL_Free>
    if (clear != 0) {
        XMEMSET(p, 0, sizeof(*p));
    }
#endif
    (void)heap;
}
 80145be:	bf00      	nop
 80145c0:	3718      	adds	r7, #24
 80145c2:	46bd      	mov	sp, r7
 80145c4:	bd80      	pop	{r7, pc}

080145c6 <sp_256_mod_mul_norm_8>:
 * r  The resulting Montgomery form number.
 * a  The number to convert.
 * m  The modulus (prime).
 */
static int sp_256_mod_mul_norm_8(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
 80145c6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80145ca:	b085      	sub	sp, #20
 80145cc:	af00      	add	r7, sp, #0
 80145ce:	60f8      	str	r0, [r7, #12]
 80145d0:	60b9      	str	r1, [r7, #8]
 80145d2:	607a      	str	r2, [r7, #4]
   (void)m;

    __asm__ __volatile__ (
 80145d4:	68f9      	ldr	r1, [r7, #12]
 80145d6:	68b8      	ldr	r0, [r7, #8]
 80145d8:	b086      	sub	sp, #24
 80145da:	6802      	ldr	r2, [r0, #0]
 80145dc:	6843      	ldr	r3, [r0, #4]
 80145de:	6884      	ldr	r4, [r0, #8]
 80145e0:	68c5      	ldr	r5, [r0, #12]
 80145e2:	6906      	ldr	r6, [r0, #16]
 80145e4:	f8d0 8014 	ldr.w	r8, [r0, #20]
 80145e8:	f8d0 9018 	ldr.w	r9, [r0, #24]
 80145ec:	f8d0 a01c 	ldr.w	sl, [r0, #28]
 80145f0:	f04f 0e00 	mov.w	lr, #0
 80145f4:	f04f 0c00 	mov.w	ip, #0
 80145f8:	eb12 0b03 	adds.w	fp, r2, r3
 80145fc:	f14e 0e00 	adc.w	lr, lr, #0
 8014600:	ebbb 0b05 	subs.w	fp, fp, r5
 8014604:	f16c 0c00 	sbc.w	ip, ip, #0
 8014608:	ebbb 0b06 	subs.w	fp, fp, r6
 801460c:	f16c 0c00 	sbc.w	ip, ip, #0
 8014610:	ebbb 0b08 	subs.w	fp, fp, r8
 8014614:	f16c 0c00 	sbc.w	ip, ip, #0
 8014618:	ebbb 0b09 	subs.w	fp, fp, r9
 801461c:	f16c 0c00 	sbc.w	ip, ip, #0
 8014620:	f8cd b000 	str.w	fp, [sp]
 8014624:	f1cc 0c00 	rsb	ip, ip, #0
 8014628:	f04f 0b00 	mov.w	fp, #0
 801462c:	eb1e 0e03 	adds.w	lr, lr, r3
 8014630:	f14b 0b00 	adc.w	fp, fp, #0
 8014634:	eb1e 0e04 	adds.w	lr, lr, r4
 8014638:	f14b 0b00 	adc.w	fp, fp, #0
 801463c:	ebbe 0e0c 	subs.w	lr, lr, ip
 8014640:	f04f 0c00 	mov.w	ip, #0
 8014644:	f16c 0c00 	sbc.w	ip, ip, #0
 8014648:	ebbe 0e06 	subs.w	lr, lr, r6
 801464c:	f16c 0c00 	sbc.w	ip, ip, #0
 8014650:	ebbe 0e08 	subs.w	lr, lr, r8
 8014654:	f16c 0c00 	sbc.w	ip, ip, #0
 8014658:	ebbe 0e09 	subs.w	lr, lr, r9
 801465c:	f16c 0c00 	sbc.w	ip, ip, #0
 8014660:	ebbe 0e0a 	subs.w	lr, lr, sl
 8014664:	f16c 0c00 	sbc.w	ip, ip, #0
 8014668:	f8cd e004 	str.w	lr, [sp, #4]
 801466c:	f1cc 0c00 	rsb	ip, ip, #0
 8014670:	f04f 0e00 	mov.w	lr, #0
 8014674:	eb1b 0b04 	adds.w	fp, fp, r4
 8014678:	f14e 0e00 	adc.w	lr, lr, #0
 801467c:	eb1b 0b05 	adds.w	fp, fp, r5
 8014680:	f14e 0e00 	adc.w	lr, lr, #0
 8014684:	ebbb 0b0c 	subs.w	fp, fp, ip
 8014688:	f04f 0c00 	mov.w	ip, #0
 801468c:	f16c 0c00 	sbc.w	ip, ip, #0
 8014690:	ebbb 0b08 	subs.w	fp, fp, r8
 8014694:	f16c 0c00 	sbc.w	ip, ip, #0
 8014698:	ebbb 0b09 	subs.w	fp, fp, r9
 801469c:	f16c 0c00 	sbc.w	ip, ip, #0
 80146a0:	ebbb 0b0a 	subs.w	fp, fp, sl
 80146a4:	f16c 0c00 	sbc.w	ip, ip, #0
 80146a8:	f8cd b008 	str.w	fp, [sp, #8]
 80146ac:	f1cc 0c00 	rsb	ip, ip, #0
 80146b0:	f04f 0b00 	mov.w	fp, #0
 80146b4:	eb1e 0e05 	adds.w	lr, lr, r5
 80146b8:	f14b 0b00 	adc.w	fp, fp, #0
 80146bc:	eb1e 0e05 	adds.w	lr, lr, r5
 80146c0:	f14b 0b00 	adc.w	fp, fp, #0
 80146c4:	eb1e 0e06 	adds.w	lr, lr, r6
 80146c8:	f14b 0b00 	adc.w	fp, fp, #0
 80146cc:	eb1e 0e06 	adds.w	lr, lr, r6
 80146d0:	f14b 0b00 	adc.w	fp, fp, #0
 80146d4:	eb1e 0e08 	adds.w	lr, lr, r8
 80146d8:	f14b 0b00 	adc.w	fp, fp, #0
 80146dc:	ebbe 0e0c 	subs.w	lr, lr, ip
 80146e0:	f04f 0c00 	mov.w	ip, #0
 80146e4:	f16c 0c00 	sbc.w	ip, ip, #0
 80146e8:	ebbe 0e02 	subs.w	lr, lr, r2
 80146ec:	f16c 0c00 	sbc.w	ip, ip, #0
 80146f0:	ebbe 0e03 	subs.w	lr, lr, r3
 80146f4:	f16c 0c00 	sbc.w	ip, ip, #0
 80146f8:	ebbe 0e0a 	subs.w	lr, lr, sl
 80146fc:	f16c 0c00 	sbc.w	ip, ip, #0
 8014700:	f8cd e00c 	str.w	lr, [sp, #12]
 8014704:	f1cc 0c00 	rsb	ip, ip, #0
 8014708:	f04f 0e00 	mov.w	lr, #0
 801470c:	eb1b 0b06 	adds.w	fp, fp, r6
 8014710:	f14e 0e00 	adc.w	lr, lr, #0
 8014714:	eb1b 0b06 	adds.w	fp, fp, r6
 8014718:	f14e 0e00 	adc.w	lr, lr, #0
 801471c:	eb1b 0b08 	adds.w	fp, fp, r8
 8014720:	f14e 0e00 	adc.w	lr, lr, #0
 8014724:	eb1b 0b08 	adds.w	fp, fp, r8
 8014728:	f14e 0e00 	adc.w	lr, lr, #0
 801472c:	eb1b 0b09 	adds.w	fp, fp, r9
 8014730:	f14e 0e00 	adc.w	lr, lr, #0
 8014734:	ebbb 0b0c 	subs.w	fp, fp, ip
 8014738:	f04f 0c00 	mov.w	ip, #0
 801473c:	f16c 0c00 	sbc.w	ip, ip, #0
 8014740:	ebbb 0b03 	subs.w	fp, fp, r3
 8014744:	f16c 0c00 	sbc.w	ip, ip, #0
 8014748:	ebbb 0b04 	subs.w	fp, fp, r4
 801474c:	f16c 0c00 	sbc.w	ip, ip, #0
 8014750:	f8cd b010 	str.w	fp, [sp, #16]
 8014754:	f1cc 0c00 	rsb	ip, ip, #0
 8014758:	f04f 0b00 	mov.w	fp, #0
 801475c:	eb1e 0e08 	adds.w	lr, lr, r8
 8014760:	f14b 0b00 	adc.w	fp, fp, #0
 8014764:	eb1e 0e08 	adds.w	lr, lr, r8
 8014768:	f14b 0b00 	adc.w	fp, fp, #0
 801476c:	eb1e 0e09 	adds.w	lr, lr, r9
 8014770:	f14b 0b00 	adc.w	fp, fp, #0
 8014774:	eb1e 0e09 	adds.w	lr, lr, r9
 8014778:	f14b 0b00 	adc.w	fp, fp, #0
 801477c:	eb1e 0e0a 	adds.w	lr, lr, sl
 8014780:	f14b 0b00 	adc.w	fp, fp, #0
 8014784:	ebbe 0e0c 	subs.w	lr, lr, ip
 8014788:	f04f 0c00 	mov.w	ip, #0
 801478c:	f16c 0c00 	sbc.w	ip, ip, #0
 8014790:	ebbe 0e04 	subs.w	lr, lr, r4
 8014794:	f16c 0c00 	sbc.w	ip, ip, #0
 8014798:	ebbe 0e05 	subs.w	lr, lr, r5
 801479c:	f16c 0c00 	sbc.w	ip, ip, #0
 80147a0:	f8cd e014 	str.w	lr, [sp, #20]
 80147a4:	f1cc 0c00 	rsb	ip, ip, #0
 80147a8:	f04f 0e00 	mov.w	lr, #0
 80147ac:	eb1b 0b08 	adds.w	fp, fp, r8
 80147b0:	f14e 0e00 	adc.w	lr, lr, #0
 80147b4:	eb1b 0b09 	adds.w	fp, fp, r9
 80147b8:	f14e 0e00 	adc.w	lr, lr, #0
 80147bc:	eb1b 0b09 	adds.w	fp, fp, r9
 80147c0:	f14e 0e00 	adc.w	lr, lr, #0
 80147c4:	eb1b 0b09 	adds.w	fp, fp, r9
 80147c8:	f14e 0e00 	adc.w	lr, lr, #0
 80147cc:	eb1b 0b0a 	adds.w	fp, fp, sl
 80147d0:	f14e 0e00 	adc.w	lr, lr, #0
 80147d4:	eb1b 0b0a 	adds.w	fp, fp, sl
 80147d8:	f14e 0e00 	adc.w	lr, lr, #0
 80147dc:	ebbb 0b0c 	subs.w	fp, fp, ip
 80147e0:	f04f 0c00 	mov.w	ip, #0
 80147e4:	f16c 0c00 	sbc.w	ip, ip, #0
 80147e8:	ebbb 0b02 	subs.w	fp, fp, r2
 80147ec:	f16c 0c00 	sbc.w	ip, ip, #0
 80147f0:	ebbb 0b03 	subs.w	fp, fp, r3
 80147f4:	f16c 0c00 	sbc.w	ip, ip, #0
 80147f8:	46d9      	mov	r9, fp
 80147fa:	f1cc 0c00 	rsb	ip, ip, #0
 80147fe:	f04f 0b00 	mov.w	fp, #0
 8014802:	eb1e 0e02 	adds.w	lr, lr, r2
 8014806:	f14b 0b00 	adc.w	fp, fp, #0
 801480a:	eb1e 0e0a 	adds.w	lr, lr, sl
 801480e:	f14b 0b00 	adc.w	fp, fp, #0
 8014812:	eb1e 0e0a 	adds.w	lr, lr, sl
 8014816:	f14b 0b00 	adc.w	fp, fp, #0
 801481a:	eb1e 0e0a 	adds.w	lr, lr, sl
 801481e:	f14b 0b00 	adc.w	fp, fp, #0
 8014822:	ebbe 0e0c 	subs.w	lr, lr, ip
 8014826:	f04f 0c00 	mov.w	ip, #0
 801482a:	f16c 0c00 	sbc.w	ip, ip, #0
 801482e:	ebbe 0e04 	subs.w	lr, lr, r4
 8014832:	f16c 0c00 	sbc.w	ip, ip, #0
 8014836:	ebbe 0e05 	subs.w	lr, lr, r5
 801483a:	f16c 0c00 	sbc.w	ip, ip, #0
 801483e:	ebbe 0e06 	subs.w	lr, lr, r6
 8014842:	f16c 0c00 	sbc.w	ip, ip, #0
 8014846:	ebbe 0e08 	subs.w	lr, lr, r8
 801484a:	f16c 0c00 	sbc.w	ip, ip, #0
 801484e:	9a00      	ldr	r2, [sp, #0]
 8014850:	9b01      	ldr	r3, [sp, #4]
 8014852:	9c02      	ldr	r4, [sp, #8]
 8014854:	9d03      	ldr	r5, [sp, #12]
 8014856:	9e04      	ldr	r6, [sp, #16]
 8014858:	f8dd 8014 	ldr.w	r8, [sp, #20]
 801485c:	f1cc 0c00 	rsb	ip, ip, #0
 8014860:	eb12 020b 	adds.w	r2, r2, fp
 8014864:	f153 0300 	adcs.w	r3, r3, #0
 8014868:	f154 0400 	adcs.w	r4, r4, #0
 801486c:	eb15 050c 	adds.w	r5, r5, ip
 8014870:	f156 0600 	adcs.w	r6, r6, #0
 8014874:	f158 0800 	adcs.w	r8, r8, #0
 8014878:	eb59 090c 	adcs.w	r9, r9, ip
 801487c:	eb4e 0e0b 	adc.w	lr, lr, fp
 8014880:	ebb2 020c 	subs.w	r2, r2, ip
 8014884:	f173 0300 	sbcs.w	r3, r3, #0
 8014888:	f174 0400 	sbcs.w	r4, r4, #0
 801488c:	ebb5 050b 	subs.w	r5, r5, fp
 8014890:	f176 0600 	sbcs.w	r6, r6, #0
 8014894:	f178 0800 	sbcs.w	r8, r8, #0
 8014898:	eb79 090b 	sbcs.w	r9, r9, fp
 801489c:	eb6e 0e0c 	sbc.w	lr, lr, ip
 80148a0:	600a      	str	r2, [r1, #0]
 80148a2:	604b      	str	r3, [r1, #4]
 80148a4:	608c      	str	r4, [r1, #8]
 80148a6:	60cd      	str	r5, [r1, #12]
 80148a8:	610e      	str	r6, [r1, #16]
 80148aa:	f8c1 8014 	str.w	r8, [r1, #20]
 80148ae:	f8c1 9018 	str.w	r9, [r1, #24]
 80148b2:	f8c1 e01c 	str.w	lr, [r1, #28]
 80148b6:	b006      	add	sp, #24
        :
        : [r] "r" (r), [a] "r" (a)
        : "r2", "r3", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r14", "r12"
    );

    return MP_OKAY;
 80148b8:	2300      	movs	r3, #0
}
 80148ba:	4618      	mov	r0, r3
 80148bc:	3714      	adds	r7, #20
 80148be:	46bd      	mov	sp, r7
 80148c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080148c4 <sp_256_from_mp>:
 * r  A single precision integer.
 * size  Maximum number of bytes to convert
 * a  A multi-precision integer.
 */
static void sp_256_from_mp(sp_digit* r, int size, const mp_int* a)
{
 80148c4:	b580      	push	{r7, lr}
 80148c6:	b086      	sub	sp, #24
 80148c8:	af00      	add	r7, sp, #0
 80148ca:	60f8      	str	r0, [r7, #12]
 80148cc:	60b9      	str	r1, [r7, #8]
 80148ce:	607a      	str	r2, [r7, #4]
#if DIGIT_BIT == 32
    int j;

    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
 80148d0:	687b      	ldr	r3, [r7, #4]
 80148d2:	f103 0108 	add.w	r1, r3, #8
 80148d6:	687b      	ldr	r3, [r7, #4]
 80148d8:	681b      	ldr	r3, [r3, #0]
 80148da:	009b      	lsls	r3, r3, #2
 80148dc:	461a      	mov	r2, r3
 80148de:	68f8      	ldr	r0, [r7, #12]
 80148e0:	f004 fd89 	bl	80193f6 <memcpy>

    for (j = a->used; j < size; j++) {
 80148e4:	687b      	ldr	r3, [r7, #4]
 80148e6:	681b      	ldr	r3, [r3, #0]
 80148e8:	617b      	str	r3, [r7, #20]
 80148ea:	e008      	b.n	80148fe <sp_256_from_mp+0x3a>
        r[j] = 0;
 80148ec:	697b      	ldr	r3, [r7, #20]
 80148ee:	009b      	lsls	r3, r3, #2
 80148f0:	68fa      	ldr	r2, [r7, #12]
 80148f2:	4413      	add	r3, r2
 80148f4:	2200      	movs	r2, #0
 80148f6:	601a      	str	r2, [r3, #0]
    for (j = a->used; j < size; j++) {
 80148f8:	697b      	ldr	r3, [r7, #20]
 80148fa:	3301      	adds	r3, #1
 80148fc:	617b      	str	r3, [r7, #20]
 80148fe:	697a      	ldr	r2, [r7, #20]
 8014900:	68bb      	ldr	r3, [r7, #8]
 8014902:	429a      	cmp	r2, r3
 8014904:	dbf2      	blt.n	80148ec <sp_256_from_mp+0x28>

    for (j++; j < size; j++) {
        r[j] = 0;
    }
#endif
}
 8014906:	bf00      	nop
 8014908:	3718      	adds	r7, #24
 801490a:	46bd      	mov	sp, r7
 801490c:	bd80      	pop	{r7, pc}

0801490e <sp_256_to_mp>:
 *
 * a  A single precision integer.
 * r  A multi-precision integer.
 */
static int sp_256_to_mp(const sp_digit* a, mp_int* r)
{
 801490e:	b580      	push	{r7, lr}
 8014910:	b084      	sub	sp, #16
 8014912:	af00      	add	r7, sp, #0
 8014914:	6078      	str	r0, [r7, #4]
 8014916:	6039      	str	r1, [r7, #0]
    int err;

    err = mp_grow(r, (256 + DIGIT_BIT - 1) / DIGIT_BIT);
 8014918:	2108      	movs	r1, #8
 801491a:	6838      	ldr	r0, [r7, #0]
 801491c:	f004 f856 	bl	80189cc <sp_grow>
 8014920:	60b8      	str	r0, [r7, #8]
    if (err == MP_OKAY) { /*lint !e774 case where err is always MP_OKAY*/
 8014922:	68bb      	ldr	r3, [r7, #8]
 8014924:	2b00      	cmp	r3, #0
 8014926:	d11f      	bne.n	8014968 <sp_256_to_mp+0x5a>
#if DIGIT_BIT == 32
        XMEMCPY(r->dp, a, sizeof(sp_digit) * 8);
 8014928:	683b      	ldr	r3, [r7, #0]
 801492a:	3308      	adds	r3, #8
 801492c:	2220      	movs	r2, #32
 801492e:	6879      	ldr	r1, [r7, #4]
 8014930:	4618      	mov	r0, r3
 8014932:	f004 fd60 	bl	80193f6 <memcpy>
        r->used = 8;
 8014936:	683b      	ldr	r3, [r7, #0]
 8014938:	2208      	movs	r2, #8
 801493a:	601a      	str	r2, [r3, #0]
        mp_clamp(r);
 801493c:	683b      	ldr	r3, [r7, #0]
 801493e:	681b      	ldr	r3, [r3, #0]
 8014940:	3b01      	subs	r3, #1
 8014942:	60fb      	str	r3, [r7, #12]
 8014944:	e002      	b.n	801494c <sp_256_to_mp+0x3e>
 8014946:	68fb      	ldr	r3, [r7, #12]
 8014948:	3b01      	subs	r3, #1
 801494a:	60fb      	str	r3, [r7, #12]
 801494c:	68fb      	ldr	r3, [r7, #12]
 801494e:	2b00      	cmp	r3, #0
 8014950:	db06      	blt.n	8014960 <sp_256_to_mp+0x52>
 8014952:	683b      	ldr	r3, [r7, #0]
 8014954:	68fa      	ldr	r2, [r7, #12]
 8014956:	3202      	adds	r2, #2
 8014958:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801495c:	2b00      	cmp	r3, #0
 801495e:	d0f2      	beq.n	8014946 <sp_256_to_mp+0x38>
 8014960:	68fb      	ldr	r3, [r7, #12]
 8014962:	1c5a      	adds	r2, r3, #1
 8014964:	683b      	ldr	r3, [r7, #0]
 8014966:	601a      	str	r2, [r3, #0]
        r->used = (256 + DIGIT_BIT - 1) / DIGIT_BIT;
        mp_clamp(r);
#endif
    }

    return err;
 8014968:	68bb      	ldr	r3, [r7, #8]
}
 801496a:	4618      	mov	r0, r3
 801496c:	3710      	adds	r7, #16
 801496e:	46bd      	mov	sp, r7
 8014970:	bd80      	pop	{r7, pc}

08014972 <sp_256_point_to_ecc_point_8>:
 * pm  Point of type ecc_point (result).
 * returns MEMORY_E when allocation of memory in ecc_point fails otherwise
 * MP_OKAY.
 */
static int sp_256_point_to_ecc_point_8(const sp_point_256* p, ecc_point* pm)
{
 8014972:	b580      	push	{r7, lr}
 8014974:	b084      	sub	sp, #16
 8014976:	af00      	add	r7, sp, #0
 8014978:	6078      	str	r0, [r7, #4]
 801497a:	6039      	str	r1, [r7, #0]
    int err;

    err = sp_256_to_mp(p->x, pm->x);
 801497c:	687a      	ldr	r2, [r7, #4]
 801497e:	683b      	ldr	r3, [r7, #0]
 8014980:	681b      	ldr	r3, [r3, #0]
 8014982:	4619      	mov	r1, r3
 8014984:	4610      	mov	r0, r2
 8014986:	f7ff ffc2 	bl	801490e <sp_256_to_mp>
 801498a:	60f8      	str	r0, [r7, #12]
    if (err == MP_OKAY) {
 801498c:	68fb      	ldr	r3, [r7, #12]
 801498e:	2b00      	cmp	r3, #0
 8014990:	d109      	bne.n	80149a6 <sp_256_point_to_ecc_point_8+0x34>
        err = sp_256_to_mp(p->y, pm->y);
 8014992:	687b      	ldr	r3, [r7, #4]
 8014994:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8014998:	683b      	ldr	r3, [r7, #0]
 801499a:	685b      	ldr	r3, [r3, #4]
 801499c:	4619      	mov	r1, r3
 801499e:	4610      	mov	r0, r2
 80149a0:	f7ff ffb5 	bl	801490e <sp_256_to_mp>
 80149a4:	60f8      	str	r0, [r7, #12]
    }
    if (err == MP_OKAY) {
 80149a6:	68fb      	ldr	r3, [r7, #12]
 80149a8:	2b00      	cmp	r3, #0
 80149aa:	d109      	bne.n	80149c0 <sp_256_point_to_ecc_point_8+0x4e>
        err = sp_256_to_mp(p->z, pm->z);
 80149ac:	687b      	ldr	r3, [r7, #4]
 80149ae:	f103 0280 	add.w	r2, r3, #128	; 0x80
 80149b2:	683b      	ldr	r3, [r7, #0]
 80149b4:	689b      	ldr	r3, [r3, #8]
 80149b6:	4619      	mov	r1, r3
 80149b8:	4610      	mov	r0, r2
 80149ba:	f7ff ffa8 	bl	801490e <sp_256_to_mp>
 80149be:	60f8      	str	r0, [r7, #12]
    }

    return err;
 80149c0:	68fb      	ldr	r3, [r7, #12]
}
 80149c2:	4618      	mov	r0, r3
 80149c4:	3710      	adds	r7, #16
 80149c6:	46bd      	mov	sp, r7
 80149c8:	bd80      	pop	{r7, pc}

080149ca <sp_256_mont_mul_8>:
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
SP_NOINLINE static void sp_256_mont_mul_8(sp_digit* r, const sp_digit* a, const sp_digit* b,
        const sp_digit* m, sp_digit mp)
{
 80149ca:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80149ce:	b085      	sub	sp, #20
 80149d0:	af00      	add	r7, sp, #0
 80149d2:	60f8      	str	r0, [r7, #12]
 80149d4:	60b9      	str	r1, [r7, #8]
 80149d6:	607a      	str	r2, [r7, #4]
 80149d8:	603b      	str	r3, [r7, #0]
    (void)mp;
    (void)m;

    __asm__ __volatile__ (
 80149da:	68f8      	ldr	r0, [r7, #12]
 80149dc:	68ba      	ldr	r2, [r7, #8]
 80149de:	687b      	ldr	r3, [r7, #4]
 80149e0:	4611      	mov	r1, r2
 80149e2:	461a      	mov	r2, r3
 80149e4:	b091      	sub	sp, #68	; 0x44
 80149e6:	f04f 0500 	mov.w	r5, #0
 80149ea:	680e      	ldr	r6, [r1, #0]
 80149ec:	f8d2 8000 	ldr.w	r8, [r2]
 80149f0:	fba6 9a08 	umull	r9, sl, r6, r8
 80149f4:	f8cd 9000 	str.w	r9, [sp]
 80149f8:	680e      	ldr	r6, [r1, #0]
 80149fa:	f8d2 8004 	ldr.w	r8, [r2, #4]
 80149fe:	fba6 3408 	umull	r3, r4, r6, r8
 8014a02:	eb13 0a0a 	adds.w	sl, r3, sl
 8014a06:	f144 0b00 	adc.w	fp, r4, #0
 8014a0a:	684e      	ldr	r6, [r1, #4]
 8014a0c:	f8d2 8000 	ldr.w	r8, [r2]
 8014a10:	fba6 3408 	umull	r3, r4, r6, r8
 8014a14:	eb13 0a0a 	adds.w	sl, r3, sl
 8014a18:	eb54 0b0b 	adcs.w	fp, r4, fp
 8014a1c:	f145 0e00 	adc.w	lr, r5, #0
 8014a20:	f8cd a004 	str.w	sl, [sp, #4]
 8014a24:	680e      	ldr	r6, [r1, #0]
 8014a26:	f8d2 8008 	ldr.w	r8, [r2, #8]
 8014a2a:	fba6 3408 	umull	r3, r4, r6, r8
 8014a2e:	eb13 0b0b 	adds.w	fp, r3, fp
 8014a32:	eb44 0e0e 	adc.w	lr, r4, lr
 8014a36:	684e      	ldr	r6, [r1, #4]
 8014a38:	f8d2 8004 	ldr.w	r8, [r2, #4]
 8014a3c:	fba6 3408 	umull	r3, r4, r6, r8
 8014a40:	eb13 0b0b 	adds.w	fp, r3, fp
 8014a44:	eb54 0e0e 	adcs.w	lr, r4, lr
 8014a48:	f145 0900 	adc.w	r9, r5, #0
 8014a4c:	688e      	ldr	r6, [r1, #8]
 8014a4e:	f8d2 8000 	ldr.w	r8, [r2]
 8014a52:	fba6 3408 	umull	r3, r4, r6, r8
 8014a56:	eb13 0b0b 	adds.w	fp, r3, fp
 8014a5a:	eb54 0e0e 	adcs.w	lr, r4, lr
 8014a5e:	eb45 0909 	adc.w	r9, r5, r9
 8014a62:	f8cd b008 	str.w	fp, [sp, #8]
 8014a66:	680e      	ldr	r6, [r1, #0]
 8014a68:	f8d2 800c 	ldr.w	r8, [r2, #12]
 8014a6c:	fba6 3408 	umull	r3, r4, r6, r8
 8014a70:	eb13 0e0e 	adds.w	lr, r3, lr
 8014a74:	eb54 0909 	adcs.w	r9, r4, r9
 8014a78:	f145 0a00 	adc.w	sl, r5, #0
 8014a7c:	684e      	ldr	r6, [r1, #4]
 8014a7e:	f8d2 8008 	ldr.w	r8, [r2, #8]
 8014a82:	fba6 3408 	umull	r3, r4, r6, r8
 8014a86:	eb13 0e0e 	adds.w	lr, r3, lr
 8014a8a:	eb54 0909 	adcs.w	r9, r4, r9
 8014a8e:	eb45 0a0a 	adc.w	sl, r5, sl
 8014a92:	688e      	ldr	r6, [r1, #8]
 8014a94:	f8d2 8004 	ldr.w	r8, [r2, #4]
 8014a98:	fba6 3408 	umull	r3, r4, r6, r8
 8014a9c:	eb13 0e0e 	adds.w	lr, r3, lr
 8014aa0:	eb54 0909 	adcs.w	r9, r4, r9
 8014aa4:	eb45 0a0a 	adc.w	sl, r5, sl
 8014aa8:	68ce      	ldr	r6, [r1, #12]
 8014aaa:	f8d2 8000 	ldr.w	r8, [r2]
 8014aae:	fba6 3408 	umull	r3, r4, r6, r8
 8014ab2:	eb13 0e0e 	adds.w	lr, r3, lr
 8014ab6:	eb54 0909 	adcs.w	r9, r4, r9
 8014aba:	eb45 0a0a 	adc.w	sl, r5, sl
 8014abe:	f8cd e00c 	str.w	lr, [sp, #12]
 8014ac2:	680e      	ldr	r6, [r1, #0]
 8014ac4:	f8d2 8010 	ldr.w	r8, [r2, #16]
 8014ac8:	fba6 3408 	umull	r3, r4, r6, r8
 8014acc:	eb13 0909 	adds.w	r9, r3, r9
 8014ad0:	eb54 0a0a 	adcs.w	sl, r4, sl
 8014ad4:	f145 0b00 	adc.w	fp, r5, #0
 8014ad8:	684e      	ldr	r6, [r1, #4]
 8014ada:	f8d2 800c 	ldr.w	r8, [r2, #12]
 8014ade:	fba6 3408 	umull	r3, r4, r6, r8
 8014ae2:	eb13 0909 	adds.w	r9, r3, r9
 8014ae6:	eb54 0a0a 	adcs.w	sl, r4, sl
 8014aea:	eb45 0b0b 	adc.w	fp, r5, fp
 8014aee:	688e      	ldr	r6, [r1, #8]
 8014af0:	f8d2 8008 	ldr.w	r8, [r2, #8]
 8014af4:	fba6 3408 	umull	r3, r4, r6, r8
 8014af8:	eb13 0909 	adds.w	r9, r3, r9
 8014afc:	eb54 0a0a 	adcs.w	sl, r4, sl
 8014b00:	eb45 0b0b 	adc.w	fp, r5, fp
 8014b04:	68ce      	ldr	r6, [r1, #12]
 8014b06:	f8d2 8004 	ldr.w	r8, [r2, #4]
 8014b0a:	fba6 3408 	umull	r3, r4, r6, r8
 8014b0e:	eb13 0909 	adds.w	r9, r3, r9
 8014b12:	eb54 0a0a 	adcs.w	sl, r4, sl
 8014b16:	eb45 0b0b 	adc.w	fp, r5, fp
 8014b1a:	690e      	ldr	r6, [r1, #16]
 8014b1c:	f8d2 8000 	ldr.w	r8, [r2]
 8014b20:	fba6 3408 	umull	r3, r4, r6, r8
 8014b24:	eb13 0909 	adds.w	r9, r3, r9
 8014b28:	eb54 0a0a 	adcs.w	sl, r4, sl
 8014b2c:	eb45 0b0b 	adc.w	fp, r5, fp
 8014b30:	f8cd 9010 	str.w	r9, [sp, #16]
 8014b34:	680e      	ldr	r6, [r1, #0]
 8014b36:	f8d2 8014 	ldr.w	r8, [r2, #20]
 8014b3a:	fba6 3408 	umull	r3, r4, r6, r8
 8014b3e:	eb13 0a0a 	adds.w	sl, r3, sl
 8014b42:	eb54 0b0b 	adcs.w	fp, r4, fp
 8014b46:	f145 0e00 	adc.w	lr, r5, #0
 8014b4a:	684e      	ldr	r6, [r1, #4]
 8014b4c:	f8d2 8010 	ldr.w	r8, [r2, #16]
 8014b50:	fba6 3408 	umull	r3, r4, r6, r8
 8014b54:	eb13 0a0a 	adds.w	sl, r3, sl
 8014b58:	eb54 0b0b 	adcs.w	fp, r4, fp
 8014b5c:	eb45 0e0e 	adc.w	lr, r5, lr
 8014b60:	688e      	ldr	r6, [r1, #8]
 8014b62:	f8d2 800c 	ldr.w	r8, [r2, #12]
 8014b66:	fba6 3408 	umull	r3, r4, r6, r8
 8014b6a:	eb13 0a0a 	adds.w	sl, r3, sl
 8014b6e:	eb54 0b0b 	adcs.w	fp, r4, fp
 8014b72:	eb45 0e0e 	adc.w	lr, r5, lr
 8014b76:	68ce      	ldr	r6, [r1, #12]
 8014b78:	f8d2 8008 	ldr.w	r8, [r2, #8]
 8014b7c:	fba6 3408 	umull	r3, r4, r6, r8
 8014b80:	eb13 0a0a 	adds.w	sl, r3, sl
 8014b84:	eb54 0b0b 	adcs.w	fp, r4, fp
 8014b88:	eb45 0e0e 	adc.w	lr, r5, lr
 8014b8c:	690e      	ldr	r6, [r1, #16]
 8014b8e:	f8d2 8004 	ldr.w	r8, [r2, #4]
 8014b92:	fba6 3408 	umull	r3, r4, r6, r8
 8014b96:	eb13 0a0a 	adds.w	sl, r3, sl
 8014b9a:	eb54 0b0b 	adcs.w	fp, r4, fp
 8014b9e:	eb45 0e0e 	adc.w	lr, r5, lr
 8014ba2:	694e      	ldr	r6, [r1, #20]
 8014ba4:	f8d2 8000 	ldr.w	r8, [r2]
 8014ba8:	fba6 3408 	umull	r3, r4, r6, r8
 8014bac:	eb13 0a0a 	adds.w	sl, r3, sl
 8014bb0:	eb54 0b0b 	adcs.w	fp, r4, fp
 8014bb4:	eb45 0e0e 	adc.w	lr, r5, lr
 8014bb8:	f8cd a014 	str.w	sl, [sp, #20]
 8014bbc:	680e      	ldr	r6, [r1, #0]
 8014bbe:	f8d2 8018 	ldr.w	r8, [r2, #24]
 8014bc2:	fba6 3408 	umull	r3, r4, r6, r8
 8014bc6:	eb13 0b0b 	adds.w	fp, r3, fp
 8014bca:	eb54 0e0e 	adcs.w	lr, r4, lr
 8014bce:	f145 0900 	adc.w	r9, r5, #0
 8014bd2:	684e      	ldr	r6, [r1, #4]
 8014bd4:	f8d2 8014 	ldr.w	r8, [r2, #20]
 8014bd8:	fba6 3408 	umull	r3, r4, r6, r8
 8014bdc:	eb13 0b0b 	adds.w	fp, r3, fp
 8014be0:	eb54 0e0e 	adcs.w	lr, r4, lr
 8014be4:	eb45 0909 	adc.w	r9, r5, r9
 8014be8:	688e      	ldr	r6, [r1, #8]
 8014bea:	f8d2 8010 	ldr.w	r8, [r2, #16]
 8014bee:	fba6 3408 	umull	r3, r4, r6, r8
 8014bf2:	eb13 0b0b 	adds.w	fp, r3, fp
 8014bf6:	eb54 0e0e 	adcs.w	lr, r4, lr
 8014bfa:	eb45 0909 	adc.w	r9, r5, r9
 8014bfe:	68ce      	ldr	r6, [r1, #12]
 8014c00:	f8d2 800c 	ldr.w	r8, [r2, #12]
 8014c04:	fba6 3408 	umull	r3, r4, r6, r8
 8014c08:	eb13 0b0b 	adds.w	fp, r3, fp
 8014c0c:	eb54 0e0e 	adcs.w	lr, r4, lr
 8014c10:	eb45 0909 	adc.w	r9, r5, r9
 8014c14:	690e      	ldr	r6, [r1, #16]
 8014c16:	f8d2 8008 	ldr.w	r8, [r2, #8]
 8014c1a:	fba6 3408 	umull	r3, r4, r6, r8
 8014c1e:	eb13 0b0b 	adds.w	fp, r3, fp
 8014c22:	eb54 0e0e 	adcs.w	lr, r4, lr
 8014c26:	eb45 0909 	adc.w	r9, r5, r9
 8014c2a:	694e      	ldr	r6, [r1, #20]
 8014c2c:	f8d2 8004 	ldr.w	r8, [r2, #4]
 8014c30:	fba6 3408 	umull	r3, r4, r6, r8
 8014c34:	eb13 0b0b 	adds.w	fp, r3, fp
 8014c38:	eb54 0e0e 	adcs.w	lr, r4, lr
 8014c3c:	eb45 0909 	adc.w	r9, r5, r9
 8014c40:	698e      	ldr	r6, [r1, #24]
 8014c42:	f8d2 8000 	ldr.w	r8, [r2]
 8014c46:	fba6 3408 	umull	r3, r4, r6, r8
 8014c4a:	eb13 0b0b 	adds.w	fp, r3, fp
 8014c4e:	eb54 0e0e 	adcs.w	lr, r4, lr
 8014c52:	eb45 0909 	adc.w	r9, r5, r9
 8014c56:	f8cd b018 	str.w	fp, [sp, #24]
 8014c5a:	680e      	ldr	r6, [r1, #0]
 8014c5c:	f8d2 801c 	ldr.w	r8, [r2, #28]
 8014c60:	fba6 3408 	umull	r3, r4, r6, r8
 8014c64:	eb13 0e0e 	adds.w	lr, r3, lr
 8014c68:	eb54 0909 	adcs.w	r9, r4, r9
 8014c6c:	f145 0a00 	adc.w	sl, r5, #0
 8014c70:	684e      	ldr	r6, [r1, #4]
 8014c72:	f8d2 8018 	ldr.w	r8, [r2, #24]
 8014c76:	fba6 3408 	umull	r3, r4, r6, r8
 8014c7a:	eb13 0e0e 	adds.w	lr, r3, lr
 8014c7e:	eb54 0909 	adcs.w	r9, r4, r9
 8014c82:	eb45 0a0a 	adc.w	sl, r5, sl
 8014c86:	688e      	ldr	r6, [r1, #8]
 8014c88:	f8d2 8014 	ldr.w	r8, [r2, #20]
 8014c8c:	fba6 3408 	umull	r3, r4, r6, r8
 8014c90:	eb13 0e0e 	adds.w	lr, r3, lr
 8014c94:	eb54 0909 	adcs.w	r9, r4, r9
 8014c98:	eb45 0a0a 	adc.w	sl, r5, sl
 8014c9c:	68ce      	ldr	r6, [r1, #12]
 8014c9e:	f8d2 8010 	ldr.w	r8, [r2, #16]
 8014ca2:	fba6 3408 	umull	r3, r4, r6, r8
 8014ca6:	eb13 0e0e 	adds.w	lr, r3, lr
 8014caa:	eb54 0909 	adcs.w	r9, r4, r9
 8014cae:	eb45 0a0a 	adc.w	sl, r5, sl
 8014cb2:	690e      	ldr	r6, [r1, #16]
 8014cb4:	f8d2 800c 	ldr.w	r8, [r2, #12]
 8014cb8:	fba6 3408 	umull	r3, r4, r6, r8
 8014cbc:	eb13 0e0e 	adds.w	lr, r3, lr
 8014cc0:	eb54 0909 	adcs.w	r9, r4, r9
 8014cc4:	eb45 0a0a 	adc.w	sl, r5, sl
 8014cc8:	694e      	ldr	r6, [r1, #20]
 8014cca:	f8d2 8008 	ldr.w	r8, [r2, #8]
 8014cce:	fba6 3408 	umull	r3, r4, r6, r8
 8014cd2:	eb13 0e0e 	adds.w	lr, r3, lr
 8014cd6:	eb54 0909 	adcs.w	r9, r4, r9
 8014cda:	eb45 0a0a 	adc.w	sl, r5, sl
 8014cde:	698e      	ldr	r6, [r1, #24]
 8014ce0:	f8d2 8004 	ldr.w	r8, [r2, #4]
 8014ce4:	fba6 3408 	umull	r3, r4, r6, r8
 8014ce8:	eb13 0e0e 	adds.w	lr, r3, lr
 8014cec:	eb54 0909 	adcs.w	r9, r4, r9
 8014cf0:	eb45 0a0a 	adc.w	sl, r5, sl
 8014cf4:	69ce      	ldr	r6, [r1, #28]
 8014cf6:	f8d2 8000 	ldr.w	r8, [r2]
 8014cfa:	fba6 3408 	umull	r3, r4, r6, r8
 8014cfe:	eb13 0e0e 	adds.w	lr, r3, lr
 8014d02:	eb54 0909 	adcs.w	r9, r4, r9
 8014d06:	eb45 0a0a 	adc.w	sl, r5, sl
 8014d0a:	f8cd e01c 	str.w	lr, [sp, #28]
 8014d0e:	684e      	ldr	r6, [r1, #4]
 8014d10:	f8d2 801c 	ldr.w	r8, [r2, #28]
 8014d14:	fba6 3408 	umull	r3, r4, r6, r8
 8014d18:	eb13 0909 	adds.w	r9, r3, r9
 8014d1c:	eb54 0a0a 	adcs.w	sl, r4, sl
 8014d20:	f145 0b00 	adc.w	fp, r5, #0
 8014d24:	688e      	ldr	r6, [r1, #8]
 8014d26:	f8d2 8018 	ldr.w	r8, [r2, #24]
 8014d2a:	fba6 3408 	umull	r3, r4, r6, r8
 8014d2e:	eb13 0909 	adds.w	r9, r3, r9
 8014d32:	eb54 0a0a 	adcs.w	sl, r4, sl
 8014d36:	eb45 0b0b 	adc.w	fp, r5, fp
 8014d3a:	68ce      	ldr	r6, [r1, #12]
 8014d3c:	f8d2 8014 	ldr.w	r8, [r2, #20]
 8014d40:	fba6 3408 	umull	r3, r4, r6, r8
 8014d44:	eb13 0909 	adds.w	r9, r3, r9
 8014d48:	eb54 0a0a 	adcs.w	sl, r4, sl
 8014d4c:	eb45 0b0b 	adc.w	fp, r5, fp
 8014d50:	690e      	ldr	r6, [r1, #16]
 8014d52:	f8d2 8010 	ldr.w	r8, [r2, #16]
 8014d56:	fba6 3408 	umull	r3, r4, r6, r8
 8014d5a:	eb13 0909 	adds.w	r9, r3, r9
 8014d5e:	eb54 0a0a 	adcs.w	sl, r4, sl
 8014d62:	eb45 0b0b 	adc.w	fp, r5, fp
 8014d66:	694e      	ldr	r6, [r1, #20]
 8014d68:	f8d2 800c 	ldr.w	r8, [r2, #12]
 8014d6c:	fba6 3408 	umull	r3, r4, r6, r8
 8014d70:	eb13 0909 	adds.w	r9, r3, r9
 8014d74:	eb54 0a0a 	adcs.w	sl, r4, sl
 8014d78:	eb45 0b0b 	adc.w	fp, r5, fp
 8014d7c:	698e      	ldr	r6, [r1, #24]
 8014d7e:	f8d2 8008 	ldr.w	r8, [r2, #8]
 8014d82:	fba6 3408 	umull	r3, r4, r6, r8
 8014d86:	eb13 0909 	adds.w	r9, r3, r9
 8014d8a:	eb54 0a0a 	adcs.w	sl, r4, sl
 8014d8e:	eb45 0b0b 	adc.w	fp, r5, fp
 8014d92:	69ce      	ldr	r6, [r1, #28]
 8014d94:	f8d2 8004 	ldr.w	r8, [r2, #4]
 8014d98:	fba6 3408 	umull	r3, r4, r6, r8
 8014d9c:	eb13 0909 	adds.w	r9, r3, r9
 8014da0:	eb54 0a0a 	adcs.w	sl, r4, sl
 8014da4:	eb45 0b0b 	adc.w	fp, r5, fp
 8014da8:	f8cd 9020 	str.w	r9, [sp, #32]
 8014dac:	688e      	ldr	r6, [r1, #8]
 8014dae:	f8d2 801c 	ldr.w	r8, [r2, #28]
 8014db2:	fba6 3408 	umull	r3, r4, r6, r8
 8014db6:	eb13 0a0a 	adds.w	sl, r3, sl
 8014dba:	eb54 0b0b 	adcs.w	fp, r4, fp
 8014dbe:	f145 0e00 	adc.w	lr, r5, #0
 8014dc2:	68ce      	ldr	r6, [r1, #12]
 8014dc4:	f8d2 8018 	ldr.w	r8, [r2, #24]
 8014dc8:	fba6 3408 	umull	r3, r4, r6, r8
 8014dcc:	eb13 0a0a 	adds.w	sl, r3, sl
 8014dd0:	eb54 0b0b 	adcs.w	fp, r4, fp
 8014dd4:	eb45 0e0e 	adc.w	lr, r5, lr
 8014dd8:	690e      	ldr	r6, [r1, #16]
 8014dda:	f8d2 8014 	ldr.w	r8, [r2, #20]
 8014dde:	fba6 3408 	umull	r3, r4, r6, r8
 8014de2:	eb13 0a0a 	adds.w	sl, r3, sl
 8014de6:	eb54 0b0b 	adcs.w	fp, r4, fp
 8014dea:	eb45 0e0e 	adc.w	lr, r5, lr
 8014dee:	694e      	ldr	r6, [r1, #20]
 8014df0:	f8d2 8010 	ldr.w	r8, [r2, #16]
 8014df4:	fba6 3408 	umull	r3, r4, r6, r8
 8014df8:	eb13 0a0a 	adds.w	sl, r3, sl
 8014dfc:	eb54 0b0b 	adcs.w	fp, r4, fp
 8014e00:	eb45 0e0e 	adc.w	lr, r5, lr
 8014e04:	698e      	ldr	r6, [r1, #24]
 8014e06:	f8d2 800c 	ldr.w	r8, [r2, #12]
 8014e0a:	fba6 3408 	umull	r3, r4, r6, r8
 8014e0e:	eb13 0a0a 	adds.w	sl, r3, sl
 8014e12:	eb54 0b0b 	adcs.w	fp, r4, fp
 8014e16:	eb45 0e0e 	adc.w	lr, r5, lr
 8014e1a:	69ce      	ldr	r6, [r1, #28]
 8014e1c:	f8d2 8008 	ldr.w	r8, [r2, #8]
 8014e20:	fba6 3408 	umull	r3, r4, r6, r8
 8014e24:	eb13 0a0a 	adds.w	sl, r3, sl
 8014e28:	eb54 0b0b 	adcs.w	fp, r4, fp
 8014e2c:	eb45 0e0e 	adc.w	lr, r5, lr
 8014e30:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
 8014e34:	68ce      	ldr	r6, [r1, #12]
 8014e36:	f8d2 801c 	ldr.w	r8, [r2, #28]
 8014e3a:	fba6 3408 	umull	r3, r4, r6, r8
 8014e3e:	eb13 0b0b 	adds.w	fp, r3, fp
 8014e42:	eb54 0e0e 	adcs.w	lr, r4, lr
 8014e46:	f145 0900 	adc.w	r9, r5, #0
 8014e4a:	690e      	ldr	r6, [r1, #16]
 8014e4c:	f8d2 8018 	ldr.w	r8, [r2, #24]
 8014e50:	fba6 3408 	umull	r3, r4, r6, r8
 8014e54:	eb13 0b0b 	adds.w	fp, r3, fp
 8014e58:	eb54 0e0e 	adcs.w	lr, r4, lr
 8014e5c:	eb45 0909 	adc.w	r9, r5, r9
 8014e60:	694e      	ldr	r6, [r1, #20]
 8014e62:	f8d2 8014 	ldr.w	r8, [r2, #20]
 8014e66:	fba6 3408 	umull	r3, r4, r6, r8
 8014e6a:	eb13 0b0b 	adds.w	fp, r3, fp
 8014e6e:	eb54 0e0e 	adcs.w	lr, r4, lr
 8014e72:	eb45 0909 	adc.w	r9, r5, r9
 8014e76:	698e      	ldr	r6, [r1, #24]
 8014e78:	f8d2 8010 	ldr.w	r8, [r2, #16]
 8014e7c:	fba6 3408 	umull	r3, r4, r6, r8
 8014e80:	eb13 0b0b 	adds.w	fp, r3, fp
 8014e84:	eb54 0e0e 	adcs.w	lr, r4, lr
 8014e88:	eb45 0909 	adc.w	r9, r5, r9
 8014e8c:	69ce      	ldr	r6, [r1, #28]
 8014e8e:	f8d2 800c 	ldr.w	r8, [r2, #12]
 8014e92:	fba6 3408 	umull	r3, r4, r6, r8
 8014e96:	eb13 0b0b 	adds.w	fp, r3, fp
 8014e9a:	eb54 0e0e 	adcs.w	lr, r4, lr
 8014e9e:	eb45 0909 	adc.w	r9, r5, r9
 8014ea2:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
 8014ea6:	690e      	ldr	r6, [r1, #16]
 8014ea8:	f8d2 801c 	ldr.w	r8, [r2, #28]
 8014eac:	fba6 3408 	umull	r3, r4, r6, r8
 8014eb0:	eb13 0e0e 	adds.w	lr, r3, lr
 8014eb4:	eb54 0909 	adcs.w	r9, r4, r9
 8014eb8:	f145 0a00 	adc.w	sl, r5, #0
 8014ebc:	694e      	ldr	r6, [r1, #20]
 8014ebe:	f8d2 8018 	ldr.w	r8, [r2, #24]
 8014ec2:	fba6 3408 	umull	r3, r4, r6, r8
 8014ec6:	eb13 0e0e 	adds.w	lr, r3, lr
 8014eca:	eb54 0909 	adcs.w	r9, r4, r9
 8014ece:	eb45 0a0a 	adc.w	sl, r5, sl
 8014ed2:	698e      	ldr	r6, [r1, #24]
 8014ed4:	f8d2 8014 	ldr.w	r8, [r2, #20]
 8014ed8:	fba6 3408 	umull	r3, r4, r6, r8
 8014edc:	eb13 0e0e 	adds.w	lr, r3, lr
 8014ee0:	eb54 0909 	adcs.w	r9, r4, r9
 8014ee4:	eb45 0a0a 	adc.w	sl, r5, sl
 8014ee8:	69ce      	ldr	r6, [r1, #28]
 8014eea:	f8d2 8010 	ldr.w	r8, [r2, #16]
 8014eee:	fba6 3408 	umull	r3, r4, r6, r8
 8014ef2:	eb13 0e0e 	adds.w	lr, r3, lr
 8014ef6:	eb54 0909 	adcs.w	r9, r4, r9
 8014efa:	eb45 0a0a 	adc.w	sl, r5, sl
 8014efe:	f8cd e02c 	str.w	lr, [sp, #44]	; 0x2c
 8014f02:	694e      	ldr	r6, [r1, #20]
 8014f04:	f8d2 801c 	ldr.w	r8, [r2, #28]
 8014f08:	fba6 3408 	umull	r3, r4, r6, r8
 8014f0c:	eb13 0909 	adds.w	r9, r3, r9
 8014f10:	eb54 0a0a 	adcs.w	sl, r4, sl
 8014f14:	f145 0b00 	adc.w	fp, r5, #0
 8014f18:	698e      	ldr	r6, [r1, #24]
 8014f1a:	f8d2 8018 	ldr.w	r8, [r2, #24]
 8014f1e:	fba6 3408 	umull	r3, r4, r6, r8
 8014f22:	eb13 0909 	adds.w	r9, r3, r9
 8014f26:	eb54 0a0a 	adcs.w	sl, r4, sl
 8014f2a:	eb45 0b0b 	adc.w	fp, r5, fp
 8014f2e:	69ce      	ldr	r6, [r1, #28]
 8014f30:	f8d2 8014 	ldr.w	r8, [r2, #20]
 8014f34:	fba6 3408 	umull	r3, r4, r6, r8
 8014f38:	eb13 0909 	adds.w	r9, r3, r9
 8014f3c:	eb54 0a0a 	adcs.w	sl, r4, sl
 8014f40:	eb45 0b0b 	adc.w	fp, r5, fp
 8014f44:	698e      	ldr	r6, [r1, #24]
 8014f46:	f8d2 801c 	ldr.w	r8, [r2, #28]
 8014f4a:	fba6 3408 	umull	r3, r4, r6, r8
 8014f4e:	eb13 0a0a 	adds.w	sl, r3, sl
 8014f52:	eb54 0b0b 	adcs.w	fp, r4, fp
 8014f56:	f145 0e00 	adc.w	lr, r5, #0
 8014f5a:	69ce      	ldr	r6, [r1, #28]
 8014f5c:	f8d2 8018 	ldr.w	r8, [r2, #24]
 8014f60:	fba6 3408 	umull	r3, r4, r6, r8
 8014f64:	eb13 0a0a 	adds.w	sl, r3, sl
 8014f68:	eb54 0b0b 	adcs.w	fp, r4, fp
 8014f6c:	eb45 0e0e 	adc.w	lr, r5, lr
 8014f70:	69ce      	ldr	r6, [r1, #28]
 8014f72:	f8d2 801c 	ldr.w	r8, [r2, #28]
 8014f76:	fba6 3408 	umull	r3, r4, r6, r8
 8014f7a:	eb13 0b0b 	adds.w	fp, r3, fp
 8014f7e:	eb44 0e0e 	adc.w	lr, r4, lr
 8014f82:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
 8014f86:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8014f8a:	f8cd b038 	str.w	fp, [sp, #56]	; 0x38
 8014f8e:	f8cd e03c 	str.w	lr, [sp, #60]	; 0x3c
 8014f92:	9c00      	ldr	r4, [sp, #0]
 8014f94:	9d01      	ldr	r5, [sp, #4]
 8014f96:	9e02      	ldr	r6, [sp, #8]
 8014f98:	f8dd 800c 	ldr.w	r8, [sp, #12]
 8014f9c:	f8dd 9010 	ldr.w	r9, [sp, #16]
 8014fa0:	f8dd a014 	ldr.w	sl, [sp, #20]
 8014fa4:	f8dd b018 	ldr.w	fp, [sp, #24]
 8014fa8:	f8dd e01c 	ldr.w	lr, [sp, #28]
 8014fac:	eb1b 0b04 	adds.w	fp, fp, r4
 8014fb0:	eb4e 0e05 	adc.w	lr, lr, r5
 8014fb4:	eb1b 0b04 	adds.w	fp, fp, r4
 8014fb8:	eb4e 0e05 	adc.w	lr, lr, r5
 8014fbc:	ebae 0e04 	sub.w	lr, lr, r4
 8014fc0:	4641      	mov	r1, r8
 8014fc2:	464a      	mov	r2, r9
 8014fc4:	eb18 0804 	adds.w	r8, r8, r4
 8014fc8:	eb59 0905 	adcs.w	r9, r9, r5
 8014fcc:	eb5a 0a06 	adcs.w	sl, sl, r6
 8014fd0:	eb5b 0b01 	adcs.w	fp, fp, r1
 8014fd4:	eb4e 0e02 	adc.w	lr, lr, r2
 8014fd8:	9400      	str	r4, [sp, #0]
 8014fda:	9501      	str	r5, [sp, #4]
 8014fdc:	9602      	str	r6, [sp, #8]
 8014fde:	f8cd 800c 	str.w	r8, [sp, #12]
 8014fe2:	f8cd 9010 	str.w	r9, [sp, #16]
 8014fe6:	f8cd a014 	str.w	sl, [sp, #20]
 8014fea:	f04f 0100 	mov.w	r1, #0
 8014fee:	9b06      	ldr	r3, [sp, #24]
 8014ff0:	191b      	adds	r3, r3, r4
 8014ff2:	f141 0200 	adc.w	r2, r1, #0
 8014ff6:	eb13 0308 	adds.w	r3, r3, r8
 8014ffa:	f142 0200 	adc.w	r2, r2, #0
 8014ffe:	f8cd b018 	str.w	fp, [sp, #24]
 8015002:	9b07      	ldr	r3, [sp, #28]
 8015004:	189b      	adds	r3, r3, r2
 8015006:	f141 0200 	adc.w	r2, r1, #0
 801500a:	195b      	adds	r3, r3, r5
 801500c:	f142 0200 	adc.w	r2, r2, #0
 8015010:	eb13 0309 	adds.w	r3, r3, r9
 8015014:	f142 0200 	adc.w	r2, r2, #0
 8015018:	f8cd e01c 	str.w	lr, [sp, #28]
 801501c:	9310      	str	r3, [sp, #64]	; 0x40
 801501e:	9b08      	ldr	r3, [sp, #32]
 8015020:	189b      	adds	r3, r3, r2
 8015022:	f141 0200 	adc.w	r2, r1, #0
 8015026:	191b      	adds	r3, r3, r4
 8015028:	f142 0200 	adc.w	r2, r2, #0
 801502c:	199b      	adds	r3, r3, r6
 801502e:	f142 0200 	adc.w	r2, r2, #0
 8015032:	eb13 030a 	adds.w	r3, r3, sl
 8015036:	f142 0200 	adc.w	r2, r2, #0
 801503a:	9308      	str	r3, [sp, #32]
 801503c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801503e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8015040:	189b      	adds	r3, r3, r2
 8015042:	f154 0400 	adcs.w	r4, r4, #0
 8015046:	f141 0200 	adc.w	r2, r1, #0
 801504a:	195b      	adds	r3, r3, r5
 801504c:	4174      	adcs	r4, r6
 801504e:	f142 0200 	adc.w	r2, r2, #0
 8015052:	eb13 0308 	adds.w	r3, r3, r8
 8015056:	eb54 0409 	adcs.w	r4, r4, r9
 801505a:	f142 0200 	adc.w	r2, r2, #0
 801505e:	eb13 030b 	adds.w	r3, r3, fp
 8015062:	eb54 040e 	adcs.w	r4, r4, lr
 8015066:	f142 0200 	adc.w	r2, r2, #0
 801506a:	9309      	str	r3, [sp, #36]	; 0x24
 801506c:	940a      	str	r4, [sp, #40]	; 0x28
 801506e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8015070:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8015072:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 8015074:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 8015076:	189b      	adds	r3, r3, r2
 8015078:	f154 0400 	adcs.w	r4, r4, #0
 801507c:	f155 0500 	adcs.w	r5, r5, #0
 8015080:	f156 0600 	adcs.w	r6, r6, #0
 8015084:	f141 0200 	adc.w	r2, r1, #0
 8015088:	eb13 0308 	adds.w	r3, r3, r8
 801508c:	eb54 0409 	adcs.w	r4, r4, r9
 8015090:	eb55 050a 	adcs.w	r5, r5, sl
 8015094:	eb56 060b 	adcs.w	r6, r6, fp
 8015098:	f142 0200 	adc.w	r2, r2, #0
 801509c:	eb13 030a 	adds.w	r3, r3, sl
 80150a0:	eb54 040b 	adcs.w	r4, r4, fp
 80150a4:	eb55 050e 	adcs.w	r5, r5, lr
 80150a8:	f156 0600 	adcs.w	r6, r6, #0
 80150ac:	f142 0200 	adc.w	r2, r2, #0
 80150b0:	930b      	str	r3, [sp, #44]	; 0x2c
 80150b2:	940c      	str	r4, [sp, #48]	; 0x30
 80150b4:	950d      	str	r5, [sp, #52]	; 0x34
 80150b6:	960e      	str	r6, [sp, #56]	; 0x38
 80150b8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80150ba:	189b      	adds	r3, r3, r2
 80150bc:	f141 0200 	adc.w	r2, r1, #0
 80150c0:	eb13 030e 	adds.w	r3, r3, lr
 80150c4:	f142 0200 	adc.w	r2, r2, #0
 80150c8:	930f      	str	r3, [sp, #60]	; 0x3c
 80150ca:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80150cc:	9c08      	ldr	r4, [sp, #32]
 80150ce:	9d09      	ldr	r5, [sp, #36]	; 0x24
 80150d0:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 80150d2:	f8dd 9000 	ldr.w	r9, [sp]
 80150d6:	f8dd a004 	ldr.w	sl, [sp, #4]
 80150da:	f8dd b008 	ldr.w	fp, [sp, #8]
 80150de:	f8dd e00c 	ldr.w	lr, [sp, #12]
 80150e2:	ebb3 0309 	subs.w	r3, r3, r9
 80150e6:	eb74 040a 	sbcs.w	r4, r4, sl
 80150ea:	eb75 050b 	sbcs.w	r5, r5, fp
 80150ee:	eb76 060e 	sbcs.w	r6, r6, lr
 80150f2:	9408      	str	r4, [sp, #32]
 80150f4:	9509      	str	r5, [sp, #36]	; 0x24
 80150f6:	960a      	str	r6, [sp, #40]	; 0x28
 80150f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80150fa:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 80150fc:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 80150fe:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 8015100:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
 8015104:	f8dd 9010 	ldr.w	r9, [sp, #16]
 8015108:	f8dd a014 	ldr.w	sl, [sp, #20]
 801510c:	f8dd b018 	ldr.w	fp, [sp, #24]
 8015110:	f8dd e01c 	ldr.w	lr, [sp, #28]
 8015114:	eb73 0309 	sbcs.w	r3, r3, r9
 8015118:	eb74 040a 	sbcs.w	r4, r4, sl
 801511c:	eb75 050b 	sbcs.w	r5, r5, fp
 8015120:	eb76 060e 	sbcs.w	r6, r6, lr
 8015124:	f168 0800 	sbc.w	r8, r8, #0
 8015128:	930b      	str	r3, [sp, #44]	; 0x2c
 801512a:	940c      	str	r4, [sp, #48]	; 0x30
 801512c:	950d      	str	r5, [sp, #52]	; 0x34
 801512e:	960e      	str	r6, [sp, #56]	; 0x38
 8015130:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 8015134:	eba1 0202 	sub.w	r2, r1, r2
 8015138:	f002 0101 	and.w	r1, r2, #1
 801513c:	9b08      	ldr	r3, [sp, #32]
 801513e:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8015140:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8015142:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8015144:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 8015148:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
 801514c:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
 8015150:	f8dd b03c 	ldr.w	fp, [sp, #60]	; 0x3c
 8015154:	1a9b      	subs	r3, r3, r2
 8015156:	4194      	sbcs	r4, r2
 8015158:	4195      	sbcs	r5, r2
 801515a:	f176 0600 	sbcs.w	r6, r6, #0
 801515e:	f178 0800 	sbcs.w	r8, r8, #0
 8015162:	f179 0900 	sbcs.w	r9, r9, #0
 8015166:	eb7a 0a01 	sbcs.w	sl, sl, r1
 801516a:	eb6b 0b02 	sbc.w	fp, fp, r2
 801516e:	6003      	str	r3, [r0, #0]
 8015170:	6044      	str	r4, [r0, #4]
 8015172:	6085      	str	r5, [r0, #8]
 8015174:	60c6      	str	r6, [r0, #12]
 8015176:	f8c0 8010 	str.w	r8, [r0, #16]
 801517a:	f8c0 9014 	str.w	r9, [r0, #20]
 801517e:	f8c0 a018 	str.w	sl, [r0, #24]
 8015182:	f8c0 b01c 	str.w	fp, [r0, #28]
 8015186:	b011      	add	sp, #68	; 0x44
 8015188:	60b9      	str	r1, [r7, #8]
 801518a:	607a      	str	r2, [r7, #4]
        "add   sp, sp, #68\n\t"
        : [a] "+r" (a), [b] "+r" (b)
        : [r] "r" (r)
        : "memory", "r9", "r10", "r11", "r14", "r3", "r4", "r5", "r6", "r8"
    );
}
 801518c:	bf00      	nop
 801518e:	3714      	adds	r7, #20
 8015190:	46bd      	mov	sp, r7
 8015192:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08015196 <sp_256_mont_sqr_8>:
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
SP_NOINLINE static void sp_256_mont_sqr_8(sp_digit* r, const sp_digit* a, const sp_digit* m,
        sp_digit mp)
{
 8015196:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801519a:	b085      	sub	sp, #20
 801519c:	af00      	add	r7, sp, #0
 801519e:	60f8      	str	r0, [r7, #12]
 80151a0:	60b9      	str	r1, [r7, #8]
 80151a2:	607a      	str	r2, [r7, #4]
 80151a4:	603b      	str	r3, [r7, #0]
    (void)mp;
    (void)m;

    __asm__ __volatile__ (
 80151a6:	68f9      	ldr	r1, [r7, #12]
 80151a8:	68bb      	ldr	r3, [r7, #8]
 80151aa:	461a      	mov	r2, r3
 80151ac:	b091      	sub	sp, #68	; 0x44
 80151ae:	f04f 0500 	mov.w	r5, #0
 80151b2:	6816      	ldr	r6, [r2, #0]
 80151b4:	f8d2 8004 	ldr.w	r8, [r2, #4]
 80151b8:	fba6 ab08 	umull	sl, fp, r6, r8
 80151bc:	f8cd a004 	str.w	sl, [sp, #4]
 80151c0:	6816      	ldr	r6, [r2, #0]
 80151c2:	f8d2 8008 	ldr.w	r8, [r2, #8]
 80151c6:	fba6 3408 	umull	r3, r4, r6, r8
 80151ca:	eb13 0b0b 	adds.w	fp, r3, fp
 80151ce:	f144 0e00 	adc.w	lr, r4, #0
 80151d2:	f8cd b008 	str.w	fp, [sp, #8]
 80151d6:	6816      	ldr	r6, [r2, #0]
 80151d8:	f8d2 800c 	ldr.w	r8, [r2, #12]
 80151dc:	fba6 3408 	umull	r3, r4, r6, r8
 80151e0:	eb13 0e0e 	adds.w	lr, r3, lr
 80151e4:	f144 0900 	adc.w	r9, r4, #0
 80151e8:	6856      	ldr	r6, [r2, #4]
 80151ea:	f8d2 8008 	ldr.w	r8, [r2, #8]
 80151ee:	fba6 3408 	umull	r3, r4, r6, r8
 80151f2:	eb13 0e0e 	adds.w	lr, r3, lr
 80151f6:	eb54 0909 	adcs.w	r9, r4, r9
 80151fa:	f145 0a00 	adc.w	sl, r5, #0
 80151fe:	f8cd e00c 	str.w	lr, [sp, #12]
 8015202:	6816      	ldr	r6, [r2, #0]
 8015204:	f8d2 8010 	ldr.w	r8, [r2, #16]
 8015208:	fba6 3408 	umull	r3, r4, r6, r8
 801520c:	eb13 0909 	adds.w	r9, r3, r9
 8015210:	eb44 0a0a 	adc.w	sl, r4, sl
 8015214:	6856      	ldr	r6, [r2, #4]
 8015216:	f8d2 800c 	ldr.w	r8, [r2, #12]
 801521a:	fba6 3408 	umull	r3, r4, r6, r8
 801521e:	eb13 0909 	adds.w	r9, r3, r9
 8015222:	eb54 0a0a 	adcs.w	sl, r4, sl
 8015226:	f145 0b00 	adc.w	fp, r5, #0
 801522a:	f8cd 9010 	str.w	r9, [sp, #16]
 801522e:	6816      	ldr	r6, [r2, #0]
 8015230:	f8d2 8014 	ldr.w	r8, [r2, #20]
 8015234:	fba6 3408 	umull	r3, r4, r6, r8
 8015238:	eb13 0a0a 	adds.w	sl, r3, sl
 801523c:	eb44 0b0b 	adc.w	fp, r4, fp
 8015240:	6856      	ldr	r6, [r2, #4]
 8015242:	f8d2 8010 	ldr.w	r8, [r2, #16]
 8015246:	fba6 3408 	umull	r3, r4, r6, r8
 801524a:	eb13 0a0a 	adds.w	sl, r3, sl
 801524e:	eb54 0b0b 	adcs.w	fp, r4, fp
 8015252:	f145 0e00 	adc.w	lr, r5, #0
 8015256:	6896      	ldr	r6, [r2, #8]
 8015258:	f8d2 800c 	ldr.w	r8, [r2, #12]
 801525c:	fba6 3408 	umull	r3, r4, r6, r8
 8015260:	eb13 0a0a 	adds.w	sl, r3, sl
 8015264:	eb54 0b0b 	adcs.w	fp, r4, fp
 8015268:	eb45 0e0e 	adc.w	lr, r5, lr
 801526c:	f8cd a014 	str.w	sl, [sp, #20]
 8015270:	6816      	ldr	r6, [r2, #0]
 8015272:	f8d2 8018 	ldr.w	r8, [r2, #24]
 8015276:	fba6 3408 	umull	r3, r4, r6, r8
 801527a:	eb13 0b0b 	adds.w	fp, r3, fp
 801527e:	eb54 0e0e 	adcs.w	lr, r4, lr
 8015282:	f145 0900 	adc.w	r9, r5, #0
 8015286:	6856      	ldr	r6, [r2, #4]
 8015288:	f8d2 8014 	ldr.w	r8, [r2, #20]
 801528c:	fba6 3408 	umull	r3, r4, r6, r8
 8015290:	eb13 0b0b 	adds.w	fp, r3, fp
 8015294:	eb54 0e0e 	adcs.w	lr, r4, lr
 8015298:	eb45 0909 	adc.w	r9, r5, r9
 801529c:	6896      	ldr	r6, [r2, #8]
 801529e:	f8d2 8010 	ldr.w	r8, [r2, #16]
 80152a2:	fba6 3408 	umull	r3, r4, r6, r8
 80152a6:	eb13 0b0b 	adds.w	fp, r3, fp
 80152aa:	eb54 0e0e 	adcs.w	lr, r4, lr
 80152ae:	eb45 0909 	adc.w	r9, r5, r9
 80152b2:	f8cd b018 	str.w	fp, [sp, #24]
 80152b6:	6816      	ldr	r6, [r2, #0]
 80152b8:	f8d2 801c 	ldr.w	r8, [r2, #28]
 80152bc:	fba6 3408 	umull	r3, r4, r6, r8
 80152c0:	eb13 0e0e 	adds.w	lr, r3, lr
 80152c4:	eb54 0909 	adcs.w	r9, r4, r9
 80152c8:	f145 0a00 	adc.w	sl, r5, #0
 80152cc:	6856      	ldr	r6, [r2, #4]
 80152ce:	f8d2 8018 	ldr.w	r8, [r2, #24]
 80152d2:	fba6 3408 	umull	r3, r4, r6, r8
 80152d6:	eb13 0e0e 	adds.w	lr, r3, lr
 80152da:	eb54 0909 	adcs.w	r9, r4, r9
 80152de:	eb45 0a0a 	adc.w	sl, r5, sl
 80152e2:	6896      	ldr	r6, [r2, #8]
 80152e4:	f8d2 8014 	ldr.w	r8, [r2, #20]
 80152e8:	fba6 3408 	umull	r3, r4, r6, r8
 80152ec:	eb13 0e0e 	adds.w	lr, r3, lr
 80152f0:	eb54 0909 	adcs.w	r9, r4, r9
 80152f4:	eb45 0a0a 	adc.w	sl, r5, sl
 80152f8:	68d6      	ldr	r6, [r2, #12]
 80152fa:	f8d2 8010 	ldr.w	r8, [r2, #16]
 80152fe:	fba6 3408 	umull	r3, r4, r6, r8
 8015302:	eb13 0e0e 	adds.w	lr, r3, lr
 8015306:	eb54 0909 	adcs.w	r9, r4, r9
 801530a:	eb45 0a0a 	adc.w	sl, r5, sl
 801530e:	f8cd e01c 	str.w	lr, [sp, #28]
 8015312:	6856      	ldr	r6, [r2, #4]
 8015314:	f8d2 801c 	ldr.w	r8, [r2, #28]
 8015318:	fba6 3408 	umull	r3, r4, r6, r8
 801531c:	eb13 0909 	adds.w	r9, r3, r9
 8015320:	eb54 0a0a 	adcs.w	sl, r4, sl
 8015324:	f145 0b00 	adc.w	fp, r5, #0
 8015328:	6896      	ldr	r6, [r2, #8]
 801532a:	f8d2 8018 	ldr.w	r8, [r2, #24]
 801532e:	fba6 3408 	umull	r3, r4, r6, r8
 8015332:	eb13 0909 	adds.w	r9, r3, r9
 8015336:	eb54 0a0a 	adcs.w	sl, r4, sl
 801533a:	eb45 0b0b 	adc.w	fp, r5, fp
 801533e:	68d6      	ldr	r6, [r2, #12]
 8015340:	f8d2 8014 	ldr.w	r8, [r2, #20]
 8015344:	fba6 3408 	umull	r3, r4, r6, r8
 8015348:	eb13 0909 	adds.w	r9, r3, r9
 801534c:	eb54 0a0a 	adcs.w	sl, r4, sl
 8015350:	eb45 0b0b 	adc.w	fp, r5, fp
 8015354:	f8cd 9020 	str.w	r9, [sp, #32]
 8015358:	6896      	ldr	r6, [r2, #8]
 801535a:	f8d2 801c 	ldr.w	r8, [r2, #28]
 801535e:	fba6 3408 	umull	r3, r4, r6, r8
 8015362:	eb13 0a0a 	adds.w	sl, r3, sl
 8015366:	eb54 0b0b 	adcs.w	fp, r4, fp
 801536a:	f145 0e00 	adc.w	lr, r5, #0
 801536e:	68d6      	ldr	r6, [r2, #12]
 8015370:	f8d2 8018 	ldr.w	r8, [r2, #24]
 8015374:	fba6 3408 	umull	r3, r4, r6, r8
 8015378:	eb13 0a0a 	adds.w	sl, r3, sl
 801537c:	eb54 0b0b 	adcs.w	fp, r4, fp
 8015380:	eb45 0e0e 	adc.w	lr, r5, lr
 8015384:	6916      	ldr	r6, [r2, #16]
 8015386:	f8d2 8014 	ldr.w	r8, [r2, #20]
 801538a:	fba6 3408 	umull	r3, r4, r6, r8
 801538e:	eb13 0a0a 	adds.w	sl, r3, sl
 8015392:	eb54 0b0b 	adcs.w	fp, r4, fp
 8015396:	eb45 0e0e 	adc.w	lr, r5, lr
 801539a:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
 801539e:	68d6      	ldr	r6, [r2, #12]
 80153a0:	f8d2 801c 	ldr.w	r8, [r2, #28]
 80153a4:	fba6 3408 	umull	r3, r4, r6, r8
 80153a8:	eb13 0b0b 	adds.w	fp, r3, fp
 80153ac:	eb54 0e0e 	adcs.w	lr, r4, lr
 80153b0:	f145 0900 	adc.w	r9, r5, #0
 80153b4:	6916      	ldr	r6, [r2, #16]
 80153b6:	f8d2 8018 	ldr.w	r8, [r2, #24]
 80153ba:	fba6 3408 	umull	r3, r4, r6, r8
 80153be:	eb13 0b0b 	adds.w	fp, r3, fp
 80153c2:	eb54 0e0e 	adcs.w	lr, r4, lr
 80153c6:	eb45 0909 	adc.w	r9, r5, r9
 80153ca:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
 80153ce:	6916      	ldr	r6, [r2, #16]
 80153d0:	f8d2 801c 	ldr.w	r8, [r2, #28]
 80153d4:	fba6 3408 	umull	r3, r4, r6, r8
 80153d8:	eb13 0e0e 	adds.w	lr, r3, lr
 80153dc:	eb54 0909 	adcs.w	r9, r4, r9
 80153e0:	f145 0a00 	adc.w	sl, r5, #0
 80153e4:	6956      	ldr	r6, [r2, #20]
 80153e6:	f8d2 8018 	ldr.w	r8, [r2, #24]
 80153ea:	fba6 3408 	umull	r3, r4, r6, r8
 80153ee:	eb13 0e0e 	adds.w	lr, r3, lr
 80153f2:	eb54 0909 	adcs.w	r9, r4, r9
 80153f6:	eb45 0a0a 	adc.w	sl, r5, sl
 80153fa:	f8cd e02c 	str.w	lr, [sp, #44]	; 0x2c
 80153fe:	6956      	ldr	r6, [r2, #20]
 8015400:	f8d2 801c 	ldr.w	r8, [r2, #28]
 8015404:	fba6 3408 	umull	r3, r4, r6, r8
 8015408:	eb13 0909 	adds.w	r9, r3, r9
 801540c:	eb54 0a0a 	adcs.w	sl, r4, sl
 8015410:	f145 0b00 	adc.w	fp, r5, #0
 8015414:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
 8015418:	6996      	ldr	r6, [r2, #24]
 801541a:	f8d2 801c 	ldr.w	r8, [r2, #28]
 801541e:	fba6 3408 	umull	r3, r4, r6, r8
 8015422:	eb13 0a0a 	adds.w	sl, r3, sl
 8015426:	eb44 0b0b 	adc.w	fp, r4, fp
 801542a:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 801542e:	f8cd b038 	str.w	fp, [sp, #56]	; 0x38
 8015432:	9c01      	ldr	r4, [sp, #4]
 8015434:	9e02      	ldr	r6, [sp, #8]
 8015436:	f8dd 800c 	ldr.w	r8, [sp, #12]
 801543a:	f8dd 9010 	ldr.w	r9, [sp, #16]
 801543e:	f8dd a014 	ldr.w	sl, [sp, #20]
 8015442:	f8dd b018 	ldr.w	fp, [sp, #24]
 8015446:	f8dd e01c 	ldr.w	lr, [sp, #28]
 801544a:	f8dd c020 	ldr.w	ip, [sp, #32]
 801544e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8015450:	1924      	adds	r4, r4, r4
 8015452:	4176      	adcs	r6, r6
 8015454:	eb58 0808 	adcs.w	r8, r8, r8
 8015458:	eb59 0909 	adcs.w	r9, r9, r9
 801545c:	eb5a 0a0a 	adcs.w	sl, sl, sl
 8015460:	eb5b 0b0b 	adcs.w	fp, fp, fp
 8015464:	eb5e 0e0e 	adcs.w	lr, lr, lr
 8015468:	eb5c 0c0c 	adcs.w	ip, ip, ip
 801546c:	415b      	adcs	r3, r3
 801546e:	9401      	str	r4, [sp, #4]
 8015470:	9602      	str	r6, [sp, #8]
 8015472:	f8cd 800c 	str.w	r8, [sp, #12]
 8015476:	f8cd 9010 	str.w	r9, [sp, #16]
 801547a:	f8cd a014 	str.w	sl, [sp, #20]
 801547e:	f8cd b018 	str.w	fp, [sp, #24]
 8015482:	f8cd e01c 	str.w	lr, [sp, #28]
 8015486:	f8cd c020 	str.w	ip, [sp, #32]
 801548a:	9309      	str	r3, [sp, #36]	; 0x24
 801548c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 801548e:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8015490:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 8015494:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
 8015498:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
 801549c:	4164      	adcs	r4, r4
 801549e:	4176      	adcs	r6, r6
 80154a0:	eb58 0808 	adcs.w	r8, r8, r8
 80154a4:	eb59 0909 	adcs.w	r9, r9, r9
 80154a8:	eb5a 0a0a 	adcs.w	sl, sl, sl
 80154ac:	940a      	str	r4, [sp, #40]	; 0x28
 80154ae:	960b      	str	r6, [sp, #44]	; 0x2c
 80154b0:	f8cd 8030 	str.w	r8, [sp, #48]	; 0x30
 80154b4:	f8cd 9034 	str.w	r9, [sp, #52]	; 0x34
 80154b8:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
 80154bc:	f145 0b00 	adc.w	fp, r5, #0
 80154c0:	f8cd b03c 	str.w	fp, [sp, #60]	; 0x3c
 80154c4:	9c01      	ldr	r4, [sp, #4]
 80154c6:	9d02      	ldr	r5, [sp, #8]
 80154c8:	f8dd c00c 	ldr.w	ip, [sp, #12]
 80154cc:	6816      	ldr	r6, [r2, #0]
 80154ce:	fba6 9a06 	umull	r9, sl, r6, r6
 80154d2:	6856      	ldr	r6, [r2, #4]
 80154d4:	fba6 be06 	umull	fp, lr, r6, r6
 80154d8:	eb1a 0a04 	adds.w	sl, sl, r4
 80154dc:	eb5b 0b05 	adcs.w	fp, fp, r5
 80154e0:	eb5e 0e0c 	adcs.w	lr, lr, ip
 80154e4:	f8cd 9000 	str.w	r9, [sp]
 80154e8:	f8cd a004 	str.w	sl, [sp, #4]
 80154ec:	f8cd b008 	str.w	fp, [sp, #8]
 80154f0:	f8cd e00c 	str.w	lr, [sp, #12]
 80154f4:	9b04      	ldr	r3, [sp, #16]
 80154f6:	9c05      	ldr	r4, [sp, #20]
 80154f8:	9d06      	ldr	r5, [sp, #24]
 80154fa:	f8dd c01c 	ldr.w	ip, [sp, #28]
 80154fe:	6896      	ldr	r6, [r2, #8]
 8015500:	fba6 9a06 	umull	r9, sl, r6, r6
 8015504:	68d6      	ldr	r6, [r2, #12]
 8015506:	fba6 be06 	umull	fp, lr, r6, r6
 801550a:	eb59 0903 	adcs.w	r9, r9, r3
 801550e:	eb5a 0a04 	adcs.w	sl, sl, r4
 8015512:	eb5b 0b05 	adcs.w	fp, fp, r5
 8015516:	eb5e 0e0c 	adcs.w	lr, lr, ip
 801551a:	f8cd 9010 	str.w	r9, [sp, #16]
 801551e:	f8cd a014 	str.w	sl, [sp, #20]
 8015522:	f8cd b018 	str.w	fp, [sp, #24]
 8015526:	f8cd e01c 	str.w	lr, [sp, #28]
 801552a:	9b08      	ldr	r3, [sp, #32]
 801552c:	9c09      	ldr	r4, [sp, #36]	; 0x24
 801552e:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8015530:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
 8015534:	6916      	ldr	r6, [r2, #16]
 8015536:	fba6 9a06 	umull	r9, sl, r6, r6
 801553a:	6956      	ldr	r6, [r2, #20]
 801553c:	fba6 be06 	umull	fp, lr, r6, r6
 8015540:	eb59 0903 	adcs.w	r9, r9, r3
 8015544:	eb5a 0a04 	adcs.w	sl, sl, r4
 8015548:	eb5b 0b05 	adcs.w	fp, fp, r5
 801554c:	eb5e 0e0c 	adcs.w	lr, lr, ip
 8015550:	f8cd 9020 	str.w	r9, [sp, #32]
 8015554:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
 8015558:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
 801555c:	f8cd e02c 	str.w	lr, [sp, #44]	; 0x2c
 8015560:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8015562:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8015564:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 8015566:	f8dd c03c 	ldr.w	ip, [sp, #60]	; 0x3c
 801556a:	6996      	ldr	r6, [r2, #24]
 801556c:	fba6 9a06 	umull	r9, sl, r6, r6
 8015570:	69d6      	ldr	r6, [r2, #28]
 8015572:	fba6 be06 	umull	fp, lr, r6, r6
 8015576:	eb59 0903 	adcs.w	r9, r9, r3
 801557a:	eb5a 0a04 	adcs.w	sl, sl, r4
 801557e:	eb5b 0b05 	adcs.w	fp, fp, r5
 8015582:	eb4e 0e0c 	adc.w	lr, lr, ip
 8015586:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
 801558a:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 801558e:	f8cd b038 	str.w	fp, [sp, #56]	; 0x38
 8015592:	f8cd e03c 	str.w	lr, [sp, #60]	; 0x3c
 8015596:	9c00      	ldr	r4, [sp, #0]
 8015598:	9d01      	ldr	r5, [sp, #4]
 801559a:	9e02      	ldr	r6, [sp, #8]
 801559c:	f8dd 800c 	ldr.w	r8, [sp, #12]
 80155a0:	f8dd 9010 	ldr.w	r9, [sp, #16]
 80155a4:	f8dd a014 	ldr.w	sl, [sp, #20]
 80155a8:	f8dd b018 	ldr.w	fp, [sp, #24]
 80155ac:	f8dd e01c 	ldr.w	lr, [sp, #28]
 80155b0:	eb1b 0b04 	adds.w	fp, fp, r4
 80155b4:	eb4e 0e05 	adc.w	lr, lr, r5
 80155b8:	eb1b 0b04 	adds.w	fp, fp, r4
 80155bc:	eb4e 0e05 	adc.w	lr, lr, r5
 80155c0:	ebae 0e04 	sub.w	lr, lr, r4
 80155c4:	4642      	mov	r2, r8
 80155c6:	46cc      	mov	ip, r9
 80155c8:	eb18 0804 	adds.w	r8, r8, r4
 80155cc:	eb59 0905 	adcs.w	r9, r9, r5
 80155d0:	eb5a 0a06 	adcs.w	sl, sl, r6
 80155d4:	eb5b 0b02 	adcs.w	fp, fp, r2
 80155d8:	eb4e 0e0c 	adc.w	lr, lr, ip
 80155dc:	9400      	str	r4, [sp, #0]
 80155de:	9501      	str	r5, [sp, #4]
 80155e0:	9602      	str	r6, [sp, #8]
 80155e2:	f8cd 800c 	str.w	r8, [sp, #12]
 80155e6:	f8cd 9010 	str.w	r9, [sp, #16]
 80155ea:	f8cd a014 	str.w	sl, [sp, #20]
 80155ee:	f04f 0200 	mov.w	r2, #0
 80155f2:	9b06      	ldr	r3, [sp, #24]
 80155f4:	191b      	adds	r3, r3, r4
 80155f6:	f142 0c00 	adc.w	ip, r2, #0
 80155fa:	eb13 0308 	adds.w	r3, r3, r8
 80155fe:	f14c 0c00 	adc.w	ip, ip, #0
 8015602:	f8cd b018 	str.w	fp, [sp, #24]
 8015606:	9b07      	ldr	r3, [sp, #28]
 8015608:	eb13 030c 	adds.w	r3, r3, ip
 801560c:	f142 0c00 	adc.w	ip, r2, #0
 8015610:	195b      	adds	r3, r3, r5
 8015612:	f14c 0c00 	adc.w	ip, ip, #0
 8015616:	eb13 0309 	adds.w	r3, r3, r9
 801561a:	f14c 0c00 	adc.w	ip, ip, #0
 801561e:	f8cd e01c 	str.w	lr, [sp, #28]
 8015622:	9310      	str	r3, [sp, #64]	; 0x40
 8015624:	9b08      	ldr	r3, [sp, #32]
 8015626:	eb13 030c 	adds.w	r3, r3, ip
 801562a:	f142 0c00 	adc.w	ip, r2, #0
 801562e:	191b      	adds	r3, r3, r4
 8015630:	f14c 0c00 	adc.w	ip, ip, #0
 8015634:	199b      	adds	r3, r3, r6
 8015636:	f14c 0c00 	adc.w	ip, ip, #0
 801563a:	eb13 030a 	adds.w	r3, r3, sl
 801563e:	f14c 0c00 	adc.w	ip, ip, #0
 8015642:	9308      	str	r3, [sp, #32]
 8015644:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8015646:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8015648:	eb13 030c 	adds.w	r3, r3, ip
 801564c:	f154 0400 	adcs.w	r4, r4, #0
 8015650:	f142 0c00 	adc.w	ip, r2, #0
 8015654:	195b      	adds	r3, r3, r5
 8015656:	4174      	adcs	r4, r6
 8015658:	f14c 0c00 	adc.w	ip, ip, #0
 801565c:	eb13 0308 	adds.w	r3, r3, r8
 8015660:	eb54 0409 	adcs.w	r4, r4, r9
 8015664:	f14c 0c00 	adc.w	ip, ip, #0
 8015668:	eb13 030b 	adds.w	r3, r3, fp
 801566c:	eb54 040e 	adcs.w	r4, r4, lr
 8015670:	f14c 0c00 	adc.w	ip, ip, #0
 8015674:	9309      	str	r3, [sp, #36]	; 0x24
 8015676:	940a      	str	r4, [sp, #40]	; 0x28
 8015678:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801567a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 801567c:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 801567e:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 8015680:	eb13 030c 	adds.w	r3, r3, ip
 8015684:	f154 0400 	adcs.w	r4, r4, #0
 8015688:	f155 0500 	adcs.w	r5, r5, #0
 801568c:	f156 0600 	adcs.w	r6, r6, #0
 8015690:	f142 0c00 	adc.w	ip, r2, #0
 8015694:	eb13 0308 	adds.w	r3, r3, r8
 8015698:	eb54 0409 	adcs.w	r4, r4, r9
 801569c:	eb55 050a 	adcs.w	r5, r5, sl
 80156a0:	eb56 060b 	adcs.w	r6, r6, fp
 80156a4:	f14c 0c00 	adc.w	ip, ip, #0
 80156a8:	eb13 030a 	adds.w	r3, r3, sl
 80156ac:	eb54 040b 	adcs.w	r4, r4, fp
 80156b0:	eb55 050e 	adcs.w	r5, r5, lr
 80156b4:	f156 0600 	adcs.w	r6, r6, #0
 80156b8:	f14c 0c00 	adc.w	ip, ip, #0
 80156bc:	930b      	str	r3, [sp, #44]	; 0x2c
 80156be:	940c      	str	r4, [sp, #48]	; 0x30
 80156c0:	950d      	str	r5, [sp, #52]	; 0x34
 80156c2:	960e      	str	r6, [sp, #56]	; 0x38
 80156c4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80156c6:	eb13 030c 	adds.w	r3, r3, ip
 80156ca:	f142 0c00 	adc.w	ip, r2, #0
 80156ce:	eb13 030e 	adds.w	r3, r3, lr
 80156d2:	f14c 0c00 	adc.w	ip, ip, #0
 80156d6:	930f      	str	r3, [sp, #60]	; 0x3c
 80156d8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80156da:	9c08      	ldr	r4, [sp, #32]
 80156dc:	9d09      	ldr	r5, [sp, #36]	; 0x24
 80156de:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 80156e0:	f8dd 9000 	ldr.w	r9, [sp]
 80156e4:	f8dd a004 	ldr.w	sl, [sp, #4]
 80156e8:	f8dd b008 	ldr.w	fp, [sp, #8]
 80156ec:	f8dd e00c 	ldr.w	lr, [sp, #12]
 80156f0:	ebb3 0309 	subs.w	r3, r3, r9
 80156f4:	eb74 040a 	sbcs.w	r4, r4, sl
 80156f8:	eb75 050b 	sbcs.w	r5, r5, fp
 80156fc:	eb76 060e 	sbcs.w	r6, r6, lr
 8015700:	9408      	str	r4, [sp, #32]
 8015702:	9509      	str	r5, [sp, #36]	; 0x24
 8015704:	960a      	str	r6, [sp, #40]	; 0x28
 8015706:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8015708:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 801570a:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 801570c:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 801570e:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
 8015712:	f8dd 9010 	ldr.w	r9, [sp, #16]
 8015716:	f8dd a014 	ldr.w	sl, [sp, #20]
 801571a:	f8dd b018 	ldr.w	fp, [sp, #24]
 801571e:	f8dd e01c 	ldr.w	lr, [sp, #28]
 8015722:	eb73 0309 	sbcs.w	r3, r3, r9
 8015726:	eb74 040a 	sbcs.w	r4, r4, sl
 801572a:	eb75 050b 	sbcs.w	r5, r5, fp
 801572e:	eb76 060e 	sbcs.w	r6, r6, lr
 8015732:	f168 0800 	sbc.w	r8, r8, #0
 8015736:	930b      	str	r3, [sp, #44]	; 0x2c
 8015738:	940c      	str	r4, [sp, #48]	; 0x30
 801573a:	950d      	str	r5, [sp, #52]	; 0x34
 801573c:	960e      	str	r6, [sp, #56]	; 0x38
 801573e:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 8015742:	eba2 0c0c 	sub.w	ip, r2, ip
 8015746:	f00c 0201 	and.w	r2, ip, #1
 801574a:	9b08      	ldr	r3, [sp, #32]
 801574c:	9c09      	ldr	r4, [sp, #36]	; 0x24
 801574e:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8015750:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8015752:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 8015756:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
 801575a:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
 801575e:	f8dd b03c 	ldr.w	fp, [sp, #60]	; 0x3c
 8015762:	ebb3 030c 	subs.w	r3, r3, ip
 8015766:	eb74 040c 	sbcs.w	r4, r4, ip
 801576a:	eb75 050c 	sbcs.w	r5, r5, ip
 801576e:	f176 0600 	sbcs.w	r6, r6, #0
 8015772:	f178 0800 	sbcs.w	r8, r8, #0
 8015776:	f179 0900 	sbcs.w	r9, r9, #0
 801577a:	eb7a 0a02 	sbcs.w	sl, sl, r2
 801577e:	eb6b 0b0c 	sbc.w	fp, fp, ip
 8015782:	600b      	str	r3, [r1, #0]
 8015784:	604c      	str	r4, [r1, #4]
 8015786:	608d      	str	r5, [r1, #8]
 8015788:	60ce      	str	r6, [r1, #12]
 801578a:	f8c1 8010 	str.w	r8, [r1, #16]
 801578e:	f8c1 9014 	str.w	r9, [r1, #20]
 8015792:	f8c1 a018 	str.w	sl, [r1, #24]
 8015796:	f8c1 b01c 	str.w	fp, [r1, #28]
 801579a:	b011      	add	sp, #68	; 0x44
 801579c:	60ba      	str	r2, [r7, #8]
        "add   sp, sp, #68\n\t"
        : [a] "+r" (a)
        : [r] "r" (r)
        : "memory", "r9", "r10", "r11", "r14", "r3", "r4", "r5", "r6", "r8", "r12"
    );
}
 801579e:	bf00      	nop
 80157a0:	3714      	adds	r7, #20
 80157a2:	46bd      	mov	sp, r7
 80157a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080157a8 <sp_256_mont_inv_8>:
 * r   Inverse result.
 * a   Number to invert.
 * td  Temporary data.
 */
static void sp_256_mont_inv_8(sp_digit* r, const sp_digit* a, sp_digit* td)
{
 80157a8:	b580      	push	{r7, lr}
 80157aa:	b088      	sub	sp, #32
 80157ac:	af02      	add	r7, sp, #8
 80157ae:	60f8      	str	r0, [r7, #12]
 80157b0:	60b9      	str	r1, [r7, #8]
 80157b2:	607a      	str	r2, [r7, #4]
#ifdef WOLFSSL_SP_SMALL
    sp_digit* t = td;
 80157b4:	687b      	ldr	r3, [r7, #4]
 80157b6:	613b      	str	r3, [r7, #16]
    int i;

    XMEMCPY(t, a, sizeof(sp_digit) * 8);
 80157b8:	2220      	movs	r2, #32
 80157ba:	68b9      	ldr	r1, [r7, #8]
 80157bc:	6938      	ldr	r0, [r7, #16]
 80157be:	f003 fe1a 	bl	80193f6 <memcpy>
    for (i=254; i>=0; i--) {
 80157c2:	23fe      	movs	r3, #254	; 0xfe
 80157c4:	617b      	str	r3, [r7, #20]
 80157c6:	e027      	b.n	8015818 <sp_256_mont_inv_8+0x70>
        sp_256_mont_sqr_8(t, t, p256_mod, p256_mp_mod);
 80157c8:	2301      	movs	r3, #1
 80157ca:	4a19      	ldr	r2, [pc, #100]	; (8015830 <sp_256_mont_inv_8+0x88>)
 80157cc:	6939      	ldr	r1, [r7, #16]
 80157ce:	6938      	ldr	r0, [r7, #16]
 80157d0:	f7ff fce1 	bl	8015196 <sp_256_mont_sqr_8>
        if (p256_mod_minus_2[i / 32] & ((sp_digit)1 << (i % 32)))
 80157d4:	697b      	ldr	r3, [r7, #20]
 80157d6:	2b00      	cmp	r3, #0
 80157d8:	da00      	bge.n	80157dc <sp_256_mont_inv_8+0x34>
 80157da:	331f      	adds	r3, #31
 80157dc:	115b      	asrs	r3, r3, #5
 80157de:	461a      	mov	r2, r3
 80157e0:	4b14      	ldr	r3, [pc, #80]	; (8015834 <sp_256_mont_inv_8+0x8c>)
 80157e2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80157e6:	697b      	ldr	r3, [r7, #20]
 80157e8:	4259      	negs	r1, r3
 80157ea:	f003 031f 	and.w	r3, r3, #31
 80157ee:	f001 011f 	and.w	r1, r1, #31
 80157f2:	bf58      	it	pl
 80157f4:	424b      	negpl	r3, r1
 80157f6:	2101      	movs	r1, #1
 80157f8:	fa01 f303 	lsl.w	r3, r1, r3
 80157fc:	4013      	ands	r3, r2
 80157fe:	2b00      	cmp	r3, #0
 8015800:	d007      	beq.n	8015812 <sp_256_mont_inv_8+0x6a>
            sp_256_mont_mul_8(t, t, a, p256_mod, p256_mp_mod);
 8015802:	2301      	movs	r3, #1
 8015804:	9300      	str	r3, [sp, #0]
 8015806:	4b0a      	ldr	r3, [pc, #40]	; (8015830 <sp_256_mont_inv_8+0x88>)
 8015808:	68ba      	ldr	r2, [r7, #8]
 801580a:	6939      	ldr	r1, [r7, #16]
 801580c:	6938      	ldr	r0, [r7, #16]
 801580e:	f7ff f8dc 	bl	80149ca <sp_256_mont_mul_8>
    for (i=254; i>=0; i--) {
 8015812:	697b      	ldr	r3, [r7, #20]
 8015814:	3b01      	subs	r3, #1
 8015816:	617b      	str	r3, [r7, #20]
 8015818:	697b      	ldr	r3, [r7, #20]
 801581a:	2b00      	cmp	r3, #0
 801581c:	dad4      	bge.n	80157c8 <sp_256_mont_inv_8+0x20>
    }
    XMEMCPY(r, t, sizeof(sp_digit) * 8);
 801581e:	2220      	movs	r2, #32
 8015820:	6939      	ldr	r1, [r7, #16]
 8015822:	68f8      	ldr	r0, [r7, #12]
 8015824:	f003 fde7 	bl	80193f6 <memcpy>
    /* 0xffffffff00000001000000000000000000000000ffffffffffffffff00000000 */
    sp_256_mont_sqr_n_8(r, r, 32, p256_mod, p256_mp_mod);
    /* 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffd */
    sp_256_mont_mul_8(r, r, t3, p256_mod, p256_mp_mod);
#endif /* WOLFSSL_SP_SMALL */
}
 8015828:	bf00      	nop
 801582a:	3718      	adds	r7, #24
 801582c:	46bd      	mov	sp, r7
 801582e:	bd80      	pop	{r7, pc}
 8015830:	0801aef4 	.word	0x0801aef4
 8015834:	0801b038 	.word	0x0801b038

08015838 <sp_256_cmp_8>:
 * b  A single precision integer.
 * return -ve, 0 or +ve if a is less than, equal to or greater than b
 * respectively.
 */
SP_NOINLINE static int32_t sp_256_cmp_8(const sp_digit* a, const sp_digit* b)
{
 8015838:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 801583c:	b085      	sub	sp, #20
 801583e:	af00      	add	r7, sp, #0
 8015840:	6078      	str	r0, [r7, #4]
 8015842:	6039      	str	r1, [r7, #0]
    sp_digit r = 0;
 8015844:	2300      	movs	r3, #0
 8015846:	60fb      	str	r3, [r7, #12]


    __asm__ __volatile__ (
 8015848:	6879      	ldr	r1, [r7, #4]
 801584a:	6838      	ldr	r0, [r7, #0]
 801584c:	68fb      	ldr	r3, [r7, #12]
 801584e:	461a      	mov	r2, r3
 8015850:	f04f 0300 	mov.w	r3, #0
 8015854:	ea6f 0303 	mvn.w	r3, r3
 8015858:	f04f 061c 	mov.w	r6, #28
 801585c:	f851 8006 	ldr.w	r8, [r1, r6]
 8015860:	5985      	ldr	r5, [r0, r6]
 8015862:	ea08 0803 	and.w	r8, r8, r3
 8015866:	ea05 0503 	and.w	r5, r5, r3
 801586a:	4644      	mov	r4, r8
 801586c:	ebb8 0805 	subs.w	r8, r8, r5
 8015870:	eb68 0808 	sbc.w	r8, r8, r8
 8015874:	4442      	add	r2, r8
 8015876:	ea6f 0808 	mvn.w	r8, r8
 801587a:	ea03 0308 	and.w	r3, r3, r8
 801587e:	1b2d      	subs	r5, r5, r4
 8015880:	eb68 0808 	sbc.w	r8, r8, r8
 8015884:	eba2 0208 	sub.w	r2, r2, r8
 8015888:	ea6f 0808 	mvn.w	r8, r8
 801588c:	ea03 0308 	and.w	r3, r3, r8
 8015890:	f1a6 0604 	sub.w	r6, r6, #4
 8015894:	2e00      	cmp	r6, #0
 8015896:	dae1      	bge.n	801585c <sp_256_cmp_8+0x24>
 8015898:	60fa      	str	r2, [r7, #12]
        : [r] "+r" (r)
        : [a] "r" (a), [b] "r" (b)
        : "r3", "r4", "r5", "r6", "r8"
    );

    return r;
 801589a:	68fb      	ldr	r3, [r7, #12]
}
 801589c:	4618      	mov	r0, r3
 801589e:	3714      	adds	r7, #20
 80158a0:	46bd      	mov	sp, r7
 80158a2:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 80158a6:	4770      	bx	lr

080158a8 <sp_256_cond_sub_8>:
 * b  A single precision number to subtract.
 * m  Mask value to apply.
 */
SP_NOINLINE static sp_digit sp_256_cond_sub_8(sp_digit* r, const sp_digit* a,
        const sp_digit* b, sp_digit m)
{
 80158a8:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 80158ac:	b086      	sub	sp, #24
 80158ae:	af00      	add	r7, sp, #0
 80158b0:	60f8      	str	r0, [r7, #12]
 80158b2:	60b9      	str	r1, [r7, #8]
 80158b4:	607a      	str	r2, [r7, #4]
 80158b6:	603b      	str	r3, [r7, #0]
    sp_digit c = 0;
 80158b8:	2300      	movs	r3, #0
 80158ba:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 80158bc:	68fa      	ldr	r2, [r7, #12]
 80158be:	68b9      	ldr	r1, [r7, #8]
 80158c0:	6878      	ldr	r0, [r7, #4]
 80158c2:	683c      	ldr	r4, [r7, #0]
 80158c4:	697b      	ldr	r3, [r7, #20]
 80158c6:	f04f 0520 	mov.w	r5, #32
 80158ca:	46a9      	mov	r9, r5
 80158cc:	f04f 0800 	mov.w	r8, #0
 80158d0:	f850 6008 	ldr.w	r6, [r0, r8]
 80158d4:	ea06 0604 	and.w	r6, r6, r4
 80158d8:	f04f 0500 	mov.w	r5, #0
 80158dc:	1aed      	subs	r5, r5, r3
 80158de:	f851 5008 	ldr.w	r5, [r1, r8]
 80158e2:	41b5      	sbcs	r5, r6
 80158e4:	419b      	sbcs	r3, r3
 80158e6:	f842 5008 	str.w	r5, [r2, r8]
 80158ea:	f108 0804 	add.w	r8, r8, #4
 80158ee:	45c8      	cmp	r8, r9
 80158f0:	dbee      	blt.n	80158d0 <sp_256_cond_sub_8+0x28>
 80158f2:	617b      	str	r3, [r7, #20]
        : [c] "+r" (c)
        : [r] "r" (r), [a] "r" (a), [b] "r" (b), [m] "r" (m)
        : "memory", "r5", "r6", "r8", "r9"
    );

    return c;
 80158f4:	697b      	ldr	r3, [r7, #20]
}
 80158f6:	4618      	mov	r0, r3
 80158f8:	3718      	adds	r7, #24
 80158fa:	46bd      	mov	sp, r7
 80158fc:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8015900:	4770      	bx	lr

08015902 <sp_256_mont_reduce_8>:
 * m   The single precision number representing the modulus.
 * mp  The digit representing the negative inverse of m mod 2^n.
 */
SP_NOINLINE static void sp_256_mont_reduce_8(sp_digit* a, const sp_digit* m,
        sp_digit mp)
{
 8015902:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015906:	b085      	sub	sp, #20
 8015908:	af00      	add	r7, sp, #0
 801590a:	60f8      	str	r0, [r7, #12]
 801590c:	60b9      	str	r1, [r7, #8]
 801590e:	607a      	str	r2, [r7, #4]
    (void)mp;
    (void)m;

    __asm__ __volatile__ (
 8015910:	68fb      	ldr	r3, [r7, #12]
 8015912:	4618      	mov	r0, r3
 8015914:	f04f 0200 	mov.w	r2, #0
 8015918:	f04f 0100 	mov.w	r1, #0
 801591c:	4691      	mov	r9, r2
 801591e:	f04f 0400 	mov.w	r4, #0
 8015922:	6803      	ldr	r3, [r0, #0]
 8015924:	6846      	ldr	r6, [r0, #4]
 8015926:	f04f 0500 	mov.w	r5, #0
 801592a:	19a4      	adds	r4, r4, r6
 801592c:	eb45 0502 	adc.w	r5, r5, r2
 8015930:	6044      	str	r4, [r0, #4]
 8015932:	6886      	ldr	r6, [r0, #8]
 8015934:	f04f 0400 	mov.w	r4, #0
 8015938:	19ad      	adds	r5, r5, r6
 801593a:	eb44 0402 	adc.w	r4, r4, r2
 801593e:	6085      	str	r5, [r0, #8]
 8015940:	68c6      	ldr	r6, [r0, #12]
 8015942:	f04f 0500 	mov.w	r5, #0
 8015946:	18e4      	adds	r4, r4, r3
 8015948:	eb45 0502 	adc.w	r5, r5, r2
 801594c:	19a4      	adds	r4, r4, r6
 801594e:	eb45 0502 	adc.w	r5, r5, r2
 8015952:	60c4      	str	r4, [r0, #12]
 8015954:	6906      	ldr	r6, [r0, #16]
 8015956:	f04f 0400 	mov.w	r4, #0
 801595a:	19ad      	adds	r5, r5, r6
 801595c:	eb44 0402 	adc.w	r4, r4, r2
 8015960:	6105      	str	r5, [r0, #16]
 8015962:	6946      	ldr	r6, [r0, #20]
 8015964:	f04f 0500 	mov.w	r5, #0
 8015968:	19a4      	adds	r4, r4, r6
 801596a:	eb45 0502 	adc.w	r5, r5, r2
 801596e:	6144      	str	r4, [r0, #20]
 8015970:	6986      	ldr	r6, [r0, #24]
 8015972:	f04f 0400 	mov.w	r4, #0
 8015976:	18ed      	adds	r5, r5, r3
 8015978:	eb44 0402 	adc.w	r4, r4, r2
 801597c:	19ad      	adds	r5, r5, r6
 801597e:	eb44 0402 	adc.w	r4, r4, r2
 8015982:	6185      	str	r5, [r0, #24]
 8015984:	69c6      	ldr	r6, [r0, #28]
 8015986:	f8d0 8020 	ldr.w	r8, [r0, #32]
 801598a:	18cd      	adds	r5, r1, r3
 801598c:	f04f 0100 	mov.w	r1, #0
 8015990:	eb41 0102 	adc.w	r1, r1, r2
 8015994:	1ae4      	subs	r4, r4, r3
 8015996:	4195      	sbcs	r5, r2
 8015998:	eb61 0102 	sbc.w	r1, r1, r2
 801599c:	19a4      	adds	r4, r4, r6
 801599e:	eb55 0508 	adcs.w	r5, r5, r8
 80159a2:	eb41 0102 	adc.w	r1, r1, r2
 80159a6:	61c4      	str	r4, [r0, #28]
 80159a8:	6205      	str	r5, [r0, #32]
 80159aa:	f109 0901 	add.w	r9, r9, #1
 80159ae:	f100 0004 	add.w	r0, r0, #4
 80159b2:	f04f 0608 	mov.w	r6, #8
 80159b6:	45b1      	cmp	r9, r6
 80159b8:	dbb1      	blt.n	801591e <sp_256_mont_reduce_8+0x1c>
 80159ba:	f1a0 0020 	sub.w	r0, r0, #32
 80159be:	460b      	mov	r3, r1
 80159c0:	f1a1 0101 	sub.w	r1, r1, #1
 80159c4:	ea6f 0101 	mvn.w	r1, r1
 80159c8:	6a04      	ldr	r4, [r0, #32]
 80159ca:	6a45      	ldr	r5, [r0, #36]	; 0x24
 80159cc:	6a86      	ldr	r6, [r0, #40]	; 0x28
 80159ce:	f8d0 802c 	ldr.w	r8, [r0, #44]	; 0x2c
 80159d2:	f8d0 9030 	ldr.w	r9, [r0, #48]	; 0x30
 80159d6:	f8d0 a034 	ldr.w	sl, [r0, #52]	; 0x34
 80159da:	f8d0 b038 	ldr.w	fp, [r0, #56]	; 0x38
 80159de:	f8d0 e03c 	ldr.w	lr, [r0, #60]	; 0x3c
 80159e2:	1a64      	subs	r4, r4, r1
 80159e4:	418d      	sbcs	r5, r1
 80159e6:	418e      	sbcs	r6, r1
 80159e8:	eb78 0802 	sbcs.w	r8, r8, r2
 80159ec:	eb79 0902 	sbcs.w	r9, r9, r2
 80159f0:	eb7a 0a02 	sbcs.w	sl, sl, r2
 80159f4:	eb7b 0b03 	sbcs.w	fp, fp, r3
 80159f8:	eb6e 0e01 	sbc.w	lr, lr, r1
 80159fc:	6004      	str	r4, [r0, #0]
 80159fe:	6045      	str	r5, [r0, #4]
 8015a00:	6086      	str	r6, [r0, #8]
 8015a02:	f8c0 800c 	str.w	r8, [r0, #12]
 8015a06:	f8c0 9010 	str.w	r9, [r0, #16]
 8015a0a:	f8c0 a014 	str.w	sl, [r0, #20]
 8015a0e:	f8c0 b018 	str.w	fp, [r0, #24]
 8015a12:	f8c0 e01c 	str.w	lr, [r0, #28]
 8015a16:	60f8      	str	r0, [r7, #12]
    );


    (void)m;
    (void)mp;
}
 8015a18:	bf00      	nop
 8015a1a:	3714      	adds	r7, #20
 8015a1c:	46bd      	mov	sp, r7
 8015a1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08015a22 <sp_256_mont_reduce_order_8>:
 * m   The single precision number representing the modulus.
 * mp  The digit representing the negative inverse of m mod 2^n.
 */
SP_NOINLINE static void sp_256_mont_reduce_order_8(sp_digit* a, const sp_digit* m,
        sp_digit mp)
{
 8015a22:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015a26:	b087      	sub	sp, #28
 8015a28:	af00      	add	r7, sp, #0
 8015a2a:	60f8      	str	r0, [r7, #12]
 8015a2c:	60b9      	str	r1, [r7, #8]
 8015a2e:	607a      	str	r2, [r7, #4]
    sp_digit ca = 0;
 8015a30:	2300      	movs	r3, #0
 8015a32:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 8015a34:	68b9      	ldr	r1, [r7, #8]
 8015a36:	6878      	ldr	r0, [r7, #4]
 8015a38:	697a      	ldr	r2, [r7, #20]
 8015a3a:	68fb      	ldr	r3, [r7, #12]
 8015a3c:	4681      	mov	r9, r0
 8015a3e:	468c      	mov	ip, r1
 8015a40:	469a      	mov	sl, r3
 8015a42:	f04f 0400 	mov.w	r4, #0
 8015a46:	f10a 0b20 	add.w	fp, sl, #32
 8015a4a:	4648      	mov	r0, r9
 8015a4c:	f8da 3000 	ldr.w	r3, [sl]
 8015a50:	fb00 f003 	mul.w	r0, r0, r3
 8015a54:	4661      	mov	r1, ip
 8015a56:	f10a 0e18 	add.w	lr, sl, #24
 8015a5a:	f8da 3000 	ldr.w	r3, [sl]
 8015a5e:	f04f 0500 	mov.w	r5, #0
 8015a62:	f851 8b04 	ldr.w	r8, [r1], #4
 8015a66:	fba0 6808 	umull	r6, r8, r0, r8
 8015a6a:	199b      	adds	r3, r3, r6
 8015a6c:	eb45 0508 	adc.w	r5, r5, r8
 8015a70:	18e4      	adds	r4, r4, r3
 8015a72:	f145 0500 	adc.w	r5, r5, #0
 8015a76:	f84a 4b04 	str.w	r4, [sl], #4
 8015a7a:	f8da 3000 	ldr.w	r3, [sl]
 8015a7e:	f04f 0400 	mov.w	r4, #0
 8015a82:	f851 8b04 	ldr.w	r8, [r1], #4
 8015a86:	fba0 6808 	umull	r6, r8, r0, r8
 8015a8a:	199b      	adds	r3, r3, r6
 8015a8c:	eb44 0408 	adc.w	r4, r4, r8
 8015a90:	18ed      	adds	r5, r5, r3
 8015a92:	f144 0400 	adc.w	r4, r4, #0
 8015a96:	f84a 5b04 	str.w	r5, [sl], #4
 8015a9a:	45f2      	cmp	sl, lr
 8015a9c:	dbdd      	blt.n	8015a5a <sp_256_mont_reduce_order_8+0x38>
 8015a9e:	f8da 3000 	ldr.w	r3, [sl]
 8015aa2:	f04f 0500 	mov.w	r5, #0
 8015aa6:	f851 8b04 	ldr.w	r8, [r1], #4
 8015aaa:	fba0 6808 	umull	r6, r8, r0, r8
 8015aae:	199b      	adds	r3, r3, r6
 8015ab0:	eb45 0508 	adc.w	r5, r5, r8
 8015ab4:	18e4      	adds	r4, r4, r3
 8015ab6:	f145 0500 	adc.w	r5, r5, #0
 8015aba:	f84a 4b04 	str.w	r4, [sl], #4
 8015abe:	4614      	mov	r4, r2
 8015ac0:	f04f 0200 	mov.w	r2, #0
 8015ac4:	f8d1 8000 	ldr.w	r8, [r1]
 8015ac8:	fba0 6808 	umull	r6, r8, r0, r8
 8015acc:	19ad      	adds	r5, r5, r6
 8015ace:	eb54 0408 	adcs.w	r4, r4, r8
 8015ad2:	f142 0200 	adc.w	r2, r2, #0
 8015ad6:	f8da 6000 	ldr.w	r6, [sl]
 8015ada:	f8da 8004 	ldr.w	r8, [sl, #4]
 8015ade:	1976      	adds	r6, r6, r5
 8015ae0:	eb58 0804 	adcs.w	r8, r8, r4
 8015ae4:	f142 0200 	adc.w	r2, r2, #0
 8015ae8:	f8ca 6000 	str.w	r6, [sl]
 8015aec:	f8ca 8004 	str.w	r8, [sl, #4]
 8015af0:	f1aa 0a18 	sub.w	sl, sl, #24
 8015af4:	45da      	cmp	sl, fp
 8015af6:	dba8      	blt.n	8015a4a <sp_256_mont_reduce_order_8+0x28>
 8015af8:	4653      	mov	r3, sl
 8015afa:	4661      	mov	r1, ip
 8015afc:	617a      	str	r2, [r7, #20]
 8015afe:	60fb      	str	r3, [r7, #12]
        : [ca] "+r" (ca), [a] "+r" (a)
        : [m] "r" (m), [mp] "r" (mp)
        : "memory", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r12", "r14"
    );

    sp_256_cond_sub_8(a - 8, a, m, (sp_digit)0 - ca);
 8015b00:	68fb      	ldr	r3, [r7, #12]
 8015b02:	f1a3 0020 	sub.w	r0, r3, #32
 8015b06:	697b      	ldr	r3, [r7, #20]
 8015b08:	425b      	negs	r3, r3
 8015b0a:	68ba      	ldr	r2, [r7, #8]
 8015b0c:	68f9      	ldr	r1, [r7, #12]
 8015b0e:	f7ff fecb 	bl	80158a8 <sp_256_cond_sub_8>
}
 8015b12:	bf00      	nop
 8015b14:	371c      	adds	r7, #28
 8015b16:	46bd      	mov	sp, r7
 8015b18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08015b1c <sp_256_map_8>:
 * r  Resulting affine coordinate point.
 * p  Montgomery form projective coordinate point.
 * t  Temporary ordinate data.
 */
static void sp_256_map_8(sp_point_256* r, const sp_point_256* p, sp_digit* t)
{
 8015b1c:	b580      	push	{r7, lr}
 8015b1e:	b08a      	sub	sp, #40	; 0x28
 8015b20:	af02      	add	r7, sp, #8
 8015b22:	60f8      	str	r0, [r7, #12]
 8015b24:	60b9      	str	r1, [r7, #8]
 8015b26:	607a      	str	r2, [r7, #4]
    sp_digit* t1 = t;
 8015b28:	687b      	ldr	r3, [r7, #4]
 8015b2a:	61fb      	str	r3, [r7, #28]
    sp_digit* t2 = t + 2*8;
 8015b2c:	687b      	ldr	r3, [r7, #4]
 8015b2e:	3340      	adds	r3, #64	; 0x40
 8015b30:	61bb      	str	r3, [r7, #24]
    int32_t n;

    sp_256_mont_inv_8(t1, p->z, t + 2*8);
 8015b32:	68bb      	ldr	r3, [r7, #8]
 8015b34:	f103 0180 	add.w	r1, r3, #128	; 0x80
 8015b38:	687b      	ldr	r3, [r7, #4]
 8015b3a:	3340      	adds	r3, #64	; 0x40
 8015b3c:	461a      	mov	r2, r3
 8015b3e:	69f8      	ldr	r0, [r7, #28]
 8015b40:	f7ff fe32 	bl	80157a8 <sp_256_mont_inv_8>

    sp_256_mont_sqr_8(t2, t1, p256_mod, p256_mp_mod);
 8015b44:	2301      	movs	r3, #1
 8015b46:	4a3a      	ldr	r2, [pc, #232]	; (8015c30 <sp_256_map_8+0x114>)
 8015b48:	69f9      	ldr	r1, [r7, #28]
 8015b4a:	69b8      	ldr	r0, [r7, #24]
 8015b4c:	f7ff fb23 	bl	8015196 <sp_256_mont_sqr_8>
    sp_256_mont_mul_8(t1, t2, t1, p256_mod, p256_mp_mod);
 8015b50:	2301      	movs	r3, #1
 8015b52:	9300      	str	r3, [sp, #0]
 8015b54:	4b36      	ldr	r3, [pc, #216]	; (8015c30 <sp_256_map_8+0x114>)
 8015b56:	69fa      	ldr	r2, [r7, #28]
 8015b58:	69b9      	ldr	r1, [r7, #24]
 8015b5a:	69f8      	ldr	r0, [r7, #28]
 8015b5c:	f7fe ff35 	bl	80149ca <sp_256_mont_mul_8>

    /* x /= z^2 */
    sp_256_mont_mul_8(r->x, p->x, t2, p256_mod, p256_mp_mod);
 8015b60:	68f8      	ldr	r0, [r7, #12]
 8015b62:	68b9      	ldr	r1, [r7, #8]
 8015b64:	2301      	movs	r3, #1
 8015b66:	9300      	str	r3, [sp, #0]
 8015b68:	4b31      	ldr	r3, [pc, #196]	; (8015c30 <sp_256_map_8+0x114>)
 8015b6a:	69ba      	ldr	r2, [r7, #24]
 8015b6c:	f7fe ff2d 	bl	80149ca <sp_256_mont_mul_8>
    XMEMSET(r->x + 8, 0, sizeof(r->x) / 2U);
 8015b70:	68fb      	ldr	r3, [r7, #12]
 8015b72:	3320      	adds	r3, #32
 8015b74:	2220      	movs	r2, #32
 8015b76:	2100      	movs	r1, #0
 8015b78:	4618      	mov	r0, r3
 8015b7a:	f003 fc60 	bl	801943e <memset>
    sp_256_mont_reduce_8(r->x, p256_mod, p256_mp_mod);
 8015b7e:	68fb      	ldr	r3, [r7, #12]
 8015b80:	2201      	movs	r2, #1
 8015b82:	492b      	ldr	r1, [pc, #172]	; (8015c30 <sp_256_map_8+0x114>)
 8015b84:	4618      	mov	r0, r3
 8015b86:	f7ff febc 	bl	8015902 <sp_256_mont_reduce_8>
    /* Reduce x to less than modulus */
    n = sp_256_cmp_8(r->x, p256_mod);
 8015b8a:	68fb      	ldr	r3, [r7, #12]
 8015b8c:	4928      	ldr	r1, [pc, #160]	; (8015c30 <sp_256_map_8+0x114>)
 8015b8e:	4618      	mov	r0, r3
 8015b90:	f7ff fe52 	bl	8015838 <sp_256_cmp_8>
 8015b94:	6178      	str	r0, [r7, #20]
    sp_256_cond_sub_8(r->x, r->x, p256_mod, 0 - ((n >= 0) ?
 8015b96:	68f8      	ldr	r0, [r7, #12]
 8015b98:	68f9      	ldr	r1, [r7, #12]
 8015b9a:	697b      	ldr	r3, [r7, #20]
 8015b9c:	2b00      	cmp	r3, #0
 8015b9e:	db02      	blt.n	8015ba6 <sp_256_map_8+0x8a>
 8015ba0:	f04f 33ff 	mov.w	r3, #4294967295
 8015ba4:	e000      	b.n	8015ba8 <sp_256_map_8+0x8c>
 8015ba6:	2300      	movs	r3, #0
 8015ba8:	4a21      	ldr	r2, [pc, #132]	; (8015c30 <sp_256_map_8+0x114>)
 8015baa:	f7ff fe7d 	bl	80158a8 <sp_256_cond_sub_8>
                (sp_digit)1 : (sp_digit)0));
    sp_256_norm_8(r->x);

    /* y /= z^3 */
    sp_256_mont_mul_8(r->y, p->y, t1, p256_mod, p256_mp_mod);
 8015bae:	68fb      	ldr	r3, [r7, #12]
 8015bb0:	f103 0040 	add.w	r0, r3, #64	; 0x40
 8015bb4:	68bb      	ldr	r3, [r7, #8]
 8015bb6:	f103 0140 	add.w	r1, r3, #64	; 0x40
 8015bba:	2301      	movs	r3, #1
 8015bbc:	9300      	str	r3, [sp, #0]
 8015bbe:	4b1c      	ldr	r3, [pc, #112]	; (8015c30 <sp_256_map_8+0x114>)
 8015bc0:	69fa      	ldr	r2, [r7, #28]
 8015bc2:	f7fe ff02 	bl	80149ca <sp_256_mont_mul_8>
    XMEMSET(r->y + 8, 0, sizeof(r->y) / 2U);
 8015bc6:	68fb      	ldr	r3, [r7, #12]
 8015bc8:	3340      	adds	r3, #64	; 0x40
 8015bca:	3320      	adds	r3, #32
 8015bcc:	2220      	movs	r2, #32
 8015bce:	2100      	movs	r1, #0
 8015bd0:	4618      	mov	r0, r3
 8015bd2:	f003 fc34 	bl	801943e <memset>
    sp_256_mont_reduce_8(r->y, p256_mod, p256_mp_mod);
 8015bd6:	68fb      	ldr	r3, [r7, #12]
 8015bd8:	3340      	adds	r3, #64	; 0x40
 8015bda:	2201      	movs	r2, #1
 8015bdc:	4914      	ldr	r1, [pc, #80]	; (8015c30 <sp_256_map_8+0x114>)
 8015bde:	4618      	mov	r0, r3
 8015be0:	f7ff fe8f 	bl	8015902 <sp_256_mont_reduce_8>
    /* Reduce y to less than modulus */
    n = sp_256_cmp_8(r->y, p256_mod);
 8015be4:	68fb      	ldr	r3, [r7, #12]
 8015be6:	3340      	adds	r3, #64	; 0x40
 8015be8:	4911      	ldr	r1, [pc, #68]	; (8015c30 <sp_256_map_8+0x114>)
 8015bea:	4618      	mov	r0, r3
 8015bec:	f7ff fe24 	bl	8015838 <sp_256_cmp_8>
 8015bf0:	6178      	str	r0, [r7, #20]
    sp_256_cond_sub_8(r->y, r->y, p256_mod, 0 - ((n >= 0) ?
 8015bf2:	68fb      	ldr	r3, [r7, #12]
 8015bf4:	f103 0040 	add.w	r0, r3, #64	; 0x40
 8015bf8:	68fb      	ldr	r3, [r7, #12]
 8015bfa:	f103 0140 	add.w	r1, r3, #64	; 0x40
 8015bfe:	697b      	ldr	r3, [r7, #20]
 8015c00:	2b00      	cmp	r3, #0
 8015c02:	db02      	blt.n	8015c0a <sp_256_map_8+0xee>
 8015c04:	f04f 33ff 	mov.w	r3, #4294967295
 8015c08:	e000      	b.n	8015c0c <sp_256_map_8+0xf0>
 8015c0a:	2300      	movs	r3, #0
 8015c0c:	4a08      	ldr	r2, [pc, #32]	; (8015c30 <sp_256_map_8+0x114>)
 8015c0e:	f7ff fe4b 	bl	80158a8 <sp_256_cond_sub_8>
                (sp_digit)1 : (sp_digit)0));
    sp_256_norm_8(r->y);

    XMEMSET(r->z, 0, sizeof(r->z));
 8015c12:	68fb      	ldr	r3, [r7, #12]
 8015c14:	3380      	adds	r3, #128	; 0x80
 8015c16:	2240      	movs	r2, #64	; 0x40
 8015c18:	2100      	movs	r1, #0
 8015c1a:	4618      	mov	r0, r3
 8015c1c:	f003 fc0f 	bl	801943e <memset>
    r->z[0] = 1;
 8015c20:	68fb      	ldr	r3, [r7, #12]
 8015c22:	2201      	movs	r2, #1
 8015c24:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

}
 8015c28:	bf00      	nop
 8015c2a:	3720      	adds	r7, #32
 8015c2c:	46bd      	mov	sp, r7
 8015c2e:	bd80      	pop	{r7, pc}
 8015c30:	0801aef4 	.word	0x0801aef4

08015c34 <sp_256_add_8>:
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static sp_digit sp_256_add_8(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
 8015c34:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 8015c38:	b087      	sub	sp, #28
 8015c3a:	af00      	add	r7, sp, #0
 8015c3c:	60f8      	str	r0, [r7, #12]
 8015c3e:	60b9      	str	r1, [r7, #8]
 8015c40:	607a      	str	r2, [r7, #4]
    sp_digit c = 0;
 8015c42:	2300      	movs	r3, #0
 8015c44:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 8015c46:	6978      	ldr	r0, [r7, #20]
 8015c48:	68f9      	ldr	r1, [r7, #12]
 8015c4a:	68ba      	ldr	r2, [r7, #8]
 8015c4c:	687b      	ldr	r3, [r7, #4]
 8015c4e:	4616      	mov	r6, r2
 8015c50:	f04f 0800 	mov.w	r8, #0
 8015c54:	f106 0620 	add.w	r6, r6, #32
 8015c58:	f1a8 0801 	sub.w	r8, r8, #1
 8015c5c:	eb10 0008 	adds.w	r0, r0, r8
 8015c60:	6814      	ldr	r4, [r2, #0]
 8015c62:	681d      	ldr	r5, [r3, #0]
 8015c64:	416c      	adcs	r4, r5
 8015c66:	600c      	str	r4, [r1, #0]
 8015c68:	f04f 0000 	mov.w	r0, #0
 8015c6c:	eb40 0000 	adc.w	r0, r0, r0
 8015c70:	f102 0204 	add.w	r2, r2, #4
 8015c74:	f103 0304 	add.w	r3, r3, #4
 8015c78:	f101 0104 	add.w	r1, r1, #4
 8015c7c:	42b2      	cmp	r2, r6
 8015c7e:	d1ed      	bne.n	8015c5c <sp_256_add_8+0x28>
 8015c80:	6178      	str	r0, [r7, #20]
 8015c82:	60f9      	str	r1, [r7, #12]
 8015c84:	60ba      	str	r2, [r7, #8]
 8015c86:	607b      	str	r3, [r7, #4]
        : [c] "+r" (c), [r] "+r" (r), [a] "+r" (a), [b] "+r" (b)
        :
        : "memory", "r4", "r5", "r6", "r8"
    );

    return c;
 8015c88:	697b      	ldr	r3, [r7, #20]
}
 8015c8a:	4618      	mov	r0, r3
 8015c8c:	371c      	adds	r7, #28
 8015c8e:	46bd      	mov	sp, r7
 8015c90:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8015c94:	4770      	bx	lr

08015c96 <sp_256_mont_add_8>:
 * b   Second number to add in Montogmery form.
 * m   Modulus (prime).
 */
SP_NOINLINE static void sp_256_mont_add_8(sp_digit* r, const sp_digit* a, const sp_digit* b,
        const sp_digit* m)
{
 8015c96:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015c9a:	b085      	sub	sp, #20
 8015c9c:	af00      	add	r7, sp, #0
 8015c9e:	60f8      	str	r0, [r7, #12]
 8015ca0:	60b9      	str	r1, [r7, #8]
 8015ca2:	607a      	str	r2, [r7, #4]
 8015ca4:	603b      	str	r3, [r7, #0]
    (void)m;

    __asm__ __volatile__ (
 8015ca6:	68fa      	ldr	r2, [r7, #12]
 8015ca8:	68b9      	ldr	r1, [r7, #8]
 8015caa:	6878      	ldr	r0, [r7, #4]
 8015cac:	f04f 0c00 	mov.w	ip, #0
 8015cb0:	680c      	ldr	r4, [r1, #0]
 8015cb2:	684d      	ldr	r5, [r1, #4]
 8015cb4:	688e      	ldr	r6, [r1, #8]
 8015cb6:	f8d1 800c 	ldr.w	r8, [r1, #12]
 8015cba:	f8d0 9000 	ldr.w	r9, [r0]
 8015cbe:	f8d0 a004 	ldr.w	sl, [r0, #4]
 8015cc2:	f8d0 b008 	ldr.w	fp, [r0, #8]
 8015cc6:	f8d0 e00c 	ldr.w	lr, [r0, #12]
 8015cca:	eb14 0409 	adds.w	r4, r4, r9
 8015cce:	eb55 050a 	adcs.w	r5, r5, sl
 8015cd2:	eb56 060b 	adcs.w	r6, r6, fp
 8015cd6:	eb58 080e 	adcs.w	r8, r8, lr
 8015cda:	6014      	str	r4, [r2, #0]
 8015cdc:	6055      	str	r5, [r2, #4]
 8015cde:	6096      	str	r6, [r2, #8]
 8015ce0:	f8c2 800c 	str.w	r8, [r2, #12]
 8015ce4:	690c      	ldr	r4, [r1, #16]
 8015ce6:	694d      	ldr	r5, [r1, #20]
 8015ce8:	698e      	ldr	r6, [r1, #24]
 8015cea:	f8d1 801c 	ldr.w	r8, [r1, #28]
 8015cee:	f8d0 9010 	ldr.w	r9, [r0, #16]
 8015cf2:	f8d0 a014 	ldr.w	sl, [r0, #20]
 8015cf6:	f8d0 b018 	ldr.w	fp, [r0, #24]
 8015cfa:	f8d0 e01c 	ldr.w	lr, [r0, #28]
 8015cfe:	eb54 0409 	adcs.w	r4, r4, r9
 8015d02:	eb55 050a 	adcs.w	r5, r5, sl
 8015d06:	eb56 060b 	adcs.w	r6, r6, fp
 8015d0a:	eb58 080e 	adcs.w	r8, r8, lr
 8015d0e:	f14c 0300 	adc.w	r3, ip, #0
 8015d12:	ebac 0303 	sub.w	r3, ip, r3
 8015d16:	f003 0c01 	and.w	ip, r3, #1
 8015d1a:	f8d2 9000 	ldr.w	r9, [r2]
 8015d1e:	f8d2 a004 	ldr.w	sl, [r2, #4]
 8015d22:	f8d2 b008 	ldr.w	fp, [r2, #8]
 8015d26:	f8d2 e00c 	ldr.w	lr, [r2, #12]
 8015d2a:	ebb9 0903 	subs.w	r9, r9, r3
 8015d2e:	eb7a 0a03 	sbcs.w	sl, sl, r3
 8015d32:	eb7b 0b03 	sbcs.w	fp, fp, r3
 8015d36:	f17e 0e00 	sbcs.w	lr, lr, #0
 8015d3a:	f174 0400 	sbcs.w	r4, r4, #0
 8015d3e:	f175 0500 	sbcs.w	r5, r5, #0
 8015d42:	eb76 060c 	sbcs.w	r6, r6, ip
 8015d46:	eb68 0803 	sbc.w	r8, r8, r3
 8015d4a:	f8c2 9000 	str.w	r9, [r2]
 8015d4e:	f8c2 a004 	str.w	sl, [r2, #4]
 8015d52:	f8c2 b008 	str.w	fp, [r2, #8]
 8015d56:	f8c2 e00c 	str.w	lr, [r2, #12]
 8015d5a:	6114      	str	r4, [r2, #16]
 8015d5c:	6155      	str	r5, [r2, #20]
 8015d5e:	6196      	str	r6, [r2, #24]
 8015d60:	f8c2 801c 	str.w	r8, [r2, #28]
        "str   r8, [%[r],#28]\n\t"
        :
        : [r] "r" (r), [a] "r" (a), [b] "r" (b)
        : "memory", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r14", "r3", "r12"
    );
}
 8015d64:	bf00      	nop
 8015d66:	3714      	adds	r7, #20
 8015d68:	46bd      	mov	sp, r7
 8015d6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08015d6e <sp_256_mont_dbl_8>:
 * r   Result of doubling.
 * a   Number to double in Montogmery form.
 * m   Modulus (prime).
 */
SP_NOINLINE static void sp_256_mont_dbl_8(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
 8015d6e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015d72:	b085      	sub	sp, #20
 8015d74:	af00      	add	r7, sp, #0
 8015d76:	60f8      	str	r0, [r7, #12]
 8015d78:	60b9      	str	r1, [r7, #8]
 8015d7a:	607a      	str	r2, [r7, #4]
    (void)m;

    __asm__ __volatile__ (
 8015d7c:	68fa      	ldr	r2, [r7, #12]
 8015d7e:	68b9      	ldr	r1, [r7, #8]
 8015d80:	f04f 0c00 	mov.w	ip, #0
 8015d84:	680c      	ldr	r4, [r1, #0]
 8015d86:	684d      	ldr	r5, [r1, #4]
 8015d88:	688e      	ldr	r6, [r1, #8]
 8015d8a:	f8d1 800c 	ldr.w	r8, [r1, #12]
 8015d8e:	f8d1 9010 	ldr.w	r9, [r1, #16]
 8015d92:	f8d1 a014 	ldr.w	sl, [r1, #20]
 8015d96:	f8d1 b018 	ldr.w	fp, [r1, #24]
 8015d9a:	f8d1 e01c 	ldr.w	lr, [r1, #28]
 8015d9e:	1924      	adds	r4, r4, r4
 8015da0:	416d      	adcs	r5, r5
 8015da2:	4176      	adcs	r6, r6
 8015da4:	eb58 0808 	adcs.w	r8, r8, r8
 8015da8:	eb59 0909 	adcs.w	r9, r9, r9
 8015dac:	eb5a 0a0a 	adcs.w	sl, sl, sl
 8015db0:	eb5b 0b0b 	adcs.w	fp, fp, fp
 8015db4:	eb5e 0e0e 	adcs.w	lr, lr, lr
 8015db8:	f14c 0300 	adc.w	r3, ip, #0
 8015dbc:	ebac 0303 	sub.w	r3, ip, r3
 8015dc0:	f003 0c01 	and.w	ip, r3, #1
 8015dc4:	1ae4      	subs	r4, r4, r3
 8015dc6:	419d      	sbcs	r5, r3
 8015dc8:	419e      	sbcs	r6, r3
 8015dca:	f178 0800 	sbcs.w	r8, r8, #0
 8015dce:	f179 0900 	sbcs.w	r9, r9, #0
 8015dd2:	f17a 0a00 	sbcs.w	sl, sl, #0
 8015dd6:	eb7b 0b0c 	sbcs.w	fp, fp, ip
 8015dda:	eb6e 0e03 	sbc.w	lr, lr, r3
 8015dde:	6014      	str	r4, [r2, #0]
 8015de0:	6055      	str	r5, [r2, #4]
 8015de2:	6096      	str	r6, [r2, #8]
 8015de4:	f8c2 800c 	str.w	r8, [r2, #12]
 8015de8:	f8c2 9010 	str.w	r9, [r2, #16]
 8015dec:	f8c2 a014 	str.w	sl, [r2, #20]
 8015df0:	f8c2 b018 	str.w	fp, [r2, #24]
 8015df4:	f8c2 e01c 	str.w	lr, [r2, #28]
        "str   r14, [%[r],#28]\n\t"
        :
        : [r] "r" (r), [a] "r" (a)
        : "memory", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r14", "r3", "r12"
    );
}
 8015df8:	bf00      	nop
 8015dfa:	3714      	adds	r7, #20
 8015dfc:	46bd      	mov	sp, r7
 8015dfe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08015e02 <sp_256_mont_tpl_8>:
 * r   Result of Tripling.
 * a   Number to triple in Montogmery form.
 * m   Modulus (prime).
 */
SP_NOINLINE static void sp_256_mont_tpl_8(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
 8015e02:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015e06:	b085      	sub	sp, #20
 8015e08:	af00      	add	r7, sp, #0
 8015e0a:	60f8      	str	r0, [r7, #12]
 8015e0c:	60b9      	str	r1, [r7, #8]
 8015e0e:	607a      	str	r2, [r7, #4]
    (void)m;

    __asm__ __volatile__ (
 8015e10:	68f9      	ldr	r1, [r7, #12]
 8015e12:	68b8      	ldr	r0, [r7, #8]
 8015e14:	6802      	ldr	r2, [r0, #0]
 8015e16:	6843      	ldr	r3, [r0, #4]
 8015e18:	6884      	ldr	r4, [r0, #8]
 8015e1a:	68c5      	ldr	r5, [r0, #12]
 8015e1c:	6906      	ldr	r6, [r0, #16]
 8015e1e:	f8d0 8014 	ldr.w	r8, [r0, #20]
 8015e22:	f8d0 9018 	ldr.w	r9, [r0, #24]
 8015e26:	f8d0 a01c 	ldr.w	sl, [r0, #28]
 8015e2a:	1892      	adds	r2, r2, r2
 8015e2c:	415b      	adcs	r3, r3
 8015e2e:	4164      	adcs	r4, r4
 8015e30:	416d      	adcs	r5, r5
 8015e32:	4176      	adcs	r6, r6
 8015e34:	eb58 0808 	adcs.w	r8, r8, r8
 8015e38:	eb59 0909 	adcs.w	r9, r9, r9
 8015e3c:	eb5a 0a0a 	adcs.w	sl, sl, sl
 8015e40:	f04f 0b00 	mov.w	fp, #0
 8015e44:	f04f 0e00 	mov.w	lr, #0
 8015e48:	eb4b 0b0b 	adc.w	fp, fp, fp
 8015e4c:	46dc      	mov	ip, fp
 8015e4e:	f1ab 0b01 	sub.w	fp, fp, #1
 8015e52:	ea6f 0b0b 	mvn.w	fp, fp
 8015e56:	ebb2 020b 	subs.w	r2, r2, fp
 8015e5a:	eb73 030b 	sbcs.w	r3, r3, fp
 8015e5e:	eb74 040b 	sbcs.w	r4, r4, fp
 8015e62:	eb75 050e 	sbcs.w	r5, r5, lr
 8015e66:	eb76 060e 	sbcs.w	r6, r6, lr
 8015e6a:	eb78 080e 	sbcs.w	r8, r8, lr
 8015e6e:	eb79 090c 	sbcs.w	r9, r9, ip
 8015e72:	eb6a 0a0b 	sbc.w	sl, sl, fp
 8015e76:	f8d0 c000 	ldr.w	ip, [r0]
 8015e7a:	f8d0 e004 	ldr.w	lr, [r0, #4]
 8015e7e:	eb12 020c 	adds.w	r2, r2, ip
 8015e82:	eb53 030e 	adcs.w	r3, r3, lr
 8015e86:	f8d0 c008 	ldr.w	ip, [r0, #8]
 8015e8a:	f8d0 e00c 	ldr.w	lr, [r0, #12]
 8015e8e:	eb54 040c 	adcs.w	r4, r4, ip
 8015e92:	eb55 050e 	adcs.w	r5, r5, lr
 8015e96:	f8d0 c010 	ldr.w	ip, [r0, #16]
 8015e9a:	f8d0 e014 	ldr.w	lr, [r0, #20]
 8015e9e:	eb56 060c 	adcs.w	r6, r6, ip
 8015ea2:	eb58 080e 	adcs.w	r8, r8, lr
 8015ea6:	f8d0 c018 	ldr.w	ip, [r0, #24]
 8015eaa:	f8d0 e01c 	ldr.w	lr, [r0, #28]
 8015eae:	eb59 090c 	adcs.w	r9, r9, ip
 8015eb2:	eb5a 0a0e 	adcs.w	sl, sl, lr
 8015eb6:	f04f 0b00 	mov.w	fp, #0
 8015eba:	f04f 0e00 	mov.w	lr, #0
 8015ebe:	eb4b 0b0b 	adc.w	fp, fp, fp
 8015ec2:	46dc      	mov	ip, fp
 8015ec4:	f1ab 0b01 	sub.w	fp, fp, #1
 8015ec8:	ea6f 0b0b 	mvn.w	fp, fp
 8015ecc:	ebb2 020b 	subs.w	r2, r2, fp
 8015ed0:	600a      	str	r2, [r1, #0]
 8015ed2:	eb73 030b 	sbcs.w	r3, r3, fp
 8015ed6:	604b      	str	r3, [r1, #4]
 8015ed8:	eb74 040b 	sbcs.w	r4, r4, fp
 8015edc:	608c      	str	r4, [r1, #8]
 8015ede:	eb75 050e 	sbcs.w	r5, r5, lr
 8015ee2:	60cd      	str	r5, [r1, #12]
 8015ee4:	eb76 060e 	sbcs.w	r6, r6, lr
 8015ee8:	610e      	str	r6, [r1, #16]
 8015eea:	eb78 080e 	sbcs.w	r8, r8, lr
 8015eee:	f8c1 8014 	str.w	r8, [r1, #20]
 8015ef2:	eb79 090c 	sbcs.w	r9, r9, ip
 8015ef6:	f8c1 9018 	str.w	r9, [r1, #24]
 8015efa:	eb6a 0a0b 	sbc.w	sl, sl, fp
 8015efe:	f8c1 a01c 	str.w	sl, [r1, #28]
        "str	r10, [%[r],#28]\n\t"
        :
        : [r] "r" (r), [a] "r" (a)
        : "memory", "r11", "r12", "r14", "r2", "r3", "r4", "r5", "r6", "r8", "r9", "r10"
    );
}
 8015f02:	bf00      	nop
 8015f04:	3714      	adds	r7, #20
 8015f06:	46bd      	mov	sp, r7
 8015f08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08015f0c <sp_256_mont_sub_8>:
 * b   Number to subtract with in Montogmery form.
 * m   Modulus (prime).
 */
SP_NOINLINE static void sp_256_mont_sub_8(sp_digit* r, const sp_digit* a, const sp_digit* b,
        const sp_digit* m)
{
 8015f0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015f10:	b085      	sub	sp, #20
 8015f12:	af00      	add	r7, sp, #0
 8015f14:	60f8      	str	r0, [r7, #12]
 8015f16:	60b9      	str	r1, [r7, #8]
 8015f18:	607a      	str	r2, [r7, #4]
 8015f1a:	603b      	str	r3, [r7, #0]
    (void)m;

    __asm__ __volatile__ (
 8015f1c:	68fa      	ldr	r2, [r7, #12]
 8015f1e:	68b9      	ldr	r1, [r7, #8]
 8015f20:	6878      	ldr	r0, [r7, #4]
 8015f22:	f04f 0c00 	mov.w	ip, #0
 8015f26:	680c      	ldr	r4, [r1, #0]
 8015f28:	684d      	ldr	r5, [r1, #4]
 8015f2a:	688e      	ldr	r6, [r1, #8]
 8015f2c:	f8d1 800c 	ldr.w	r8, [r1, #12]
 8015f30:	f8d0 9000 	ldr.w	r9, [r0]
 8015f34:	f8d0 a004 	ldr.w	sl, [r0, #4]
 8015f38:	f8d0 b008 	ldr.w	fp, [r0, #8]
 8015f3c:	f8d0 e00c 	ldr.w	lr, [r0, #12]
 8015f40:	ebb4 0409 	subs.w	r4, r4, r9
 8015f44:	eb75 050a 	sbcs.w	r5, r5, sl
 8015f48:	eb76 060b 	sbcs.w	r6, r6, fp
 8015f4c:	eb78 080e 	sbcs.w	r8, r8, lr
 8015f50:	6014      	str	r4, [r2, #0]
 8015f52:	6055      	str	r5, [r2, #4]
 8015f54:	6096      	str	r6, [r2, #8]
 8015f56:	f8c2 800c 	str.w	r8, [r2, #12]
 8015f5a:	690c      	ldr	r4, [r1, #16]
 8015f5c:	694d      	ldr	r5, [r1, #20]
 8015f5e:	698e      	ldr	r6, [r1, #24]
 8015f60:	f8d1 801c 	ldr.w	r8, [r1, #28]
 8015f64:	f8d0 9010 	ldr.w	r9, [r0, #16]
 8015f68:	f8d0 a014 	ldr.w	sl, [r0, #20]
 8015f6c:	f8d0 b018 	ldr.w	fp, [r0, #24]
 8015f70:	f8d0 e01c 	ldr.w	lr, [r0, #28]
 8015f74:	eb74 0409 	sbcs.w	r4, r4, r9
 8015f78:	eb75 050a 	sbcs.w	r5, r5, sl
 8015f7c:	eb76 060b 	sbcs.w	r6, r6, fp
 8015f80:	eb78 080e 	sbcs.w	r8, r8, lr
 8015f84:	f16c 0300 	sbc.w	r3, ip, #0
 8015f88:	f003 0c01 	and.w	ip, r3, #1
 8015f8c:	f8d2 9000 	ldr.w	r9, [r2]
 8015f90:	f8d2 a004 	ldr.w	sl, [r2, #4]
 8015f94:	f8d2 b008 	ldr.w	fp, [r2, #8]
 8015f98:	f8d2 e00c 	ldr.w	lr, [r2, #12]
 8015f9c:	eb19 0903 	adds.w	r9, r9, r3
 8015fa0:	eb5a 0a03 	adcs.w	sl, sl, r3
 8015fa4:	eb5b 0b03 	adcs.w	fp, fp, r3
 8015fa8:	f15e 0e00 	adcs.w	lr, lr, #0
 8015fac:	f154 0400 	adcs.w	r4, r4, #0
 8015fb0:	f155 0500 	adcs.w	r5, r5, #0
 8015fb4:	eb56 060c 	adcs.w	r6, r6, ip
 8015fb8:	eb48 0803 	adc.w	r8, r8, r3
 8015fbc:	f8c2 9000 	str.w	r9, [r2]
 8015fc0:	f8c2 a004 	str.w	sl, [r2, #4]
 8015fc4:	f8c2 b008 	str.w	fp, [r2, #8]
 8015fc8:	f8c2 e00c 	str.w	lr, [r2, #12]
 8015fcc:	6114      	str	r4, [r2, #16]
 8015fce:	6155      	str	r5, [r2, #20]
 8015fd0:	6196      	str	r6, [r2, #24]
 8015fd2:	f8c2 801c 	str.w	r8, [r2, #28]
        "str   r8, [%[r],#28]\n\t"
        :
        : [r] "r" (r), [a] "r" (a), [b] "r" (b)
        : "memory", "r4", "r5", "r6", "r8", "r9", "r10", "r11", "r14", "r3", "r12"
    );
}
 8015fd6:	bf00      	nop
 8015fd8:	3714      	adds	r7, #20
 8015fda:	46bd      	mov	sp, r7
 8015fdc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08015fe0 <sp_256_div2_8>:
 * r  Result of division by 2.
 * a  Number to divide.
 * m  Modulus (prime).
 */
SP_NOINLINE static void sp_256_div2_8(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
 8015fe0:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 8015fe4:	b085      	sub	sp, #20
 8015fe6:	af00      	add	r7, sp, #0
 8015fe8:	60f8      	str	r0, [r7, #12]
 8015fea:	60b9      	str	r1, [r7, #8]
 8015fec:	607a      	str	r2, [r7, #4]
    __asm__ __volatile__ (
 8015fee:	68fa      	ldr	r2, [r7, #12]
 8015ff0:	68b9      	ldr	r1, [r7, #8]
 8015ff2:	6878      	ldr	r0, [r7, #4]
 8015ff4:	f8d1 8000 	ldr.w	r8, [r1]
 8015ff8:	ea4f 78c8 	mov.w	r8, r8, lsl #31
 8015ffc:	ea4f 78d8 	mov.w	r8, r8, lsr #31
 8016000:	f04f 0500 	mov.w	r5, #0
 8016004:	eba5 0508 	sub.w	r5, r5, r8
 8016008:	f04f 0800 	mov.w	r8, #0
 801600c:	ea4f 76c5 	mov.w	r6, r5, lsl #31
 8016010:	ea4f 76d6 	mov.w	r6, r6, lsr #31
 8016014:	680b      	ldr	r3, [r1, #0]
 8016016:	684c      	ldr	r4, [r1, #4]
 8016018:	195b      	adds	r3, r3, r5
 801601a:	416c      	adcs	r4, r5
 801601c:	6013      	str	r3, [r2, #0]
 801601e:	6054      	str	r4, [r2, #4]
 8016020:	688b      	ldr	r3, [r1, #8]
 8016022:	68cc      	ldr	r4, [r1, #12]
 8016024:	416b      	adcs	r3, r5
 8016026:	eb54 0408 	adcs.w	r4, r4, r8
 801602a:	6093      	str	r3, [r2, #8]
 801602c:	60d4      	str	r4, [r2, #12]
 801602e:	690b      	ldr	r3, [r1, #16]
 8016030:	694c      	ldr	r4, [r1, #20]
 8016032:	eb53 0308 	adcs.w	r3, r3, r8
 8016036:	eb54 0408 	adcs.w	r4, r4, r8
 801603a:	6113      	str	r3, [r2, #16]
 801603c:	6154      	str	r4, [r2, #20]
 801603e:	698b      	ldr	r3, [r1, #24]
 8016040:	69cc      	ldr	r4, [r1, #28]
 8016042:	4173      	adcs	r3, r6
 8016044:	416c      	adcs	r4, r5
 8016046:	eb48 0808 	adc.w	r8, r8, r8
 801604a:	ea4f 78c8 	mov.w	r8, r8, lsl #31
 801604e:	ea4f 0553 	mov.w	r5, r3, lsr #1
 8016052:	ea4f 73c3 	mov.w	r3, r3, lsl #31
 8016056:	ea4f 0654 	mov.w	r6, r4, lsr #1
 801605a:	ea4f 74c4 	mov.w	r4, r4, lsl #31
 801605e:	ea45 0504 	orr.w	r5, r5, r4
 8016062:	ea46 0608 	orr.w	r6, r6, r8
 8016066:	4698      	mov	r8, r3
 8016068:	6195      	str	r5, [r2, #24]
 801606a:	61d6      	str	r6, [r2, #28]
 801606c:	690b      	ldr	r3, [r1, #16]
 801606e:	694c      	ldr	r4, [r1, #20]
 8016070:	ea4f 0553 	mov.w	r5, r3, lsr #1
 8016074:	ea4f 73c3 	mov.w	r3, r3, lsl #31
 8016078:	ea4f 0654 	mov.w	r6, r4, lsr #1
 801607c:	ea4f 74c4 	mov.w	r4, r4, lsl #31
 8016080:	ea45 0504 	orr.w	r5, r5, r4
 8016084:	ea46 0608 	orr.w	r6, r6, r8
 8016088:	4698      	mov	r8, r3
 801608a:	6115      	str	r5, [r2, #16]
 801608c:	6156      	str	r6, [r2, #20]
 801608e:	688b      	ldr	r3, [r1, #8]
 8016090:	68cc      	ldr	r4, [r1, #12]
 8016092:	ea4f 0553 	mov.w	r5, r3, lsr #1
 8016096:	ea4f 73c3 	mov.w	r3, r3, lsl #31
 801609a:	ea4f 0654 	mov.w	r6, r4, lsr #1
 801609e:	ea4f 74c4 	mov.w	r4, r4, lsl #31
 80160a2:	ea45 0504 	orr.w	r5, r5, r4
 80160a6:	ea46 0608 	orr.w	r6, r6, r8
 80160aa:	4698      	mov	r8, r3
 80160ac:	6095      	str	r5, [r2, #8]
 80160ae:	60d6      	str	r6, [r2, #12]
 80160b0:	6813      	ldr	r3, [r2, #0]
 80160b2:	6854      	ldr	r4, [r2, #4]
 80160b4:	ea4f 0553 	mov.w	r5, r3, lsr #1
 80160b8:	ea4f 0654 	mov.w	r6, r4, lsr #1
 80160bc:	ea4f 74c4 	mov.w	r4, r4, lsl #31
 80160c0:	ea45 0504 	orr.w	r5, r5, r4
 80160c4:	ea46 0608 	orr.w	r6, r6, r8
 80160c8:	6015      	str	r5, [r2, #0]
 80160ca:	6056      	str	r6, [r2, #4]
        "str	r6, [%[r], #4]\n\t"
        :
        : [r] "r" (r), [a] "r" (a), [m] "r" (m)
        : "memory", "r3", "r4", "r5", "r6", "r8"
    );
}
 80160cc:	bf00      	nop
 80160ce:	3714      	adds	r7, #20
 80160d0:	46bd      	mov	sp, r7
 80160d2:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 80160d6:	4770      	bx	lr

080160d8 <sp_256_proj_point_dbl_8>:
    return err;
}
#endif /* WOLFSSL_SP_NONBLOCK */

static void sp_256_proj_point_dbl_8(sp_point_256* r, const sp_point_256* p, sp_digit* t)
{
 80160d8:	b580      	push	{r7, lr}
 80160da:	b08c      	sub	sp, #48	; 0x30
 80160dc:	af02      	add	r7, sp, #8
 80160de:	60f8      	str	r0, [r7, #12]
 80160e0:	60b9      	str	r1, [r7, #8]
 80160e2:	607a      	str	r2, [r7, #4]
    sp_digit* t1 = t;
 80160e4:	687b      	ldr	r3, [r7, #4]
 80160e6:	627b      	str	r3, [r7, #36]	; 0x24
    sp_digit* t2 = t + 2*8;
 80160e8:	687b      	ldr	r3, [r7, #4]
 80160ea:	3340      	adds	r3, #64	; 0x40
 80160ec:	623b      	str	r3, [r7, #32]
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;

    x = r->x;
 80160ee:	68fb      	ldr	r3, [r7, #12]
 80160f0:	61fb      	str	r3, [r7, #28]
    y = r->y;
 80160f2:	68fb      	ldr	r3, [r7, #12]
 80160f4:	3340      	adds	r3, #64	; 0x40
 80160f6:	61bb      	str	r3, [r7, #24]
    z = r->z;
 80160f8:	68fb      	ldr	r3, [r7, #12]
 80160fa:	3380      	adds	r3, #128	; 0x80
 80160fc:	617b      	str	r3, [r7, #20]
    /* Put infinity into result. */
    if (r != p) {
 80160fe:	68fa      	ldr	r2, [r7, #12]
 8016100:	68bb      	ldr	r3, [r7, #8]
 8016102:	429a      	cmp	r2, r3
 8016104:	d005      	beq.n	8016112 <sp_256_proj_point_dbl_8+0x3a>
        r->infinity = p->infinity;
 8016106:	68bb      	ldr	r3, [r7, #8]
 8016108:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 801610c:	68fb      	ldr	r3, [r7, #12]
 801610e:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    }

    /* T1 = Z * Z */
    sp_256_mont_sqr_8(t1, p->z, p256_mod, p256_mp_mod);
 8016112:	68bb      	ldr	r3, [r7, #8]
 8016114:	f103 0180 	add.w	r1, r3, #128	; 0x80
 8016118:	2301      	movs	r3, #1
 801611a:	4a3c      	ldr	r2, [pc, #240]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 801611c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801611e:	f7ff f83a 	bl	8015196 <sp_256_mont_sqr_8>
    /* Z = Y * Z */
    sp_256_mont_mul_8(z, p->y, p->z, p256_mod, p256_mp_mod);
 8016122:	68bb      	ldr	r3, [r7, #8]
 8016124:	f103 0140 	add.w	r1, r3, #64	; 0x40
 8016128:	68bb      	ldr	r3, [r7, #8]
 801612a:	f103 0280 	add.w	r2, r3, #128	; 0x80
 801612e:	2301      	movs	r3, #1
 8016130:	9300      	str	r3, [sp, #0]
 8016132:	4b36      	ldr	r3, [pc, #216]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 8016134:	6978      	ldr	r0, [r7, #20]
 8016136:	f7fe fc48 	bl	80149ca <sp_256_mont_mul_8>
    /* Z = 2Z */
    sp_256_mont_dbl_8(z, z, p256_mod);
 801613a:	4a34      	ldr	r2, [pc, #208]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 801613c:	6979      	ldr	r1, [r7, #20]
 801613e:	6978      	ldr	r0, [r7, #20]
 8016140:	f7ff fe15 	bl	8015d6e <sp_256_mont_dbl_8>
    /* T2 = X - T1 */
    sp_256_mont_sub_8(t2, p->x, t1, p256_mod);
 8016144:	68b9      	ldr	r1, [r7, #8]
 8016146:	4b31      	ldr	r3, [pc, #196]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 8016148:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801614a:	6a38      	ldr	r0, [r7, #32]
 801614c:	f7ff fede 	bl	8015f0c <sp_256_mont_sub_8>
    /* T1 = X + T1 */
    sp_256_mont_add_8(t1, p->x, t1, p256_mod);
 8016150:	68b9      	ldr	r1, [r7, #8]
 8016152:	4b2e      	ldr	r3, [pc, #184]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 8016154:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016156:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8016158:	f7ff fd9d 	bl	8015c96 <sp_256_mont_add_8>
    /* T2 = T1 * T2 */
    sp_256_mont_mul_8(t2, t1, t2, p256_mod, p256_mp_mod);
 801615c:	2301      	movs	r3, #1
 801615e:	9300      	str	r3, [sp, #0]
 8016160:	4b2a      	ldr	r3, [pc, #168]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 8016162:	6a3a      	ldr	r2, [r7, #32]
 8016164:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8016166:	6a38      	ldr	r0, [r7, #32]
 8016168:	f7fe fc2f 	bl	80149ca <sp_256_mont_mul_8>
    /* T1 = 3T2 */
    sp_256_mont_tpl_8(t1, t2, p256_mod);
 801616c:	4a27      	ldr	r2, [pc, #156]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 801616e:	6a39      	ldr	r1, [r7, #32]
 8016170:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8016172:	f7ff fe46 	bl	8015e02 <sp_256_mont_tpl_8>
    /* Y = 2Y */
    sp_256_mont_dbl_8(y, p->y, p256_mod);
 8016176:	68bb      	ldr	r3, [r7, #8]
 8016178:	3340      	adds	r3, #64	; 0x40
 801617a:	4a24      	ldr	r2, [pc, #144]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 801617c:	4619      	mov	r1, r3
 801617e:	69b8      	ldr	r0, [r7, #24]
 8016180:	f7ff fdf5 	bl	8015d6e <sp_256_mont_dbl_8>
    /* Y = Y * Y */
    sp_256_mont_sqr_8(y, y, p256_mod, p256_mp_mod);
 8016184:	2301      	movs	r3, #1
 8016186:	4a21      	ldr	r2, [pc, #132]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 8016188:	69b9      	ldr	r1, [r7, #24]
 801618a:	69b8      	ldr	r0, [r7, #24]
 801618c:	f7ff f803 	bl	8015196 <sp_256_mont_sqr_8>
    /* T2 = Y * Y */
    sp_256_mont_sqr_8(t2, y, p256_mod, p256_mp_mod);
 8016190:	2301      	movs	r3, #1
 8016192:	4a1e      	ldr	r2, [pc, #120]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 8016194:	69b9      	ldr	r1, [r7, #24]
 8016196:	6a38      	ldr	r0, [r7, #32]
 8016198:	f7fe fffd 	bl	8015196 <sp_256_mont_sqr_8>
    /* T2 = T2/2 */
    sp_256_div2_8(t2, t2, p256_mod);
 801619c:	4a1b      	ldr	r2, [pc, #108]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 801619e:	6a39      	ldr	r1, [r7, #32]
 80161a0:	6a38      	ldr	r0, [r7, #32]
 80161a2:	f7ff ff1d 	bl	8015fe0 <sp_256_div2_8>
    /* Y = Y * X */
    sp_256_mont_mul_8(y, y, p->x, p256_mod, p256_mp_mod);
 80161a6:	68ba      	ldr	r2, [r7, #8]
 80161a8:	2301      	movs	r3, #1
 80161aa:	9300      	str	r3, [sp, #0]
 80161ac:	4b17      	ldr	r3, [pc, #92]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 80161ae:	69b9      	ldr	r1, [r7, #24]
 80161b0:	69b8      	ldr	r0, [r7, #24]
 80161b2:	f7fe fc0a 	bl	80149ca <sp_256_mont_mul_8>
    /* X = T1 * T1 */
    sp_256_mont_sqr_8(x, t1, p256_mod, p256_mp_mod);
 80161b6:	2301      	movs	r3, #1
 80161b8:	4a14      	ldr	r2, [pc, #80]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 80161ba:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80161bc:	69f8      	ldr	r0, [r7, #28]
 80161be:	f7fe ffea 	bl	8015196 <sp_256_mont_sqr_8>
    /* X = X - Y */
    sp_256_mont_sub_8(x, x, y, p256_mod);
 80161c2:	4b12      	ldr	r3, [pc, #72]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 80161c4:	69ba      	ldr	r2, [r7, #24]
 80161c6:	69f9      	ldr	r1, [r7, #28]
 80161c8:	69f8      	ldr	r0, [r7, #28]
 80161ca:	f7ff fe9f 	bl	8015f0c <sp_256_mont_sub_8>
    /* X = X - Y */
    sp_256_mont_sub_8(x, x, y, p256_mod);
 80161ce:	4b0f      	ldr	r3, [pc, #60]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 80161d0:	69ba      	ldr	r2, [r7, #24]
 80161d2:	69f9      	ldr	r1, [r7, #28]
 80161d4:	69f8      	ldr	r0, [r7, #28]
 80161d6:	f7ff fe99 	bl	8015f0c <sp_256_mont_sub_8>
    /* Y = Y - X */
    sp_256_mont_sub_8(y, y, x, p256_mod);
 80161da:	4b0c      	ldr	r3, [pc, #48]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 80161dc:	69fa      	ldr	r2, [r7, #28]
 80161de:	69b9      	ldr	r1, [r7, #24]
 80161e0:	69b8      	ldr	r0, [r7, #24]
 80161e2:	f7ff fe93 	bl	8015f0c <sp_256_mont_sub_8>
    /* Y = Y * T1 */
    sp_256_mont_mul_8(y, y, t1, p256_mod, p256_mp_mod);
 80161e6:	2301      	movs	r3, #1
 80161e8:	9300      	str	r3, [sp, #0]
 80161ea:	4b08      	ldr	r3, [pc, #32]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 80161ec:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80161ee:	69b9      	ldr	r1, [r7, #24]
 80161f0:	69b8      	ldr	r0, [r7, #24]
 80161f2:	f7fe fbea 	bl	80149ca <sp_256_mont_mul_8>
    /* Y = Y - T2 */
    sp_256_mont_sub_8(y, y, t2, p256_mod);
 80161f6:	4b05      	ldr	r3, [pc, #20]	; (801620c <sp_256_proj_point_dbl_8+0x134>)
 80161f8:	6a3a      	ldr	r2, [r7, #32]
 80161fa:	69b9      	ldr	r1, [r7, #24]
 80161fc:	69b8      	ldr	r0, [r7, #24]
 80161fe:	f7ff fe85 	bl	8015f0c <sp_256_mont_sub_8>
}
 8016202:	bf00      	nop
 8016204:	3728      	adds	r7, #40	; 0x28
 8016206:	46bd      	mov	sp, r7
 8016208:	bd80      	pop	{r7, pc}
 801620a:	bf00      	nop
 801620c:	0801aef4 	.word	0x0801aef4

08016210 <sp_256_sub_8>:
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static sp_digit sp_256_sub_8(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
 8016210:	b4f0      	push	{r4, r5, r6, r7}
 8016212:	b086      	sub	sp, #24
 8016214:	af00      	add	r7, sp, #0
 8016216:	60f8      	str	r0, [r7, #12]
 8016218:	60b9      	str	r1, [r7, #8]
 801621a:	607a      	str	r2, [r7, #4]
    sp_digit c = 0;
 801621c:	2300      	movs	r3, #0
 801621e:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 8016220:	6978      	ldr	r0, [r7, #20]
 8016222:	68f9      	ldr	r1, [r7, #12]
 8016224:	68ba      	ldr	r2, [r7, #8]
 8016226:	687b      	ldr	r3, [r7, #4]
 8016228:	4616      	mov	r6, r2
 801622a:	f106 0620 	add.w	r6, r6, #32
 801622e:	f04f 0500 	mov.w	r5, #0
 8016232:	1a2d      	subs	r5, r5, r0
 8016234:	6814      	ldr	r4, [r2, #0]
 8016236:	681d      	ldr	r5, [r3, #0]
 8016238:	41ac      	sbcs	r4, r5
 801623a:	600c      	str	r4, [r1, #0]
 801623c:	eb60 0000 	sbc.w	r0, r0, r0
 8016240:	f102 0204 	add.w	r2, r2, #4
 8016244:	f103 0304 	add.w	r3, r3, #4
 8016248:	f101 0104 	add.w	r1, r1, #4
 801624c:	42b2      	cmp	r2, r6
 801624e:	d1ee      	bne.n	801622e <sp_256_sub_8+0x1e>
 8016250:	6178      	str	r0, [r7, #20]
 8016252:	60f9      	str	r1, [r7, #12]
 8016254:	60ba      	str	r2, [r7, #8]
 8016256:	607b      	str	r3, [r7, #4]
        : [c] "+r" (c), [r] "+r" (r), [a] "+r" (a), [b] "+r" (b)
        :
        : "memory", "r4", "r5", "r6"
    );

    return c;
 8016258:	697b      	ldr	r3, [r7, #20]
}
 801625a:	4618      	mov	r0, r3
 801625c:	3718      	adds	r7, #24
 801625e:	46bd      	mov	sp, r7
 8016260:	bcf0      	pop	{r4, r5, r6, r7}
 8016262:	4770      	bx	lr

08016264 <sp_256_cmp_equal_8>:
 * a  First number to compare.
 * b  Second number to compare.
 * returns 1 when equal and 0 otherwise.
 */
static int sp_256_cmp_equal_8(const sp_digit* a, const sp_digit* b)
{
 8016264:	b480      	push	{r7}
 8016266:	b083      	sub	sp, #12
 8016268:	af00      	add	r7, sp, #0
 801626a:	6078      	str	r0, [r7, #4]
 801626c:	6039      	str	r1, [r7, #0]
    return ((a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2]) | (a[3] ^ b[3]) |
 801626e:	687b      	ldr	r3, [r7, #4]
 8016270:	681a      	ldr	r2, [r3, #0]
 8016272:	683b      	ldr	r3, [r7, #0]
 8016274:	681b      	ldr	r3, [r3, #0]
 8016276:	405a      	eors	r2, r3
 8016278:	687b      	ldr	r3, [r7, #4]
 801627a:	3304      	adds	r3, #4
 801627c:	6819      	ldr	r1, [r3, #0]
 801627e:	683b      	ldr	r3, [r7, #0]
 8016280:	3304      	adds	r3, #4
 8016282:	681b      	ldr	r3, [r3, #0]
 8016284:	404b      	eors	r3, r1
 8016286:	431a      	orrs	r2, r3
 8016288:	687b      	ldr	r3, [r7, #4]
 801628a:	3308      	adds	r3, #8
 801628c:	6819      	ldr	r1, [r3, #0]
 801628e:	683b      	ldr	r3, [r7, #0]
 8016290:	3308      	adds	r3, #8
 8016292:	681b      	ldr	r3, [r3, #0]
 8016294:	404b      	eors	r3, r1
 8016296:	431a      	orrs	r2, r3
 8016298:	687b      	ldr	r3, [r7, #4]
 801629a:	330c      	adds	r3, #12
 801629c:	6819      	ldr	r1, [r3, #0]
 801629e:	683b      	ldr	r3, [r7, #0]
 80162a0:	330c      	adds	r3, #12
 80162a2:	681b      	ldr	r3, [r3, #0]
 80162a4:	404b      	eors	r3, r1
 80162a6:	431a      	orrs	r2, r3
            (a[4] ^ b[4]) | (a[5] ^ b[5]) | (a[6] ^ b[6]) | (a[7] ^ b[7])) == 0;
 80162a8:	687b      	ldr	r3, [r7, #4]
 80162aa:	3310      	adds	r3, #16
 80162ac:	6819      	ldr	r1, [r3, #0]
 80162ae:	683b      	ldr	r3, [r7, #0]
 80162b0:	3310      	adds	r3, #16
 80162b2:	681b      	ldr	r3, [r3, #0]
 80162b4:	404b      	eors	r3, r1
    return ((a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2]) | (a[3] ^ b[3]) |
 80162b6:	431a      	orrs	r2, r3
            (a[4] ^ b[4]) | (a[5] ^ b[5]) | (a[6] ^ b[6]) | (a[7] ^ b[7])) == 0;
 80162b8:	687b      	ldr	r3, [r7, #4]
 80162ba:	3314      	adds	r3, #20
 80162bc:	6819      	ldr	r1, [r3, #0]
 80162be:	683b      	ldr	r3, [r7, #0]
 80162c0:	3314      	adds	r3, #20
 80162c2:	681b      	ldr	r3, [r3, #0]
 80162c4:	404b      	eors	r3, r1
 80162c6:	431a      	orrs	r2, r3
 80162c8:	687b      	ldr	r3, [r7, #4]
 80162ca:	3318      	adds	r3, #24
 80162cc:	6819      	ldr	r1, [r3, #0]
 80162ce:	683b      	ldr	r3, [r7, #0]
 80162d0:	3318      	adds	r3, #24
 80162d2:	681b      	ldr	r3, [r3, #0]
 80162d4:	404b      	eors	r3, r1
 80162d6:	431a      	orrs	r2, r3
 80162d8:	687b      	ldr	r3, [r7, #4]
 80162da:	331c      	adds	r3, #28
 80162dc:	6819      	ldr	r1, [r3, #0]
 80162de:	683b      	ldr	r3, [r7, #0]
 80162e0:	331c      	adds	r3, #28
 80162e2:	681b      	ldr	r3, [r3, #0]
 80162e4:	404b      	eors	r3, r1
 80162e6:	4313      	orrs	r3, r2
 80162e8:	2b00      	cmp	r3, #0
 80162ea:	bf0c      	ite	eq
 80162ec:	2301      	moveq	r3, #1
 80162ee:	2300      	movne	r3, #0
 80162f0:	b2db      	uxtb	r3, r3
}
 80162f2:	4618      	mov	r0, r3
 80162f4:	370c      	adds	r7, #12
 80162f6:	46bd      	mov	sp, r7
 80162f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80162fc:	4770      	bx	lr
	...

08016300 <sp_256_proj_point_add_8>:
}
#endif /* WOLFSSL_SP_NONBLOCK */

static void sp_256_proj_point_add_8(sp_point_256* r, const sp_point_256* p, const sp_point_256* q,
        sp_digit* t)
{
 8016300:	b5b0      	push	{r4, r5, r7, lr}
 8016302:	b094      	sub	sp, #80	; 0x50
 8016304:	af02      	add	r7, sp, #8
 8016306:	60f8      	str	r0, [r7, #12]
 8016308:	60b9      	str	r1, [r7, #8]
 801630a:	607a      	str	r2, [r7, #4]
 801630c:	603b      	str	r3, [r7, #0]
    const sp_point_256* ap[2];
    sp_point_256* rp[2];
    sp_digit* t1 = t;
 801630e:	683b      	ldr	r3, [r7, #0]
 8016310:	643b      	str	r3, [r7, #64]	; 0x40
    sp_digit* t2 = t + 2*8;
 8016312:	683b      	ldr	r3, [r7, #0]
 8016314:	3340      	adds	r3, #64	; 0x40
 8016316:	63fb      	str	r3, [r7, #60]	; 0x3c
    sp_digit* t3 = t + 4*8;
 8016318:	683b      	ldr	r3, [r7, #0]
 801631a:	3380      	adds	r3, #128	; 0x80
 801631c:	63bb      	str	r3, [r7, #56]	; 0x38
    sp_digit* t4 = t + 6*8;
 801631e:	683b      	ldr	r3, [r7, #0]
 8016320:	33c0      	adds	r3, #192	; 0xc0
 8016322:	637b      	str	r3, [r7, #52]	; 0x34
    sp_digit* t5 = t + 8*8;
 8016324:	683b      	ldr	r3, [r7, #0]
 8016326:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801632a:	633b      	str	r3, [r7, #48]	; 0x30
    sp_digit* y;
    sp_digit* z;
    int i;

    /* Ensure only the first point is the same as the result. */
    if (q == r) {
 801632c:	687a      	ldr	r2, [r7, #4]
 801632e:	68fb      	ldr	r3, [r7, #12]
 8016330:	429a      	cmp	r2, r3
 8016332:	d105      	bne.n	8016340 <sp_256_proj_point_add_8+0x40>
        const sp_point_256* a = p;
 8016334:	68bb      	ldr	r3, [r7, #8]
 8016336:	62fb      	str	r3, [r7, #44]	; 0x2c
        p = q;
 8016338:	687b      	ldr	r3, [r7, #4]
 801633a:	60bb      	str	r3, [r7, #8]
        q = a;
 801633c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801633e:	607b      	str	r3, [r7, #4]
    }

    /* Check double */
    (void)sp_256_sub_8(t1, p256_mod, q->y);
 8016340:	687b      	ldr	r3, [r7, #4]
 8016342:	3340      	adds	r3, #64	; 0x40
 8016344:	461a      	mov	r2, r3
 8016346:	4951      	ldr	r1, [pc, #324]	; (801648c <sp_256_proj_point_add_8+0x18c>)
 8016348:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801634a:	f7ff ff61 	bl	8016210 <sp_256_sub_8>
    sp_256_norm_8(t1);
    if ((sp_256_cmp_equal_8(p->x, q->x) & sp_256_cmp_equal_8(p->z, q->z) &
 801634e:	68bb      	ldr	r3, [r7, #8]
 8016350:	687a      	ldr	r2, [r7, #4]
 8016352:	4611      	mov	r1, r2
 8016354:	4618      	mov	r0, r3
 8016356:	f7ff ff85 	bl	8016264 <sp_256_cmp_equal_8>
 801635a:	4604      	mov	r4, r0
 801635c:	68bb      	ldr	r3, [r7, #8]
 801635e:	f103 0280 	add.w	r2, r3, #128	; 0x80
 8016362:	687b      	ldr	r3, [r7, #4]
 8016364:	3380      	adds	r3, #128	; 0x80
 8016366:	4619      	mov	r1, r3
 8016368:	4610      	mov	r0, r2
 801636a:	f7ff ff7b 	bl	8016264 <sp_256_cmp_equal_8>
 801636e:	4603      	mov	r3, r0
 8016370:	401c      	ands	r4, r3
        (sp_256_cmp_equal_8(p->y, q->y) | sp_256_cmp_equal_8(p->y, t1))) != 0) {
 8016372:	68bb      	ldr	r3, [r7, #8]
 8016374:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8016378:	687b      	ldr	r3, [r7, #4]
 801637a:	3340      	adds	r3, #64	; 0x40
 801637c:	4619      	mov	r1, r3
 801637e:	4610      	mov	r0, r2
 8016380:	f7ff ff70 	bl	8016264 <sp_256_cmp_equal_8>
 8016384:	4605      	mov	r5, r0
 8016386:	68bb      	ldr	r3, [r7, #8]
 8016388:	3340      	adds	r3, #64	; 0x40
 801638a:	6c39      	ldr	r1, [r7, #64]	; 0x40
 801638c:	4618      	mov	r0, r3
 801638e:	f7ff ff69 	bl	8016264 <sp_256_cmp_equal_8>
 8016392:	4603      	mov	r3, r0
 8016394:	432b      	orrs	r3, r5
    if ((sp_256_cmp_equal_8(p->x, q->x) & sp_256_cmp_equal_8(p->z, q->z) &
 8016396:	4023      	ands	r3, r4
 8016398:	2b00      	cmp	r3, #0
 801639a:	d005      	beq.n	80163a8 <sp_256_proj_point_add_8+0xa8>
        sp_256_proj_point_dbl_8(r, p, t);
 801639c:	683a      	ldr	r2, [r7, #0]
 801639e:	68b9      	ldr	r1, [r7, #8]
 80163a0:	68f8      	ldr	r0, [r7, #12]
 80163a2:	f7ff fe99 	bl	80160d8 <sp_256_proj_point_dbl_8>
        sp_256_mont_sub_8(y, y, x, p256_mod);
        sp_256_mont_mul_8(y, y, t4, p256_mod, p256_mp_mod);
        sp_256_mont_mul_8(t5, t5, t3, p256_mod, p256_mp_mod);
        sp_256_mont_sub_8(y, y, t5, p256_mod);
    }
}
 80163a6:	e142      	b.n	801662e <sp_256_proj_point_add_8+0x32e>
        rp[0] = r;
 80163a8:	68fb      	ldr	r3, [r7, #12]
 80163aa:	613b      	str	r3, [r7, #16]
        rp[1] = (sp_point_256*)t; /*lint !e9087 !e740*/
 80163ac:	683b      	ldr	r3, [r7, #0]
 80163ae:	617b      	str	r3, [r7, #20]
        XMEMSET(rp[1], 0, sizeof(sp_point_256));
 80163b0:	697b      	ldr	r3, [r7, #20]
 80163b2:	22c4      	movs	r2, #196	; 0xc4
 80163b4:	2100      	movs	r1, #0
 80163b6:	4618      	mov	r0, r3
 80163b8:	f003 f841 	bl	801943e <memset>
        x = rp[p->infinity | q->infinity]->x;
 80163bc:	68bb      	ldr	r3, [r7, #8]
 80163be:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 80163c2:	687b      	ldr	r3, [r7, #4]
 80163c4:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 80163c8:	4313      	orrs	r3, r2
 80163ca:	009b      	lsls	r3, r3, #2
 80163cc:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80163d0:	4413      	add	r3, r2
 80163d2:	f853 3c38 	ldr.w	r3, [r3, #-56]
 80163d6:	62bb      	str	r3, [r7, #40]	; 0x28
        y = rp[p->infinity | q->infinity]->y;
 80163d8:	68bb      	ldr	r3, [r7, #8]
 80163da:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 80163de:	687b      	ldr	r3, [r7, #4]
 80163e0:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 80163e4:	4313      	orrs	r3, r2
 80163e6:	009b      	lsls	r3, r3, #2
 80163e8:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80163ec:	4413      	add	r3, r2
 80163ee:	f853 3c38 	ldr.w	r3, [r3, #-56]
 80163f2:	3340      	adds	r3, #64	; 0x40
 80163f4:	627b      	str	r3, [r7, #36]	; 0x24
        z = rp[p->infinity | q->infinity]->z;
 80163f6:	68bb      	ldr	r3, [r7, #8]
 80163f8:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 80163fc:	687b      	ldr	r3, [r7, #4]
 80163fe:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8016402:	4313      	orrs	r3, r2
 8016404:	009b      	lsls	r3, r3, #2
 8016406:	f107 0248 	add.w	r2, r7, #72	; 0x48
 801640a:	4413      	add	r3, r2
 801640c:	f853 3c38 	ldr.w	r3, [r3, #-56]
 8016410:	3380      	adds	r3, #128	; 0x80
 8016412:	623b      	str	r3, [r7, #32]
        ap[0] = p;
 8016414:	68bb      	ldr	r3, [r7, #8]
 8016416:	61bb      	str	r3, [r7, #24]
        ap[1] = q;
 8016418:	687b      	ldr	r3, [r7, #4]
 801641a:	61fb      	str	r3, [r7, #28]
        for (i=0; i<8; i++) {
 801641c:	2300      	movs	r3, #0
 801641e:	647b      	str	r3, [r7, #68]	; 0x44
 8016420:	e012      	b.n	8016448 <sp_256_proj_point_add_8+0x148>
            r->x[i] = ap[p->infinity]->x[i];
 8016422:	68bb      	ldr	r3, [r7, #8]
 8016424:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8016428:	009b      	lsls	r3, r3, #2
 801642a:	f107 0248 	add.w	r2, r7, #72	; 0x48
 801642e:	4413      	add	r3, r2
 8016430:	f853 3c30 	ldr.w	r3, [r3, #-48]
 8016434:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8016436:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 801643a:	68fb      	ldr	r3, [r7, #12]
 801643c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801643e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i=0; i<8; i++) {
 8016442:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016444:	3301      	adds	r3, #1
 8016446:	647b      	str	r3, [r7, #68]	; 0x44
 8016448:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801644a:	2b07      	cmp	r3, #7
 801644c:	dde9      	ble.n	8016422 <sp_256_proj_point_add_8+0x122>
        for (i=0; i<8; i++) {
 801644e:	2300      	movs	r3, #0
 8016450:	647b      	str	r3, [r7, #68]	; 0x44
 8016452:	e014      	b.n	801647e <sp_256_proj_point_add_8+0x17e>
            r->y[i] = ap[p->infinity]->y[i];
 8016454:	68bb      	ldr	r3, [r7, #8]
 8016456:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 801645a:	009b      	lsls	r3, r3, #2
 801645c:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8016460:	4413      	add	r3, r2
 8016462:	f853 3c30 	ldr.w	r3, [r3, #-48]
 8016466:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8016468:	3210      	adds	r2, #16
 801646a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 801646e:	68fb      	ldr	r3, [r7, #12]
 8016470:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8016472:	3210      	adds	r2, #16
 8016474:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i=0; i<8; i++) {
 8016478:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801647a:	3301      	adds	r3, #1
 801647c:	647b      	str	r3, [r7, #68]	; 0x44
 801647e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016480:	2b07      	cmp	r3, #7
 8016482:	dde7      	ble.n	8016454 <sp_256_proj_point_add_8+0x154>
        for (i=0; i<8; i++) {
 8016484:	2300      	movs	r3, #0
 8016486:	647b      	str	r3, [r7, #68]	; 0x44
 8016488:	e017      	b.n	80164ba <sp_256_proj_point_add_8+0x1ba>
 801648a:	bf00      	nop
 801648c:	0801aef4 	.word	0x0801aef4
            r->z[i] = ap[p->infinity]->z[i];
 8016490:	68bb      	ldr	r3, [r7, #8]
 8016492:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8016496:	009b      	lsls	r3, r3, #2
 8016498:	f107 0248 	add.w	r2, r7, #72	; 0x48
 801649c:	4413      	add	r3, r2
 801649e:	f853 3c30 	ldr.w	r3, [r3, #-48]
 80164a2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80164a4:	3220      	adds	r2, #32
 80164a6:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80164aa:	68fb      	ldr	r3, [r7, #12]
 80164ac:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80164ae:	3220      	adds	r2, #32
 80164b0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i=0; i<8; i++) {
 80164b4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80164b6:	3301      	adds	r3, #1
 80164b8:	647b      	str	r3, [r7, #68]	; 0x44
 80164ba:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80164bc:	2b07      	cmp	r3, #7
 80164be:	dde7      	ble.n	8016490 <sp_256_proj_point_add_8+0x190>
        r->infinity = ap[p->infinity]->infinity;
 80164c0:	68bb      	ldr	r3, [r7, #8]
 80164c2:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 80164c6:	009b      	lsls	r3, r3, #2
 80164c8:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80164cc:	4413      	add	r3, r2
 80164ce:	f853 3c30 	ldr.w	r3, [r3, #-48]
 80164d2:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 80164d6:	68fb      	ldr	r3, [r7, #12]
 80164d8:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        sp_256_mont_sqr_8(t1, q->z, p256_mod, p256_mp_mod);
 80164dc:	687b      	ldr	r3, [r7, #4]
 80164de:	f103 0180 	add.w	r1, r3, #128	; 0x80
 80164e2:	2301      	movs	r3, #1
 80164e4:	4a54      	ldr	r2, [pc, #336]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 80164e6:	6c38      	ldr	r0, [r7, #64]	; 0x40
 80164e8:	f7fe fe55 	bl	8015196 <sp_256_mont_sqr_8>
        sp_256_mont_mul_8(t3, t1, q->z, p256_mod, p256_mp_mod);
 80164ec:	687b      	ldr	r3, [r7, #4]
 80164ee:	f103 0280 	add.w	r2, r3, #128	; 0x80
 80164f2:	2301      	movs	r3, #1
 80164f4:	9300      	str	r3, [sp, #0]
 80164f6:	4b50      	ldr	r3, [pc, #320]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 80164f8:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80164fa:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80164fc:	f7fe fa65 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_mul_8(t1, t1, x, p256_mod, p256_mp_mod);
 8016500:	2301      	movs	r3, #1
 8016502:	9300      	str	r3, [sp, #0]
 8016504:	4b4c      	ldr	r3, [pc, #304]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 8016506:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016508:	6c39      	ldr	r1, [r7, #64]	; 0x40
 801650a:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801650c:	f7fe fa5d 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_sqr_8(t2, z, p256_mod, p256_mp_mod);
 8016510:	2301      	movs	r3, #1
 8016512:	4a49      	ldr	r2, [pc, #292]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 8016514:	6a39      	ldr	r1, [r7, #32]
 8016516:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8016518:	f7fe fe3d 	bl	8015196 <sp_256_mont_sqr_8>
        sp_256_mont_mul_8(t4, t2, z, p256_mod, p256_mp_mod);
 801651c:	2301      	movs	r3, #1
 801651e:	9300      	str	r3, [sp, #0]
 8016520:	4b45      	ldr	r3, [pc, #276]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 8016522:	6a3a      	ldr	r2, [r7, #32]
 8016524:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8016526:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8016528:	f7fe fa4f 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_mul_8(t2, t2, q->x, p256_mod, p256_mp_mod);
 801652c:	687a      	ldr	r2, [r7, #4]
 801652e:	2301      	movs	r3, #1
 8016530:	9300      	str	r3, [sp, #0]
 8016532:	4b41      	ldr	r3, [pc, #260]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 8016534:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8016536:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8016538:	f7fe fa47 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_mul_8(t3, t3, y, p256_mod, p256_mp_mod);
 801653c:	2301      	movs	r3, #1
 801653e:	9300      	str	r3, [sp, #0]
 8016540:	4b3d      	ldr	r3, [pc, #244]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 8016542:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016544:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8016546:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8016548:	f7fe fa3f 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_mul_8(t4, t4, q->y, p256_mod, p256_mp_mod);
 801654c:	687b      	ldr	r3, [r7, #4]
 801654e:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8016552:	2301      	movs	r3, #1
 8016554:	9300      	str	r3, [sp, #0]
 8016556:	4b38      	ldr	r3, [pc, #224]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 8016558:	6b79      	ldr	r1, [r7, #52]	; 0x34
 801655a:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801655c:	f7fe fa35 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_sub_8(t2, t2, t1, p256_mod);
 8016560:	4b35      	ldr	r3, [pc, #212]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 8016562:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8016564:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8016566:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8016568:	f7ff fcd0 	bl	8015f0c <sp_256_mont_sub_8>
        sp_256_mont_sub_8(t4, t4, t3, p256_mod);
 801656c:	4b32      	ldr	r3, [pc, #200]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 801656e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8016570:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8016572:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8016574:	f7ff fcca 	bl	8015f0c <sp_256_mont_sub_8>
        sp_256_mont_mul_8(z, z, q->z, p256_mod, p256_mp_mod);
 8016578:	687b      	ldr	r3, [r7, #4]
 801657a:	f103 0280 	add.w	r2, r3, #128	; 0x80
 801657e:	2301      	movs	r3, #1
 8016580:	9300      	str	r3, [sp, #0]
 8016582:	4b2d      	ldr	r3, [pc, #180]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 8016584:	6a39      	ldr	r1, [r7, #32]
 8016586:	6a38      	ldr	r0, [r7, #32]
 8016588:	f7fe fa1f 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_mul_8(z, z, t2, p256_mod, p256_mp_mod);
 801658c:	2301      	movs	r3, #1
 801658e:	9300      	str	r3, [sp, #0]
 8016590:	4b29      	ldr	r3, [pc, #164]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 8016592:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016594:	6a39      	ldr	r1, [r7, #32]
 8016596:	6a38      	ldr	r0, [r7, #32]
 8016598:	f7fe fa17 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_sqr_8(x, t4, p256_mod, p256_mp_mod);
 801659c:	2301      	movs	r3, #1
 801659e:	4a26      	ldr	r2, [pc, #152]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 80165a0:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80165a2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80165a4:	f7fe fdf7 	bl	8015196 <sp_256_mont_sqr_8>
        sp_256_mont_sqr_8(t5, t2, p256_mod, p256_mp_mod);
 80165a8:	2301      	movs	r3, #1
 80165aa:	4a23      	ldr	r2, [pc, #140]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 80165ac:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 80165ae:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80165b0:	f7fe fdf1 	bl	8015196 <sp_256_mont_sqr_8>
        sp_256_mont_mul_8(y, t1, t5, p256_mod, p256_mp_mod);
 80165b4:	2301      	movs	r3, #1
 80165b6:	9300      	str	r3, [sp, #0]
 80165b8:	4b1f      	ldr	r3, [pc, #124]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 80165ba:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80165bc:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80165be:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80165c0:	f7fe fa03 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_mul_8(t5, t5, t2, p256_mod, p256_mp_mod);
 80165c4:	2301      	movs	r3, #1
 80165c6:	9300      	str	r3, [sp, #0]
 80165c8:	4b1b      	ldr	r3, [pc, #108]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 80165ca:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80165cc:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80165ce:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80165d0:	f7fe f9fb 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_sub_8(x, x, t5, p256_mod);
 80165d4:	4b18      	ldr	r3, [pc, #96]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 80165d6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80165d8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80165da:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80165dc:	f7ff fc96 	bl	8015f0c <sp_256_mont_sub_8>
        sp_256_mont_dbl_8(t1, y, p256_mod);
 80165e0:	4a15      	ldr	r2, [pc, #84]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 80165e2:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80165e4:	6c38      	ldr	r0, [r7, #64]	; 0x40
 80165e6:	f7ff fbc2 	bl	8015d6e <sp_256_mont_dbl_8>
        sp_256_mont_sub_8(x, x, t1, p256_mod);
 80165ea:	4b13      	ldr	r3, [pc, #76]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 80165ec:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80165ee:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80165f0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80165f2:	f7ff fc8b 	bl	8015f0c <sp_256_mont_sub_8>
        sp_256_mont_sub_8(y, y, x, p256_mod);
 80165f6:	4b10      	ldr	r3, [pc, #64]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 80165f8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80165fa:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80165fc:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80165fe:	f7ff fc85 	bl	8015f0c <sp_256_mont_sub_8>
        sp_256_mont_mul_8(y, y, t4, p256_mod, p256_mp_mod);
 8016602:	2301      	movs	r3, #1
 8016604:	9300      	str	r3, [sp, #0]
 8016606:	4b0c      	ldr	r3, [pc, #48]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 8016608:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801660a:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801660c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801660e:	f7fe f9dc 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_mul_8(t5, t5, t3, p256_mod, p256_mp_mod);
 8016612:	2301      	movs	r3, #1
 8016614:	9300      	str	r3, [sp, #0]
 8016616:	4b08      	ldr	r3, [pc, #32]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 8016618:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801661a:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801661c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801661e:	f7fe f9d4 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_sub_8(y, y, t5, p256_mod);
 8016622:	4b05      	ldr	r3, [pc, #20]	; (8016638 <sp_256_proj_point_add_8+0x338>)
 8016624:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8016626:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8016628:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801662a:	f7ff fc6f 	bl	8015f0c <sp_256_mont_sub_8>
}
 801662e:	bf00      	nop
 8016630:	3748      	adds	r7, #72	; 0x48
 8016632:	46bd      	mov	sp, r7
 8016634:	bdb0      	pop	{r4, r5, r7, pc}
 8016636:	bf00      	nop
 8016638:	0801aef4 	.word	0x0801aef4

0801663c <sp_256_get_point_16_8>:
 * table  Table - start of the entires to access
 * idx    Index of entry to retrieve.
 */
static void sp_256_get_point_16_8(sp_point_256* r, const sp_point_256* table,
    int idx)
{
 801663c:	b480      	push	{r7}
 801663e:	b087      	sub	sp, #28
 8016640:	af00      	add	r7, sp, #0
 8016642:	60f8      	str	r0, [r7, #12]
 8016644:	60b9      	str	r1, [r7, #8]
 8016646:	607a      	str	r2, [r7, #4]
    int i;
    sp_digit mask;

    r->x[0] = 0;
 8016648:	68fb      	ldr	r3, [r7, #12]
 801664a:	2200      	movs	r2, #0
 801664c:	601a      	str	r2, [r3, #0]
    r->x[1] = 0;
 801664e:	68fb      	ldr	r3, [r7, #12]
 8016650:	2200      	movs	r2, #0
 8016652:	605a      	str	r2, [r3, #4]
    r->x[2] = 0;
 8016654:	68fb      	ldr	r3, [r7, #12]
 8016656:	2200      	movs	r2, #0
 8016658:	609a      	str	r2, [r3, #8]
    r->x[3] = 0;
 801665a:	68fb      	ldr	r3, [r7, #12]
 801665c:	2200      	movs	r2, #0
 801665e:	60da      	str	r2, [r3, #12]
    r->x[4] = 0;
 8016660:	68fb      	ldr	r3, [r7, #12]
 8016662:	2200      	movs	r2, #0
 8016664:	611a      	str	r2, [r3, #16]
    r->x[5] = 0;
 8016666:	68fb      	ldr	r3, [r7, #12]
 8016668:	2200      	movs	r2, #0
 801666a:	615a      	str	r2, [r3, #20]
    r->x[6] = 0;
 801666c:	68fb      	ldr	r3, [r7, #12]
 801666e:	2200      	movs	r2, #0
 8016670:	619a      	str	r2, [r3, #24]
    r->x[7] = 0;
 8016672:	68fb      	ldr	r3, [r7, #12]
 8016674:	2200      	movs	r2, #0
 8016676:	61da      	str	r2, [r3, #28]
    r->y[0] = 0;
 8016678:	68fb      	ldr	r3, [r7, #12]
 801667a:	2200      	movs	r2, #0
 801667c:	641a      	str	r2, [r3, #64]	; 0x40
    r->y[1] = 0;
 801667e:	68fb      	ldr	r3, [r7, #12]
 8016680:	2200      	movs	r2, #0
 8016682:	645a      	str	r2, [r3, #68]	; 0x44
    r->y[2] = 0;
 8016684:	68fb      	ldr	r3, [r7, #12]
 8016686:	2200      	movs	r2, #0
 8016688:	649a      	str	r2, [r3, #72]	; 0x48
    r->y[3] = 0;
 801668a:	68fb      	ldr	r3, [r7, #12]
 801668c:	2200      	movs	r2, #0
 801668e:	64da      	str	r2, [r3, #76]	; 0x4c
    r->y[4] = 0;
 8016690:	68fb      	ldr	r3, [r7, #12]
 8016692:	2200      	movs	r2, #0
 8016694:	651a      	str	r2, [r3, #80]	; 0x50
    r->y[5] = 0;
 8016696:	68fb      	ldr	r3, [r7, #12]
 8016698:	2200      	movs	r2, #0
 801669a:	655a      	str	r2, [r3, #84]	; 0x54
    r->y[6] = 0;
 801669c:	68fb      	ldr	r3, [r7, #12]
 801669e:	2200      	movs	r2, #0
 80166a0:	659a      	str	r2, [r3, #88]	; 0x58
    r->y[7] = 0;
 80166a2:	68fb      	ldr	r3, [r7, #12]
 80166a4:	2200      	movs	r2, #0
 80166a6:	65da      	str	r2, [r3, #92]	; 0x5c
    r->z[0] = 0;
 80166a8:	68fb      	ldr	r3, [r7, #12]
 80166aa:	2200      	movs	r2, #0
 80166ac:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    r->z[1] = 0;
 80166b0:	68fb      	ldr	r3, [r7, #12]
 80166b2:	2200      	movs	r2, #0
 80166b4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    r->z[2] = 0;
 80166b8:	68fb      	ldr	r3, [r7, #12]
 80166ba:	2200      	movs	r2, #0
 80166bc:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    r->z[3] = 0;
 80166c0:	68fb      	ldr	r3, [r7, #12]
 80166c2:	2200      	movs	r2, #0
 80166c4:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    r->z[4] = 0;
 80166c8:	68fb      	ldr	r3, [r7, #12]
 80166ca:	2200      	movs	r2, #0
 80166cc:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    r->z[5] = 0;
 80166d0:	68fb      	ldr	r3, [r7, #12]
 80166d2:	2200      	movs	r2, #0
 80166d4:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    r->z[6] = 0;
 80166d8:	68fb      	ldr	r3, [r7, #12]
 80166da:	2200      	movs	r2, #0
 80166dc:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    r->z[7] = 0;
 80166e0:	68fb      	ldr	r3, [r7, #12]
 80166e2:	2200      	movs	r2, #0
 80166e4:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    for (i = 1; i < 16; i++) {
 80166e8:	2301      	movs	r3, #1
 80166ea:	617b      	str	r3, [r7, #20]
 80166ec:	e173      	b.n	80169d6 <sp_256_get_point_16_8+0x39a>
        mask = 0 - (i == idx);
 80166ee:	697a      	ldr	r2, [r7, #20]
 80166f0:	687b      	ldr	r3, [r7, #4]
 80166f2:	429a      	cmp	r2, r3
 80166f4:	bf0c      	ite	eq
 80166f6:	2301      	moveq	r3, #1
 80166f8:	2300      	movne	r3, #0
 80166fa:	b2db      	uxtb	r3, r3
 80166fc:	425b      	negs	r3, r3
 80166fe:	613b      	str	r3, [r7, #16]
        r->x[0] |= mask & table[i].x[0];
 8016700:	68fb      	ldr	r3, [r7, #12]
 8016702:	681a      	ldr	r2, [r3, #0]
 8016704:	697b      	ldr	r3, [r7, #20]
 8016706:	21c4      	movs	r1, #196	; 0xc4
 8016708:	fb01 f303 	mul.w	r3, r1, r3
 801670c:	68b9      	ldr	r1, [r7, #8]
 801670e:	440b      	add	r3, r1
 8016710:	6819      	ldr	r1, [r3, #0]
 8016712:	693b      	ldr	r3, [r7, #16]
 8016714:	400b      	ands	r3, r1
 8016716:	431a      	orrs	r2, r3
 8016718:	68fb      	ldr	r3, [r7, #12]
 801671a:	601a      	str	r2, [r3, #0]
        r->x[1] |= mask & table[i].x[1];
 801671c:	68fb      	ldr	r3, [r7, #12]
 801671e:	685a      	ldr	r2, [r3, #4]
 8016720:	697b      	ldr	r3, [r7, #20]
 8016722:	21c4      	movs	r1, #196	; 0xc4
 8016724:	fb01 f303 	mul.w	r3, r1, r3
 8016728:	68b9      	ldr	r1, [r7, #8]
 801672a:	440b      	add	r3, r1
 801672c:	6859      	ldr	r1, [r3, #4]
 801672e:	693b      	ldr	r3, [r7, #16]
 8016730:	400b      	ands	r3, r1
 8016732:	431a      	orrs	r2, r3
 8016734:	68fb      	ldr	r3, [r7, #12]
 8016736:	605a      	str	r2, [r3, #4]
        r->x[2] |= mask & table[i].x[2];
 8016738:	68fb      	ldr	r3, [r7, #12]
 801673a:	689a      	ldr	r2, [r3, #8]
 801673c:	697b      	ldr	r3, [r7, #20]
 801673e:	21c4      	movs	r1, #196	; 0xc4
 8016740:	fb01 f303 	mul.w	r3, r1, r3
 8016744:	68b9      	ldr	r1, [r7, #8]
 8016746:	440b      	add	r3, r1
 8016748:	6899      	ldr	r1, [r3, #8]
 801674a:	693b      	ldr	r3, [r7, #16]
 801674c:	400b      	ands	r3, r1
 801674e:	431a      	orrs	r2, r3
 8016750:	68fb      	ldr	r3, [r7, #12]
 8016752:	609a      	str	r2, [r3, #8]
        r->x[3] |= mask & table[i].x[3];
 8016754:	68fb      	ldr	r3, [r7, #12]
 8016756:	68da      	ldr	r2, [r3, #12]
 8016758:	697b      	ldr	r3, [r7, #20]
 801675a:	21c4      	movs	r1, #196	; 0xc4
 801675c:	fb01 f303 	mul.w	r3, r1, r3
 8016760:	68b9      	ldr	r1, [r7, #8]
 8016762:	440b      	add	r3, r1
 8016764:	68d9      	ldr	r1, [r3, #12]
 8016766:	693b      	ldr	r3, [r7, #16]
 8016768:	400b      	ands	r3, r1
 801676a:	431a      	orrs	r2, r3
 801676c:	68fb      	ldr	r3, [r7, #12]
 801676e:	60da      	str	r2, [r3, #12]
        r->x[4] |= mask & table[i].x[4];
 8016770:	68fb      	ldr	r3, [r7, #12]
 8016772:	691a      	ldr	r2, [r3, #16]
 8016774:	697b      	ldr	r3, [r7, #20]
 8016776:	21c4      	movs	r1, #196	; 0xc4
 8016778:	fb01 f303 	mul.w	r3, r1, r3
 801677c:	68b9      	ldr	r1, [r7, #8]
 801677e:	440b      	add	r3, r1
 8016780:	6919      	ldr	r1, [r3, #16]
 8016782:	693b      	ldr	r3, [r7, #16]
 8016784:	400b      	ands	r3, r1
 8016786:	431a      	orrs	r2, r3
 8016788:	68fb      	ldr	r3, [r7, #12]
 801678a:	611a      	str	r2, [r3, #16]
        r->x[5] |= mask & table[i].x[5];
 801678c:	68fb      	ldr	r3, [r7, #12]
 801678e:	695a      	ldr	r2, [r3, #20]
 8016790:	697b      	ldr	r3, [r7, #20]
 8016792:	21c4      	movs	r1, #196	; 0xc4
 8016794:	fb01 f303 	mul.w	r3, r1, r3
 8016798:	68b9      	ldr	r1, [r7, #8]
 801679a:	440b      	add	r3, r1
 801679c:	6959      	ldr	r1, [r3, #20]
 801679e:	693b      	ldr	r3, [r7, #16]
 80167a0:	400b      	ands	r3, r1
 80167a2:	431a      	orrs	r2, r3
 80167a4:	68fb      	ldr	r3, [r7, #12]
 80167a6:	615a      	str	r2, [r3, #20]
        r->x[6] |= mask & table[i].x[6];
 80167a8:	68fb      	ldr	r3, [r7, #12]
 80167aa:	699a      	ldr	r2, [r3, #24]
 80167ac:	697b      	ldr	r3, [r7, #20]
 80167ae:	21c4      	movs	r1, #196	; 0xc4
 80167b0:	fb01 f303 	mul.w	r3, r1, r3
 80167b4:	68b9      	ldr	r1, [r7, #8]
 80167b6:	440b      	add	r3, r1
 80167b8:	6999      	ldr	r1, [r3, #24]
 80167ba:	693b      	ldr	r3, [r7, #16]
 80167bc:	400b      	ands	r3, r1
 80167be:	431a      	orrs	r2, r3
 80167c0:	68fb      	ldr	r3, [r7, #12]
 80167c2:	619a      	str	r2, [r3, #24]
        r->x[7] |= mask & table[i].x[7];
 80167c4:	68fb      	ldr	r3, [r7, #12]
 80167c6:	69da      	ldr	r2, [r3, #28]
 80167c8:	697b      	ldr	r3, [r7, #20]
 80167ca:	21c4      	movs	r1, #196	; 0xc4
 80167cc:	fb01 f303 	mul.w	r3, r1, r3
 80167d0:	68b9      	ldr	r1, [r7, #8]
 80167d2:	440b      	add	r3, r1
 80167d4:	69d9      	ldr	r1, [r3, #28]
 80167d6:	693b      	ldr	r3, [r7, #16]
 80167d8:	400b      	ands	r3, r1
 80167da:	431a      	orrs	r2, r3
 80167dc:	68fb      	ldr	r3, [r7, #12]
 80167de:	61da      	str	r2, [r3, #28]
        r->y[0] |= mask & table[i].y[0];
 80167e0:	68fb      	ldr	r3, [r7, #12]
 80167e2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80167e4:	697b      	ldr	r3, [r7, #20]
 80167e6:	21c4      	movs	r1, #196	; 0xc4
 80167e8:	fb01 f303 	mul.w	r3, r1, r3
 80167ec:	68b9      	ldr	r1, [r7, #8]
 80167ee:	440b      	add	r3, r1
 80167f0:	6c19      	ldr	r1, [r3, #64]	; 0x40
 80167f2:	693b      	ldr	r3, [r7, #16]
 80167f4:	400b      	ands	r3, r1
 80167f6:	431a      	orrs	r2, r3
 80167f8:	68fb      	ldr	r3, [r7, #12]
 80167fa:	641a      	str	r2, [r3, #64]	; 0x40
        r->y[1] |= mask & table[i].y[1];
 80167fc:	68fb      	ldr	r3, [r7, #12]
 80167fe:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8016800:	697b      	ldr	r3, [r7, #20]
 8016802:	21c4      	movs	r1, #196	; 0xc4
 8016804:	fb01 f303 	mul.w	r3, r1, r3
 8016808:	68b9      	ldr	r1, [r7, #8]
 801680a:	440b      	add	r3, r1
 801680c:	6c59      	ldr	r1, [r3, #68]	; 0x44
 801680e:	693b      	ldr	r3, [r7, #16]
 8016810:	400b      	ands	r3, r1
 8016812:	431a      	orrs	r2, r3
 8016814:	68fb      	ldr	r3, [r7, #12]
 8016816:	645a      	str	r2, [r3, #68]	; 0x44
        r->y[2] |= mask & table[i].y[2];
 8016818:	68fb      	ldr	r3, [r7, #12]
 801681a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 801681c:	697b      	ldr	r3, [r7, #20]
 801681e:	21c4      	movs	r1, #196	; 0xc4
 8016820:	fb01 f303 	mul.w	r3, r1, r3
 8016824:	68b9      	ldr	r1, [r7, #8]
 8016826:	440b      	add	r3, r1
 8016828:	6c99      	ldr	r1, [r3, #72]	; 0x48
 801682a:	693b      	ldr	r3, [r7, #16]
 801682c:	400b      	ands	r3, r1
 801682e:	431a      	orrs	r2, r3
 8016830:	68fb      	ldr	r3, [r7, #12]
 8016832:	649a      	str	r2, [r3, #72]	; 0x48
        r->y[3] |= mask & table[i].y[3];
 8016834:	68fb      	ldr	r3, [r7, #12]
 8016836:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8016838:	697b      	ldr	r3, [r7, #20]
 801683a:	21c4      	movs	r1, #196	; 0xc4
 801683c:	fb01 f303 	mul.w	r3, r1, r3
 8016840:	68b9      	ldr	r1, [r7, #8]
 8016842:	440b      	add	r3, r1
 8016844:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8016846:	693b      	ldr	r3, [r7, #16]
 8016848:	400b      	ands	r3, r1
 801684a:	431a      	orrs	r2, r3
 801684c:	68fb      	ldr	r3, [r7, #12]
 801684e:	64da      	str	r2, [r3, #76]	; 0x4c
        r->y[4] |= mask & table[i].y[4];
 8016850:	68fb      	ldr	r3, [r7, #12]
 8016852:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8016854:	697b      	ldr	r3, [r7, #20]
 8016856:	21c4      	movs	r1, #196	; 0xc4
 8016858:	fb01 f303 	mul.w	r3, r1, r3
 801685c:	68b9      	ldr	r1, [r7, #8]
 801685e:	440b      	add	r3, r1
 8016860:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8016862:	693b      	ldr	r3, [r7, #16]
 8016864:	400b      	ands	r3, r1
 8016866:	431a      	orrs	r2, r3
 8016868:	68fb      	ldr	r3, [r7, #12]
 801686a:	651a      	str	r2, [r3, #80]	; 0x50
        r->y[5] |= mask & table[i].y[5];
 801686c:	68fb      	ldr	r3, [r7, #12]
 801686e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8016870:	697b      	ldr	r3, [r7, #20]
 8016872:	21c4      	movs	r1, #196	; 0xc4
 8016874:	fb01 f303 	mul.w	r3, r1, r3
 8016878:	68b9      	ldr	r1, [r7, #8]
 801687a:	440b      	add	r3, r1
 801687c:	6d59      	ldr	r1, [r3, #84]	; 0x54
 801687e:	693b      	ldr	r3, [r7, #16]
 8016880:	400b      	ands	r3, r1
 8016882:	431a      	orrs	r2, r3
 8016884:	68fb      	ldr	r3, [r7, #12]
 8016886:	655a      	str	r2, [r3, #84]	; 0x54
        r->y[6] |= mask & table[i].y[6];
 8016888:	68fb      	ldr	r3, [r7, #12]
 801688a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 801688c:	697b      	ldr	r3, [r7, #20]
 801688e:	21c4      	movs	r1, #196	; 0xc4
 8016890:	fb01 f303 	mul.w	r3, r1, r3
 8016894:	68b9      	ldr	r1, [r7, #8]
 8016896:	440b      	add	r3, r1
 8016898:	6d99      	ldr	r1, [r3, #88]	; 0x58
 801689a:	693b      	ldr	r3, [r7, #16]
 801689c:	400b      	ands	r3, r1
 801689e:	431a      	orrs	r2, r3
 80168a0:	68fb      	ldr	r3, [r7, #12]
 80168a2:	659a      	str	r2, [r3, #88]	; 0x58
        r->y[7] |= mask & table[i].y[7];
 80168a4:	68fb      	ldr	r3, [r7, #12]
 80168a6:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 80168a8:	697b      	ldr	r3, [r7, #20]
 80168aa:	21c4      	movs	r1, #196	; 0xc4
 80168ac:	fb01 f303 	mul.w	r3, r1, r3
 80168b0:	68b9      	ldr	r1, [r7, #8]
 80168b2:	440b      	add	r3, r1
 80168b4:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 80168b6:	693b      	ldr	r3, [r7, #16]
 80168b8:	400b      	ands	r3, r1
 80168ba:	431a      	orrs	r2, r3
 80168bc:	68fb      	ldr	r3, [r7, #12]
 80168be:	65da      	str	r2, [r3, #92]	; 0x5c
        r->z[0] |= mask & table[i].z[0];
 80168c0:	68fb      	ldr	r3, [r7, #12]
 80168c2:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 80168c6:	697b      	ldr	r3, [r7, #20]
 80168c8:	21c4      	movs	r1, #196	; 0xc4
 80168ca:	fb01 f303 	mul.w	r3, r1, r3
 80168ce:	68b9      	ldr	r1, [r7, #8]
 80168d0:	440b      	add	r3, r1
 80168d2:	f8d3 1080 	ldr.w	r1, [r3, #128]	; 0x80
 80168d6:	693b      	ldr	r3, [r7, #16]
 80168d8:	400b      	ands	r3, r1
 80168da:	431a      	orrs	r2, r3
 80168dc:	68fb      	ldr	r3, [r7, #12]
 80168de:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
        r->z[1] |= mask & table[i].z[1];
 80168e2:	68fb      	ldr	r3, [r7, #12]
 80168e4:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 80168e8:	697b      	ldr	r3, [r7, #20]
 80168ea:	21c4      	movs	r1, #196	; 0xc4
 80168ec:	fb01 f303 	mul.w	r3, r1, r3
 80168f0:	68b9      	ldr	r1, [r7, #8]
 80168f2:	440b      	add	r3, r1
 80168f4:	f8d3 1084 	ldr.w	r1, [r3, #132]	; 0x84
 80168f8:	693b      	ldr	r3, [r7, #16]
 80168fa:	400b      	ands	r3, r1
 80168fc:	431a      	orrs	r2, r3
 80168fe:	68fb      	ldr	r3, [r7, #12]
 8016900:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        r->z[2] |= mask & table[i].z[2];
 8016904:	68fb      	ldr	r3, [r7, #12]
 8016906:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 801690a:	697b      	ldr	r3, [r7, #20]
 801690c:	21c4      	movs	r1, #196	; 0xc4
 801690e:	fb01 f303 	mul.w	r3, r1, r3
 8016912:	68b9      	ldr	r1, [r7, #8]
 8016914:	440b      	add	r3, r1
 8016916:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
 801691a:	693b      	ldr	r3, [r7, #16]
 801691c:	400b      	ands	r3, r1
 801691e:	431a      	orrs	r2, r3
 8016920:	68fb      	ldr	r3, [r7, #12]
 8016922:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        r->z[3] |= mask & table[i].z[3];
 8016926:	68fb      	ldr	r3, [r7, #12]
 8016928:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 801692c:	697b      	ldr	r3, [r7, #20]
 801692e:	21c4      	movs	r1, #196	; 0xc4
 8016930:	fb01 f303 	mul.w	r3, r1, r3
 8016934:	68b9      	ldr	r1, [r7, #8]
 8016936:	440b      	add	r3, r1
 8016938:	f8d3 108c 	ldr.w	r1, [r3, #140]	; 0x8c
 801693c:	693b      	ldr	r3, [r7, #16]
 801693e:	400b      	ands	r3, r1
 8016940:	431a      	orrs	r2, r3
 8016942:	68fb      	ldr	r3, [r7, #12]
 8016944:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        r->z[4] |= mask & table[i].z[4];
 8016948:	68fb      	ldr	r3, [r7, #12]
 801694a:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 801694e:	697b      	ldr	r3, [r7, #20]
 8016950:	21c4      	movs	r1, #196	; 0xc4
 8016952:	fb01 f303 	mul.w	r3, r1, r3
 8016956:	68b9      	ldr	r1, [r7, #8]
 8016958:	440b      	add	r3, r1
 801695a:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
 801695e:	693b      	ldr	r3, [r7, #16]
 8016960:	400b      	ands	r3, r1
 8016962:	431a      	orrs	r2, r3
 8016964:	68fb      	ldr	r3, [r7, #12]
 8016966:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        r->z[5] |= mask & table[i].z[5];
 801696a:	68fb      	ldr	r3, [r7, #12]
 801696c:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8016970:	697b      	ldr	r3, [r7, #20]
 8016972:	21c4      	movs	r1, #196	; 0xc4
 8016974:	fb01 f303 	mul.w	r3, r1, r3
 8016978:	68b9      	ldr	r1, [r7, #8]
 801697a:	440b      	add	r3, r1
 801697c:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 8016980:	693b      	ldr	r3, [r7, #16]
 8016982:	400b      	ands	r3, r1
 8016984:	431a      	orrs	r2, r3
 8016986:	68fb      	ldr	r3, [r7, #12]
 8016988:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
        r->z[6] |= mask & table[i].z[6];
 801698c:	68fb      	ldr	r3, [r7, #12]
 801698e:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8016992:	697b      	ldr	r3, [r7, #20]
 8016994:	21c4      	movs	r1, #196	; 0xc4
 8016996:	fb01 f303 	mul.w	r3, r1, r3
 801699a:	68b9      	ldr	r1, [r7, #8]
 801699c:	440b      	add	r3, r1
 801699e:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
 80169a2:	693b      	ldr	r3, [r7, #16]
 80169a4:	400b      	ands	r3, r1
 80169a6:	431a      	orrs	r2, r3
 80169a8:	68fb      	ldr	r3, [r7, #12]
 80169aa:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        r->z[7] |= mask & table[i].z[7];
 80169ae:	68fb      	ldr	r3, [r7, #12]
 80169b0:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 80169b4:	697b      	ldr	r3, [r7, #20]
 80169b6:	21c4      	movs	r1, #196	; 0xc4
 80169b8:	fb01 f303 	mul.w	r3, r1, r3
 80169bc:	68b9      	ldr	r1, [r7, #8]
 80169be:	440b      	add	r3, r1
 80169c0:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
 80169c4:	693b      	ldr	r3, [r7, #16]
 80169c6:	400b      	ands	r3, r1
 80169c8:	431a      	orrs	r2, r3
 80169ca:	68fb      	ldr	r3, [r7, #12]
 80169cc:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    for (i = 1; i < 16; i++) {
 80169d0:	697b      	ldr	r3, [r7, #20]
 80169d2:	3301      	adds	r3, #1
 80169d4:	617b      	str	r3, [r7, #20]
 80169d6:	697b      	ldr	r3, [r7, #20]
 80169d8:	2b0f      	cmp	r3, #15
 80169da:	f77f ae88 	ble.w	80166ee <sp_256_get_point_16_8+0xb2>
    }
}
 80169de:	bf00      	nop
 80169e0:	371c      	adds	r7, #28
 80169e2:	46bd      	mov	sp, r7
 80169e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80169e8:	4770      	bx	lr
	...

080169ec <sp_256_ecc_mulmod_fast_8>:
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_256_ecc_mulmod_fast_8(sp_point_256* r, const sp_point_256* g, const sp_digit* k,
        int map, int ct, void* heap)
{
 80169ec:	b580      	push	{r7, lr}
 80169ee:	b090      	sub	sp, #64	; 0x40
 80169f0:	af00      	add	r7, sp, #0
 80169f2:	60f8      	str	r0, [r7, #12]
 80169f4:	60b9      	str	r1, [r7, #8]
 80169f6:	607a      	str	r2, [r7, #4]
 80169f8:	603b      	str	r3, [r7, #0]

    /* Constant time used for cache attack resistance implementation. */
    (void)ct;
    (void)heap;

    err = sp_256_point_new_8(heap, rtd, rt);
 80169fa:	f107 0314 	add.w	r3, r7, #20
 80169fe:	461a      	mov	r2, r3
 8016a00:	2100      	movs	r1, #0
 8016a02:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8016a04:	f7fd fda8 	bl	8014558 <sp_256_point_new_ex_8>
 8016a08:	6338      	str	r0, [r7, #48]	; 0x30
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
#ifndef WC_NO_CACHE_RESISTANT
    t = (sp_point_256*)XMALLOC(sizeof(sp_point_256) * 17, heap, DYNAMIC_TYPE_ECC);
 8016a0a:	f640 5004 	movw	r0, #3332	; 0xd04
 8016a0e:	f7f8 fa73 	bl	800eef8 <wolfSSL_Malloc>
 8016a12:	62f8      	str	r0, [r7, #44]	; 0x2c
#else
    t = (sp_point_256*)XMALLOC(sizeof(sp_point_256) * 16, heap, DYNAMIC_TYPE_ECC);
#endif
    if (t == NULL)
 8016a14:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016a16:	2b00      	cmp	r3, #0
 8016a18:	d102      	bne.n	8016a20 <sp_256_ecc_mulmod_fast_8+0x34>
        err = MEMORY_E;
 8016a1a:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 8016a1e:	633b      	str	r3, [r7, #48]	; 0x30
    tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 8 * 5, heap,
 8016a20:	f44f 70a0 	mov.w	r0, #320	; 0x140
 8016a24:	f7f8 fa68 	bl	800eef8 <wolfSSL_Malloc>
 8016a28:	62b8      	str	r0, [r7, #40]	; 0x28
                             DYNAMIC_TYPE_ECC);
    if (tmp == NULL)
 8016a2a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016a2c:	2b00      	cmp	r3, #0
 8016a2e:	d102      	bne.n	8016a36 <sp_256_ecc_mulmod_fast_8+0x4a>
        err = MEMORY_E;
 8016a30:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 8016a34:	633b      	str	r3, [r7, #48]	; 0x30
#else
    t = td;
    tmp = tmpd;
#endif

    if (err == MP_OKAY) {
 8016a36:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016a38:	2b00      	cmp	r3, #0
 8016a3a:	f040 81b8 	bne.w	8016dae <sp_256_ecc_mulmod_fast_8+0x3c2>
#ifndef WC_NO_CACHE_RESISTANT
    #if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        p = t + 16;
 8016a3e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016a40:	f503 6344 	add.w	r3, r3, #3136	; 0xc40
 8016a44:	627b      	str	r3, [r7, #36]	; 0x24
    #else
        p = &pd;
    #endif
#endif
        /* t[0] = {0, 0, 1} * norm */
        XMEMSET(&t[0], 0, sizeof(t[0]));
 8016a46:	22c4      	movs	r2, #196	; 0xc4
 8016a48:	2100      	movs	r1, #0
 8016a4a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8016a4c:	f002 fcf7 	bl	801943e <memset>
        t[0].infinity = 1;
 8016a50:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016a52:	2201      	movs	r2, #1
 8016a54:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        /* t[1] = {g->x, g->y, g->z} * norm */
        (void)sp_256_mod_mul_norm_8(t[1].x, g->x, p256_mod);
 8016a58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016a5a:	33c4      	adds	r3, #196	; 0xc4
 8016a5c:	4618      	mov	r0, r3
 8016a5e:	68bb      	ldr	r3, [r7, #8]
 8016a60:	4a9c      	ldr	r2, [pc, #624]	; (8016cd4 <sp_256_ecc_mulmod_fast_8+0x2e8>)
 8016a62:	4619      	mov	r1, r3
 8016a64:	f7fd fdaf 	bl	80145c6 <sp_256_mod_mul_norm_8>
        (void)sp_256_mod_mul_norm_8(t[1].y, g->y, p256_mod);
 8016a68:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016a6a:	33c4      	adds	r3, #196	; 0xc4
 8016a6c:	f103 0040 	add.w	r0, r3, #64	; 0x40
 8016a70:	68bb      	ldr	r3, [r7, #8]
 8016a72:	3340      	adds	r3, #64	; 0x40
 8016a74:	4a97      	ldr	r2, [pc, #604]	; (8016cd4 <sp_256_ecc_mulmod_fast_8+0x2e8>)
 8016a76:	4619      	mov	r1, r3
 8016a78:	f7fd fda5 	bl	80145c6 <sp_256_mod_mul_norm_8>
        (void)sp_256_mod_mul_norm_8(t[1].z, g->z, p256_mod);
 8016a7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016a7e:	33c4      	adds	r3, #196	; 0xc4
 8016a80:	f103 0080 	add.w	r0, r3, #128	; 0x80
 8016a84:	68bb      	ldr	r3, [r7, #8]
 8016a86:	3380      	adds	r3, #128	; 0x80
 8016a88:	4a92      	ldr	r2, [pc, #584]	; (8016cd4 <sp_256_ecc_mulmod_fast_8+0x2e8>)
 8016a8a:	4619      	mov	r1, r3
 8016a8c:	f7fd fd9b 	bl	80145c6 <sp_256_mod_mul_norm_8>
        t[1].infinity = 0;
 8016a90:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016a92:	33c4      	adds	r3, #196	; 0xc4
 8016a94:	2200      	movs	r2, #0
 8016a96:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        sp_256_proj_point_dbl_8(&t[ 2], &t[ 1], tmp);
 8016a9a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016a9c:	f503 70c4 	add.w	r0, r3, #392	; 0x188
 8016aa0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016aa2:	33c4      	adds	r3, #196	; 0xc4
 8016aa4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016aa6:	4619      	mov	r1, r3
 8016aa8:	f7ff fb16 	bl	80160d8 <sp_256_proj_point_dbl_8>
        t[ 2].infinity = 0;
 8016aac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016aae:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 8016ab2:	2200      	movs	r2, #0
 8016ab4:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        sp_256_proj_point_add_8(&t[ 3], &t[ 2], &t[ 1], tmp);
 8016ab8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016aba:	f503 7013 	add.w	r0, r3, #588	; 0x24c
 8016abe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016ac0:	f503 71c4 	add.w	r1, r3, #392	; 0x188
 8016ac4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016ac6:	f103 02c4 	add.w	r2, r3, #196	; 0xc4
 8016aca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016acc:	f7ff fc18 	bl	8016300 <sp_256_proj_point_add_8>
        t[ 3].infinity = 0;
 8016ad0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016ad2:	f503 7313 	add.w	r3, r3, #588	; 0x24c
 8016ad6:	2200      	movs	r2, #0
 8016ad8:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        sp_256_proj_point_dbl_8(&t[ 4], &t[ 2], tmp);
 8016adc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016ade:	f503 7044 	add.w	r0, r3, #784	; 0x310
 8016ae2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016ae4:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 8016ae8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016aea:	4619      	mov	r1, r3
 8016aec:	f7ff faf4 	bl	80160d8 <sp_256_proj_point_dbl_8>
        t[ 4].infinity = 0;
 8016af0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016af2:	f503 7344 	add.w	r3, r3, #784	; 0x310
 8016af6:	2200      	movs	r2, #0
 8016af8:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        sp_256_proj_point_add_8(&t[ 5], &t[ 3], &t[ 2], tmp);
 8016afc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016afe:	f503 7075 	add.w	r0, r3, #980	; 0x3d4
 8016b02:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b04:	f503 7113 	add.w	r1, r3, #588	; 0x24c
 8016b08:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b0a:	f503 72c4 	add.w	r2, r3, #392	; 0x188
 8016b0e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016b10:	f7ff fbf6 	bl	8016300 <sp_256_proj_point_add_8>
        t[ 5].infinity = 0;
 8016b14:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b16:	f503 7375 	add.w	r3, r3, #980	; 0x3d4
 8016b1a:	2200      	movs	r2, #0
 8016b1c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        sp_256_proj_point_dbl_8(&t[ 6], &t[ 3], tmp);
 8016b20:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b22:	f503 6093 	add.w	r0, r3, #1176	; 0x498
 8016b26:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b28:	f503 7313 	add.w	r3, r3, #588	; 0x24c
 8016b2c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016b2e:	4619      	mov	r1, r3
 8016b30:	f7ff fad2 	bl	80160d8 <sp_256_proj_point_dbl_8>
        t[ 6].infinity = 0;
 8016b34:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b36:	f503 6393 	add.w	r3, r3, #1176	; 0x498
 8016b3a:	2200      	movs	r2, #0
 8016b3c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        sp_256_proj_point_add_8(&t[ 7], &t[ 4], &t[ 3], tmp);
 8016b40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b42:	f203 505c 	addw	r0, r3, #1372	; 0x55c
 8016b46:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b48:	f503 7144 	add.w	r1, r3, #784	; 0x310
 8016b4c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b4e:	f503 7213 	add.w	r2, r3, #588	; 0x24c
 8016b52:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016b54:	f7ff fbd4 	bl	8016300 <sp_256_proj_point_add_8>
        t[ 7].infinity = 0;
 8016b58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b5a:	f203 535c 	addw	r3, r3, #1372	; 0x55c
 8016b5e:	2200      	movs	r2, #0
 8016b60:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        sp_256_proj_point_dbl_8(&t[ 8], &t[ 4], tmp);
 8016b64:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b66:	f503 60c4 	add.w	r0, r3, #1568	; 0x620
 8016b6a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b6c:	f503 7344 	add.w	r3, r3, #784	; 0x310
 8016b70:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016b72:	4619      	mov	r1, r3
 8016b74:	f7ff fab0 	bl	80160d8 <sp_256_proj_point_dbl_8>
        t[ 8].infinity = 0;
 8016b78:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b7a:	f503 63c4 	add.w	r3, r3, #1568	; 0x620
 8016b7e:	2200      	movs	r2, #0
 8016b80:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        sp_256_proj_point_add_8(&t[ 9], &t[ 5], &t[ 4], tmp);
 8016b84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b86:	f203 60e4 	addw	r0, r3, #1764	; 0x6e4
 8016b8a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b8c:	f503 7175 	add.w	r1, r3, #980	; 0x3d4
 8016b90:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b92:	f503 7244 	add.w	r2, r3, #784	; 0x310
 8016b96:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016b98:	f7ff fbb2 	bl	8016300 <sp_256_proj_point_add_8>
        t[ 9].infinity = 0;
 8016b9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b9e:	f203 63e4 	addw	r3, r3, #1764	; 0x6e4
 8016ba2:	2200      	movs	r2, #0
 8016ba4:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        sp_256_proj_point_dbl_8(&t[10], &t[ 5], tmp);
 8016ba8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016baa:	f503 60f5 	add.w	r0, r3, #1960	; 0x7a8
 8016bae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016bb0:	f503 7375 	add.w	r3, r3, #980	; 0x3d4
 8016bb4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016bb6:	4619      	mov	r1, r3
 8016bb8:	f7ff fa8e 	bl	80160d8 <sp_256_proj_point_dbl_8>
        t[10].infinity = 0;
 8016bbc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016bbe:	f503 63f5 	add.w	r3, r3, #1960	; 0x7a8
 8016bc2:	2200      	movs	r2, #0
 8016bc4:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        sp_256_proj_point_add_8(&t[11], &t[ 6], &t[ 5], tmp);
 8016bc8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016bca:	f603 006c 	addw	r0, r3, #2156	; 0x86c
 8016bce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016bd0:	f503 6193 	add.w	r1, r3, #1176	; 0x498
 8016bd4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016bd6:	f503 7275 	add.w	r2, r3, #980	; 0x3d4
 8016bda:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016bdc:	f7ff fb90 	bl	8016300 <sp_256_proj_point_add_8>
        t[11].infinity = 0;
 8016be0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016be2:	f603 036c 	addw	r3, r3, #2156	; 0x86c
 8016be6:	2200      	movs	r2, #0
 8016be8:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        sp_256_proj_point_dbl_8(&t[12], &t[ 6], tmp);
 8016bec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016bee:	f503 6013 	add.w	r0, r3, #2352	; 0x930
 8016bf2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016bf4:	f503 6393 	add.w	r3, r3, #1176	; 0x498
 8016bf8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016bfa:	4619      	mov	r1, r3
 8016bfc:	f7ff fa6c 	bl	80160d8 <sp_256_proj_point_dbl_8>
        t[12].infinity = 0;
 8016c00:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016c02:	f503 6313 	add.w	r3, r3, #2352	; 0x930
 8016c06:	2200      	movs	r2, #0
 8016c08:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        sp_256_proj_point_add_8(&t[13], &t[ 7], &t[ 6], tmp);
 8016c0c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016c0e:	f603 10f4 	addw	r0, r3, #2548	; 0x9f4
 8016c12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016c14:	f203 515c 	addw	r1, r3, #1372	; 0x55c
 8016c18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016c1a:	f503 6293 	add.w	r2, r3, #1176	; 0x498
 8016c1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016c20:	f7ff fb6e 	bl	8016300 <sp_256_proj_point_add_8>
        t[13].infinity = 0;
 8016c24:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016c26:	f603 13f4 	addw	r3, r3, #2548	; 0x9f4
 8016c2a:	2200      	movs	r2, #0
 8016c2c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        sp_256_proj_point_dbl_8(&t[14], &t[ 7], tmp);
 8016c30:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016c32:	f603 20b8 	addw	r0, r3, #2744	; 0xab8
 8016c36:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016c38:	f203 535c 	addw	r3, r3, #1372	; 0x55c
 8016c3c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016c3e:	4619      	mov	r1, r3
 8016c40:	f7ff fa4a 	bl	80160d8 <sp_256_proj_point_dbl_8>
        t[14].infinity = 0;
 8016c44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016c46:	f603 23b8 	addw	r3, r3, #2744	; 0xab8
 8016c4a:	2200      	movs	r2, #0
 8016c4c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        sp_256_proj_point_add_8(&t[15], &t[ 8], &t[ 7], tmp);
 8016c50:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016c52:	f603 307c 	addw	r0, r3, #2940	; 0xb7c
 8016c56:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016c58:	f503 61c4 	add.w	r1, r3, #1568	; 0x620
 8016c5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016c5e:	f203 525c 	addw	r2, r3, #1372	; 0x55c
 8016c62:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016c64:	f7ff fb4c 	bl	8016300 <sp_256_proj_point_add_8>
        t[15].infinity = 0;
 8016c68:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016c6a:	f603 337c 	addw	r3, r3, #2940	; 0xb7c
 8016c6e:	2200      	movs	r2, #0
 8016c70:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0

        i = 6;
 8016c74:	2306      	movs	r3, #6
 8016c76:	63bb      	str	r3, [r7, #56]	; 0x38
        n = k[i+1] << 0;
 8016c78:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016c7a:	3301      	adds	r3, #1
 8016c7c:	009b      	lsls	r3, r3, #2
 8016c7e:	687a      	ldr	r2, [r7, #4]
 8016c80:	4413      	add	r3, r2
 8016c82:	681b      	ldr	r3, [r3, #0]
 8016c84:	63fb      	str	r3, [r7, #60]	; 0x3c
        c = 28;
 8016c86:	231c      	movs	r3, #28
 8016c88:	637b      	str	r3, [r7, #52]	; 0x34
        y = n >> 28;
 8016c8a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016c8c:	0f1b      	lsrs	r3, r3, #28
 8016c8e:	623b      	str	r3, [r7, #32]
    #ifndef WC_NO_CACHE_RESISTANT
        if (ct) {
 8016c90:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016c92:	2b00      	cmp	r3, #0
 8016c94:	d00f      	beq.n	8016cb6 <sp_256_ecc_mulmod_fast_8+0x2ca>
            sp_256_get_point_16_8(rt, t, y);
 8016c96:	697b      	ldr	r3, [r7, #20]
 8016c98:	6a3a      	ldr	r2, [r7, #32]
 8016c9a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8016c9c:	4618      	mov	r0, r3
 8016c9e:	f7ff fccd 	bl	801663c <sp_256_get_point_16_8>
            rt->infinity = !y;
 8016ca2:	6a3b      	ldr	r3, [r7, #32]
 8016ca4:	2b00      	cmp	r3, #0
 8016ca6:	bf0c      	ite	eq
 8016ca8:	2301      	moveq	r3, #1
 8016caa:	2300      	movne	r3, #0
 8016cac:	b2da      	uxtb	r2, r3
 8016cae:	697b      	ldr	r3, [r7, #20]
 8016cb0:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
 8016cb4:	e00a      	b.n	8016ccc <sp_256_ecc_mulmod_fast_8+0x2e0>
        }
        else
    #endif
        {
            XMEMCPY(rt, &t[y], sizeof(sp_point_256));
 8016cb6:	6978      	ldr	r0, [r7, #20]
 8016cb8:	6a3b      	ldr	r3, [r7, #32]
 8016cba:	22c4      	movs	r2, #196	; 0xc4
 8016cbc:	fb02 f303 	mul.w	r3, r2, r3
 8016cc0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016cc2:	4413      	add	r3, r2
 8016cc4:	22c4      	movs	r2, #196	; 0xc4
 8016cc6:	4619      	mov	r1, r3
 8016cc8:	f002 fb95 	bl	80193f6 <memcpy>
        }
        n <<= 4;
 8016ccc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016cce:	011b      	lsls	r3, r3, #4
 8016cd0:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (; i>=0 || c>=4; ) {
 8016cd2:	e056      	b.n	8016d82 <sp_256_ecc_mulmod_fast_8+0x396>
 8016cd4:	0801aef4 	.word	0x0801aef4
            if (c < 4) {
 8016cd8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016cda:	2b03      	cmp	r3, #3
 8016cdc:	dc0c      	bgt.n	8016cf8 <sp_256_ecc_mulmod_fast_8+0x30c>
                n |= k[i--];
 8016cde:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016ce0:	1e5a      	subs	r2, r3, #1
 8016ce2:	63ba      	str	r2, [r7, #56]	; 0x38
 8016ce4:	009b      	lsls	r3, r3, #2
 8016ce6:	687a      	ldr	r2, [r7, #4]
 8016ce8:	4413      	add	r3, r2
 8016cea:	681b      	ldr	r3, [r3, #0]
 8016cec:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016cee:	4313      	orrs	r3, r2
 8016cf0:	63fb      	str	r3, [r7, #60]	; 0x3c
                c += 32;
 8016cf2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016cf4:	3320      	adds	r3, #32
 8016cf6:	637b      	str	r3, [r7, #52]	; 0x34
            }
            y = (n >> 28) & 0xf;
 8016cf8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016cfa:	0f1b      	lsrs	r3, r3, #28
 8016cfc:	623b      	str	r3, [r7, #32]
            n <<= 4;
 8016cfe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016d00:	011b      	lsls	r3, r3, #4
 8016d02:	63fb      	str	r3, [r7, #60]	; 0x3c
            c -= 4;
 8016d04:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d06:	3b04      	subs	r3, #4
 8016d08:	637b      	str	r3, [r7, #52]	; 0x34

            sp_256_proj_point_dbl_8(rt, rt, tmp);
 8016d0a:	697b      	ldr	r3, [r7, #20]
 8016d0c:	6979      	ldr	r1, [r7, #20]
 8016d0e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016d10:	4618      	mov	r0, r3
 8016d12:	f7ff f9e1 	bl	80160d8 <sp_256_proj_point_dbl_8>
            sp_256_proj_point_dbl_8(rt, rt, tmp);
 8016d16:	697b      	ldr	r3, [r7, #20]
 8016d18:	6979      	ldr	r1, [r7, #20]
 8016d1a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016d1c:	4618      	mov	r0, r3
 8016d1e:	f7ff f9db 	bl	80160d8 <sp_256_proj_point_dbl_8>
            sp_256_proj_point_dbl_8(rt, rt, tmp);
 8016d22:	697b      	ldr	r3, [r7, #20]
 8016d24:	6979      	ldr	r1, [r7, #20]
 8016d26:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016d28:	4618      	mov	r0, r3
 8016d2a:	f7ff f9d5 	bl	80160d8 <sp_256_proj_point_dbl_8>
            sp_256_proj_point_dbl_8(rt, rt, tmp);
 8016d2e:	697b      	ldr	r3, [r7, #20]
 8016d30:	6979      	ldr	r1, [r7, #20]
 8016d32:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016d34:	4618      	mov	r0, r3
 8016d36:	f7ff f9cf 	bl	80160d8 <sp_256_proj_point_dbl_8>

    #ifndef WC_NO_CACHE_RESISTANT
            if (ct) {
 8016d3a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016d3c:	2b00      	cmp	r3, #0
 8016d3e:	d015      	beq.n	8016d6c <sp_256_ecc_mulmod_fast_8+0x380>
                sp_256_get_point_16_8(p, t, y);
 8016d40:	6a3a      	ldr	r2, [r7, #32]
 8016d42:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8016d44:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8016d46:	f7ff fc79 	bl	801663c <sp_256_get_point_16_8>
                p->infinity = !y;
 8016d4a:	6a3b      	ldr	r3, [r7, #32]
 8016d4c:	2b00      	cmp	r3, #0
 8016d4e:	bf0c      	ite	eq
 8016d50:	2301      	moveq	r3, #1
 8016d52:	2300      	movne	r3, #0
 8016d54:	b2db      	uxtb	r3, r3
 8016d56:	461a      	mov	r2, r3
 8016d58:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016d5a:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
                sp_256_proj_point_add_8(rt, rt, p, tmp);
 8016d5e:	6978      	ldr	r0, [r7, #20]
 8016d60:	6979      	ldr	r1, [r7, #20]
 8016d62:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016d64:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016d66:	f7ff facb 	bl	8016300 <sp_256_proj_point_add_8>
 8016d6a:	e00a      	b.n	8016d82 <sp_256_ecc_mulmod_fast_8+0x396>
            }
            else
    #endif
            {
                sp_256_proj_point_add_8(rt, rt, &t[y], tmp);
 8016d6c:	6978      	ldr	r0, [r7, #20]
 8016d6e:	6979      	ldr	r1, [r7, #20]
 8016d70:	6a3b      	ldr	r3, [r7, #32]
 8016d72:	22c4      	movs	r2, #196	; 0xc4
 8016d74:	fb02 f303 	mul.w	r3, r2, r3
 8016d78:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016d7a:	441a      	add	r2, r3
 8016d7c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016d7e:	f7ff fabf 	bl	8016300 <sp_256_proj_point_add_8>
        for (; i>=0 || c>=4; ) {
 8016d82:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016d84:	2b00      	cmp	r3, #0
 8016d86:	daa7      	bge.n	8016cd8 <sp_256_ecc_mulmod_fast_8+0x2ec>
 8016d88:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d8a:	2b03      	cmp	r3, #3
 8016d8c:	dca4      	bgt.n	8016cd8 <sp_256_ecc_mulmod_fast_8+0x2ec>
            }
        }

        if (map != 0) {
 8016d8e:	683b      	ldr	r3, [r7, #0]
 8016d90:	2b00      	cmp	r3, #0
 8016d92:	d006      	beq.n	8016da2 <sp_256_ecc_mulmod_fast_8+0x3b6>
            sp_256_map_8(r, rt, tmp);
 8016d94:	697b      	ldr	r3, [r7, #20]
 8016d96:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016d98:	4619      	mov	r1, r3
 8016d9a:	68f8      	ldr	r0, [r7, #12]
 8016d9c:	f7fe febe 	bl	8015b1c <sp_256_map_8>
 8016da0:	e005      	b.n	8016dae <sp_256_ecc_mulmod_fast_8+0x3c2>
        }
        else {
            XMEMCPY(r, rt, sizeof(sp_point_256));
 8016da2:	697b      	ldr	r3, [r7, #20]
 8016da4:	22c4      	movs	r2, #196	; 0xc4
 8016da6:	4619      	mov	r1, r3
 8016da8:	68f8      	ldr	r0, [r7, #12]
 8016daa:	f002 fb24 	bl	80193f6 <memcpy>
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (tmp != NULL) {
 8016dae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016db0:	2b00      	cmp	r3, #0
 8016db2:	d00d      	beq.n	8016dd0 <sp_256_ecc_mulmod_fast_8+0x3e4>
        XMEMSET(tmp, 0, sizeof(sp_digit) * 2 * 8 * 5);
 8016db4:	f44f 72a0 	mov.w	r2, #320	; 0x140
 8016db8:	2100      	movs	r1, #0
 8016dba:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8016dbc:	f002 fb3f 	bl	801943e <memset>
        XFREE(tmp, heap, DYNAMIC_TYPE_ECC);
 8016dc0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016dc2:	61fb      	str	r3, [r7, #28]
 8016dc4:	69fb      	ldr	r3, [r7, #28]
 8016dc6:	2b00      	cmp	r3, #0
 8016dc8:	d002      	beq.n	8016dd0 <sp_256_ecc_mulmod_fast_8+0x3e4>
 8016dca:	69f8      	ldr	r0, [r7, #28]
 8016dcc:	f7f8 f8b0 	bl	800ef30 <wolfSSL_Free>
    }
    if (t != NULL) {
 8016dd0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016dd2:	2b00      	cmp	r3, #0
 8016dd4:	d00d      	beq.n	8016df2 <sp_256_ecc_mulmod_fast_8+0x406>
        XMEMSET(t, 0, sizeof(sp_point_256) * 16);
 8016dd6:	f44f 6244 	mov.w	r2, #3136	; 0xc40
 8016dda:	2100      	movs	r1, #0
 8016ddc:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8016dde:	f002 fb2e 	bl	801943e <memset>
        XFREE(t, heap, DYNAMIC_TYPE_ECC);
 8016de2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016de4:	61bb      	str	r3, [r7, #24]
 8016de6:	69bb      	ldr	r3, [r7, #24]
 8016de8:	2b00      	cmp	r3, #0
 8016dea:	d002      	beq.n	8016df2 <sp_256_ecc_mulmod_fast_8+0x406>
 8016dec:	69b8      	ldr	r0, [r7, #24]
 8016dee:	f7f8 f89f 	bl	800ef30 <wolfSSL_Free>
    }
#else
    ForceZero(tmpd, sizeof(tmpd));
    ForceZero(td, sizeof(td));
#endif
    sp_256_point_free_8(rt, 1, heap);
 8016df2:	697b      	ldr	r3, [r7, #20]
 8016df4:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8016df6:	2101      	movs	r1, #1
 8016df8:	4618      	mov	r0, r3
 8016dfa:	f7fd fbc7 	bl	801458c <sp_256_point_free_8>

    return err;
 8016dfe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
}
 8016e00:	4618      	mov	r0, r3
 8016e02:	3740      	adds	r7, #64	; 0x40
 8016e04:	46bd      	mov	sp, r7
 8016e06:	bd80      	pop	{r7, pc}

08016e08 <sp_256_proj_point_add_qz1_8>:
 * q  Second point to add.
 * t  Temporary ordinate data.
 */
static void sp_256_proj_point_add_qz1_8(sp_point_256* r, const sp_point_256* p,
        const sp_point_256* q, sp_digit* t)
{
 8016e08:	b5b0      	push	{r4, r5, r7, lr}
 8016e0a:	b094      	sub	sp, #80	; 0x50
 8016e0c:	af02      	add	r7, sp, #8
 8016e0e:	60f8      	str	r0, [r7, #12]
 8016e10:	60b9      	str	r1, [r7, #8]
 8016e12:	607a      	str	r2, [r7, #4]
 8016e14:	603b      	str	r3, [r7, #0]
    const sp_point_256* ap[2];
    sp_point_256* rp[2];
    sp_digit* t1 = t;
 8016e16:	683b      	ldr	r3, [r7, #0]
 8016e18:	643b      	str	r3, [r7, #64]	; 0x40
    sp_digit* t2 = t + 2*8;
 8016e1a:	683b      	ldr	r3, [r7, #0]
 8016e1c:	3340      	adds	r3, #64	; 0x40
 8016e1e:	63fb      	str	r3, [r7, #60]	; 0x3c
    sp_digit* t3 = t + 4*8;
 8016e20:	683b      	ldr	r3, [r7, #0]
 8016e22:	3380      	adds	r3, #128	; 0x80
 8016e24:	63bb      	str	r3, [r7, #56]	; 0x38
    sp_digit* t4 = t + 6*8;
 8016e26:	683b      	ldr	r3, [r7, #0]
 8016e28:	33c0      	adds	r3, #192	; 0xc0
 8016e2a:	637b      	str	r3, [r7, #52]	; 0x34
    sp_digit* t5 = t + 8*8;
 8016e2c:	683b      	ldr	r3, [r7, #0]
 8016e2e:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8016e32:	633b      	str	r3, [r7, #48]	; 0x30
    sp_digit* y;
    sp_digit* z;
    int i;

    /* Check double */
    (void)sp_256_sub_8(t1, p256_mod, q->y);
 8016e34:	687b      	ldr	r3, [r7, #4]
 8016e36:	3340      	adds	r3, #64	; 0x40
 8016e38:	461a      	mov	r2, r3
 8016e3a:	49a4      	ldr	r1, [pc, #656]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 8016e3c:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8016e3e:	f7ff f9e7 	bl	8016210 <sp_256_sub_8>
    sp_256_norm_8(t1);
    if ((sp_256_cmp_equal_8(p->x, q->x) & sp_256_cmp_equal_8(p->z, q->z) &
 8016e42:	68bb      	ldr	r3, [r7, #8]
 8016e44:	687a      	ldr	r2, [r7, #4]
 8016e46:	4611      	mov	r1, r2
 8016e48:	4618      	mov	r0, r3
 8016e4a:	f7ff fa0b 	bl	8016264 <sp_256_cmp_equal_8>
 8016e4e:	4604      	mov	r4, r0
 8016e50:	68bb      	ldr	r3, [r7, #8]
 8016e52:	f103 0280 	add.w	r2, r3, #128	; 0x80
 8016e56:	687b      	ldr	r3, [r7, #4]
 8016e58:	3380      	adds	r3, #128	; 0x80
 8016e5a:	4619      	mov	r1, r3
 8016e5c:	4610      	mov	r0, r2
 8016e5e:	f7ff fa01 	bl	8016264 <sp_256_cmp_equal_8>
 8016e62:	4603      	mov	r3, r0
 8016e64:	401c      	ands	r4, r3
        (sp_256_cmp_equal_8(p->y, q->y) | sp_256_cmp_equal_8(p->y, t1))) != 0) {
 8016e66:	68bb      	ldr	r3, [r7, #8]
 8016e68:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8016e6c:	687b      	ldr	r3, [r7, #4]
 8016e6e:	3340      	adds	r3, #64	; 0x40
 8016e70:	4619      	mov	r1, r3
 8016e72:	4610      	mov	r0, r2
 8016e74:	f7ff f9f6 	bl	8016264 <sp_256_cmp_equal_8>
 8016e78:	4605      	mov	r5, r0
 8016e7a:	68bb      	ldr	r3, [r7, #8]
 8016e7c:	3340      	adds	r3, #64	; 0x40
 8016e7e:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8016e80:	4618      	mov	r0, r3
 8016e82:	f7ff f9ef 	bl	8016264 <sp_256_cmp_equal_8>
 8016e86:	4603      	mov	r3, r0
 8016e88:	432b      	orrs	r3, r5
    if ((sp_256_cmp_equal_8(p->x, q->x) & sp_256_cmp_equal_8(p->z, q->z) &
 8016e8a:	4023      	ands	r3, r4
 8016e8c:	2b00      	cmp	r3, #0
 8016e8e:	d005      	beq.n	8016e9c <sp_256_proj_point_add_qz1_8+0x94>
        sp_256_proj_point_dbl_8(r, p, t);
 8016e90:	683a      	ldr	r2, [r7, #0]
 8016e92:	68b9      	ldr	r1, [r7, #8]
 8016e94:	68f8      	ldr	r0, [r7, #12]
 8016e96:	f7ff f91f 	bl	80160d8 <sp_256_proj_point_dbl_8>
        sp_256_mont_sub_8(t3, t3, x, p256_mod);
        sp_256_mont_mul_8(t3, t3, t4, p256_mod, p256_mp_mod);
        sp_256_mont_mul_8(t5, t5, y, p256_mod, p256_mp_mod);
        sp_256_mont_sub_8(y, t3, t5, p256_mod);
    }
}
 8016e9a:	e113      	b.n	80170c4 <sp_256_proj_point_add_qz1_8+0x2bc>
        rp[0] = r;
 8016e9c:	68fb      	ldr	r3, [r7, #12]
 8016e9e:	617b      	str	r3, [r7, #20]
        rp[1] = (sp_point_256*)t; /*lint !e9087 !e740*/
 8016ea0:	683b      	ldr	r3, [r7, #0]
 8016ea2:	61bb      	str	r3, [r7, #24]
        XMEMSET(rp[1], 0, sizeof(sp_point_256));
 8016ea4:	69bb      	ldr	r3, [r7, #24]
 8016ea6:	22c4      	movs	r2, #196	; 0xc4
 8016ea8:	2100      	movs	r1, #0
 8016eaa:	4618      	mov	r0, r3
 8016eac:	f002 fac7 	bl	801943e <memset>
        x = rp[p->infinity | q->infinity]->x;
 8016eb0:	68bb      	ldr	r3, [r7, #8]
 8016eb2:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 8016eb6:	687b      	ldr	r3, [r7, #4]
 8016eb8:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8016ebc:	4313      	orrs	r3, r2
 8016ebe:	009b      	lsls	r3, r3, #2
 8016ec0:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8016ec4:	4413      	add	r3, r2
 8016ec6:	f853 3c34 	ldr.w	r3, [r3, #-52]
 8016eca:	62fb      	str	r3, [r7, #44]	; 0x2c
        y = rp[p->infinity | q->infinity]->y;
 8016ecc:	68bb      	ldr	r3, [r7, #8]
 8016ece:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 8016ed2:	687b      	ldr	r3, [r7, #4]
 8016ed4:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8016ed8:	4313      	orrs	r3, r2
 8016eda:	009b      	lsls	r3, r3, #2
 8016edc:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8016ee0:	4413      	add	r3, r2
 8016ee2:	f853 3c34 	ldr.w	r3, [r3, #-52]
 8016ee6:	3340      	adds	r3, #64	; 0x40
 8016ee8:	62bb      	str	r3, [r7, #40]	; 0x28
        z = rp[p->infinity | q->infinity]->z;
 8016eea:	68bb      	ldr	r3, [r7, #8]
 8016eec:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 8016ef0:	687b      	ldr	r3, [r7, #4]
 8016ef2:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8016ef6:	4313      	orrs	r3, r2
 8016ef8:	009b      	lsls	r3, r3, #2
 8016efa:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8016efe:	4413      	add	r3, r2
 8016f00:	f853 3c34 	ldr.w	r3, [r3, #-52]
 8016f04:	3380      	adds	r3, #128	; 0x80
 8016f06:	627b      	str	r3, [r7, #36]	; 0x24
        ap[0] = p;
 8016f08:	68bb      	ldr	r3, [r7, #8]
 8016f0a:	61fb      	str	r3, [r7, #28]
        ap[1] = q;
 8016f0c:	687b      	ldr	r3, [r7, #4]
 8016f0e:	623b      	str	r3, [r7, #32]
        for (i=0; i<8; i++) {
 8016f10:	2300      	movs	r3, #0
 8016f12:	647b      	str	r3, [r7, #68]	; 0x44
 8016f14:	e012      	b.n	8016f3c <sp_256_proj_point_add_qz1_8+0x134>
            r->x[i] = ap[p->infinity]->x[i];
 8016f16:	68bb      	ldr	r3, [r7, #8]
 8016f18:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8016f1c:	009b      	lsls	r3, r3, #2
 8016f1e:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8016f22:	4413      	add	r3, r2
 8016f24:	f853 3c2c 	ldr.w	r3, [r3, #-44]
 8016f28:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8016f2a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8016f2e:	68fb      	ldr	r3, [r7, #12]
 8016f30:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8016f32:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i=0; i<8; i++) {
 8016f36:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016f38:	3301      	adds	r3, #1
 8016f3a:	647b      	str	r3, [r7, #68]	; 0x44
 8016f3c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016f3e:	2b07      	cmp	r3, #7
 8016f40:	dde9      	ble.n	8016f16 <sp_256_proj_point_add_qz1_8+0x10e>
        for (i=0; i<8; i++) {
 8016f42:	2300      	movs	r3, #0
 8016f44:	647b      	str	r3, [r7, #68]	; 0x44
 8016f46:	e014      	b.n	8016f72 <sp_256_proj_point_add_qz1_8+0x16a>
            r->y[i] = ap[p->infinity]->y[i];
 8016f48:	68bb      	ldr	r3, [r7, #8]
 8016f4a:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8016f4e:	009b      	lsls	r3, r3, #2
 8016f50:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8016f54:	4413      	add	r3, r2
 8016f56:	f853 3c2c 	ldr.w	r3, [r3, #-44]
 8016f5a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8016f5c:	3210      	adds	r2, #16
 8016f5e:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8016f62:	68fb      	ldr	r3, [r7, #12]
 8016f64:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8016f66:	3210      	adds	r2, #16
 8016f68:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i=0; i<8; i++) {
 8016f6c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016f6e:	3301      	adds	r3, #1
 8016f70:	647b      	str	r3, [r7, #68]	; 0x44
 8016f72:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016f74:	2b07      	cmp	r3, #7
 8016f76:	dde7      	ble.n	8016f48 <sp_256_proj_point_add_qz1_8+0x140>
        for (i=0; i<8; i++) {
 8016f78:	2300      	movs	r3, #0
 8016f7a:	647b      	str	r3, [r7, #68]	; 0x44
 8016f7c:	e014      	b.n	8016fa8 <sp_256_proj_point_add_qz1_8+0x1a0>
            r->z[i] = ap[p->infinity]->z[i];
 8016f7e:	68bb      	ldr	r3, [r7, #8]
 8016f80:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8016f84:	009b      	lsls	r3, r3, #2
 8016f86:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8016f8a:	4413      	add	r3, r2
 8016f8c:	f853 3c2c 	ldr.w	r3, [r3, #-44]
 8016f90:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8016f92:	3220      	adds	r2, #32
 8016f94:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8016f98:	68fb      	ldr	r3, [r7, #12]
 8016f9a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8016f9c:	3220      	adds	r2, #32
 8016f9e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i=0; i<8; i++) {
 8016fa2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016fa4:	3301      	adds	r3, #1
 8016fa6:	647b      	str	r3, [r7, #68]	; 0x44
 8016fa8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016faa:	2b07      	cmp	r3, #7
 8016fac:	dde7      	ble.n	8016f7e <sp_256_proj_point_add_qz1_8+0x176>
        r->infinity = ap[p->infinity]->infinity;
 8016fae:	68bb      	ldr	r3, [r7, #8]
 8016fb0:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8016fb4:	009b      	lsls	r3, r3, #2
 8016fb6:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8016fba:	4413      	add	r3, r2
 8016fbc:	f853 3c2c 	ldr.w	r3, [r3, #-44]
 8016fc0:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 8016fc4:	68fb      	ldr	r3, [r7, #12]
 8016fc6:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        sp_256_mont_sqr_8(t2, z, p256_mod, p256_mp_mod);
 8016fca:	2301      	movs	r3, #1
 8016fcc:	4a3f      	ldr	r2, [pc, #252]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 8016fce:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8016fd0:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8016fd2:	f7fe f8e0 	bl	8015196 <sp_256_mont_sqr_8>
        sp_256_mont_mul_8(t4, t2, z, p256_mod, p256_mp_mod);
 8016fd6:	2301      	movs	r3, #1
 8016fd8:	9300      	str	r3, [sp, #0]
 8016fda:	4b3c      	ldr	r3, [pc, #240]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 8016fdc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016fde:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8016fe0:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8016fe2:	f7fd fcf2 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_mul_8(t2, t2, q->x, p256_mod, p256_mp_mod);
 8016fe6:	687a      	ldr	r2, [r7, #4]
 8016fe8:	2301      	movs	r3, #1
 8016fea:	9300      	str	r3, [sp, #0]
 8016fec:	4b37      	ldr	r3, [pc, #220]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 8016fee:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8016ff0:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8016ff2:	f7fd fcea 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_mul_8(t4, t4, q->y, p256_mod, p256_mp_mod);
 8016ff6:	687b      	ldr	r3, [r7, #4]
 8016ff8:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8016ffc:	2301      	movs	r3, #1
 8016ffe:	9300      	str	r3, [sp, #0]
 8017000:	4b32      	ldr	r3, [pc, #200]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 8017002:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8017004:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8017006:	f7fd fce0 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_sub_8(t2, t2, x, p256_mod);
 801700a:	4b30      	ldr	r3, [pc, #192]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 801700c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801700e:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8017010:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8017012:	f7fe ff7b 	bl	8015f0c <sp_256_mont_sub_8>
        sp_256_mont_sub_8(t4, t4, y, p256_mod);
 8017016:	4b2d      	ldr	r3, [pc, #180]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 8017018:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801701a:	6b79      	ldr	r1, [r7, #52]	; 0x34
 801701c:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801701e:	f7fe ff75 	bl	8015f0c <sp_256_mont_sub_8>
        sp_256_mont_mul_8(z, z, t2, p256_mod, p256_mp_mod);
 8017022:	2301      	movs	r3, #1
 8017024:	9300      	str	r3, [sp, #0]
 8017026:	4b29      	ldr	r3, [pc, #164]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 8017028:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801702a:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801702c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801702e:	f7fd fccc 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_sqr_8(t1, t4, p256_mod, p256_mp_mod);
 8017032:	2301      	movs	r3, #1
 8017034:	4a25      	ldr	r2, [pc, #148]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 8017036:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8017038:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801703a:	f7fe f8ac 	bl	8015196 <sp_256_mont_sqr_8>
        sp_256_mont_sqr_8(t5, t2, p256_mod, p256_mp_mod);
 801703e:	2301      	movs	r3, #1
 8017040:	4a22      	ldr	r2, [pc, #136]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 8017042:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8017044:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8017046:	f7fe f8a6 	bl	8015196 <sp_256_mont_sqr_8>
        sp_256_mont_mul_8(t3, x, t5, p256_mod, p256_mp_mod);
 801704a:	2301      	movs	r3, #1
 801704c:	9300      	str	r3, [sp, #0]
 801704e:	4b1f      	ldr	r3, [pc, #124]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 8017050:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8017052:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8017054:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8017056:	f7fd fcb8 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_mul_8(t5, t5, t2, p256_mod, p256_mp_mod);
 801705a:	2301      	movs	r3, #1
 801705c:	9300      	str	r3, [sp, #0]
 801705e:	4b1b      	ldr	r3, [pc, #108]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 8017060:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8017062:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8017064:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8017066:	f7fd fcb0 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_sub_8(x, t1, t5, p256_mod);
 801706a:	4b18      	ldr	r3, [pc, #96]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 801706c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801706e:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8017070:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8017072:	f7fe ff4b 	bl	8015f0c <sp_256_mont_sub_8>
        sp_256_mont_dbl_8(t1, t3, p256_mod);
 8017076:	4a15      	ldr	r2, [pc, #84]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 8017078:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 801707a:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801707c:	f7fe fe77 	bl	8015d6e <sp_256_mont_dbl_8>
        sp_256_mont_sub_8(x, x, t1, p256_mod);
 8017080:	4b12      	ldr	r3, [pc, #72]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 8017082:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8017084:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8017086:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8017088:	f7fe ff40 	bl	8015f0c <sp_256_mont_sub_8>
        sp_256_mont_sub_8(t3, t3, x, p256_mod);
 801708c:	4b0f      	ldr	r3, [pc, #60]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 801708e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8017090:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8017092:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8017094:	f7fe ff3a 	bl	8015f0c <sp_256_mont_sub_8>
        sp_256_mont_mul_8(t3, t3, t4, p256_mod, p256_mp_mod);
 8017098:	2301      	movs	r3, #1
 801709a:	9300      	str	r3, [sp, #0]
 801709c:	4b0b      	ldr	r3, [pc, #44]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 801709e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80170a0:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 80170a2:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80170a4:	f7fd fc91 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_mul_8(t5, t5, y, p256_mod, p256_mp_mod);
 80170a8:	2301      	movs	r3, #1
 80170aa:	9300      	str	r3, [sp, #0]
 80170ac:	4b07      	ldr	r3, [pc, #28]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 80170ae:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80170b0:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80170b2:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80170b4:	f7fd fc89 	bl	80149ca <sp_256_mont_mul_8>
        sp_256_mont_sub_8(y, t3, t5, p256_mod);
 80170b8:	4b04      	ldr	r3, [pc, #16]	; (80170cc <sp_256_proj_point_add_qz1_8+0x2c4>)
 80170ba:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80170bc:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 80170be:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80170c0:	f7fe ff24 	bl	8015f0c <sp_256_mont_sub_8>
}
 80170c4:	bf00      	nop
 80170c6:	3748      	adds	r7, #72	; 0x48
 80170c8:	46bd      	mov	sp, r7
 80170ca:	bdb0      	pop	{r4, r5, r7, pc}
 80170cc:	0801aef4 	.word	0x0801aef4

080170d0 <sp_256_get_entry_16_8>:
 * table  Table - start of the entires to access
 * idx    Index of entry to retrieve.
 */
static void sp_256_get_entry_16_8(sp_point_256* r,
    const sp_table_entry_256* table, int idx)
{
 80170d0:	b480      	push	{r7}
 80170d2:	b087      	sub	sp, #28
 80170d4:	af00      	add	r7, sp, #0
 80170d6:	60f8      	str	r0, [r7, #12]
 80170d8:	60b9      	str	r1, [r7, #8]
 80170da:	607a      	str	r2, [r7, #4]
    int i;
    sp_digit mask;

    r->x[0] = 0;
 80170dc:	68fb      	ldr	r3, [r7, #12]
 80170de:	2200      	movs	r2, #0
 80170e0:	601a      	str	r2, [r3, #0]
    r->x[1] = 0;
 80170e2:	68fb      	ldr	r3, [r7, #12]
 80170e4:	2200      	movs	r2, #0
 80170e6:	605a      	str	r2, [r3, #4]
    r->x[2] = 0;
 80170e8:	68fb      	ldr	r3, [r7, #12]
 80170ea:	2200      	movs	r2, #0
 80170ec:	609a      	str	r2, [r3, #8]
    r->x[3] = 0;
 80170ee:	68fb      	ldr	r3, [r7, #12]
 80170f0:	2200      	movs	r2, #0
 80170f2:	60da      	str	r2, [r3, #12]
    r->x[4] = 0;
 80170f4:	68fb      	ldr	r3, [r7, #12]
 80170f6:	2200      	movs	r2, #0
 80170f8:	611a      	str	r2, [r3, #16]
    r->x[5] = 0;
 80170fa:	68fb      	ldr	r3, [r7, #12]
 80170fc:	2200      	movs	r2, #0
 80170fe:	615a      	str	r2, [r3, #20]
    r->x[6] = 0;
 8017100:	68fb      	ldr	r3, [r7, #12]
 8017102:	2200      	movs	r2, #0
 8017104:	619a      	str	r2, [r3, #24]
    r->x[7] = 0;
 8017106:	68fb      	ldr	r3, [r7, #12]
 8017108:	2200      	movs	r2, #0
 801710a:	61da      	str	r2, [r3, #28]
    r->y[0] = 0;
 801710c:	68fb      	ldr	r3, [r7, #12]
 801710e:	2200      	movs	r2, #0
 8017110:	641a      	str	r2, [r3, #64]	; 0x40
    r->y[1] = 0;
 8017112:	68fb      	ldr	r3, [r7, #12]
 8017114:	2200      	movs	r2, #0
 8017116:	645a      	str	r2, [r3, #68]	; 0x44
    r->y[2] = 0;
 8017118:	68fb      	ldr	r3, [r7, #12]
 801711a:	2200      	movs	r2, #0
 801711c:	649a      	str	r2, [r3, #72]	; 0x48
    r->y[3] = 0;
 801711e:	68fb      	ldr	r3, [r7, #12]
 8017120:	2200      	movs	r2, #0
 8017122:	64da      	str	r2, [r3, #76]	; 0x4c
    r->y[4] = 0;
 8017124:	68fb      	ldr	r3, [r7, #12]
 8017126:	2200      	movs	r2, #0
 8017128:	651a      	str	r2, [r3, #80]	; 0x50
    r->y[5] = 0;
 801712a:	68fb      	ldr	r3, [r7, #12]
 801712c:	2200      	movs	r2, #0
 801712e:	655a      	str	r2, [r3, #84]	; 0x54
    r->y[6] = 0;
 8017130:	68fb      	ldr	r3, [r7, #12]
 8017132:	2200      	movs	r2, #0
 8017134:	659a      	str	r2, [r3, #88]	; 0x58
    r->y[7] = 0;
 8017136:	68fb      	ldr	r3, [r7, #12]
 8017138:	2200      	movs	r2, #0
 801713a:	65da      	str	r2, [r3, #92]	; 0x5c
    for (i = 1; i < 16; i++) {
 801713c:	2301      	movs	r3, #1
 801713e:	617b      	str	r3, [r7, #20]
 8017140:	e0cb      	b.n	80172da <sp_256_get_entry_16_8+0x20a>
        mask = 0 - (i == idx);
 8017142:	697a      	ldr	r2, [r7, #20]
 8017144:	687b      	ldr	r3, [r7, #4]
 8017146:	429a      	cmp	r2, r3
 8017148:	bf0c      	ite	eq
 801714a:	2301      	moveq	r3, #1
 801714c:	2300      	movne	r3, #0
 801714e:	b2db      	uxtb	r3, r3
 8017150:	425b      	negs	r3, r3
 8017152:	613b      	str	r3, [r7, #16]
        r->x[0] |= mask & table[i].x[0];
 8017154:	68fb      	ldr	r3, [r7, #12]
 8017156:	681a      	ldr	r2, [r3, #0]
 8017158:	697b      	ldr	r3, [r7, #20]
 801715a:	019b      	lsls	r3, r3, #6
 801715c:	68b9      	ldr	r1, [r7, #8]
 801715e:	440b      	add	r3, r1
 8017160:	6819      	ldr	r1, [r3, #0]
 8017162:	693b      	ldr	r3, [r7, #16]
 8017164:	400b      	ands	r3, r1
 8017166:	431a      	orrs	r2, r3
 8017168:	68fb      	ldr	r3, [r7, #12]
 801716a:	601a      	str	r2, [r3, #0]
        r->x[1] |= mask & table[i].x[1];
 801716c:	68fb      	ldr	r3, [r7, #12]
 801716e:	685a      	ldr	r2, [r3, #4]
 8017170:	697b      	ldr	r3, [r7, #20]
 8017172:	019b      	lsls	r3, r3, #6
 8017174:	68b9      	ldr	r1, [r7, #8]
 8017176:	440b      	add	r3, r1
 8017178:	6859      	ldr	r1, [r3, #4]
 801717a:	693b      	ldr	r3, [r7, #16]
 801717c:	400b      	ands	r3, r1
 801717e:	431a      	orrs	r2, r3
 8017180:	68fb      	ldr	r3, [r7, #12]
 8017182:	605a      	str	r2, [r3, #4]
        r->x[2] |= mask & table[i].x[2];
 8017184:	68fb      	ldr	r3, [r7, #12]
 8017186:	689a      	ldr	r2, [r3, #8]
 8017188:	697b      	ldr	r3, [r7, #20]
 801718a:	019b      	lsls	r3, r3, #6
 801718c:	68b9      	ldr	r1, [r7, #8]
 801718e:	440b      	add	r3, r1
 8017190:	6899      	ldr	r1, [r3, #8]
 8017192:	693b      	ldr	r3, [r7, #16]
 8017194:	400b      	ands	r3, r1
 8017196:	431a      	orrs	r2, r3
 8017198:	68fb      	ldr	r3, [r7, #12]
 801719a:	609a      	str	r2, [r3, #8]
        r->x[3] |= mask & table[i].x[3];
 801719c:	68fb      	ldr	r3, [r7, #12]
 801719e:	68da      	ldr	r2, [r3, #12]
 80171a0:	697b      	ldr	r3, [r7, #20]
 80171a2:	019b      	lsls	r3, r3, #6
 80171a4:	68b9      	ldr	r1, [r7, #8]
 80171a6:	440b      	add	r3, r1
 80171a8:	68d9      	ldr	r1, [r3, #12]
 80171aa:	693b      	ldr	r3, [r7, #16]
 80171ac:	400b      	ands	r3, r1
 80171ae:	431a      	orrs	r2, r3
 80171b0:	68fb      	ldr	r3, [r7, #12]
 80171b2:	60da      	str	r2, [r3, #12]
        r->x[4] |= mask & table[i].x[4];
 80171b4:	68fb      	ldr	r3, [r7, #12]
 80171b6:	691a      	ldr	r2, [r3, #16]
 80171b8:	697b      	ldr	r3, [r7, #20]
 80171ba:	019b      	lsls	r3, r3, #6
 80171bc:	68b9      	ldr	r1, [r7, #8]
 80171be:	440b      	add	r3, r1
 80171c0:	6919      	ldr	r1, [r3, #16]
 80171c2:	693b      	ldr	r3, [r7, #16]
 80171c4:	400b      	ands	r3, r1
 80171c6:	431a      	orrs	r2, r3
 80171c8:	68fb      	ldr	r3, [r7, #12]
 80171ca:	611a      	str	r2, [r3, #16]
        r->x[5] |= mask & table[i].x[5];
 80171cc:	68fb      	ldr	r3, [r7, #12]
 80171ce:	695a      	ldr	r2, [r3, #20]
 80171d0:	697b      	ldr	r3, [r7, #20]
 80171d2:	019b      	lsls	r3, r3, #6
 80171d4:	68b9      	ldr	r1, [r7, #8]
 80171d6:	440b      	add	r3, r1
 80171d8:	6959      	ldr	r1, [r3, #20]
 80171da:	693b      	ldr	r3, [r7, #16]
 80171dc:	400b      	ands	r3, r1
 80171de:	431a      	orrs	r2, r3
 80171e0:	68fb      	ldr	r3, [r7, #12]
 80171e2:	615a      	str	r2, [r3, #20]
        r->x[6] |= mask & table[i].x[6];
 80171e4:	68fb      	ldr	r3, [r7, #12]
 80171e6:	699a      	ldr	r2, [r3, #24]
 80171e8:	697b      	ldr	r3, [r7, #20]
 80171ea:	019b      	lsls	r3, r3, #6
 80171ec:	68b9      	ldr	r1, [r7, #8]
 80171ee:	440b      	add	r3, r1
 80171f0:	6999      	ldr	r1, [r3, #24]
 80171f2:	693b      	ldr	r3, [r7, #16]
 80171f4:	400b      	ands	r3, r1
 80171f6:	431a      	orrs	r2, r3
 80171f8:	68fb      	ldr	r3, [r7, #12]
 80171fa:	619a      	str	r2, [r3, #24]
        r->x[7] |= mask & table[i].x[7];
 80171fc:	68fb      	ldr	r3, [r7, #12]
 80171fe:	69da      	ldr	r2, [r3, #28]
 8017200:	697b      	ldr	r3, [r7, #20]
 8017202:	019b      	lsls	r3, r3, #6
 8017204:	68b9      	ldr	r1, [r7, #8]
 8017206:	440b      	add	r3, r1
 8017208:	69d9      	ldr	r1, [r3, #28]
 801720a:	693b      	ldr	r3, [r7, #16]
 801720c:	400b      	ands	r3, r1
 801720e:	431a      	orrs	r2, r3
 8017210:	68fb      	ldr	r3, [r7, #12]
 8017212:	61da      	str	r2, [r3, #28]
        r->y[0] |= mask & table[i].y[0];
 8017214:	68fb      	ldr	r3, [r7, #12]
 8017216:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8017218:	697b      	ldr	r3, [r7, #20]
 801721a:	019b      	lsls	r3, r3, #6
 801721c:	68b9      	ldr	r1, [r7, #8]
 801721e:	440b      	add	r3, r1
 8017220:	6a19      	ldr	r1, [r3, #32]
 8017222:	693b      	ldr	r3, [r7, #16]
 8017224:	400b      	ands	r3, r1
 8017226:	431a      	orrs	r2, r3
 8017228:	68fb      	ldr	r3, [r7, #12]
 801722a:	641a      	str	r2, [r3, #64]	; 0x40
        r->y[1] |= mask & table[i].y[1];
 801722c:	68fb      	ldr	r3, [r7, #12]
 801722e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8017230:	697b      	ldr	r3, [r7, #20]
 8017232:	019b      	lsls	r3, r3, #6
 8017234:	68b9      	ldr	r1, [r7, #8]
 8017236:	440b      	add	r3, r1
 8017238:	6a59      	ldr	r1, [r3, #36]	; 0x24
 801723a:	693b      	ldr	r3, [r7, #16]
 801723c:	400b      	ands	r3, r1
 801723e:	431a      	orrs	r2, r3
 8017240:	68fb      	ldr	r3, [r7, #12]
 8017242:	645a      	str	r2, [r3, #68]	; 0x44
        r->y[2] |= mask & table[i].y[2];
 8017244:	68fb      	ldr	r3, [r7, #12]
 8017246:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8017248:	697b      	ldr	r3, [r7, #20]
 801724a:	019b      	lsls	r3, r3, #6
 801724c:	68b9      	ldr	r1, [r7, #8]
 801724e:	440b      	add	r3, r1
 8017250:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8017252:	693b      	ldr	r3, [r7, #16]
 8017254:	400b      	ands	r3, r1
 8017256:	431a      	orrs	r2, r3
 8017258:	68fb      	ldr	r3, [r7, #12]
 801725a:	649a      	str	r2, [r3, #72]	; 0x48
        r->y[3] |= mask & table[i].y[3];
 801725c:	68fb      	ldr	r3, [r7, #12]
 801725e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8017260:	697b      	ldr	r3, [r7, #20]
 8017262:	019b      	lsls	r3, r3, #6
 8017264:	68b9      	ldr	r1, [r7, #8]
 8017266:	440b      	add	r3, r1
 8017268:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 801726a:	693b      	ldr	r3, [r7, #16]
 801726c:	400b      	ands	r3, r1
 801726e:	431a      	orrs	r2, r3
 8017270:	68fb      	ldr	r3, [r7, #12]
 8017272:	64da      	str	r2, [r3, #76]	; 0x4c
        r->y[4] |= mask & table[i].y[4];
 8017274:	68fb      	ldr	r3, [r7, #12]
 8017276:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8017278:	697b      	ldr	r3, [r7, #20]
 801727a:	019b      	lsls	r3, r3, #6
 801727c:	68b9      	ldr	r1, [r7, #8]
 801727e:	440b      	add	r3, r1
 8017280:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8017282:	693b      	ldr	r3, [r7, #16]
 8017284:	400b      	ands	r3, r1
 8017286:	431a      	orrs	r2, r3
 8017288:	68fb      	ldr	r3, [r7, #12]
 801728a:	651a      	str	r2, [r3, #80]	; 0x50
        r->y[5] |= mask & table[i].y[5];
 801728c:	68fb      	ldr	r3, [r7, #12]
 801728e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8017290:	697b      	ldr	r3, [r7, #20]
 8017292:	019b      	lsls	r3, r3, #6
 8017294:	68b9      	ldr	r1, [r7, #8]
 8017296:	440b      	add	r3, r1
 8017298:	6b59      	ldr	r1, [r3, #52]	; 0x34
 801729a:	693b      	ldr	r3, [r7, #16]
 801729c:	400b      	ands	r3, r1
 801729e:	431a      	orrs	r2, r3
 80172a0:	68fb      	ldr	r3, [r7, #12]
 80172a2:	655a      	str	r2, [r3, #84]	; 0x54
        r->y[6] |= mask & table[i].y[6];
 80172a4:	68fb      	ldr	r3, [r7, #12]
 80172a6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80172a8:	697b      	ldr	r3, [r7, #20]
 80172aa:	019b      	lsls	r3, r3, #6
 80172ac:	68b9      	ldr	r1, [r7, #8]
 80172ae:	440b      	add	r3, r1
 80172b0:	6b99      	ldr	r1, [r3, #56]	; 0x38
 80172b2:	693b      	ldr	r3, [r7, #16]
 80172b4:	400b      	ands	r3, r1
 80172b6:	431a      	orrs	r2, r3
 80172b8:	68fb      	ldr	r3, [r7, #12]
 80172ba:	659a      	str	r2, [r3, #88]	; 0x58
        r->y[7] |= mask & table[i].y[7];
 80172bc:	68fb      	ldr	r3, [r7, #12]
 80172be:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 80172c0:	697b      	ldr	r3, [r7, #20]
 80172c2:	019b      	lsls	r3, r3, #6
 80172c4:	68b9      	ldr	r1, [r7, #8]
 80172c6:	440b      	add	r3, r1
 80172c8:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 80172ca:	693b      	ldr	r3, [r7, #16]
 80172cc:	400b      	ands	r3, r1
 80172ce:	431a      	orrs	r2, r3
 80172d0:	68fb      	ldr	r3, [r7, #12]
 80172d2:	65da      	str	r2, [r3, #92]	; 0x5c
    for (i = 1; i < 16; i++) {
 80172d4:	697b      	ldr	r3, [r7, #20]
 80172d6:	3301      	adds	r3, #1
 80172d8:	617b      	str	r3, [r7, #20]
 80172da:	697b      	ldr	r3, [r7, #20]
 80172dc:	2b0f      	cmp	r3, #15
 80172de:	f77f af30 	ble.w	8017142 <sp_256_get_entry_16_8+0x72>
    }
}
 80172e2:	bf00      	nop
 80172e4:	371c      	adds	r7, #28
 80172e6:	46bd      	mov	sp, r7
 80172e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80172ec:	4770      	bx	lr
	...

080172f0 <sp_256_ecc_mulmod_stripe_8>:
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_256_ecc_mulmod_stripe_8(sp_point_256* r, const sp_point_256* g,
        const sp_table_entry_256* table, const sp_digit* k, int map,
        int ct, void* heap)
{
 80172f0:	b580      	push	{r7, lr}
 80172f2:	b08e      	sub	sp, #56	; 0x38
 80172f4:	af00      	add	r7, sp, #0
 80172f6:	60f8      	str	r0, [r7, #12]
 80172f8:	60b9      	str	r1, [r7, #8]
 80172fa:	607a      	str	r2, [r7, #4]
 80172fc:	603b      	str	r3, [r7, #0]
    sp_point_256 rtd;
    sp_point_256 pd;
    sp_digit td[2 * 8 * 5];
#endif
    sp_point_256* rt;
    sp_point_256* p = NULL;
 80172fe:	2300      	movs	r3, #0
 8017300:	617b      	str	r3, [r7, #20]
    /* Constant time used for cache attack resistance implementation. */
    (void)ct;
    (void)heap;


    err = sp_256_point_new_8(heap, rtd, rt);
 8017302:	f107 0318 	add.w	r3, r7, #24
 8017306:	461a      	mov	r2, r3
 8017308:	2100      	movs	r1, #0
 801730a:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 801730c:	f7fd f924 	bl	8014558 <sp_256_point_new_ex_8>
 8017310:	6278      	str	r0, [r7, #36]	; 0x24
    if (err == MP_OKAY) {
 8017312:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017314:	2b00      	cmp	r3, #0
 8017316:	d107      	bne.n	8017328 <sp_256_ecc_mulmod_stripe_8+0x38>
        err = sp_256_point_new_8(heap, pd, p);
 8017318:	f107 0314 	add.w	r3, r7, #20
 801731c:	461a      	mov	r2, r3
 801731e:	2100      	movs	r1, #0
 8017320:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8017322:	f7fd f919 	bl	8014558 <sp_256_point_new_ex_8>
 8017326:	6278      	str	r0, [r7, #36]	; 0x24
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    t = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 8 * 5, heap,
 8017328:	f44f 70a0 	mov.w	r0, #320	; 0x140
 801732c:	f7f7 fde4 	bl	800eef8 <wolfSSL_Malloc>
 8017330:	6238      	str	r0, [r7, #32]
                           DYNAMIC_TYPE_ECC);
    if (t == NULL) {
 8017332:	6a3b      	ldr	r3, [r7, #32]
 8017334:	2b00      	cmp	r3, #0
 8017336:	d102      	bne.n	801733e <sp_256_ecc_mulmod_stripe_8+0x4e>
        err = MEMORY_E;
 8017338:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 801733c:	627b      	str	r3, [r7, #36]	; 0x24
    }
#else
    t = td;
#endif

    if (err == MP_OKAY) {
 801733e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017340:	2b00      	cmp	r3, #0
 8017342:	f040 80dd 	bne.w	8017500 <sp_256_ecc_mulmod_stripe_8+0x210>
        XMEMCPY(p->z, p256_norm_mod, sizeof(p256_norm_mod));
 8017346:	697b      	ldr	r3, [r7, #20]
 8017348:	3380      	adds	r3, #128	; 0x80
 801734a:	2220      	movs	r2, #32
 801734c:	497a      	ldr	r1, [pc, #488]	; (8017538 <sp_256_ecc_mulmod_stripe_8+0x248>)
 801734e:	4618      	mov	r0, r3
 8017350:	f002 f851 	bl	80193f6 <memcpy>
        XMEMCPY(rt->z, p256_norm_mod, sizeof(p256_norm_mod));
 8017354:	69bb      	ldr	r3, [r7, #24]
 8017356:	3380      	adds	r3, #128	; 0x80
 8017358:	2220      	movs	r2, #32
 801735a:	4977      	ldr	r1, [pc, #476]	; (8017538 <sp_256_ecc_mulmod_stripe_8+0x248>)
 801735c:	4618      	mov	r0, r3
 801735e:	f002 f84a 	bl	80193f6 <memcpy>

        y = 0;
 8017362:	2300      	movs	r3, #0
 8017364:	62fb      	str	r3, [r7, #44]	; 0x2c
        for (j=0,x=63; j<4; j++,x+=64) {
 8017366:	2300      	movs	r3, #0
 8017368:	633b      	str	r3, [r7, #48]	; 0x30
 801736a:	233f      	movs	r3, #63	; 0x3f
 801736c:	62bb      	str	r3, [r7, #40]	; 0x28
 801736e:	e021      	b.n	80173b4 <sp_256_ecc_mulmod_stripe_8+0xc4>
            y |= (int)(((k[x / 32] >> (x % 32)) & 1) << j);
 8017370:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017372:	2b00      	cmp	r3, #0
 8017374:	da00      	bge.n	8017378 <sp_256_ecc_mulmod_stripe_8+0x88>
 8017376:	331f      	adds	r3, #31
 8017378:	115b      	asrs	r3, r3, #5
 801737a:	009b      	lsls	r3, r3, #2
 801737c:	683a      	ldr	r2, [r7, #0]
 801737e:	4413      	add	r3, r2
 8017380:	681a      	ldr	r2, [r3, #0]
 8017382:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017384:	4259      	negs	r1, r3
 8017386:	f003 031f 	and.w	r3, r3, #31
 801738a:	f001 011f 	and.w	r1, r1, #31
 801738e:	bf58      	it	pl
 8017390:	424b      	negpl	r3, r1
 8017392:	fa22 f303 	lsr.w	r3, r2, r3
 8017396:	f003 0201 	and.w	r2, r3, #1
 801739a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801739c:	fa02 f303 	lsl.w	r3, r2, r3
 80173a0:	461a      	mov	r2, r3
 80173a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80173a4:	4313      	orrs	r3, r2
 80173a6:	62fb      	str	r3, [r7, #44]	; 0x2c
        for (j=0,x=63; j<4; j++,x+=64) {
 80173a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80173aa:	3301      	adds	r3, #1
 80173ac:	633b      	str	r3, [r7, #48]	; 0x30
 80173ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80173b0:	3340      	adds	r3, #64	; 0x40
 80173b2:	62bb      	str	r3, [r7, #40]	; 0x28
 80173b4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80173b6:	2b03      	cmp	r3, #3
 80173b8:	ddda      	ble.n	8017370 <sp_256_ecc_mulmod_stripe_8+0x80>
        }
    #ifndef WC_NO_CACHE_RESISTANT
        if (ct) {
 80173ba:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80173bc:	2b00      	cmp	r3, #0
 80173be:	d006      	beq.n	80173ce <sp_256_ecc_mulmod_stripe_8+0xde>
            sp_256_get_entry_16_8(rt, table, y);
 80173c0:	69bb      	ldr	r3, [r7, #24]
 80173c2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80173c4:	6879      	ldr	r1, [r7, #4]
 80173c6:	4618      	mov	r0, r3
 80173c8:	f7ff fe82 	bl	80170d0 <sp_256_get_entry_16_8>
 80173cc:	e015      	b.n	80173fa <sp_256_ecc_mulmod_stripe_8+0x10a>
        } else
    #endif
        {
            XMEMCPY(rt->x, table[y].x, sizeof(table[y].x));
 80173ce:	69bb      	ldr	r3, [r7, #24]
 80173d0:	4618      	mov	r0, r3
 80173d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80173d4:	019b      	lsls	r3, r3, #6
 80173d6:	687a      	ldr	r2, [r7, #4]
 80173d8:	4413      	add	r3, r2
 80173da:	2220      	movs	r2, #32
 80173dc:	4619      	mov	r1, r3
 80173de:	f002 f80a 	bl	80193f6 <memcpy>
            XMEMCPY(rt->y, table[y].y, sizeof(table[y].y));
 80173e2:	69bb      	ldr	r3, [r7, #24]
 80173e4:	f103 0040 	add.w	r0, r3, #64	; 0x40
 80173e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80173ea:	019b      	lsls	r3, r3, #6
 80173ec:	687a      	ldr	r2, [r7, #4]
 80173ee:	4413      	add	r3, r2
 80173f0:	3320      	adds	r3, #32
 80173f2:	2220      	movs	r2, #32
 80173f4:	4619      	mov	r1, r3
 80173f6:	f001 fffe 	bl	80193f6 <memcpy>
        }
        rt->infinity = !y;
 80173fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80173fc:	2b00      	cmp	r3, #0
 80173fe:	bf0c      	ite	eq
 8017400:	2301      	moveq	r3, #1
 8017402:	2300      	movne	r3, #0
 8017404:	b2da      	uxtb	r2, r3
 8017406:	69bb      	ldr	r3, [r7, #24]
 8017408:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        for (i=62; i>=0; i--) {
 801740c:	233e      	movs	r3, #62	; 0x3e
 801740e:	637b      	str	r3, [r7, #52]	; 0x34
 8017410:	e063      	b.n	80174da <sp_256_ecc_mulmod_stripe_8+0x1ea>
            y = 0;
 8017412:	2300      	movs	r3, #0
 8017414:	62fb      	str	r3, [r7, #44]	; 0x2c
            for (j=0,x=i; j<4; j++,x+=64) {
 8017416:	2300      	movs	r3, #0
 8017418:	633b      	str	r3, [r7, #48]	; 0x30
 801741a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801741c:	62bb      	str	r3, [r7, #40]	; 0x28
 801741e:	e021      	b.n	8017464 <sp_256_ecc_mulmod_stripe_8+0x174>
                y |= (int)(((k[x / 32] >> (x % 32)) & 1) << j);
 8017420:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017422:	2b00      	cmp	r3, #0
 8017424:	da00      	bge.n	8017428 <sp_256_ecc_mulmod_stripe_8+0x138>
 8017426:	331f      	adds	r3, #31
 8017428:	115b      	asrs	r3, r3, #5
 801742a:	009b      	lsls	r3, r3, #2
 801742c:	683a      	ldr	r2, [r7, #0]
 801742e:	4413      	add	r3, r2
 8017430:	681a      	ldr	r2, [r3, #0]
 8017432:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017434:	4259      	negs	r1, r3
 8017436:	f003 031f 	and.w	r3, r3, #31
 801743a:	f001 011f 	and.w	r1, r1, #31
 801743e:	bf58      	it	pl
 8017440:	424b      	negpl	r3, r1
 8017442:	fa22 f303 	lsr.w	r3, r2, r3
 8017446:	f003 0201 	and.w	r2, r3, #1
 801744a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801744c:	fa02 f303 	lsl.w	r3, r2, r3
 8017450:	461a      	mov	r2, r3
 8017452:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017454:	4313      	orrs	r3, r2
 8017456:	62fb      	str	r3, [r7, #44]	; 0x2c
            for (j=0,x=i; j<4; j++,x+=64) {
 8017458:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801745a:	3301      	adds	r3, #1
 801745c:	633b      	str	r3, [r7, #48]	; 0x30
 801745e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017460:	3340      	adds	r3, #64	; 0x40
 8017462:	62bb      	str	r3, [r7, #40]	; 0x28
 8017464:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017466:	2b03      	cmp	r3, #3
 8017468:	ddda      	ble.n	8017420 <sp_256_ecc_mulmod_stripe_8+0x130>
            }

            sp_256_proj_point_dbl_8(rt, rt, t);
 801746a:	69bb      	ldr	r3, [r7, #24]
 801746c:	69b9      	ldr	r1, [r7, #24]
 801746e:	6a3a      	ldr	r2, [r7, #32]
 8017470:	4618      	mov	r0, r3
 8017472:	f7fe fe31 	bl	80160d8 <sp_256_proj_point_dbl_8>
        #ifndef WC_NO_CACHE_RESISTANT
            if (ct) {
 8017476:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017478:	2b00      	cmp	r3, #0
 801747a:	d006      	beq.n	801748a <sp_256_ecc_mulmod_stripe_8+0x19a>
                sp_256_get_entry_16_8(p, table, y);
 801747c:	697b      	ldr	r3, [r7, #20]
 801747e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8017480:	6879      	ldr	r1, [r7, #4]
 8017482:	4618      	mov	r0, r3
 8017484:	f7ff fe24 	bl	80170d0 <sp_256_get_entry_16_8>
 8017488:	e015      	b.n	80174b6 <sp_256_ecc_mulmod_stripe_8+0x1c6>
            }
            else
        #endif
            {
                XMEMCPY(p->x, table[y].x, sizeof(table[y].x));
 801748a:	697b      	ldr	r3, [r7, #20]
 801748c:	4618      	mov	r0, r3
 801748e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017490:	019b      	lsls	r3, r3, #6
 8017492:	687a      	ldr	r2, [r7, #4]
 8017494:	4413      	add	r3, r2
 8017496:	2220      	movs	r2, #32
 8017498:	4619      	mov	r1, r3
 801749a:	f001 ffac 	bl	80193f6 <memcpy>
                XMEMCPY(p->y, table[y].y, sizeof(table[y].y));
 801749e:	697b      	ldr	r3, [r7, #20]
 80174a0:	f103 0040 	add.w	r0, r3, #64	; 0x40
 80174a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80174a6:	019b      	lsls	r3, r3, #6
 80174a8:	687a      	ldr	r2, [r7, #4]
 80174aa:	4413      	add	r3, r2
 80174ac:	3320      	adds	r3, #32
 80174ae:	2220      	movs	r2, #32
 80174b0:	4619      	mov	r1, r3
 80174b2:	f001 ffa0 	bl	80193f6 <memcpy>
            }
            p->infinity = !y;
 80174b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80174b8:	2b00      	cmp	r3, #0
 80174ba:	bf0c      	ite	eq
 80174bc:	2301      	moveq	r3, #1
 80174be:	2300      	movne	r3, #0
 80174c0:	b2da      	uxtb	r2, r3
 80174c2:	697b      	ldr	r3, [r7, #20]
 80174c4:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
            sp_256_proj_point_add_qz1_8(rt, rt, p, t);
 80174c8:	69b8      	ldr	r0, [r7, #24]
 80174ca:	69b9      	ldr	r1, [r7, #24]
 80174cc:	697a      	ldr	r2, [r7, #20]
 80174ce:	6a3b      	ldr	r3, [r7, #32]
 80174d0:	f7ff fc9a 	bl	8016e08 <sp_256_proj_point_add_qz1_8>
        for (i=62; i>=0; i--) {
 80174d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80174d6:	3b01      	subs	r3, #1
 80174d8:	637b      	str	r3, [r7, #52]	; 0x34
 80174da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80174dc:	2b00      	cmp	r3, #0
 80174de:	da98      	bge.n	8017412 <sp_256_ecc_mulmod_stripe_8+0x122>
        }

        if (map != 0) {
 80174e0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80174e2:	2b00      	cmp	r3, #0
 80174e4:	d006      	beq.n	80174f4 <sp_256_ecc_mulmod_stripe_8+0x204>
            sp_256_map_8(r, rt, t);
 80174e6:	69bb      	ldr	r3, [r7, #24]
 80174e8:	6a3a      	ldr	r2, [r7, #32]
 80174ea:	4619      	mov	r1, r3
 80174ec:	68f8      	ldr	r0, [r7, #12]
 80174ee:	f7fe fb15 	bl	8015b1c <sp_256_map_8>
 80174f2:	e005      	b.n	8017500 <sp_256_ecc_mulmod_stripe_8+0x210>
        }
        else {
            XMEMCPY(r, rt, sizeof(sp_point_256));
 80174f4:	69bb      	ldr	r3, [r7, #24]
 80174f6:	22c4      	movs	r2, #196	; 0xc4
 80174f8:	4619      	mov	r1, r3
 80174fa:	68f8      	ldr	r0, [r7, #12]
 80174fc:	f001 ff7b 	bl	80193f6 <memcpy>
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (t != NULL) {
 8017500:	6a3b      	ldr	r3, [r7, #32]
 8017502:	2b00      	cmp	r3, #0
 8017504:	d007      	beq.n	8017516 <sp_256_ecc_mulmod_stripe_8+0x226>
        XFREE(t, heap, DYNAMIC_TYPE_ECC);
 8017506:	6a3b      	ldr	r3, [r7, #32]
 8017508:	61fb      	str	r3, [r7, #28]
 801750a:	69fb      	ldr	r3, [r7, #28]
 801750c:	2b00      	cmp	r3, #0
 801750e:	d002      	beq.n	8017516 <sp_256_ecc_mulmod_stripe_8+0x226>
 8017510:	69f8      	ldr	r0, [r7, #28]
 8017512:	f7f7 fd0d 	bl	800ef30 <wolfSSL_Free>
    }
#endif
    sp_256_point_free_8(p, 0, heap);
 8017516:	697b      	ldr	r3, [r7, #20]
 8017518:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801751a:	2100      	movs	r1, #0
 801751c:	4618      	mov	r0, r3
 801751e:	f7fd f835 	bl	801458c <sp_256_point_free_8>
    sp_256_point_free_8(rt, 0, heap);
 8017522:	69bb      	ldr	r3, [r7, #24]
 8017524:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8017526:	2100      	movs	r1, #0
 8017528:	4618      	mov	r0, r3
 801752a:	f7fd f82f 	bl	801458c <sp_256_point_free_8>

    return err;
 801752e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8017530:	4618      	mov	r0, r3
 8017532:	3738      	adds	r7, #56	; 0x38
 8017534:	46bd      	mov	sp, r7
 8017536:	bd80      	pop	{r7, pc}
 8017538:	0801af14 	.word	0x0801af14

0801753c <sp_256_ecc_mulmod_8>:
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_256_ecc_mulmod_8(sp_point_256* r, const sp_point_256* g, const sp_digit* k,
        int map, int ct, void* heap)
{
 801753c:	b580      	push	{r7, lr}
 801753e:	b086      	sub	sp, #24
 8017540:	af02      	add	r7, sp, #8
 8017542:	60f8      	str	r0, [r7, #12]
 8017544:	60b9      	str	r1, [r7, #8]
 8017546:	607a      	str	r2, [r7, #4]
 8017548:	603b      	str	r3, [r7, #0]
#ifndef FP_ECC
    return sp_256_ecc_mulmod_fast_8(r, g, k, map, ct, heap);
 801754a:	69fb      	ldr	r3, [r7, #28]
 801754c:	9301      	str	r3, [sp, #4]
 801754e:	69bb      	ldr	r3, [r7, #24]
 8017550:	9300      	str	r3, [sp, #0]
 8017552:	683b      	ldr	r3, [r7, #0]
 8017554:	687a      	ldr	r2, [r7, #4]
 8017556:	68b9      	ldr	r1, [r7, #8]
 8017558:	68f8      	ldr	r0, [r7, #12]
 801755a:	f7ff fa47 	bl	80169ec <sp_256_ecc_mulmod_fast_8>
 801755e:	4603      	mov	r3, r0
        }
    }

    return err;
#endif
}
 8017560:	4618      	mov	r0, r3
 8017562:	3710      	adds	r7, #16
 8017564:	46bd      	mov	sp, r7
 8017566:	bd80      	pop	{r7, pc}

08017568 <sp_256_ecc_mulmod_base_8>:
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_256_ecc_mulmod_base_8(sp_point_256* r, const sp_digit* k,
        int map, int ct, void* heap)
{
 8017568:	b580      	push	{r7, lr}
 801756a:	b088      	sub	sp, #32
 801756c:	af04      	add	r7, sp, #16
 801756e:	60f8      	str	r0, [r7, #12]
 8017570:	60b9      	str	r1, [r7, #8]
 8017572:	607a      	str	r2, [r7, #4]
 8017574:	603b      	str	r3, [r7, #0]
    return sp_256_ecc_mulmod_stripe_8(r, &p256_base, p256_table,
 8017576:	69bb      	ldr	r3, [r7, #24]
 8017578:	9302      	str	r3, [sp, #8]
 801757a:	683b      	ldr	r3, [r7, #0]
 801757c:	9301      	str	r3, [sp, #4]
 801757e:	687b      	ldr	r3, [r7, #4]
 8017580:	9300      	str	r3, [sp, #0]
 8017582:	68bb      	ldr	r3, [r7, #8]
 8017584:	4a04      	ldr	r2, [pc, #16]	; (8017598 <sp_256_ecc_mulmod_base_8+0x30>)
 8017586:	4905      	ldr	r1, [pc, #20]	; (801759c <sp_256_ecc_mulmod_base_8+0x34>)
 8017588:	68f8      	ldr	r0, [r7, #12]
 801758a:	f7ff feb1 	bl	80172f0 <sp_256_ecc_mulmod_stripe_8>
 801758e:	4603      	mov	r3, r0
                                      k, map, ct, heap);
}
 8017590:	4618      	mov	r0, r3
 8017592:	3710      	adds	r7, #16
 8017594:	46bd      	mov	sp, r7
 8017596:	bd80      	pop	{r7, pc}
 8017598:	0801b058 	.word	0x0801b058
 801759c:	0801af74 	.word	0x0801af74

080175a0 <sp_ecc_mulmod_base_256>:
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_mulmod_base_256(mp_int* km, ecc_point* r, int map, void* heap)
{
 80175a0:	b580      	push	{r7, lr}
 80175a2:	b08a      	sub	sp, #40	; 0x28
 80175a4:	af02      	add	r7, sp, #8
 80175a6:	60f8      	str	r0, [r7, #12]
 80175a8:	60b9      	str	r1, [r7, #8]
 80175aa:	607a      	str	r2, [r7, #4]
 80175ac:	603b      	str	r3, [r7, #0]
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_256 p;
    sp_digit kd[8];
#endif
    sp_point_256* point;
    sp_digit* k = NULL;
 80175ae:	2300      	movs	r3, #0
 80175b0:	61fb      	str	r3, [r7, #28]
    int err = MP_OKAY;
 80175b2:	2300      	movs	r3, #0
 80175b4:	61bb      	str	r3, [r7, #24]

    err = sp_256_point_new_8(heap, p, point);
 80175b6:	f107 0310 	add.w	r3, r7, #16
 80175ba:	461a      	mov	r2, r3
 80175bc:	2100      	movs	r1, #0
 80175be:	6838      	ldr	r0, [r7, #0]
 80175c0:	f7fc ffca 	bl	8014558 <sp_256_point_new_ex_8>
 80175c4:	61b8      	str	r0, [r7, #24]
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
 80175c6:	69bb      	ldr	r3, [r7, #24]
 80175c8:	2b00      	cmp	r3, #0
 80175ca:	d109      	bne.n	80175e0 <sp_ecc_mulmod_base_256+0x40>
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * 8, heap,
 80175cc:	2020      	movs	r0, #32
 80175ce:	f7f7 fc93 	bl	800eef8 <wolfSSL_Malloc>
 80175d2:	61f8      	str	r0, [r7, #28]
                                                              DYNAMIC_TYPE_ECC);
        if (k == NULL) {
 80175d4:	69fb      	ldr	r3, [r7, #28]
 80175d6:	2b00      	cmp	r3, #0
 80175d8:	d102      	bne.n	80175e0 <sp_ecc_mulmod_base_256+0x40>
            err = MEMORY_E;
 80175da:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 80175de:	61bb      	str	r3, [r7, #24]
        }
    }
#else
    k = kd;
#endif
    if (err == MP_OKAY) {
 80175e0:	69bb      	ldr	r3, [r7, #24]
 80175e2:	2b00      	cmp	r3, #0
 80175e4:	d10d      	bne.n	8017602 <sp_ecc_mulmod_base_256+0x62>
        sp_256_from_mp(k, 8, km);
 80175e6:	68fa      	ldr	r2, [r7, #12]
 80175e8:	2108      	movs	r1, #8
 80175ea:	69f8      	ldr	r0, [r7, #28]
 80175ec:	f7fd f96a 	bl	80148c4 <sp_256_from_mp>

            err = sp_256_ecc_mulmod_base_8(point, k, map, 1, heap);
 80175f0:	6938      	ldr	r0, [r7, #16]
 80175f2:	683b      	ldr	r3, [r7, #0]
 80175f4:	9300      	str	r3, [sp, #0]
 80175f6:	2301      	movs	r3, #1
 80175f8:	687a      	ldr	r2, [r7, #4]
 80175fa:	69f9      	ldr	r1, [r7, #28]
 80175fc:	f7ff ffb4 	bl	8017568 <sp_256_ecc_mulmod_base_8>
 8017600:	61b8      	str	r0, [r7, #24]
    }
    if (err == MP_OKAY) {
 8017602:	69bb      	ldr	r3, [r7, #24]
 8017604:	2b00      	cmp	r3, #0
 8017606:	d105      	bne.n	8017614 <sp_ecc_mulmod_base_256+0x74>
        err = sp_256_point_to_ecc_point_8(point, r);
 8017608:	693b      	ldr	r3, [r7, #16]
 801760a:	68b9      	ldr	r1, [r7, #8]
 801760c:	4618      	mov	r0, r3
 801760e:	f7fd f9b0 	bl	8014972 <sp_256_point_to_ecc_point_8>
 8017612:	61b8      	str	r0, [r7, #24]
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
 8017614:	69fb      	ldr	r3, [r7, #28]
 8017616:	2b00      	cmp	r3, #0
 8017618:	d007      	beq.n	801762a <sp_ecc_mulmod_base_256+0x8a>
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
 801761a:	69fb      	ldr	r3, [r7, #28]
 801761c:	617b      	str	r3, [r7, #20]
 801761e:	697b      	ldr	r3, [r7, #20]
 8017620:	2b00      	cmp	r3, #0
 8017622:	d002      	beq.n	801762a <sp_ecc_mulmod_base_256+0x8a>
 8017624:	6978      	ldr	r0, [r7, #20]
 8017626:	f7f7 fc83 	bl	800ef30 <wolfSSL_Free>
    }
#endif
    sp_256_point_free_8(point, 0, heap);
 801762a:	693b      	ldr	r3, [r7, #16]
 801762c:	683a      	ldr	r2, [r7, #0]
 801762e:	2100      	movs	r1, #0
 8017630:	4618      	mov	r0, r3
 8017632:	f7fc ffab 	bl	801458c <sp_256_point_free_8>

    return err;
 8017636:	69bb      	ldr	r3, [r7, #24]
}
 8017638:	4618      	mov	r0, r3
 801763a:	3720      	adds	r7, #32
 801763c:	46bd      	mov	sp, r7
 801763e:	bd80      	pop	{r7, pc}

08017640 <sp_256_iszero_8>:
 *
 * a  Number to check.
 * returns 1 if the number is zero and 0 otherwise.
 */
static int sp_256_iszero_8(const sp_digit* a)
{
 8017640:	b480      	push	{r7}
 8017642:	b083      	sub	sp, #12
 8017644:	af00      	add	r7, sp, #0
 8017646:	6078      	str	r0, [r7, #4]
    return (a[0] | a[1] | a[2] | a[3] | a[4] | a[5] | a[6] | a[7]) == 0;
 8017648:	687b      	ldr	r3, [r7, #4]
 801764a:	681a      	ldr	r2, [r3, #0]
 801764c:	687b      	ldr	r3, [r7, #4]
 801764e:	3304      	adds	r3, #4
 8017650:	681b      	ldr	r3, [r3, #0]
 8017652:	431a      	orrs	r2, r3
 8017654:	687b      	ldr	r3, [r7, #4]
 8017656:	3308      	adds	r3, #8
 8017658:	681b      	ldr	r3, [r3, #0]
 801765a:	431a      	orrs	r2, r3
 801765c:	687b      	ldr	r3, [r7, #4]
 801765e:	330c      	adds	r3, #12
 8017660:	681b      	ldr	r3, [r3, #0]
 8017662:	431a      	orrs	r2, r3
 8017664:	687b      	ldr	r3, [r7, #4]
 8017666:	3310      	adds	r3, #16
 8017668:	681b      	ldr	r3, [r3, #0]
 801766a:	431a      	orrs	r2, r3
 801766c:	687b      	ldr	r3, [r7, #4]
 801766e:	3314      	adds	r3, #20
 8017670:	681b      	ldr	r3, [r3, #0]
 8017672:	431a      	orrs	r2, r3
 8017674:	687b      	ldr	r3, [r7, #4]
 8017676:	3318      	adds	r3, #24
 8017678:	681b      	ldr	r3, [r3, #0]
 801767a:	431a      	orrs	r2, r3
 801767c:	687b      	ldr	r3, [r7, #4]
 801767e:	331c      	adds	r3, #28
 8017680:	681b      	ldr	r3, [r3, #0]
 8017682:	4313      	orrs	r3, r2
 8017684:	2b00      	cmp	r3, #0
 8017686:	bf0c      	ite	eq
 8017688:	2301      	moveq	r3, #1
 801768a:	2300      	movne	r3, #0
 801768c:	b2db      	uxtb	r3, r3
}
 801768e:	4618      	mov	r0, r3
 8017690:	370c      	adds	r7, #12
 8017692:	46bd      	mov	sp, r7
 8017694:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017698:	4770      	bx	lr

0801769a <sp_256_from_bin>:
 * size  Maximum number of bytes to convert
 * a  Byte array.
 * n  Number of bytes in array to read.
 */
static void sp_256_from_bin(sp_digit* r, int size, const byte* a, int n)
{
 801769a:	b480      	push	{r7}
 801769c:	b089      	sub	sp, #36	; 0x24
 801769e:	af00      	add	r7, sp, #0
 80176a0:	60f8      	str	r0, [r7, #12]
 80176a2:	60b9      	str	r1, [r7, #8]
 80176a4:	607a      	str	r2, [r7, #4]
 80176a6:	603b      	str	r3, [r7, #0]
    int i, j = 0;
 80176a8:	2300      	movs	r3, #0
 80176aa:	61bb      	str	r3, [r7, #24]
    word32 s = 0;
 80176ac:	2300      	movs	r3, #0
 80176ae:	617b      	str	r3, [r7, #20]

    r[0] = 0;
 80176b0:	68fb      	ldr	r3, [r7, #12]
 80176b2:	2200      	movs	r2, #0
 80176b4:	601a      	str	r2, [r3, #0]
    for (i = n-1; i >= 0; i--) {
 80176b6:	683b      	ldr	r3, [r7, #0]
 80176b8:	3b01      	subs	r3, #1
 80176ba:	61fb      	str	r3, [r7, #28]
 80176bc:	e042      	b.n	8017744 <sp_256_from_bin+0xaa>
        r[j] |= (((sp_digit)a[i]) << s);
 80176be:	69bb      	ldr	r3, [r7, #24]
 80176c0:	009b      	lsls	r3, r3, #2
 80176c2:	68fa      	ldr	r2, [r7, #12]
 80176c4:	4413      	add	r3, r2
 80176c6:	6819      	ldr	r1, [r3, #0]
 80176c8:	69fb      	ldr	r3, [r7, #28]
 80176ca:	687a      	ldr	r2, [r7, #4]
 80176cc:	4413      	add	r3, r2
 80176ce:	781b      	ldrb	r3, [r3, #0]
 80176d0:	461a      	mov	r2, r3
 80176d2:	697b      	ldr	r3, [r7, #20]
 80176d4:	409a      	lsls	r2, r3
 80176d6:	69bb      	ldr	r3, [r7, #24]
 80176d8:	009b      	lsls	r3, r3, #2
 80176da:	68f8      	ldr	r0, [r7, #12]
 80176dc:	4403      	add	r3, r0
 80176de:	430a      	orrs	r2, r1
 80176e0:	601a      	str	r2, [r3, #0]
        if (s >= 24U) {
 80176e2:	697b      	ldr	r3, [r7, #20]
 80176e4:	2b17      	cmp	r3, #23
 80176e6:	d927      	bls.n	8017738 <sp_256_from_bin+0x9e>
            r[j] &= 0xffffffff;
 80176e8:	69bb      	ldr	r3, [r7, #24]
 80176ea:	009b      	lsls	r3, r3, #2
 80176ec:	68fa      	ldr	r2, [r7, #12]
 80176ee:	441a      	add	r2, r3
 80176f0:	69bb      	ldr	r3, [r7, #24]
 80176f2:	009b      	lsls	r3, r3, #2
 80176f4:	68f9      	ldr	r1, [r7, #12]
 80176f6:	440b      	add	r3, r1
 80176f8:	6812      	ldr	r2, [r2, #0]
 80176fa:	601a      	str	r2, [r3, #0]
            s = 32U - s;
 80176fc:	697b      	ldr	r3, [r7, #20]
 80176fe:	f1c3 0320 	rsb	r3, r3, #32
 8017702:	617b      	str	r3, [r7, #20]
            if (j + 1 >= size) {
 8017704:	69bb      	ldr	r3, [r7, #24]
 8017706:	3301      	adds	r3, #1
 8017708:	68ba      	ldr	r2, [r7, #8]
 801770a:	429a      	cmp	r2, r3
 801770c:	dd1e      	ble.n	801774c <sp_256_from_bin+0xb2>
                break;
            }
            r[++j] = (sp_digit)a[i] >> s;
 801770e:	69fb      	ldr	r3, [r7, #28]
 8017710:	687a      	ldr	r2, [r7, #4]
 8017712:	4413      	add	r3, r2
 8017714:	781b      	ldrb	r3, [r3, #0]
 8017716:	4619      	mov	r1, r3
 8017718:	69bb      	ldr	r3, [r7, #24]
 801771a:	3301      	adds	r3, #1
 801771c:	61bb      	str	r3, [r7, #24]
 801771e:	69bb      	ldr	r3, [r7, #24]
 8017720:	009b      	lsls	r3, r3, #2
 8017722:	68fa      	ldr	r2, [r7, #12]
 8017724:	4413      	add	r3, r2
 8017726:	697a      	ldr	r2, [r7, #20]
 8017728:	fa21 f202 	lsr.w	r2, r1, r2
 801772c:	601a      	str	r2, [r3, #0]
            s = 8U - s;
 801772e:	697b      	ldr	r3, [r7, #20]
 8017730:	f1c3 0308 	rsb	r3, r3, #8
 8017734:	617b      	str	r3, [r7, #20]
 8017736:	e002      	b.n	801773e <sp_256_from_bin+0xa4>
        }
        else {
            s += 8U;
 8017738:	697b      	ldr	r3, [r7, #20]
 801773a:	3308      	adds	r3, #8
 801773c:	617b      	str	r3, [r7, #20]
    for (i = n-1; i >= 0; i--) {
 801773e:	69fb      	ldr	r3, [r7, #28]
 8017740:	3b01      	subs	r3, #1
 8017742:	61fb      	str	r3, [r7, #28]
 8017744:	69fb      	ldr	r3, [r7, #28]
 8017746:	2b00      	cmp	r3, #0
 8017748:	dab9      	bge.n	80176be <sp_256_from_bin+0x24>
 801774a:	e000      	b.n	801774e <sp_256_from_bin+0xb4>
                break;
 801774c:	bf00      	nop
        }
    }

    for (j++; j < size; j++) {
 801774e:	69bb      	ldr	r3, [r7, #24]
 8017750:	3301      	adds	r3, #1
 8017752:	61bb      	str	r3, [r7, #24]
 8017754:	e008      	b.n	8017768 <sp_256_from_bin+0xce>
        r[j] = 0;
 8017756:	69bb      	ldr	r3, [r7, #24]
 8017758:	009b      	lsls	r3, r3, #2
 801775a:	68fa      	ldr	r2, [r7, #12]
 801775c:	4413      	add	r3, r2
 801775e:	2200      	movs	r2, #0
 8017760:	601a      	str	r2, [r3, #0]
    for (j++; j < size; j++) {
 8017762:	69bb      	ldr	r3, [r7, #24]
 8017764:	3301      	adds	r3, #1
 8017766:	61bb      	str	r3, [r7, #24]
 8017768:	69ba      	ldr	r2, [r7, #24]
 801776a:	68bb      	ldr	r3, [r7, #8]
 801776c:	429a      	cmp	r2, r3
 801776e:	dbf2      	blt.n	8017756 <sp_256_from_bin+0xbc>
    }
}
 8017770:	bf00      	nop
 8017772:	3724      	adds	r7, #36	; 0x24
 8017774:	46bd      	mov	sp, r7
 8017776:	f85d 7b04 	ldr.w	r7, [sp], #4
 801777a:	4770      	bx	lr

0801777c <sp_256_mul_8>:
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_256_mul_8(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
 801777c:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 8017780:	b08f      	sub	sp, #60	; 0x3c
 8017782:	af00      	add	r7, sp, #0
 8017784:	60f8      	str	r0, [r7, #12]
 8017786:	60b9      	str	r1, [r7, #8]
 8017788:	607a      	str	r2, [r7, #4]
    sp_digit tmp_arr[8];
    sp_digit* tmp = tmp_arr;
 801778a:	f107 0314 	add.w	r3, r7, #20
 801778e:	637b      	str	r3, [r7, #52]	; 0x34

    __asm__ __volatile__ (
 8017790:	68fa      	ldr	r2, [r7, #12]
 8017792:	68b9      	ldr	r1, [r7, #8]
 8017794:	6878      	ldr	r0, [r7, #4]
 8017796:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017798:	469c      	mov	ip, r3
 801779a:	680e      	ldr	r6, [r1, #0]
 801779c:	f8d0 8000 	ldr.w	r8, [r0]
 80177a0:	fba6 3408 	umull	r3, r4, r6, r8
 80177a4:	f04f 0500 	mov.w	r5, #0
 80177a8:	f8cc 3000 	str.w	r3, [ip]
 80177ac:	f04f 0300 	mov.w	r3, #0
 80177b0:	f8d0 8004 	ldr.w	r8, [r0, #4]
 80177b4:	fba6 6808 	umull	r6, r8, r6, r8
 80177b8:	19a4      	adds	r4, r4, r6
 80177ba:	eb45 0508 	adc.w	r5, r5, r8
 80177be:	684e      	ldr	r6, [r1, #4]
 80177c0:	f8d0 8000 	ldr.w	r8, [r0]
 80177c4:	fba6 6808 	umull	r6, r8, r6, r8
 80177c8:	19a4      	adds	r4, r4, r6
 80177ca:	eb55 0508 	adcs.w	r5, r5, r8
 80177ce:	f143 0300 	adc.w	r3, r3, #0
 80177d2:	f8cc 4004 	str.w	r4, [ip, #4]
 80177d6:	f04f 0400 	mov.w	r4, #0
 80177da:	680e      	ldr	r6, [r1, #0]
 80177dc:	f8d0 8008 	ldr.w	r8, [r0, #8]
 80177e0:	fba6 6808 	umull	r6, r8, r6, r8
 80177e4:	19ad      	adds	r5, r5, r6
 80177e6:	eb53 0308 	adcs.w	r3, r3, r8
 80177ea:	f144 0400 	adc.w	r4, r4, #0
 80177ee:	684e      	ldr	r6, [r1, #4]
 80177f0:	f8d0 8004 	ldr.w	r8, [r0, #4]
 80177f4:	fba6 6808 	umull	r6, r8, r6, r8
 80177f8:	19ad      	adds	r5, r5, r6
 80177fa:	eb53 0308 	adcs.w	r3, r3, r8
 80177fe:	f144 0400 	adc.w	r4, r4, #0
 8017802:	688e      	ldr	r6, [r1, #8]
 8017804:	f8d0 8000 	ldr.w	r8, [r0]
 8017808:	fba6 6808 	umull	r6, r8, r6, r8
 801780c:	19ad      	adds	r5, r5, r6
 801780e:	eb53 0308 	adcs.w	r3, r3, r8
 8017812:	f144 0400 	adc.w	r4, r4, #0
 8017816:	f8cc 5008 	str.w	r5, [ip, #8]
 801781a:	f04f 0500 	mov.w	r5, #0
 801781e:	680e      	ldr	r6, [r1, #0]
 8017820:	f8d0 800c 	ldr.w	r8, [r0, #12]
 8017824:	fba6 6808 	umull	r6, r8, r6, r8
 8017828:	199b      	adds	r3, r3, r6
 801782a:	eb54 0408 	adcs.w	r4, r4, r8
 801782e:	f145 0500 	adc.w	r5, r5, #0
 8017832:	684e      	ldr	r6, [r1, #4]
 8017834:	f8d0 8008 	ldr.w	r8, [r0, #8]
 8017838:	fba6 6808 	umull	r6, r8, r6, r8
 801783c:	199b      	adds	r3, r3, r6
 801783e:	eb54 0408 	adcs.w	r4, r4, r8
 8017842:	f145 0500 	adc.w	r5, r5, #0
 8017846:	688e      	ldr	r6, [r1, #8]
 8017848:	f8d0 8004 	ldr.w	r8, [r0, #4]
 801784c:	fba6 6808 	umull	r6, r8, r6, r8
 8017850:	199b      	adds	r3, r3, r6
 8017852:	eb54 0408 	adcs.w	r4, r4, r8
 8017856:	f145 0500 	adc.w	r5, r5, #0
 801785a:	68ce      	ldr	r6, [r1, #12]
 801785c:	f8d0 8000 	ldr.w	r8, [r0]
 8017860:	fba6 6808 	umull	r6, r8, r6, r8
 8017864:	199b      	adds	r3, r3, r6
 8017866:	eb54 0408 	adcs.w	r4, r4, r8
 801786a:	f145 0500 	adc.w	r5, r5, #0
 801786e:	f8cc 300c 	str.w	r3, [ip, #12]
 8017872:	f04f 0300 	mov.w	r3, #0
 8017876:	680e      	ldr	r6, [r1, #0]
 8017878:	f8d0 8010 	ldr.w	r8, [r0, #16]
 801787c:	fba6 6808 	umull	r6, r8, r6, r8
 8017880:	19a4      	adds	r4, r4, r6
 8017882:	eb55 0508 	adcs.w	r5, r5, r8
 8017886:	f143 0300 	adc.w	r3, r3, #0
 801788a:	684e      	ldr	r6, [r1, #4]
 801788c:	f8d0 800c 	ldr.w	r8, [r0, #12]
 8017890:	fba6 6808 	umull	r6, r8, r6, r8
 8017894:	19a4      	adds	r4, r4, r6
 8017896:	eb55 0508 	adcs.w	r5, r5, r8
 801789a:	f143 0300 	adc.w	r3, r3, #0
 801789e:	688e      	ldr	r6, [r1, #8]
 80178a0:	f8d0 8008 	ldr.w	r8, [r0, #8]
 80178a4:	fba6 6808 	umull	r6, r8, r6, r8
 80178a8:	19a4      	adds	r4, r4, r6
 80178aa:	eb55 0508 	adcs.w	r5, r5, r8
 80178ae:	f143 0300 	adc.w	r3, r3, #0
 80178b2:	68ce      	ldr	r6, [r1, #12]
 80178b4:	f8d0 8004 	ldr.w	r8, [r0, #4]
 80178b8:	fba6 6808 	umull	r6, r8, r6, r8
 80178bc:	19a4      	adds	r4, r4, r6
 80178be:	eb55 0508 	adcs.w	r5, r5, r8
 80178c2:	f143 0300 	adc.w	r3, r3, #0
 80178c6:	690e      	ldr	r6, [r1, #16]
 80178c8:	f8d0 8000 	ldr.w	r8, [r0]
 80178cc:	fba6 6808 	umull	r6, r8, r6, r8
 80178d0:	19a4      	adds	r4, r4, r6
 80178d2:	eb55 0508 	adcs.w	r5, r5, r8
 80178d6:	f143 0300 	adc.w	r3, r3, #0
 80178da:	f8cc 4010 	str.w	r4, [ip, #16]
 80178de:	f04f 0400 	mov.w	r4, #0
 80178e2:	680e      	ldr	r6, [r1, #0]
 80178e4:	f8d0 8014 	ldr.w	r8, [r0, #20]
 80178e8:	fba6 6808 	umull	r6, r8, r6, r8
 80178ec:	19ad      	adds	r5, r5, r6
 80178ee:	eb53 0308 	adcs.w	r3, r3, r8
 80178f2:	f144 0400 	adc.w	r4, r4, #0
 80178f6:	684e      	ldr	r6, [r1, #4]
 80178f8:	f8d0 8010 	ldr.w	r8, [r0, #16]
 80178fc:	fba6 6808 	umull	r6, r8, r6, r8
 8017900:	19ad      	adds	r5, r5, r6
 8017902:	eb53 0308 	adcs.w	r3, r3, r8
 8017906:	f144 0400 	adc.w	r4, r4, #0
 801790a:	688e      	ldr	r6, [r1, #8]
 801790c:	f8d0 800c 	ldr.w	r8, [r0, #12]
 8017910:	fba6 6808 	umull	r6, r8, r6, r8
 8017914:	19ad      	adds	r5, r5, r6
 8017916:	eb53 0308 	adcs.w	r3, r3, r8
 801791a:	f144 0400 	adc.w	r4, r4, #0
 801791e:	68ce      	ldr	r6, [r1, #12]
 8017920:	f8d0 8008 	ldr.w	r8, [r0, #8]
 8017924:	fba6 6808 	umull	r6, r8, r6, r8
 8017928:	19ad      	adds	r5, r5, r6
 801792a:	eb53 0308 	adcs.w	r3, r3, r8
 801792e:	f144 0400 	adc.w	r4, r4, #0
 8017932:	690e      	ldr	r6, [r1, #16]
 8017934:	f8d0 8004 	ldr.w	r8, [r0, #4]
 8017938:	fba6 6808 	umull	r6, r8, r6, r8
 801793c:	19ad      	adds	r5, r5, r6
 801793e:	eb53 0308 	adcs.w	r3, r3, r8
 8017942:	f144 0400 	adc.w	r4, r4, #0
 8017946:	694e      	ldr	r6, [r1, #20]
 8017948:	f8d0 8000 	ldr.w	r8, [r0]
 801794c:	fba6 6808 	umull	r6, r8, r6, r8
 8017950:	19ad      	adds	r5, r5, r6
 8017952:	eb53 0308 	adcs.w	r3, r3, r8
 8017956:	f144 0400 	adc.w	r4, r4, #0
 801795a:	f8cc 5014 	str.w	r5, [ip, #20]
 801795e:	f04f 0500 	mov.w	r5, #0
 8017962:	680e      	ldr	r6, [r1, #0]
 8017964:	f8d0 8018 	ldr.w	r8, [r0, #24]
 8017968:	fba6 6808 	umull	r6, r8, r6, r8
 801796c:	199b      	adds	r3, r3, r6
 801796e:	eb54 0408 	adcs.w	r4, r4, r8
 8017972:	f145 0500 	adc.w	r5, r5, #0
 8017976:	684e      	ldr	r6, [r1, #4]
 8017978:	f8d0 8014 	ldr.w	r8, [r0, #20]
 801797c:	fba6 6808 	umull	r6, r8, r6, r8
 8017980:	199b      	adds	r3, r3, r6
 8017982:	eb54 0408 	adcs.w	r4, r4, r8
 8017986:	f145 0500 	adc.w	r5, r5, #0
 801798a:	688e      	ldr	r6, [r1, #8]
 801798c:	f8d0 8010 	ldr.w	r8, [r0, #16]
 8017990:	fba6 6808 	umull	r6, r8, r6, r8
 8017994:	199b      	adds	r3, r3, r6
 8017996:	eb54 0408 	adcs.w	r4, r4, r8
 801799a:	f145 0500 	adc.w	r5, r5, #0
 801799e:	68ce      	ldr	r6, [r1, #12]
 80179a0:	f8d0 800c 	ldr.w	r8, [r0, #12]
 80179a4:	fba6 6808 	umull	r6, r8, r6, r8
 80179a8:	199b      	adds	r3, r3, r6
 80179aa:	eb54 0408 	adcs.w	r4, r4, r8
 80179ae:	f145 0500 	adc.w	r5, r5, #0
 80179b2:	690e      	ldr	r6, [r1, #16]
 80179b4:	f8d0 8008 	ldr.w	r8, [r0, #8]
 80179b8:	fba6 6808 	umull	r6, r8, r6, r8
 80179bc:	199b      	adds	r3, r3, r6
 80179be:	eb54 0408 	adcs.w	r4, r4, r8
 80179c2:	f145 0500 	adc.w	r5, r5, #0
 80179c6:	694e      	ldr	r6, [r1, #20]
 80179c8:	f8d0 8004 	ldr.w	r8, [r0, #4]
 80179cc:	fba6 6808 	umull	r6, r8, r6, r8
 80179d0:	199b      	adds	r3, r3, r6
 80179d2:	eb54 0408 	adcs.w	r4, r4, r8
 80179d6:	f145 0500 	adc.w	r5, r5, #0
 80179da:	698e      	ldr	r6, [r1, #24]
 80179dc:	f8d0 8000 	ldr.w	r8, [r0]
 80179e0:	fba6 6808 	umull	r6, r8, r6, r8
 80179e4:	199b      	adds	r3, r3, r6
 80179e6:	eb54 0408 	adcs.w	r4, r4, r8
 80179ea:	f145 0500 	adc.w	r5, r5, #0
 80179ee:	f8cc 3018 	str.w	r3, [ip, #24]
 80179f2:	f04f 0300 	mov.w	r3, #0
 80179f6:	680e      	ldr	r6, [r1, #0]
 80179f8:	f8d0 801c 	ldr.w	r8, [r0, #28]
 80179fc:	fba6 6808 	umull	r6, r8, r6, r8
 8017a00:	19a4      	adds	r4, r4, r6
 8017a02:	eb55 0508 	adcs.w	r5, r5, r8
 8017a06:	f143 0300 	adc.w	r3, r3, #0
 8017a0a:	684e      	ldr	r6, [r1, #4]
 8017a0c:	f8d0 8018 	ldr.w	r8, [r0, #24]
 8017a10:	fba6 6808 	umull	r6, r8, r6, r8
 8017a14:	19a4      	adds	r4, r4, r6
 8017a16:	eb55 0508 	adcs.w	r5, r5, r8
 8017a1a:	f143 0300 	adc.w	r3, r3, #0
 8017a1e:	688e      	ldr	r6, [r1, #8]
 8017a20:	f8d0 8014 	ldr.w	r8, [r0, #20]
 8017a24:	fba6 6808 	umull	r6, r8, r6, r8
 8017a28:	19a4      	adds	r4, r4, r6
 8017a2a:	eb55 0508 	adcs.w	r5, r5, r8
 8017a2e:	f143 0300 	adc.w	r3, r3, #0
 8017a32:	68ce      	ldr	r6, [r1, #12]
 8017a34:	f8d0 8010 	ldr.w	r8, [r0, #16]
 8017a38:	fba6 6808 	umull	r6, r8, r6, r8
 8017a3c:	19a4      	adds	r4, r4, r6
 8017a3e:	eb55 0508 	adcs.w	r5, r5, r8
 8017a42:	f143 0300 	adc.w	r3, r3, #0
 8017a46:	690e      	ldr	r6, [r1, #16]
 8017a48:	f8d0 800c 	ldr.w	r8, [r0, #12]
 8017a4c:	fba6 6808 	umull	r6, r8, r6, r8
 8017a50:	19a4      	adds	r4, r4, r6
 8017a52:	eb55 0508 	adcs.w	r5, r5, r8
 8017a56:	f143 0300 	adc.w	r3, r3, #0
 8017a5a:	694e      	ldr	r6, [r1, #20]
 8017a5c:	f8d0 8008 	ldr.w	r8, [r0, #8]
 8017a60:	fba6 6808 	umull	r6, r8, r6, r8
 8017a64:	19a4      	adds	r4, r4, r6
 8017a66:	eb55 0508 	adcs.w	r5, r5, r8
 8017a6a:	f143 0300 	adc.w	r3, r3, #0
 8017a6e:	698e      	ldr	r6, [r1, #24]
 8017a70:	f8d0 8004 	ldr.w	r8, [r0, #4]
 8017a74:	fba6 6808 	umull	r6, r8, r6, r8
 8017a78:	19a4      	adds	r4, r4, r6
 8017a7a:	eb55 0508 	adcs.w	r5, r5, r8
 8017a7e:	f143 0300 	adc.w	r3, r3, #0
 8017a82:	69ce      	ldr	r6, [r1, #28]
 8017a84:	f8d0 8000 	ldr.w	r8, [r0]
 8017a88:	fba6 6808 	umull	r6, r8, r6, r8
 8017a8c:	19a4      	adds	r4, r4, r6
 8017a8e:	eb55 0508 	adcs.w	r5, r5, r8
 8017a92:	f143 0300 	adc.w	r3, r3, #0
 8017a96:	f8cc 401c 	str.w	r4, [ip, #28]
 8017a9a:	f04f 0400 	mov.w	r4, #0
 8017a9e:	684e      	ldr	r6, [r1, #4]
 8017aa0:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8017aa4:	fba6 6808 	umull	r6, r8, r6, r8
 8017aa8:	19ad      	adds	r5, r5, r6
 8017aaa:	eb53 0308 	adcs.w	r3, r3, r8
 8017aae:	f144 0400 	adc.w	r4, r4, #0
 8017ab2:	688e      	ldr	r6, [r1, #8]
 8017ab4:	f8d0 8018 	ldr.w	r8, [r0, #24]
 8017ab8:	fba6 6808 	umull	r6, r8, r6, r8
 8017abc:	19ad      	adds	r5, r5, r6
 8017abe:	eb53 0308 	adcs.w	r3, r3, r8
 8017ac2:	f144 0400 	adc.w	r4, r4, #0
 8017ac6:	68ce      	ldr	r6, [r1, #12]
 8017ac8:	f8d0 8014 	ldr.w	r8, [r0, #20]
 8017acc:	fba6 6808 	umull	r6, r8, r6, r8
 8017ad0:	19ad      	adds	r5, r5, r6
 8017ad2:	eb53 0308 	adcs.w	r3, r3, r8
 8017ad6:	f144 0400 	adc.w	r4, r4, #0
 8017ada:	690e      	ldr	r6, [r1, #16]
 8017adc:	f8d0 8010 	ldr.w	r8, [r0, #16]
 8017ae0:	fba6 6808 	umull	r6, r8, r6, r8
 8017ae4:	19ad      	adds	r5, r5, r6
 8017ae6:	eb53 0308 	adcs.w	r3, r3, r8
 8017aea:	f144 0400 	adc.w	r4, r4, #0
 8017aee:	694e      	ldr	r6, [r1, #20]
 8017af0:	f8d0 800c 	ldr.w	r8, [r0, #12]
 8017af4:	fba6 6808 	umull	r6, r8, r6, r8
 8017af8:	19ad      	adds	r5, r5, r6
 8017afa:	eb53 0308 	adcs.w	r3, r3, r8
 8017afe:	f144 0400 	adc.w	r4, r4, #0
 8017b02:	698e      	ldr	r6, [r1, #24]
 8017b04:	f8d0 8008 	ldr.w	r8, [r0, #8]
 8017b08:	fba6 6808 	umull	r6, r8, r6, r8
 8017b0c:	19ad      	adds	r5, r5, r6
 8017b0e:	eb53 0308 	adcs.w	r3, r3, r8
 8017b12:	f144 0400 	adc.w	r4, r4, #0
 8017b16:	69ce      	ldr	r6, [r1, #28]
 8017b18:	f8d0 8004 	ldr.w	r8, [r0, #4]
 8017b1c:	fba6 6808 	umull	r6, r8, r6, r8
 8017b20:	19ad      	adds	r5, r5, r6
 8017b22:	eb53 0308 	adcs.w	r3, r3, r8
 8017b26:	f144 0400 	adc.w	r4, r4, #0
 8017b2a:	6215      	str	r5, [r2, #32]
 8017b2c:	f04f 0500 	mov.w	r5, #0
 8017b30:	688e      	ldr	r6, [r1, #8]
 8017b32:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8017b36:	fba6 6808 	umull	r6, r8, r6, r8
 8017b3a:	199b      	adds	r3, r3, r6
 8017b3c:	eb54 0408 	adcs.w	r4, r4, r8
 8017b40:	f145 0500 	adc.w	r5, r5, #0
 8017b44:	68ce      	ldr	r6, [r1, #12]
 8017b46:	f8d0 8018 	ldr.w	r8, [r0, #24]
 8017b4a:	fba6 6808 	umull	r6, r8, r6, r8
 8017b4e:	199b      	adds	r3, r3, r6
 8017b50:	eb54 0408 	adcs.w	r4, r4, r8
 8017b54:	f145 0500 	adc.w	r5, r5, #0
 8017b58:	690e      	ldr	r6, [r1, #16]
 8017b5a:	f8d0 8014 	ldr.w	r8, [r0, #20]
 8017b5e:	fba6 6808 	umull	r6, r8, r6, r8
 8017b62:	199b      	adds	r3, r3, r6
 8017b64:	eb54 0408 	adcs.w	r4, r4, r8
 8017b68:	f145 0500 	adc.w	r5, r5, #0
 8017b6c:	694e      	ldr	r6, [r1, #20]
 8017b6e:	f8d0 8010 	ldr.w	r8, [r0, #16]
 8017b72:	fba6 6808 	umull	r6, r8, r6, r8
 8017b76:	199b      	adds	r3, r3, r6
 8017b78:	eb54 0408 	adcs.w	r4, r4, r8
 8017b7c:	f145 0500 	adc.w	r5, r5, #0
 8017b80:	698e      	ldr	r6, [r1, #24]
 8017b82:	f8d0 800c 	ldr.w	r8, [r0, #12]
 8017b86:	fba6 6808 	umull	r6, r8, r6, r8
 8017b8a:	199b      	adds	r3, r3, r6
 8017b8c:	eb54 0408 	adcs.w	r4, r4, r8
 8017b90:	f145 0500 	adc.w	r5, r5, #0
 8017b94:	69ce      	ldr	r6, [r1, #28]
 8017b96:	f8d0 8008 	ldr.w	r8, [r0, #8]
 8017b9a:	fba6 6808 	umull	r6, r8, r6, r8
 8017b9e:	199b      	adds	r3, r3, r6
 8017ba0:	eb54 0408 	adcs.w	r4, r4, r8
 8017ba4:	f145 0500 	adc.w	r5, r5, #0
 8017ba8:	6253      	str	r3, [r2, #36]	; 0x24
 8017baa:	f04f 0300 	mov.w	r3, #0
 8017bae:	68ce      	ldr	r6, [r1, #12]
 8017bb0:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8017bb4:	fba6 6808 	umull	r6, r8, r6, r8
 8017bb8:	19a4      	adds	r4, r4, r6
 8017bba:	eb55 0508 	adcs.w	r5, r5, r8
 8017bbe:	f143 0300 	adc.w	r3, r3, #0
 8017bc2:	690e      	ldr	r6, [r1, #16]
 8017bc4:	f8d0 8018 	ldr.w	r8, [r0, #24]
 8017bc8:	fba6 6808 	umull	r6, r8, r6, r8
 8017bcc:	19a4      	adds	r4, r4, r6
 8017bce:	eb55 0508 	adcs.w	r5, r5, r8
 8017bd2:	f143 0300 	adc.w	r3, r3, #0
 8017bd6:	694e      	ldr	r6, [r1, #20]
 8017bd8:	f8d0 8014 	ldr.w	r8, [r0, #20]
 8017bdc:	fba6 6808 	umull	r6, r8, r6, r8
 8017be0:	19a4      	adds	r4, r4, r6
 8017be2:	eb55 0508 	adcs.w	r5, r5, r8
 8017be6:	f143 0300 	adc.w	r3, r3, #0
 8017bea:	698e      	ldr	r6, [r1, #24]
 8017bec:	f8d0 8010 	ldr.w	r8, [r0, #16]
 8017bf0:	fba6 6808 	umull	r6, r8, r6, r8
 8017bf4:	19a4      	adds	r4, r4, r6
 8017bf6:	eb55 0508 	adcs.w	r5, r5, r8
 8017bfa:	f143 0300 	adc.w	r3, r3, #0
 8017bfe:	69ce      	ldr	r6, [r1, #28]
 8017c00:	f8d0 800c 	ldr.w	r8, [r0, #12]
 8017c04:	fba6 6808 	umull	r6, r8, r6, r8
 8017c08:	19a4      	adds	r4, r4, r6
 8017c0a:	eb55 0508 	adcs.w	r5, r5, r8
 8017c0e:	f143 0300 	adc.w	r3, r3, #0
 8017c12:	6294      	str	r4, [r2, #40]	; 0x28
 8017c14:	f04f 0400 	mov.w	r4, #0
 8017c18:	690e      	ldr	r6, [r1, #16]
 8017c1a:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8017c1e:	fba6 6808 	umull	r6, r8, r6, r8
 8017c22:	19ad      	adds	r5, r5, r6
 8017c24:	eb53 0308 	adcs.w	r3, r3, r8
 8017c28:	f144 0400 	adc.w	r4, r4, #0
 8017c2c:	694e      	ldr	r6, [r1, #20]
 8017c2e:	f8d0 8018 	ldr.w	r8, [r0, #24]
 8017c32:	fba6 6808 	umull	r6, r8, r6, r8
 8017c36:	19ad      	adds	r5, r5, r6
 8017c38:	eb53 0308 	adcs.w	r3, r3, r8
 8017c3c:	f144 0400 	adc.w	r4, r4, #0
 8017c40:	698e      	ldr	r6, [r1, #24]
 8017c42:	f8d0 8014 	ldr.w	r8, [r0, #20]
 8017c46:	fba6 6808 	umull	r6, r8, r6, r8
 8017c4a:	19ad      	adds	r5, r5, r6
 8017c4c:	eb53 0308 	adcs.w	r3, r3, r8
 8017c50:	f144 0400 	adc.w	r4, r4, #0
 8017c54:	69ce      	ldr	r6, [r1, #28]
 8017c56:	f8d0 8010 	ldr.w	r8, [r0, #16]
 8017c5a:	fba6 6808 	umull	r6, r8, r6, r8
 8017c5e:	19ad      	adds	r5, r5, r6
 8017c60:	eb53 0308 	adcs.w	r3, r3, r8
 8017c64:	f144 0400 	adc.w	r4, r4, #0
 8017c68:	62d5      	str	r5, [r2, #44]	; 0x2c
 8017c6a:	f04f 0500 	mov.w	r5, #0
 8017c6e:	694e      	ldr	r6, [r1, #20]
 8017c70:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8017c74:	fba6 6808 	umull	r6, r8, r6, r8
 8017c78:	199b      	adds	r3, r3, r6
 8017c7a:	eb54 0408 	adcs.w	r4, r4, r8
 8017c7e:	f145 0500 	adc.w	r5, r5, #0
 8017c82:	698e      	ldr	r6, [r1, #24]
 8017c84:	f8d0 8018 	ldr.w	r8, [r0, #24]
 8017c88:	fba6 6808 	umull	r6, r8, r6, r8
 8017c8c:	199b      	adds	r3, r3, r6
 8017c8e:	eb54 0408 	adcs.w	r4, r4, r8
 8017c92:	f145 0500 	adc.w	r5, r5, #0
 8017c96:	69ce      	ldr	r6, [r1, #28]
 8017c98:	f8d0 8014 	ldr.w	r8, [r0, #20]
 8017c9c:	fba6 6808 	umull	r6, r8, r6, r8
 8017ca0:	199b      	adds	r3, r3, r6
 8017ca2:	eb54 0408 	adcs.w	r4, r4, r8
 8017ca6:	f145 0500 	adc.w	r5, r5, #0
 8017caa:	6313      	str	r3, [r2, #48]	; 0x30
 8017cac:	f04f 0300 	mov.w	r3, #0
 8017cb0:	698e      	ldr	r6, [r1, #24]
 8017cb2:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8017cb6:	fba6 6808 	umull	r6, r8, r6, r8
 8017cba:	19a4      	adds	r4, r4, r6
 8017cbc:	eb55 0508 	adcs.w	r5, r5, r8
 8017cc0:	f143 0300 	adc.w	r3, r3, #0
 8017cc4:	69ce      	ldr	r6, [r1, #28]
 8017cc6:	f8d0 8018 	ldr.w	r8, [r0, #24]
 8017cca:	fba6 6808 	umull	r6, r8, r6, r8
 8017cce:	19a4      	adds	r4, r4, r6
 8017cd0:	eb55 0508 	adcs.w	r5, r5, r8
 8017cd4:	f143 0300 	adc.w	r3, r3, #0
 8017cd8:	6354      	str	r4, [r2, #52]	; 0x34
 8017cda:	f04f 0400 	mov.w	r4, #0
 8017cde:	69ce      	ldr	r6, [r1, #28]
 8017ce0:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8017ce4:	fba6 6808 	umull	r6, r8, r6, r8
 8017ce8:	19ad      	adds	r5, r5, r6
 8017cea:	eb43 0308 	adc.w	r3, r3, r8
 8017cee:	6395      	str	r5, [r2, #56]	; 0x38
 8017cf0:	63d3      	str	r3, [r2, #60]	; 0x3c
 8017cf2:	f8dc 3000 	ldr.w	r3, [ip]
 8017cf6:	f8dc 4004 	ldr.w	r4, [ip, #4]
 8017cfa:	f8dc 5008 	ldr.w	r5, [ip, #8]
 8017cfe:	f8dc 600c 	ldr.w	r6, [ip, #12]
 8017d02:	6013      	str	r3, [r2, #0]
 8017d04:	6054      	str	r4, [r2, #4]
 8017d06:	6095      	str	r5, [r2, #8]
 8017d08:	60d6      	str	r6, [r2, #12]
 8017d0a:	f8dc 3010 	ldr.w	r3, [ip, #16]
 8017d0e:	f8dc 4014 	ldr.w	r4, [ip, #20]
 8017d12:	f8dc 5018 	ldr.w	r5, [ip, #24]
 8017d16:	f8dc 601c 	ldr.w	r6, [ip, #28]
 8017d1a:	6113      	str	r3, [r2, #16]
 8017d1c:	6154      	str	r4, [r2, #20]
 8017d1e:	6195      	str	r5, [r2, #24]
 8017d20:	61d6      	str	r6, [r2, #28]
        "str	r6, [%[r], #28]\n\t"
        :
        : [r] "r" (r), [a] "r" (a), [b] "r" (b), [tmp] "r" (tmp)
        : "memory", "r3", "r4", "r5", "r6", "r8"
    );
}
 8017d22:	bf00      	nop
 8017d24:	373c      	adds	r7, #60	; 0x3c
 8017d26:	46bd      	mov	sp, r7
 8017d28:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8017d2c:	4770      	bx	lr

08017d2e <sp_256_sub_in_place_8>:
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static sp_digit sp_256_sub_in_place_8(sp_digit* a,
        const sp_digit* b)
{
 8017d2e:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 8017d32:	b085      	sub	sp, #20
 8017d34:	af00      	add	r7, sp, #0
 8017d36:	6078      	str	r0, [r7, #4]
 8017d38:	6039      	str	r1, [r7, #0]
    sp_digit c = 0;
 8017d3a:	2300      	movs	r3, #0
 8017d3c:	60fb      	str	r3, [r7, #12]
    __asm__ __volatile__ (
 8017d3e:	68f9      	ldr	r1, [r7, #12]
 8017d40:	687a      	ldr	r2, [r7, #4]
 8017d42:	683b      	ldr	r3, [r7, #0]
 8017d44:	4608      	mov	r0, r1
 8017d46:	4611      	mov	r1, r2
 8017d48:	461a      	mov	r2, r3
 8017d4a:	4688      	mov	r8, r1
 8017d4c:	f108 0820 	add.w	r8, r8, #32
 8017d50:	f04f 0500 	mov.w	r5, #0
 8017d54:	1a2d      	subs	r5, r5, r0
 8017d56:	680b      	ldr	r3, [r1, #0]
 8017d58:	684c      	ldr	r4, [r1, #4]
 8017d5a:	6815      	ldr	r5, [r2, #0]
 8017d5c:	6856      	ldr	r6, [r2, #4]
 8017d5e:	41ab      	sbcs	r3, r5
 8017d60:	41b4      	sbcs	r4, r6
 8017d62:	600b      	str	r3, [r1, #0]
 8017d64:	604c      	str	r4, [r1, #4]
 8017d66:	eb60 0000 	sbc.w	r0, r0, r0
 8017d6a:	f101 0108 	add.w	r1, r1, #8
 8017d6e:	f102 0208 	add.w	r2, r2, #8
 8017d72:	4541      	cmp	r1, r8
 8017d74:	d1ec      	bne.n	8017d50 <sp_256_sub_in_place_8+0x22>
 8017d76:	60f8      	str	r0, [r7, #12]
 8017d78:	6079      	str	r1, [r7, #4]
 8017d7a:	603a      	str	r2, [r7, #0]
        : [c] "+r" (c), [a] "+r" (a), [b] "+r" (b)
        :
        : "memory", "r3", "r4", "r5", "r6", "r8"
    );

    return c;
 8017d7c:	68fb      	ldr	r3, [r7, #12]
}
 8017d7e:	4618      	mov	r0, r3
 8017d80:	3714      	adds	r7, #20
 8017d82:	46bd      	mov	sp, r7
 8017d84:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8017d88:	4770      	bx	lr

08017d8a <sp_256_mul_d_8>:
 * a  A single precision integer.
 * b  A single precision digit.
 */
SP_NOINLINE static void sp_256_mul_d_8(sp_digit* r, const sp_digit* a,
        sp_digit b)
{
 8017d8a:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 8017d8e:	b084      	sub	sp, #16
 8017d90:	af00      	add	r7, sp, #0
 8017d92:	60f8      	str	r0, [r7, #12]
 8017d94:	60b9      	str	r1, [r7, #8]
 8017d96:	607a      	str	r2, [r7, #4]
    __asm__ __volatile__ (
 8017d98:	6878      	ldr	r0, [r7, #4]
 8017d9a:	68fa      	ldr	r2, [r7, #12]
 8017d9c:	68bb      	ldr	r3, [r7, #8]
 8017d9e:	4611      	mov	r1, r2
 8017da0:	461a      	mov	r2, r3
 8017da2:	f102 0920 	add.w	r9, r2, #32
 8017da6:	f852 6b04 	ldr.w	r6, [r2], #4
 8017daa:	fba6 5300 	umull	r5, r3, r6, r0
 8017dae:	f04f 0400 	mov.w	r4, #0
 8017db2:	f841 5b04 	str.w	r5, [r1], #4
 8017db6:	f04f 0500 	mov.w	r5, #0
 8017dba:	f852 6b04 	ldr.w	r6, [r2], #4
 8017dbe:	fba6 6800 	umull	r6, r8, r6, r0
 8017dc2:	199b      	adds	r3, r3, r6
 8017dc4:	eb54 0408 	adcs.w	r4, r4, r8
 8017dc8:	f145 0500 	adc.w	r5, r5, #0
 8017dcc:	f841 3b04 	str.w	r3, [r1], #4
 8017dd0:	4623      	mov	r3, r4
 8017dd2:	462c      	mov	r4, r5
 8017dd4:	454a      	cmp	r2, r9
 8017dd6:	dbee      	blt.n	8017db6 <sp_256_mul_d_8+0x2c>
 8017dd8:	600b      	str	r3, [r1, #0]
 8017dda:	60f9      	str	r1, [r7, #12]
 8017ddc:	60ba      	str	r2, [r7, #8]
        "str	r3, [%[r]]\n\t"
        : [r] "+r" (r), [a] "+r" (a)
        : [b] "r" (b)
        : "memory", "r3", "r4", "r5", "r6", "r8", "r9"
    );
}
 8017dde:	bf00      	nop
 8017de0:	3710      	adds	r7, #16
 8017de2:	46bd      	mov	sp, r7
 8017de4:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8017de8:	4770      	bx	lr

08017dea <div_256_word_8>:
 *
 * Note that this is an approximate div. It may give an answer 1 larger.
 */
SP_NOINLINE static sp_digit div_256_word_8(sp_digit d1, sp_digit d0,
        sp_digit div)
{
 8017dea:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 8017dee:	b087      	sub	sp, #28
 8017df0:	af00      	add	r7, sp, #0
 8017df2:	60f8      	str	r0, [r7, #12]
 8017df4:	60b9      	str	r1, [r7, #8]
 8017df6:	607a      	str	r2, [r7, #4]
    sp_digit r = 0;
 8017df8:	2300      	movs	r3, #0
 8017dfa:	617b      	str	r3, [r7, #20]

    __asm__ __volatile__ (
 8017dfc:	68fa      	ldr	r2, [r7, #12]
 8017dfe:	68b9      	ldr	r1, [r7, #8]
 8017e00:	6878      	ldr	r0, [r7, #4]
 8017e02:	697b      	ldr	r3, [r7, #20]
 8017e04:	ea4f 4610 	mov.w	r6, r0, lsr #16
 8017e08:	f106 0601 	add.w	r6, r6, #1
 8017e0c:	fbb2 f4f6 	udiv	r4, r2, r6
 8017e10:	ea4f 4804 	mov.w	r8, r4, lsl #16
 8017e14:	fba0 4508 	umull	r4, r5, r0, r8
 8017e18:	1b09      	subs	r1, r1, r4
 8017e1a:	eb62 0205 	sbc.w	r2, r2, r5
 8017e1e:	fbb2 f5f6 	udiv	r5, r2, r6
 8017e22:	ea4f 4405 	mov.w	r4, r5, lsl #16
 8017e26:	44a0      	add	r8, r4
 8017e28:	fba0 4504 	umull	r4, r5, r0, r4
 8017e2c:	1b09      	subs	r1, r1, r4
 8017e2e:	eb62 0205 	sbc.w	r2, r2, r5
 8017e32:	ea4f 4402 	mov.w	r4, r2, lsl #16
 8017e36:	ea44 4411 	orr.w	r4, r4, r1, lsr #16
 8017e3a:	fbb4 f4f6 	udiv	r4, r4, r6
 8017e3e:	44a0      	add	r8, r4
 8017e40:	fba0 4504 	umull	r4, r5, r0, r4
 8017e44:	1b09      	subs	r1, r1, r4
 8017e46:	eb62 0205 	sbc.w	r2, r2, r5
 8017e4a:	ea4f 4402 	mov.w	r4, r2, lsl #16
 8017e4e:	ea44 4411 	orr.w	r4, r4, r1, lsr #16
 8017e52:	fbb4 f4f6 	udiv	r4, r4, r6
 8017e56:	44a0      	add	r8, r4
 8017e58:	fba0 4504 	umull	r4, r5, r0, r4
 8017e5c:	1b09      	subs	r1, r1, r4
 8017e5e:	eb62 0205 	sbc.w	r2, r2, r5
 8017e62:	fbb1 f4f0 	udiv	r4, r1, r0
 8017e66:	44a0      	add	r8, r4
 8017e68:	4643      	mov	r3, r8
 8017e6a:	617b      	str	r3, [r7, #20]
        "mov	%[r], r8\n\t"
        : [r] "+r" (r)
        : [d1] "r" (d1), [d0] "r" (d0), [div] "r" (div)
        : "r4", "r5", "r6", "r8"
    );
    return r;
 8017e6c:	697b      	ldr	r3, [r7, #20]
}
 8017e6e:	4618      	mov	r0, r3
 8017e70:	371c      	adds	r7, #28
 8017e72:	46bd      	mov	sp, r7
 8017e74:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8017e78:	4770      	bx	lr

08017e7a <sp_256_mask_8>:
 * r  A single precision integer.
 * a  A single precision integer.
 * m  Mask to AND against each digit.
 */
static void sp_256_mask_8(sp_digit* r, const sp_digit* a, sp_digit m)
{
 8017e7a:	b480      	push	{r7}
 8017e7c:	b087      	sub	sp, #28
 8017e7e:	af00      	add	r7, sp, #0
 8017e80:	60f8      	str	r0, [r7, #12]
 8017e82:	60b9      	str	r1, [r7, #8]
 8017e84:	607a      	str	r2, [r7, #4]
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=0; i<8; i++) {
 8017e86:	2300      	movs	r3, #0
 8017e88:	617b      	str	r3, [r7, #20]
 8017e8a:	e00e      	b.n	8017eaa <sp_256_mask_8+0x30>
        r[i] = a[i] & m;
 8017e8c:	697b      	ldr	r3, [r7, #20]
 8017e8e:	009b      	lsls	r3, r3, #2
 8017e90:	68ba      	ldr	r2, [r7, #8]
 8017e92:	4413      	add	r3, r2
 8017e94:	6819      	ldr	r1, [r3, #0]
 8017e96:	697b      	ldr	r3, [r7, #20]
 8017e98:	009b      	lsls	r3, r3, #2
 8017e9a:	68fa      	ldr	r2, [r7, #12]
 8017e9c:	4413      	add	r3, r2
 8017e9e:	687a      	ldr	r2, [r7, #4]
 8017ea0:	400a      	ands	r2, r1
 8017ea2:	601a      	str	r2, [r3, #0]
    for (i=0; i<8; i++) {
 8017ea4:	697b      	ldr	r3, [r7, #20]
 8017ea6:	3301      	adds	r3, #1
 8017ea8:	617b      	str	r3, [r7, #20]
 8017eaa:	697b      	ldr	r3, [r7, #20]
 8017eac:	2b07      	cmp	r3, #7
 8017eae:	dded      	ble.n	8017e8c <sp_256_mask_8+0x12>
    r[4] = a[4] & m;
    r[5] = a[5] & m;
    r[6] = a[6] & m;
    r[7] = a[7] & m;
#endif
}
 8017eb0:	bf00      	nop
 8017eb2:	371c      	adds	r7, #28
 8017eb4:	46bd      	mov	sp, r7
 8017eb6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017eba:	4770      	bx	lr

08017ebc <sp_256_div_8>:
 * r  Remainder from the division.
 * returns MP_OKAY indicating success.
 */
static WC_INLINE int sp_256_div_8(const sp_digit* a, const sp_digit* d, sp_digit* m,
        sp_digit* r)
{
 8017ebc:	b580      	push	{r7, lr}
 8017ebe:	b0a2      	sub	sp, #136	; 0x88
 8017ec0:	af00      	add	r7, sp, #0
 8017ec2:	60f8      	str	r0, [r7, #12]
 8017ec4:	60b9      	str	r1, [r7, #8]
 8017ec6:	607a      	str	r2, [r7, #4]
 8017ec8:	603b      	str	r3, [r7, #0]
    sp_digit div, r1;
    int i;

    (void)m;

    div = d[7];
 8017eca:	68bb      	ldr	r3, [r7, #8]
 8017ecc:	69db      	ldr	r3, [r3, #28]
 8017ece:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
    XMEMCPY(t1, a, sizeof(*t1) * 2 * 8);
 8017ed2:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8017ed6:	2240      	movs	r2, #64	; 0x40
 8017ed8:	68f9      	ldr	r1, [r7, #12]
 8017eda:	4618      	mov	r0, r3
 8017edc:	f001 fa8b 	bl	80193f6 <memcpy>
    for (i=7; i>=0; i--) {
 8017ee0:	2307      	movs	r3, #7
 8017ee2:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 8017ee6:	e0d2      	b.n	801808e <sp_256_div_8+0x1d2>
        sp_digit hi = t1[8 + i] - (t1[8 + i] == div);
 8017ee8:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017eec:	3308      	adds	r3, #8
 8017eee:	009b      	lsls	r3, r3, #2
 8017ef0:	f107 0288 	add.w	r2, r7, #136	; 0x88
 8017ef4:	4413      	add	r3, r2
 8017ef6:	f853 2c50 	ldr.w	r2, [r3, #-80]
 8017efa:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017efe:	3308      	adds	r3, #8
 8017f00:	009b      	lsls	r3, r3, #2
 8017f02:	f107 0188 	add.w	r1, r7, #136	; 0x88
 8017f06:	440b      	add	r3, r1
 8017f08:	f853 3c50 	ldr.w	r3, [r3, #-80]
 8017f0c:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 8017f10:	4299      	cmp	r1, r3
 8017f12:	bf0c      	ite	eq
 8017f14:	2301      	moveq	r3, #1
 8017f16:	2300      	movne	r3, #0
 8017f18:	b2db      	uxtb	r3, r3
 8017f1a:	1ad3      	subs	r3, r2, r3
 8017f1c:	67bb      	str	r3, [r7, #120]	; 0x78
        r1 = div_256_word_8(hi, t1[8 + i - 1], div);
 8017f1e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017f22:	3307      	adds	r3, #7
 8017f24:	009b      	lsls	r3, r3, #2
 8017f26:	f107 0288 	add.w	r2, r7, #136	; 0x88
 8017f2a:	4413      	add	r3, r2
 8017f2c:	f853 3c50 	ldr.w	r3, [r3, #-80]
 8017f30:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8017f34:	4619      	mov	r1, r3
 8017f36:	6fb8      	ldr	r0, [r7, #120]	; 0x78
 8017f38:	f7ff ff57 	bl	8017dea <div_256_word_8>
 8017f3c:	67f8      	str	r0, [r7, #124]	; 0x7c

        sp_256_mul_d_8(t2, d, r1);
 8017f3e:	f107 0314 	add.w	r3, r7, #20
 8017f42:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8017f44:	68b9      	ldr	r1, [r7, #8]
 8017f46:	4618      	mov	r0, r3
 8017f48:	f7ff ff1f 	bl	8017d8a <sp_256_mul_d_8>
        t1[8 + i] += sp_256_sub_in_place_8(&t1[i], t2);
 8017f4c:	f107 0238 	add.w	r2, r7, #56	; 0x38
 8017f50:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017f54:	009b      	lsls	r3, r3, #2
 8017f56:	4413      	add	r3, r2
 8017f58:	f107 0214 	add.w	r2, r7, #20
 8017f5c:	4611      	mov	r1, r2
 8017f5e:	4618      	mov	r0, r3
 8017f60:	f7ff fee5 	bl	8017d2e <sp_256_sub_in_place_8>
 8017f64:	4601      	mov	r1, r0
 8017f66:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017f6a:	3308      	adds	r3, #8
 8017f6c:	009b      	lsls	r3, r3, #2
 8017f6e:	f107 0288 	add.w	r2, r7, #136	; 0x88
 8017f72:	4413      	add	r3, r2
 8017f74:	f853 2c50 	ldr.w	r2, [r3, #-80]
 8017f78:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017f7c:	3308      	adds	r3, #8
 8017f7e:	440a      	add	r2, r1
 8017f80:	009b      	lsls	r3, r3, #2
 8017f82:	f107 0188 	add.w	r1, r7, #136	; 0x88
 8017f86:	440b      	add	r3, r1
 8017f88:	f843 2c50 	str.w	r2, [r3, #-80]
        t1[8 + i] -= t2[8];
 8017f8c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017f90:	3308      	adds	r3, #8
 8017f92:	009b      	lsls	r3, r3, #2
 8017f94:	f107 0288 	add.w	r2, r7, #136	; 0x88
 8017f98:	4413      	add	r3, r2
 8017f9a:	f853 1c50 	ldr.w	r1, [r3, #-80]
 8017f9e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8017fa0:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017fa4:	3308      	adds	r3, #8
 8017fa6:	1a8a      	subs	r2, r1, r2
 8017fa8:	009b      	lsls	r3, r3, #2
 8017faa:	f107 0188 	add.w	r1, r7, #136	; 0x88
 8017fae:	440b      	add	r3, r1
 8017fb0:	f843 2c50 	str.w	r2, [r3, #-80]
        sp_256_mask_8(t2, d, t1[8 + i]);
 8017fb4:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017fb8:	3308      	adds	r3, #8
 8017fba:	009b      	lsls	r3, r3, #2
 8017fbc:	f107 0288 	add.w	r2, r7, #136	; 0x88
 8017fc0:	4413      	add	r3, r2
 8017fc2:	f853 2c50 	ldr.w	r2, [r3, #-80]
 8017fc6:	f107 0314 	add.w	r3, r7, #20
 8017fca:	68b9      	ldr	r1, [r7, #8]
 8017fcc:	4618      	mov	r0, r3
 8017fce:	f7ff ff54 	bl	8017e7a <sp_256_mask_8>
        t1[8 + i] += sp_256_add_8(&t1[i], &t1[i], t2);
 8017fd2:	f107 0238 	add.w	r2, r7, #56	; 0x38
 8017fd6:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017fda:	009b      	lsls	r3, r3, #2
 8017fdc:	18d0      	adds	r0, r2, r3
 8017fde:	f107 0238 	add.w	r2, r7, #56	; 0x38
 8017fe2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017fe6:	009b      	lsls	r3, r3, #2
 8017fe8:	4413      	add	r3, r2
 8017fea:	f107 0214 	add.w	r2, r7, #20
 8017fee:	4619      	mov	r1, r3
 8017ff0:	f7fd fe20 	bl	8015c34 <sp_256_add_8>
 8017ff4:	4601      	mov	r1, r0
 8017ff6:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017ffa:	3308      	adds	r3, #8
 8017ffc:	009b      	lsls	r3, r3, #2
 8017ffe:	f107 0288 	add.w	r2, r7, #136	; 0x88
 8018002:	4413      	add	r3, r2
 8018004:	f853 2c50 	ldr.w	r2, [r3, #-80]
 8018008:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 801800c:	3308      	adds	r3, #8
 801800e:	440a      	add	r2, r1
 8018010:	009b      	lsls	r3, r3, #2
 8018012:	f107 0188 	add.w	r1, r7, #136	; 0x88
 8018016:	440b      	add	r3, r1
 8018018:	f843 2c50 	str.w	r2, [r3, #-80]
        sp_256_mask_8(t2, d, t1[8 + i]);
 801801c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8018020:	3308      	adds	r3, #8
 8018022:	009b      	lsls	r3, r3, #2
 8018024:	f107 0288 	add.w	r2, r7, #136	; 0x88
 8018028:	4413      	add	r3, r2
 801802a:	f853 2c50 	ldr.w	r2, [r3, #-80]
 801802e:	f107 0314 	add.w	r3, r7, #20
 8018032:	68b9      	ldr	r1, [r7, #8]
 8018034:	4618      	mov	r0, r3
 8018036:	f7ff ff20 	bl	8017e7a <sp_256_mask_8>
        t1[8 + i] += sp_256_add_8(&t1[i], &t1[i], t2);
 801803a:	f107 0238 	add.w	r2, r7, #56	; 0x38
 801803e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8018042:	009b      	lsls	r3, r3, #2
 8018044:	18d0      	adds	r0, r2, r3
 8018046:	f107 0238 	add.w	r2, r7, #56	; 0x38
 801804a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 801804e:	009b      	lsls	r3, r3, #2
 8018050:	4413      	add	r3, r2
 8018052:	f107 0214 	add.w	r2, r7, #20
 8018056:	4619      	mov	r1, r3
 8018058:	f7fd fdec 	bl	8015c34 <sp_256_add_8>
 801805c:	4601      	mov	r1, r0
 801805e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8018062:	3308      	adds	r3, #8
 8018064:	009b      	lsls	r3, r3, #2
 8018066:	f107 0288 	add.w	r2, r7, #136	; 0x88
 801806a:	4413      	add	r3, r2
 801806c:	f853 2c50 	ldr.w	r2, [r3, #-80]
 8018070:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8018074:	3308      	adds	r3, #8
 8018076:	440a      	add	r2, r1
 8018078:	009b      	lsls	r3, r3, #2
 801807a:	f107 0188 	add.w	r1, r7, #136	; 0x88
 801807e:	440b      	add	r3, r1
 8018080:	f843 2c50 	str.w	r2, [r3, #-80]
    for (i=7; i>=0; i--) {
 8018084:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8018088:	3b01      	subs	r3, #1
 801808a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 801808e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8018092:	2b00      	cmp	r3, #0
 8018094:	f6bf af28 	bge.w	8017ee8 <sp_256_div_8+0x2c>
    }

    r1 = sp_256_cmp_8(t1, d) >= 0;
 8018098:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801809c:	68b9      	ldr	r1, [r7, #8]
 801809e:	4618      	mov	r0, r3
 80180a0:	f7fd fbca 	bl	8015838 <sp_256_cmp_8>
 80180a4:	4603      	mov	r3, r0
 80180a6:	43db      	mvns	r3, r3
 80180a8:	0fdb      	lsrs	r3, r3, #31
 80180aa:	b2db      	uxtb	r3, r3
 80180ac:	67fb      	str	r3, [r7, #124]	; 0x7c
    sp_256_cond_sub_8(r, t1, d, (sp_digit)0 - r1);
 80180ae:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80180b0:	425b      	negs	r3, r3
 80180b2:	f107 0138 	add.w	r1, r7, #56	; 0x38
 80180b6:	68ba      	ldr	r2, [r7, #8]
 80180b8:	6838      	ldr	r0, [r7, #0]
 80180ba:	f7fd fbf5 	bl	80158a8 <sp_256_cond_sub_8>

    return MP_OKAY;
 80180be:	2300      	movs	r3, #0
}
 80180c0:	4618      	mov	r0, r3
 80180c2:	3788      	adds	r7, #136	; 0x88
 80180c4:	46bd      	mov	sp, r7
 80180c6:	bd80      	pop	{r7, pc}

080180c8 <sp_256_mod_8>:
 * a  A single precision number that is to be reduced.
 * m  A single precision number that is the modulus to reduce with.
 * returns MP_OKAY indicating success.
 */
static WC_INLINE int sp_256_mod_8(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
 80180c8:	b580      	push	{r7, lr}
 80180ca:	b084      	sub	sp, #16
 80180cc:	af00      	add	r7, sp, #0
 80180ce:	60f8      	str	r0, [r7, #12]
 80180d0:	60b9      	str	r1, [r7, #8]
 80180d2:	607a      	str	r2, [r7, #4]
    return sp_256_div_8(a, m, NULL, r);
 80180d4:	68fb      	ldr	r3, [r7, #12]
 80180d6:	2200      	movs	r2, #0
 80180d8:	6879      	ldr	r1, [r7, #4]
 80180da:	68b8      	ldr	r0, [r7, #8]
 80180dc:	f7ff feee 	bl	8017ebc <sp_256_div_8>
 80180e0:	4603      	mov	r3, r0
}
 80180e2:	4618      	mov	r0, r3
 80180e4:	3710      	adds	r7, #16
 80180e6:	46bd      	mov	sp, r7
 80180e8:	bd80      	pop	{r7, pc}

080180ea <sp_256_sqr_8>:
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_256_sqr_8(sp_digit* r, const sp_digit* a)
{
 80180ea:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80180ee:	b08c      	sub	sp, #48	; 0x30
 80180f0:	af00      	add	r7, sp, #0
 80180f2:	6078      	str	r0, [r7, #4]
 80180f4:	6039      	str	r1, [r7, #0]
    sp_digit tmp_arr[8];
    sp_digit* tmp = tmp_arr;
 80180f6:	f107 030c 	add.w	r3, r7, #12
 80180fa:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ __volatile__ (
 80180fc:	687a      	ldr	r2, [r7, #4]
 80180fe:	6839      	ldr	r1, [r7, #0]
 8018100:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8018102:	680e      	ldr	r6, [r1, #0]
 8018104:	fba6 3406 	umull	r3, r4, r6, r6
 8018108:	f04f 0500 	mov.w	r5, #0
 801810c:	6003      	str	r3, [r0, #0]
 801810e:	f04f 0300 	mov.w	r3, #0
 8018112:	f8d1 8004 	ldr.w	r8, [r1, #4]
 8018116:	fba6 6808 	umull	r6, r8, r6, r8
 801811a:	19a4      	adds	r4, r4, r6
 801811c:	eb45 0508 	adc.w	r5, r5, r8
 8018120:	19a4      	adds	r4, r4, r6
 8018122:	eb55 0508 	adcs.w	r5, r5, r8
 8018126:	f143 0300 	adc.w	r3, r3, #0
 801812a:	6044      	str	r4, [r0, #4]
 801812c:	f04f 0400 	mov.w	r4, #0
 8018130:	680e      	ldr	r6, [r1, #0]
 8018132:	f8d1 8008 	ldr.w	r8, [r1, #8]
 8018136:	fba6 6808 	umull	r6, r8, r6, r8
 801813a:	19ad      	adds	r5, r5, r6
 801813c:	eb43 0308 	adc.w	r3, r3, r8
 8018140:	19ad      	adds	r5, r5, r6
 8018142:	eb53 0308 	adcs.w	r3, r3, r8
 8018146:	f144 0400 	adc.w	r4, r4, #0
 801814a:	684e      	ldr	r6, [r1, #4]
 801814c:	fba6 6806 	umull	r6, r8, r6, r6
 8018150:	19ad      	adds	r5, r5, r6
 8018152:	eb53 0308 	adcs.w	r3, r3, r8
 8018156:	f144 0400 	adc.w	r4, r4, #0
 801815a:	6085      	str	r5, [r0, #8]
 801815c:	f04f 0500 	mov.w	r5, #0
 8018160:	680e      	ldr	r6, [r1, #0]
 8018162:	f8d1 800c 	ldr.w	r8, [r1, #12]
 8018166:	fba6 9a08 	umull	r9, sl, r6, r8
 801816a:	f04f 0b00 	mov.w	fp, #0
 801816e:	684e      	ldr	r6, [r1, #4]
 8018170:	f8d1 8008 	ldr.w	r8, [r1, #8]
 8018174:	fba6 6808 	umull	r6, r8, r6, r8
 8018178:	eb19 0906 	adds.w	r9, r9, r6
 801817c:	eb5a 0a08 	adcs.w	sl, sl, r8
 8018180:	f14b 0b00 	adc.w	fp, fp, #0
 8018184:	eb19 0909 	adds.w	r9, r9, r9
 8018188:	eb5a 0a0a 	adcs.w	sl, sl, sl
 801818c:	eb4b 0b0b 	adc.w	fp, fp, fp
 8018190:	eb13 0309 	adds.w	r3, r3, r9
 8018194:	eb54 040a 	adcs.w	r4, r4, sl
 8018198:	eb45 050b 	adc.w	r5, r5, fp
 801819c:	60c3      	str	r3, [r0, #12]
 801819e:	f04f 0300 	mov.w	r3, #0
 80181a2:	680e      	ldr	r6, [r1, #0]
 80181a4:	f8d1 8010 	ldr.w	r8, [r1, #16]
 80181a8:	fba6 9a08 	umull	r9, sl, r6, r8
 80181ac:	f04f 0b00 	mov.w	fp, #0
 80181b0:	684e      	ldr	r6, [r1, #4]
 80181b2:	f8d1 800c 	ldr.w	r8, [r1, #12]
 80181b6:	fba6 6808 	umull	r6, r8, r6, r8
 80181ba:	eb19 0906 	adds.w	r9, r9, r6
 80181be:	eb5a 0a08 	adcs.w	sl, sl, r8
 80181c2:	f14b 0b00 	adc.w	fp, fp, #0
 80181c6:	688e      	ldr	r6, [r1, #8]
 80181c8:	fba6 6806 	umull	r6, r8, r6, r6
 80181cc:	19a4      	adds	r4, r4, r6
 80181ce:	eb55 0508 	adcs.w	r5, r5, r8
 80181d2:	f143 0300 	adc.w	r3, r3, #0
 80181d6:	eb19 0909 	adds.w	r9, r9, r9
 80181da:	eb5a 0a0a 	adcs.w	sl, sl, sl
 80181de:	eb4b 0b0b 	adc.w	fp, fp, fp
 80181e2:	eb14 0409 	adds.w	r4, r4, r9
 80181e6:	eb55 050a 	adcs.w	r5, r5, sl
 80181ea:	eb43 030b 	adc.w	r3, r3, fp
 80181ee:	6104      	str	r4, [r0, #16]
 80181f0:	f04f 0400 	mov.w	r4, #0
 80181f4:	680e      	ldr	r6, [r1, #0]
 80181f6:	f8d1 8014 	ldr.w	r8, [r1, #20]
 80181fa:	fba6 9a08 	umull	r9, sl, r6, r8
 80181fe:	f04f 0b00 	mov.w	fp, #0
 8018202:	684e      	ldr	r6, [r1, #4]
 8018204:	f8d1 8010 	ldr.w	r8, [r1, #16]
 8018208:	fba6 6808 	umull	r6, r8, r6, r8
 801820c:	eb19 0906 	adds.w	r9, r9, r6
 8018210:	eb5a 0a08 	adcs.w	sl, sl, r8
 8018214:	f14b 0b00 	adc.w	fp, fp, #0
 8018218:	688e      	ldr	r6, [r1, #8]
 801821a:	f8d1 800c 	ldr.w	r8, [r1, #12]
 801821e:	fba6 6808 	umull	r6, r8, r6, r8
 8018222:	eb19 0906 	adds.w	r9, r9, r6
 8018226:	eb5a 0a08 	adcs.w	sl, sl, r8
 801822a:	f14b 0b00 	adc.w	fp, fp, #0
 801822e:	eb19 0909 	adds.w	r9, r9, r9
 8018232:	eb5a 0a0a 	adcs.w	sl, sl, sl
 8018236:	eb4b 0b0b 	adc.w	fp, fp, fp
 801823a:	eb15 0509 	adds.w	r5, r5, r9
 801823e:	eb53 030a 	adcs.w	r3, r3, sl
 8018242:	eb44 040b 	adc.w	r4, r4, fp
 8018246:	6145      	str	r5, [r0, #20]
 8018248:	f04f 0500 	mov.w	r5, #0
 801824c:	680e      	ldr	r6, [r1, #0]
 801824e:	f8d1 8018 	ldr.w	r8, [r1, #24]
 8018252:	fba6 9a08 	umull	r9, sl, r6, r8
 8018256:	f04f 0b00 	mov.w	fp, #0
 801825a:	684e      	ldr	r6, [r1, #4]
 801825c:	f8d1 8014 	ldr.w	r8, [r1, #20]
 8018260:	fba6 6808 	umull	r6, r8, r6, r8
 8018264:	eb19 0906 	adds.w	r9, r9, r6
 8018268:	eb5a 0a08 	adcs.w	sl, sl, r8
 801826c:	f14b 0b00 	adc.w	fp, fp, #0
 8018270:	688e      	ldr	r6, [r1, #8]
 8018272:	f8d1 8010 	ldr.w	r8, [r1, #16]
 8018276:	fba6 6808 	umull	r6, r8, r6, r8
 801827a:	eb19 0906 	adds.w	r9, r9, r6
 801827e:	eb5a 0a08 	adcs.w	sl, sl, r8
 8018282:	f14b 0b00 	adc.w	fp, fp, #0
 8018286:	68ce      	ldr	r6, [r1, #12]
 8018288:	fba6 6806 	umull	r6, r8, r6, r6
 801828c:	199b      	adds	r3, r3, r6
 801828e:	eb54 0408 	adcs.w	r4, r4, r8
 8018292:	f145 0500 	adc.w	r5, r5, #0
 8018296:	eb19 0909 	adds.w	r9, r9, r9
 801829a:	eb5a 0a0a 	adcs.w	sl, sl, sl
 801829e:	eb4b 0b0b 	adc.w	fp, fp, fp
 80182a2:	eb13 0309 	adds.w	r3, r3, r9
 80182a6:	eb54 040a 	adcs.w	r4, r4, sl
 80182aa:	eb45 050b 	adc.w	r5, r5, fp
 80182ae:	6183      	str	r3, [r0, #24]
 80182b0:	f04f 0300 	mov.w	r3, #0
 80182b4:	680e      	ldr	r6, [r1, #0]
 80182b6:	f8d1 801c 	ldr.w	r8, [r1, #28]
 80182ba:	fba6 9a08 	umull	r9, sl, r6, r8
 80182be:	f04f 0b00 	mov.w	fp, #0
 80182c2:	684e      	ldr	r6, [r1, #4]
 80182c4:	f8d1 8018 	ldr.w	r8, [r1, #24]
 80182c8:	fba6 6808 	umull	r6, r8, r6, r8
 80182cc:	eb19 0906 	adds.w	r9, r9, r6
 80182d0:	eb5a 0a08 	adcs.w	sl, sl, r8
 80182d4:	f14b 0b00 	adc.w	fp, fp, #0
 80182d8:	688e      	ldr	r6, [r1, #8]
 80182da:	f8d1 8014 	ldr.w	r8, [r1, #20]
 80182de:	fba6 6808 	umull	r6, r8, r6, r8
 80182e2:	eb19 0906 	adds.w	r9, r9, r6
 80182e6:	eb5a 0a08 	adcs.w	sl, sl, r8
 80182ea:	f14b 0b00 	adc.w	fp, fp, #0
 80182ee:	68ce      	ldr	r6, [r1, #12]
 80182f0:	f8d1 8010 	ldr.w	r8, [r1, #16]
 80182f4:	fba6 6808 	umull	r6, r8, r6, r8
 80182f8:	eb19 0906 	adds.w	r9, r9, r6
 80182fc:	eb5a 0a08 	adcs.w	sl, sl, r8
 8018300:	f14b 0b00 	adc.w	fp, fp, #0
 8018304:	eb19 0909 	adds.w	r9, r9, r9
 8018308:	eb5a 0a0a 	adcs.w	sl, sl, sl
 801830c:	eb4b 0b0b 	adc.w	fp, fp, fp
 8018310:	eb14 0409 	adds.w	r4, r4, r9
 8018314:	eb55 050a 	adcs.w	r5, r5, sl
 8018318:	eb43 030b 	adc.w	r3, r3, fp
 801831c:	61c4      	str	r4, [r0, #28]
 801831e:	f04f 0400 	mov.w	r4, #0
 8018322:	684e      	ldr	r6, [r1, #4]
 8018324:	f8d1 801c 	ldr.w	r8, [r1, #28]
 8018328:	fba6 9a08 	umull	r9, sl, r6, r8
 801832c:	f04f 0b00 	mov.w	fp, #0
 8018330:	688e      	ldr	r6, [r1, #8]
 8018332:	f8d1 8018 	ldr.w	r8, [r1, #24]
 8018336:	fba6 6808 	umull	r6, r8, r6, r8
 801833a:	eb19 0906 	adds.w	r9, r9, r6
 801833e:	eb5a 0a08 	adcs.w	sl, sl, r8
 8018342:	f14b 0b00 	adc.w	fp, fp, #0
 8018346:	68ce      	ldr	r6, [r1, #12]
 8018348:	f8d1 8014 	ldr.w	r8, [r1, #20]
 801834c:	fba6 6808 	umull	r6, r8, r6, r8
 8018350:	eb19 0906 	adds.w	r9, r9, r6
 8018354:	eb5a 0a08 	adcs.w	sl, sl, r8
 8018358:	f14b 0b00 	adc.w	fp, fp, #0
 801835c:	690e      	ldr	r6, [r1, #16]
 801835e:	fba6 6806 	umull	r6, r8, r6, r6
 8018362:	19ad      	adds	r5, r5, r6
 8018364:	eb53 0308 	adcs.w	r3, r3, r8
 8018368:	f144 0400 	adc.w	r4, r4, #0
 801836c:	eb19 0909 	adds.w	r9, r9, r9
 8018370:	eb5a 0a0a 	adcs.w	sl, sl, sl
 8018374:	eb4b 0b0b 	adc.w	fp, fp, fp
 8018378:	eb15 0509 	adds.w	r5, r5, r9
 801837c:	eb53 030a 	adcs.w	r3, r3, sl
 8018380:	eb44 040b 	adc.w	r4, r4, fp
 8018384:	6215      	str	r5, [r2, #32]
 8018386:	f04f 0500 	mov.w	r5, #0
 801838a:	688e      	ldr	r6, [r1, #8]
 801838c:	f8d1 801c 	ldr.w	r8, [r1, #28]
 8018390:	fba6 9a08 	umull	r9, sl, r6, r8
 8018394:	f04f 0b00 	mov.w	fp, #0
 8018398:	68ce      	ldr	r6, [r1, #12]
 801839a:	f8d1 8018 	ldr.w	r8, [r1, #24]
 801839e:	fba6 6808 	umull	r6, r8, r6, r8
 80183a2:	eb19 0906 	adds.w	r9, r9, r6
 80183a6:	eb5a 0a08 	adcs.w	sl, sl, r8
 80183aa:	f14b 0b00 	adc.w	fp, fp, #0
 80183ae:	690e      	ldr	r6, [r1, #16]
 80183b0:	f8d1 8014 	ldr.w	r8, [r1, #20]
 80183b4:	fba6 6808 	umull	r6, r8, r6, r8
 80183b8:	eb19 0906 	adds.w	r9, r9, r6
 80183bc:	eb5a 0a08 	adcs.w	sl, sl, r8
 80183c0:	f14b 0b00 	adc.w	fp, fp, #0
 80183c4:	eb19 0909 	adds.w	r9, r9, r9
 80183c8:	eb5a 0a0a 	adcs.w	sl, sl, sl
 80183cc:	eb4b 0b0b 	adc.w	fp, fp, fp
 80183d0:	eb13 0309 	adds.w	r3, r3, r9
 80183d4:	eb54 040a 	adcs.w	r4, r4, sl
 80183d8:	eb45 050b 	adc.w	r5, r5, fp
 80183dc:	6253      	str	r3, [r2, #36]	; 0x24
 80183de:	f04f 0300 	mov.w	r3, #0
 80183e2:	68ce      	ldr	r6, [r1, #12]
 80183e4:	f8d1 801c 	ldr.w	r8, [r1, #28]
 80183e8:	fba6 9a08 	umull	r9, sl, r6, r8
 80183ec:	f04f 0b00 	mov.w	fp, #0
 80183f0:	690e      	ldr	r6, [r1, #16]
 80183f2:	f8d1 8018 	ldr.w	r8, [r1, #24]
 80183f6:	fba6 6808 	umull	r6, r8, r6, r8
 80183fa:	eb19 0906 	adds.w	r9, r9, r6
 80183fe:	eb5a 0a08 	adcs.w	sl, sl, r8
 8018402:	f14b 0b00 	adc.w	fp, fp, #0
 8018406:	694e      	ldr	r6, [r1, #20]
 8018408:	fba6 6806 	umull	r6, r8, r6, r6
 801840c:	19a4      	adds	r4, r4, r6
 801840e:	eb55 0508 	adcs.w	r5, r5, r8
 8018412:	f143 0300 	adc.w	r3, r3, #0
 8018416:	eb19 0909 	adds.w	r9, r9, r9
 801841a:	eb5a 0a0a 	adcs.w	sl, sl, sl
 801841e:	eb4b 0b0b 	adc.w	fp, fp, fp
 8018422:	eb14 0409 	adds.w	r4, r4, r9
 8018426:	eb55 050a 	adcs.w	r5, r5, sl
 801842a:	eb43 030b 	adc.w	r3, r3, fp
 801842e:	6294      	str	r4, [r2, #40]	; 0x28
 8018430:	f04f 0400 	mov.w	r4, #0
 8018434:	690e      	ldr	r6, [r1, #16]
 8018436:	f8d1 801c 	ldr.w	r8, [r1, #28]
 801843a:	fba6 6808 	umull	r6, r8, r6, r8
 801843e:	19ad      	adds	r5, r5, r6
 8018440:	eb53 0308 	adcs.w	r3, r3, r8
 8018444:	f144 0400 	adc.w	r4, r4, #0
 8018448:	19ad      	adds	r5, r5, r6
 801844a:	eb53 0308 	adcs.w	r3, r3, r8
 801844e:	f144 0400 	adc.w	r4, r4, #0
 8018452:	694e      	ldr	r6, [r1, #20]
 8018454:	f8d1 8018 	ldr.w	r8, [r1, #24]
 8018458:	fba6 6808 	umull	r6, r8, r6, r8
 801845c:	19ad      	adds	r5, r5, r6
 801845e:	eb53 0308 	adcs.w	r3, r3, r8
 8018462:	f144 0400 	adc.w	r4, r4, #0
 8018466:	19ad      	adds	r5, r5, r6
 8018468:	eb53 0308 	adcs.w	r3, r3, r8
 801846c:	f144 0400 	adc.w	r4, r4, #0
 8018470:	62d5      	str	r5, [r2, #44]	; 0x2c
 8018472:	f04f 0500 	mov.w	r5, #0
 8018476:	694e      	ldr	r6, [r1, #20]
 8018478:	f8d1 801c 	ldr.w	r8, [r1, #28]
 801847c:	fba6 6808 	umull	r6, r8, r6, r8
 8018480:	199b      	adds	r3, r3, r6
 8018482:	eb54 0408 	adcs.w	r4, r4, r8
 8018486:	f145 0500 	adc.w	r5, r5, #0
 801848a:	199b      	adds	r3, r3, r6
 801848c:	eb54 0408 	adcs.w	r4, r4, r8
 8018490:	f145 0500 	adc.w	r5, r5, #0
 8018494:	698e      	ldr	r6, [r1, #24]
 8018496:	fba6 6806 	umull	r6, r8, r6, r6
 801849a:	199b      	adds	r3, r3, r6
 801849c:	eb54 0408 	adcs.w	r4, r4, r8
 80184a0:	f145 0500 	adc.w	r5, r5, #0
 80184a4:	6313      	str	r3, [r2, #48]	; 0x30
 80184a6:	f04f 0300 	mov.w	r3, #0
 80184aa:	698e      	ldr	r6, [r1, #24]
 80184ac:	f8d1 801c 	ldr.w	r8, [r1, #28]
 80184b0:	fba6 6808 	umull	r6, r8, r6, r8
 80184b4:	19a4      	adds	r4, r4, r6
 80184b6:	eb55 0508 	adcs.w	r5, r5, r8
 80184ba:	f143 0300 	adc.w	r3, r3, #0
 80184be:	19a4      	adds	r4, r4, r6
 80184c0:	eb55 0508 	adcs.w	r5, r5, r8
 80184c4:	f143 0300 	adc.w	r3, r3, #0
 80184c8:	6354      	str	r4, [r2, #52]	; 0x34
 80184ca:	f04f 0400 	mov.w	r4, #0
 80184ce:	69ce      	ldr	r6, [r1, #28]
 80184d0:	fba6 6806 	umull	r6, r8, r6, r6
 80184d4:	19ad      	adds	r5, r5, r6
 80184d6:	eb43 0308 	adc.w	r3, r3, r8
 80184da:	6395      	str	r5, [r2, #56]	; 0x38
 80184dc:	63d3      	str	r3, [r2, #60]	; 0x3c
 80184de:	6803      	ldr	r3, [r0, #0]
 80184e0:	6844      	ldr	r4, [r0, #4]
 80184e2:	6885      	ldr	r5, [r0, #8]
 80184e4:	68c6      	ldr	r6, [r0, #12]
 80184e6:	6013      	str	r3, [r2, #0]
 80184e8:	6054      	str	r4, [r2, #4]
 80184ea:	6095      	str	r5, [r2, #8]
 80184ec:	60d6      	str	r6, [r2, #12]
 80184ee:	6903      	ldr	r3, [r0, #16]
 80184f0:	6944      	ldr	r4, [r0, #20]
 80184f2:	6985      	ldr	r5, [r0, #24]
 80184f4:	69c6      	ldr	r6, [r0, #28]
 80184f6:	6113      	str	r3, [r2, #16]
 80184f8:	6154      	str	r4, [r2, #20]
 80184fa:	6195      	str	r5, [r2, #24]
 80184fc:	61d6      	str	r6, [r2, #28]
        "str	r6, [%[r], #28]\n\t"
        :
        : [r] "r" (r), [a] "r" (a), [tmp] "r" (tmp)
        : "memory", "r3", "r4", "r5", "r6", "r8", "r9", "r10", "r11"
    );
}
 80184fe:	bf00      	nop
 8018500:	3730      	adds	r7, #48	; 0x30
 8018502:	46bd      	mov	sp, r7
 8018504:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8018508:	4770      	bx	lr
	...

0801850c <sp_256_mont_mul_order_8>:
 * r  Result of the multiplication.
 * a  First operand of the multiplication.
 * b  Second operand of the multiplication.
 */
static void sp_256_mont_mul_order_8(sp_digit* r, const sp_digit* a, const sp_digit* b)
{
 801850c:	b580      	push	{r7, lr}
 801850e:	b084      	sub	sp, #16
 8018510:	af00      	add	r7, sp, #0
 8018512:	60f8      	str	r0, [r7, #12]
 8018514:	60b9      	str	r1, [r7, #8]
 8018516:	607a      	str	r2, [r7, #4]
    sp_256_mul_8(r, a, b);
 8018518:	687a      	ldr	r2, [r7, #4]
 801851a:	68b9      	ldr	r1, [r7, #8]
 801851c:	68f8      	ldr	r0, [r7, #12]
 801851e:	f7ff f92d 	bl	801777c <sp_256_mul_8>
    sp_256_mont_reduce_order_8(r, p256_order, p256_mp_order);
 8018522:	4b05      	ldr	r3, [pc, #20]	; (8018538 <sp_256_mont_mul_order_8+0x2c>)
 8018524:	461a      	mov	r2, r3
 8018526:	4905      	ldr	r1, [pc, #20]	; (801853c <sp_256_mont_mul_order_8+0x30>)
 8018528:	68f8      	ldr	r0, [r7, #12]
 801852a:	f7fd fa7a 	bl	8015a22 <sp_256_mont_reduce_order_8>
}
 801852e:	bf00      	nop
 8018530:	3710      	adds	r7, #16
 8018532:	46bd      	mov	sp, r7
 8018534:	bd80      	pop	{r7, pc}
 8018536:	bf00      	nop
 8018538:	ee00bc4f 	.word	0xee00bc4f
 801853c:	0801af34 	.word	0x0801af34

08018540 <sp_256_mont_sqr_order_8>:
 *
 * r  Result of the squaring.
 * a  Number to square.
 */
static void sp_256_mont_sqr_order_8(sp_digit* r, const sp_digit* a)
{
 8018540:	b580      	push	{r7, lr}
 8018542:	b082      	sub	sp, #8
 8018544:	af00      	add	r7, sp, #0
 8018546:	6078      	str	r0, [r7, #4]
 8018548:	6039      	str	r1, [r7, #0]
    sp_256_sqr_8(r, a);
 801854a:	6839      	ldr	r1, [r7, #0]
 801854c:	6878      	ldr	r0, [r7, #4]
 801854e:	f7ff fdcc 	bl	80180ea <sp_256_sqr_8>
    sp_256_mont_reduce_order_8(r, p256_order, p256_mp_order);
 8018552:	4b05      	ldr	r3, [pc, #20]	; (8018568 <sp_256_mont_sqr_order_8+0x28>)
 8018554:	461a      	mov	r2, r3
 8018556:	4905      	ldr	r1, [pc, #20]	; (801856c <sp_256_mont_sqr_order_8+0x2c>)
 8018558:	6878      	ldr	r0, [r7, #4]
 801855a:	f7fd fa62 	bl	8015a22 <sp_256_mont_reduce_order_8>
}
 801855e:	bf00      	nop
 8018560:	3708      	adds	r7, #8
 8018562:	46bd      	mov	sp, r7
 8018564:	bd80      	pop	{r7, pc}
 8018566:	bf00      	nop
 8018568:	ee00bc4f 	.word	0xee00bc4f
 801856c:	0801af34 	.word	0x0801af34

08018570 <sp_256_mont_inv_order_8>:
}
#endif /* WOLFSSL_SP_NONBLOCK */

static void sp_256_mont_inv_order_8(sp_digit* r, const sp_digit* a,
        sp_digit* td)
{
 8018570:	b580      	push	{r7, lr}
 8018572:	b086      	sub	sp, #24
 8018574:	af00      	add	r7, sp, #0
 8018576:	60f8      	str	r0, [r7, #12]
 8018578:	60b9      	str	r1, [r7, #8]
 801857a:	607a      	str	r2, [r7, #4]
#ifdef WOLFSSL_SP_SMALL
    sp_digit* t = td;
 801857c:	687b      	ldr	r3, [r7, #4]
 801857e:	613b      	str	r3, [r7, #16]
    int i;

    XMEMCPY(t, a, sizeof(sp_digit) * 8);
 8018580:	2220      	movs	r2, #32
 8018582:	68b9      	ldr	r1, [r7, #8]
 8018584:	6938      	ldr	r0, [r7, #16]
 8018586:	f000 ff36 	bl	80193f6 <memcpy>
    for (i=254; i>=0; i--) {
 801858a:	23fe      	movs	r3, #254	; 0xfe
 801858c:	617b      	str	r3, [r7, #20]
 801858e:	e022      	b.n	80185d6 <sp_256_mont_inv_order_8+0x66>
        sp_256_mont_sqr_order_8(t, t);
 8018590:	6939      	ldr	r1, [r7, #16]
 8018592:	6938      	ldr	r0, [r7, #16]
 8018594:	f7ff ffd4 	bl	8018540 <sp_256_mont_sqr_order_8>
        if ((p256_order_minus_2[i / 32] & ((sp_int_digit)1 << (i % 32))) != 0) {
 8018598:	697b      	ldr	r3, [r7, #20]
 801859a:	2b00      	cmp	r3, #0
 801859c:	da00      	bge.n	80185a0 <sp_256_mont_inv_order_8+0x30>
 801859e:	331f      	adds	r3, #31
 80185a0:	115b      	asrs	r3, r3, #5
 80185a2:	461a      	mov	r2, r3
 80185a4:	4b12      	ldr	r3, [pc, #72]	; (80185f0 <sp_256_mont_inv_order_8+0x80>)
 80185a6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80185aa:	697b      	ldr	r3, [r7, #20]
 80185ac:	4259      	negs	r1, r3
 80185ae:	f003 031f 	and.w	r3, r3, #31
 80185b2:	f001 011f 	and.w	r1, r1, #31
 80185b6:	bf58      	it	pl
 80185b8:	424b      	negpl	r3, r1
 80185ba:	2101      	movs	r1, #1
 80185bc:	fa01 f303 	lsl.w	r3, r1, r3
 80185c0:	4013      	ands	r3, r2
 80185c2:	2b00      	cmp	r3, #0
 80185c4:	d004      	beq.n	80185d0 <sp_256_mont_inv_order_8+0x60>
            sp_256_mont_mul_order_8(t, t, a);
 80185c6:	68ba      	ldr	r2, [r7, #8]
 80185c8:	6939      	ldr	r1, [r7, #16]
 80185ca:	6938      	ldr	r0, [r7, #16]
 80185cc:	f7ff ff9e 	bl	801850c <sp_256_mont_mul_order_8>
    for (i=254; i>=0; i--) {
 80185d0:	697b      	ldr	r3, [r7, #20]
 80185d2:	3b01      	subs	r3, #1
 80185d4:	617b      	str	r3, [r7, #20]
 80185d6:	697b      	ldr	r3, [r7, #20]
 80185d8:	2b00      	cmp	r3, #0
 80185da:	dad9      	bge.n	8018590 <sp_256_mont_inv_order_8+0x20>
        }
    }
    XMEMCPY(r, t, sizeof(sp_digit) * 8U);
 80185dc:	2220      	movs	r2, #32
 80185de:	6939      	ldr	r1, [r7, #16]
 80185e0:	68f8      	ldr	r0, [r7, #12]
 80185e2:	f000 ff08 	bl	80193f6 <memcpy>
    /* t2= a^ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632540 */
    sp_256_mont_sqr_n_order_8(t2, t2, 4);
    /* r = a^ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63254f */
    sp_256_mont_mul_order_8(r, t2, t3);
#endif /* WOLFSSL_SP_SMALL */
}
 80185e6:	bf00      	nop
 80185e8:	3718      	adds	r7, #24
 80185ea:	46bd      	mov	sp, r7
 80185ec:	bd80      	pop	{r7, pc}
 80185ee:	bf00      	nop
 80185f0:	0801b458 	.word	0x0801b458

080185f4 <sp_ecc_verify_256>:
}
#endif /* WOLFSSL_SP_NONBLOCK */

int sp_ecc_verify_256(const byte* hash, word32 hashLen, mp_int* pX,
    mp_int* pY, mp_int* pZ, mp_int* r, mp_int* sm, int* res, void* heap)
{
 80185f4:	b580      	push	{r7, lr}
 80185f6:	b092      	sub	sp, #72	; 0x48
 80185f8:	af02      	add	r7, sp, #8
 80185fa:	60f8      	str	r0, [r7, #12]
 80185fc:	60b9      	str	r1, [r7, #8]
 80185fe:	607a      	str	r2, [r7, #4]
 8018600:	603b      	str	r3, [r7, #0]
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* d = NULL;
 8018602:	2300      	movs	r3, #0
 8018604:	63fb      	str	r3, [r7, #60]	; 0x3c
    sp_digit sd[2*8];
    sp_digit tmpd[2*8 * 5];
    sp_point_256 p1d;
    sp_point_256 p2d;
#endif
    sp_digit* u1 = NULL;
 8018606:	2300      	movs	r3, #0
 8018608:	63bb      	str	r3, [r7, #56]	; 0x38
    sp_digit* u2 = NULL;
 801860a:	2300      	movs	r3, #0
 801860c:	637b      	str	r3, [r7, #52]	; 0x34
    sp_digit* s = NULL;
 801860e:	2300      	movs	r3, #0
 8018610:	633b      	str	r3, [r7, #48]	; 0x30
    sp_digit* tmp = NULL;
 8018612:	2300      	movs	r3, #0
 8018614:	62fb      	str	r3, [r7, #44]	; 0x2c
    sp_point_256* p1;
    sp_point_256* p2 = NULL;
 8018616:	2300      	movs	r3, #0
 8018618:	617b      	str	r3, [r7, #20]
    sp_digit carry;
    int32_t c;
    int err;

    err = sp_256_point_new_8(heap, p1d, p1);
 801861a:	f107 0318 	add.w	r3, r7, #24
 801861e:	461a      	mov	r2, r3
 8018620:	2100      	movs	r1, #0
 8018622:	6db8      	ldr	r0, [r7, #88]	; 0x58
 8018624:	f7fb ff98 	bl	8014558 <sp_256_point_new_ex_8>
 8018628:	62b8      	str	r0, [r7, #40]	; 0x28
    if (err == MP_OKAY) {
 801862a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801862c:	2b00      	cmp	r3, #0
 801862e:	d107      	bne.n	8018640 <sp_ecc_verify_256+0x4c>
        err = sp_256_point_new_8(heap, p2d, p2);
 8018630:	f107 0314 	add.w	r3, r7, #20
 8018634:	461a      	mov	r2, r3
 8018636:	2100      	movs	r1, #0
 8018638:	6db8      	ldr	r0, [r7, #88]	; 0x58
 801863a:	f7fb ff8d 	bl	8014558 <sp_256_point_new_ex_8>
 801863e:	62b8      	str	r0, [r7, #40]	; 0x28
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
 8018640:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018642:	2b00      	cmp	r3, #0
 8018644:	d10a      	bne.n	801865c <sp_ecc_verify_256+0x68>
        d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 16 * 8, heap,
 8018646:	f44f 7000 	mov.w	r0, #512	; 0x200
 801864a:	f7f6 fc55 	bl	800eef8 <wolfSSL_Malloc>
 801864e:	63f8      	str	r0, [r7, #60]	; 0x3c
                                                              DYNAMIC_TYPE_ECC);
        if (d == NULL) {
 8018650:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018652:	2b00      	cmp	r3, #0
 8018654:	d102      	bne.n	801865c <sp_ecc_verify_256+0x68>
            err = MEMORY_E;
 8018656:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 801865a:	62bb      	str	r3, [r7, #40]	; 0x28
        }
    }
#endif

    if (err == MP_OKAY) {
 801865c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801865e:	2b00      	cmp	r3, #0
 8018660:	d13e      	bne.n	80186e0 <sp_ecc_verify_256+0xec>
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        u1  = d + 0 * 8;
 8018662:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018664:	63bb      	str	r3, [r7, #56]	; 0x38
        u2  = d + 2 * 8;
 8018666:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018668:	3340      	adds	r3, #64	; 0x40
 801866a:	637b      	str	r3, [r7, #52]	; 0x34
        s   = d + 4 * 8;
 801866c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801866e:	3380      	adds	r3, #128	; 0x80
 8018670:	633b      	str	r3, [r7, #48]	; 0x30
        tmp = d + 6 * 8;
 8018672:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018674:	33c0      	adds	r3, #192	; 0xc0
 8018676:	62fb      	str	r3, [r7, #44]	; 0x2c
        u2 = u2d;
        s  = sd;
        tmp = tmpd;
#endif

        if (hashLen > 32U) {
 8018678:	68bb      	ldr	r3, [r7, #8]
 801867a:	2b20      	cmp	r3, #32
 801867c:	d901      	bls.n	8018682 <sp_ecc_verify_256+0x8e>
            hashLen = 32U;
 801867e:	2320      	movs	r3, #32
 8018680:	60bb      	str	r3, [r7, #8]
        }

        sp_256_from_bin(u1, 8, hash, (int)hashLen);
 8018682:	68bb      	ldr	r3, [r7, #8]
 8018684:	68fa      	ldr	r2, [r7, #12]
 8018686:	2108      	movs	r1, #8
 8018688:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 801868a:	f7ff f806 	bl	801769a <sp_256_from_bin>
        sp_256_from_mp(u2, 8, r);
 801868e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8018690:	2108      	movs	r1, #8
 8018692:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8018694:	f7fc f916 	bl	80148c4 <sp_256_from_mp>
        sp_256_from_mp(s, 8, sm);
 8018698:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 801869a:	2108      	movs	r1, #8
 801869c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801869e:	f7fc f911 	bl	80148c4 <sp_256_from_mp>
        sp_256_from_mp(p2->x, 8, pX);
 80186a2:	697b      	ldr	r3, [r7, #20]
 80186a4:	687a      	ldr	r2, [r7, #4]
 80186a6:	2108      	movs	r1, #8
 80186a8:	4618      	mov	r0, r3
 80186aa:	f7fc f90b 	bl	80148c4 <sp_256_from_mp>
        sp_256_from_mp(p2->y, 8, pY);
 80186ae:	697b      	ldr	r3, [r7, #20]
 80186b0:	3340      	adds	r3, #64	; 0x40
 80186b2:	683a      	ldr	r2, [r7, #0]
 80186b4:	2108      	movs	r1, #8
 80186b6:	4618      	mov	r0, r3
 80186b8:	f7fc f904 	bl	80148c4 <sp_256_from_mp>
        sp_256_from_mp(p2->z, 8, pZ);
 80186bc:	697b      	ldr	r3, [r7, #20]
 80186be:	3380      	adds	r3, #128	; 0x80
 80186c0:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80186c2:	2108      	movs	r1, #8
 80186c4:	4618      	mov	r0, r3
 80186c6:	f7fc f8fd 	bl	80148c4 <sp_256_from_mp>
        {
            sp_256_mod_inv_8(s, s, p256_order);
        }
#endif /* !WOLFSSL_SP_SMALL */
        {
            sp_256_mul_8(s, s, p256_norm_order);
 80186ca:	4a80      	ldr	r2, [pc, #512]	; (80188cc <sp_ecc_verify_256+0x2d8>)
 80186cc:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80186ce:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80186d0:	f7ff f854 	bl	801777c <sp_256_mul_8>
        }
        err = sp_256_mod_8(s, s, p256_order);
 80186d4:	4a7e      	ldr	r2, [pc, #504]	; (80188d0 <sp_ecc_verify_256+0x2dc>)
 80186d6:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80186d8:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80186da:	f7ff fcf5 	bl	80180c8 <sp_256_mod_8>
 80186de:	62b8      	str	r0, [r7, #40]	; 0x28
    }
    if (err == MP_OKAY) {
 80186e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80186e2:	2b00      	cmp	r3, #0
 80186e4:	d117      	bne.n	8018716 <sp_ecc_verify_256+0x122>
        sp_256_norm_8(s);
#ifdef WOLFSSL_SP_SMALL
        {
            sp_256_mont_inv_order_8(s, s, tmp);
 80186e6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80186e8:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80186ea:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80186ec:	f7ff ff40 	bl	8018570 <sp_256_mont_inv_order_8>
            sp_256_mont_mul_order_8(u1, u1, s);
 80186f0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80186f2:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 80186f4:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80186f6:	f7ff ff09 	bl	801850c <sp_256_mont_mul_order_8>
            sp_256_mont_mul_order_8(u2, u2, s);
 80186fa:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80186fc:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80186fe:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8018700:	f7ff ff04 	bl	801850c <sp_256_mont_mul_order_8>
            sp_256_mont_mul_order_8(u1, u1, s);
            sp_256_mont_mul_order_8(u2, u2, s);
        }

#endif /* WOLFSSL_SP_SMALL */
            err = sp_256_ecc_mulmod_base_8(p1, u1, 0, 0, heap);
 8018704:	69b8      	ldr	r0, [r7, #24]
 8018706:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8018708:	9300      	str	r3, [sp, #0]
 801870a:	2300      	movs	r3, #0
 801870c:	2200      	movs	r2, #0
 801870e:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8018710:	f7fe ff2a 	bl	8017568 <sp_256_ecc_mulmod_base_8>
 8018714:	62b8      	str	r0, [r7, #40]	; 0x28
    }
    if (err == MP_OKAY) {
 8018716:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018718:	2b00      	cmp	r3, #0
 801871a:	d10a      	bne.n	8018732 <sp_ecc_verify_256+0x13e>
            err = sp_256_ecc_mulmod_8(p2, p2, u2, 0, 0, heap);
 801871c:	6978      	ldr	r0, [r7, #20]
 801871e:	6979      	ldr	r1, [r7, #20]
 8018720:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8018722:	9301      	str	r3, [sp, #4]
 8018724:	2300      	movs	r3, #0
 8018726:	9300      	str	r3, [sp, #0]
 8018728:	2300      	movs	r3, #0
 801872a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801872c:	f7fe ff06 	bl	801753c <sp_256_ecc_mulmod_8>
 8018730:	62b8      	str	r0, [r7, #40]	; 0x28
    }

    if (err == MP_OKAY) {
 8018732:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018734:	2b00      	cmp	r3, #0
 8018736:	d14d      	bne.n	80187d4 <sp_ecc_verify_256+0x1e0>
        {
            sp_256_proj_point_add_8(p1, p1, p2, tmp);
 8018738:	69b8      	ldr	r0, [r7, #24]
 801873a:	69b9      	ldr	r1, [r7, #24]
 801873c:	697a      	ldr	r2, [r7, #20]
 801873e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018740:	f7fd fdde 	bl	8016300 <sp_256_proj_point_add_8>
            if (sp_256_iszero_8(p1->z)) {
 8018744:	69bb      	ldr	r3, [r7, #24]
 8018746:	3380      	adds	r3, #128	; 0x80
 8018748:	4618      	mov	r0, r3
 801874a:	f7fe ff79 	bl	8017640 <sp_256_iszero_8>
 801874e:	4603      	mov	r3, r0
 8018750:	2b00      	cmp	r3, #0
 8018752:	d034      	beq.n	80187be <sp_ecc_verify_256+0x1ca>
                if (sp_256_iszero_8(p1->x) && sp_256_iszero_8(p1->y)) {
 8018754:	69bb      	ldr	r3, [r7, #24]
 8018756:	4618      	mov	r0, r3
 8018758:	f7fe ff72 	bl	8017640 <sp_256_iszero_8>
 801875c:	4603      	mov	r3, r0
 801875e:	2b00      	cmp	r3, #0
 8018760:	d00e      	beq.n	8018780 <sp_ecc_verify_256+0x18c>
 8018762:	69bb      	ldr	r3, [r7, #24]
 8018764:	3340      	adds	r3, #64	; 0x40
 8018766:	4618      	mov	r0, r3
 8018768:	f7fe ff6a 	bl	8017640 <sp_256_iszero_8>
 801876c:	4603      	mov	r3, r0
 801876e:	2b00      	cmp	r3, #0
 8018770:	d006      	beq.n	8018780 <sp_ecc_verify_256+0x18c>
                    sp_256_proj_point_dbl_8(p1, p2, tmp);
 8018772:	69bb      	ldr	r3, [r7, #24]
 8018774:	6979      	ldr	r1, [r7, #20]
 8018776:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8018778:	4618      	mov	r0, r3
 801877a:	f7fd fcad 	bl	80160d8 <sp_256_proj_point_dbl_8>
 801877e:	e01e      	b.n	80187be <sp_ecc_verify_256+0x1ca>
                }
                else {
                    /* Y ordinate is not used from here - don't set. */
                    p1->x[0] = 0;
 8018780:	69bb      	ldr	r3, [r7, #24]
 8018782:	2200      	movs	r2, #0
 8018784:	601a      	str	r2, [r3, #0]
                    p1->x[1] = 0;
 8018786:	69bb      	ldr	r3, [r7, #24]
 8018788:	2200      	movs	r2, #0
 801878a:	605a      	str	r2, [r3, #4]
                    p1->x[2] = 0;
 801878c:	69bb      	ldr	r3, [r7, #24]
 801878e:	2200      	movs	r2, #0
 8018790:	609a      	str	r2, [r3, #8]
                    p1->x[3] = 0;
 8018792:	69bb      	ldr	r3, [r7, #24]
 8018794:	2200      	movs	r2, #0
 8018796:	60da      	str	r2, [r3, #12]
                    p1->x[4] = 0;
 8018798:	69bb      	ldr	r3, [r7, #24]
 801879a:	2200      	movs	r2, #0
 801879c:	611a      	str	r2, [r3, #16]
                    p1->x[5] = 0;
 801879e:	69bb      	ldr	r3, [r7, #24]
 80187a0:	2200      	movs	r2, #0
 80187a2:	615a      	str	r2, [r3, #20]
                    p1->x[6] = 0;
 80187a4:	69bb      	ldr	r3, [r7, #24]
 80187a6:	2200      	movs	r2, #0
 80187a8:	619a      	str	r2, [r3, #24]
                    p1->x[7] = 0;
 80187aa:	69bb      	ldr	r3, [r7, #24]
 80187ac:	2200      	movs	r2, #0
 80187ae:	61da      	str	r2, [r3, #28]
                    XMEMCPY(p1->z, p256_norm_mod, sizeof(p256_norm_mod));
 80187b0:	69bb      	ldr	r3, [r7, #24]
 80187b2:	3380      	adds	r3, #128	; 0x80
 80187b4:	2220      	movs	r2, #32
 80187b6:	4947      	ldr	r1, [pc, #284]	; (80188d4 <sp_ecc_verify_256+0x2e0>)
 80187b8:	4618      	mov	r0, r3
 80187ba:	f000 fe1c 	bl	80193f6 <memcpy>
            }
        }

        /* (r + n*order).z'.z' mod prime == (u1.G + u2.Q)->x' */
        /* Reload r and convert to Montgomery form. */
        sp_256_from_mp(u2, 8, r);
 80187be:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80187c0:	2108      	movs	r1, #8
 80187c2:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80187c4:	f7fc f87e 	bl	80148c4 <sp_256_from_mp>
        err = sp_256_mod_mul_norm_8(u2, u2, p256_mod);
 80187c8:	4a43      	ldr	r2, [pc, #268]	; (80188d8 <sp_ecc_verify_256+0x2e4>)
 80187ca:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80187cc:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80187ce:	f7fb fefa 	bl	80145c6 <sp_256_mod_mul_norm_8>
 80187d2:	62b8      	str	r0, [r7, #40]	; 0x28
    }

    if (err == MP_OKAY) {
 80187d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80187d6:	2b00      	cmp	r3, #0
 80187d8:	d15c      	bne.n	8018894 <sp_ecc_verify_256+0x2a0>
        /* u1 = r.z'.z' mod prime */
        sp_256_mont_sqr_8(p1->z, p1->z, p256_mod, p256_mp_mod);
 80187da:	69bb      	ldr	r3, [r7, #24]
 80187dc:	f103 0080 	add.w	r0, r3, #128	; 0x80
 80187e0:	69bb      	ldr	r3, [r7, #24]
 80187e2:	f103 0180 	add.w	r1, r3, #128	; 0x80
 80187e6:	2301      	movs	r3, #1
 80187e8:	4a3b      	ldr	r2, [pc, #236]	; (80188d8 <sp_ecc_verify_256+0x2e4>)
 80187ea:	f7fc fcd4 	bl	8015196 <sp_256_mont_sqr_8>
        sp_256_mont_mul_8(u1, u2, p1->z, p256_mod, p256_mp_mod);
 80187ee:	69bb      	ldr	r3, [r7, #24]
 80187f0:	f103 0280 	add.w	r2, r3, #128	; 0x80
 80187f4:	2301      	movs	r3, #1
 80187f6:	9300      	str	r3, [sp, #0]
 80187f8:	4b37      	ldr	r3, [pc, #220]	; (80188d8 <sp_ecc_verify_256+0x2e4>)
 80187fa:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80187fc:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80187fe:	f7fc f8e4 	bl	80149ca <sp_256_mont_mul_8>
        *res = (int)(sp_256_cmp_8(p1->x, u1) == 0);
 8018802:	69bb      	ldr	r3, [r7, #24]
 8018804:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8018806:	4618      	mov	r0, r3
 8018808:	f7fd f816 	bl	8015838 <sp_256_cmp_8>
 801880c:	4603      	mov	r3, r0
 801880e:	2b00      	cmp	r3, #0
 8018810:	bf0c      	ite	eq
 8018812:	2301      	moveq	r3, #1
 8018814:	2300      	movne	r3, #0
 8018816:	b2db      	uxtb	r3, r3
 8018818:	461a      	mov	r2, r3
 801881a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801881c:	601a      	str	r2, [r3, #0]
        if (*res == 0) {
 801881e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8018820:	681b      	ldr	r3, [r3, #0]
 8018822:	2b00      	cmp	r3, #0
 8018824:	d136      	bne.n	8018894 <sp_ecc_verify_256+0x2a0>
            /* Reload r and add order. */
            sp_256_from_mp(u2, 8, r);
 8018826:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8018828:	2108      	movs	r1, #8
 801882a:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801882c:	f7fc f84a 	bl	80148c4 <sp_256_from_mp>
            carry = sp_256_add_8(u2, u2, p256_order);
 8018830:	4a27      	ldr	r2, [pc, #156]	; (80188d0 <sp_ecc_verify_256+0x2dc>)
 8018832:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8018834:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8018836:	f7fd f9fd 	bl	8015c34 <sp_256_add_8>
 801883a:	6278      	str	r0, [r7, #36]	; 0x24
            /* Carry means result is greater than mod and is not valid. */
            if (carry == 0) {
 801883c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801883e:	2b00      	cmp	r3, #0
 8018840:	d128      	bne.n	8018894 <sp_ecc_verify_256+0x2a0>
                sp_256_norm_8(u2);

                /* Compare with mod and if greater or equal then not valid. */
                c = sp_256_cmp_8(u2, p256_mod);
 8018842:	4925      	ldr	r1, [pc, #148]	; (80188d8 <sp_ecc_verify_256+0x2e4>)
 8018844:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8018846:	f7fc fff7 	bl	8015838 <sp_256_cmp_8>
 801884a:	6238      	str	r0, [r7, #32]
                if (c < 0) {
 801884c:	6a3b      	ldr	r3, [r7, #32]
 801884e:	2b00      	cmp	r3, #0
 8018850:	da20      	bge.n	8018894 <sp_ecc_verify_256+0x2a0>
                    /* Convert to Montogomery form */
                    err = sp_256_mod_mul_norm_8(u2, u2, p256_mod);
 8018852:	4a21      	ldr	r2, [pc, #132]	; (80188d8 <sp_ecc_verify_256+0x2e4>)
 8018854:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8018856:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8018858:	f7fb feb5 	bl	80145c6 <sp_256_mod_mul_norm_8>
 801885c:	62b8      	str	r0, [r7, #40]	; 0x28
                    if (err == MP_OKAY) {
 801885e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018860:	2b00      	cmp	r3, #0
 8018862:	d117      	bne.n	8018894 <sp_ecc_verify_256+0x2a0>
                        /* u1 = (r + 1*order).z'.z' mod prime */
                        sp_256_mont_mul_8(u1, u2, p1->z, p256_mod,
 8018864:	69bb      	ldr	r3, [r7, #24]
 8018866:	f103 0280 	add.w	r2, r3, #128	; 0x80
 801886a:	2301      	movs	r3, #1
 801886c:	9300      	str	r3, [sp, #0]
 801886e:	4b1a      	ldr	r3, [pc, #104]	; (80188d8 <sp_ecc_verify_256+0x2e4>)
 8018870:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8018872:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8018874:	f7fc f8a9 	bl	80149ca <sp_256_mont_mul_8>
                                                                  p256_mp_mod);
                        *res = (int)(sp_256_cmp_8(p1->x, u1) == 0);
 8018878:	69bb      	ldr	r3, [r7, #24]
 801887a:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 801887c:	4618      	mov	r0, r3
 801887e:	f7fc ffdb 	bl	8015838 <sp_256_cmp_8>
 8018882:	4603      	mov	r3, r0
 8018884:	2b00      	cmp	r3, #0
 8018886:	bf0c      	ite	eq
 8018888:	2301      	moveq	r3, #1
 801888a:	2300      	movne	r3, #0
 801888c:	b2db      	uxtb	r3, r3
 801888e:	461a      	mov	r2, r3
 8018890:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8018892:	601a      	str	r2, [r3, #0]
            }
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (d != NULL)
 8018894:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018896:	2b00      	cmp	r3, #0
 8018898:	d007      	beq.n	80188aa <sp_ecc_verify_256+0x2b6>
        XFREE(d, heap, DYNAMIC_TYPE_ECC);
 801889a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801889c:	61fb      	str	r3, [r7, #28]
 801889e:	69fb      	ldr	r3, [r7, #28]
 80188a0:	2b00      	cmp	r3, #0
 80188a2:	d002      	beq.n	80188aa <sp_ecc_verify_256+0x2b6>
 80188a4:	69f8      	ldr	r0, [r7, #28]
 80188a6:	f7f6 fb43 	bl	800ef30 <wolfSSL_Free>
#endif
    sp_256_point_free_8(p1, 0, heap);
 80188aa:	69bb      	ldr	r3, [r7, #24]
 80188ac:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80188ae:	2100      	movs	r1, #0
 80188b0:	4618      	mov	r0, r3
 80188b2:	f7fb fe6b 	bl	801458c <sp_256_point_free_8>
    sp_256_point_free_8(p2, 0, heap);
 80188b6:	697b      	ldr	r3, [r7, #20]
 80188b8:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80188ba:	2100      	movs	r1, #0
 80188bc:	4618      	mov	r0, r3
 80188be:	f7fb fe65 	bl	801458c <sp_256_point_free_8>

    return err;
 80188c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
}
 80188c4:	4618      	mov	r0, r3
 80188c6:	3740      	adds	r7, #64	; 0x40
 80188c8:	46bd      	mov	sp, r7
 80188ca:	bd80      	pop	{r7, pc}
 80188cc:	0801af54 	.word	0x0801af54
 80188d0:	0801af34 	.word	0x0801af34
 80188d4:	0801af14 	.word	0x0801af14
 80188d8:	0801aef4 	.word	0x0801aef4

080188dc <ForceZero>:
{
 80188dc:	b480      	push	{r7}
 80188de:	b085      	sub	sp, #20
 80188e0:	af00      	add	r7, sp, #0
 80188e2:	6078      	str	r0, [r7, #4]
 80188e4:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 80188e6:	687b      	ldr	r3, [r7, #4]
 80188e8:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 80188ea:	e004      	b.n	80188f6 <ForceZero+0x1a>
 80188ec:	68fb      	ldr	r3, [r7, #12]
 80188ee:	1c5a      	adds	r2, r3, #1
 80188f0:	60fa      	str	r2, [r7, #12]
 80188f2:	2200      	movs	r2, #0
 80188f4:	701a      	strb	r2, [r3, #0]
 80188f6:	683b      	ldr	r3, [r7, #0]
 80188f8:	1e5a      	subs	r2, r3, #1
 80188fa:	603a      	str	r2, [r7, #0]
 80188fc:	2b00      	cmp	r3, #0
 80188fe:	d1f5      	bne.n	80188ec <ForceZero+0x10>
}
 8018900:	bf00      	nop
 8018902:	3714      	adds	r7, #20
 8018904:	46bd      	mov	sp, r7
 8018906:	f85d 7b04 	ldr.w	r7, [sp], #4
 801890a:	4770      	bx	lr

0801890c <sp_init>:
 *
 * @return  MP_OKAY on success.
 * @return  MP_VAL when a is NULL.
 */
int sp_init(sp_int* a)
{
 801890c:	b480      	push	{r7}
 801890e:	b085      	sub	sp, #20
 8018910:	af00      	add	r7, sp, #0
 8018912:	6078      	str	r0, [r7, #4]
    int err = MP_OKAY;
 8018914:	2300      	movs	r3, #0
 8018916:	60fb      	str	r3, [r7, #12]

    if (a == NULL) {
 8018918:	687b      	ldr	r3, [r7, #4]
 801891a:	2b00      	cmp	r3, #0
 801891c:	d102      	bne.n	8018924 <sp_init+0x18>
        err = MP_VAL;
 801891e:	f06f 0302 	mvn.w	r3, #2
 8018922:	60fb      	str	r3, [r7, #12]
    }
    if (err == MP_OKAY) {
 8018924:	68fb      	ldr	r3, [r7, #12]
 8018926:	2b00      	cmp	r3, #0
 8018928:	d105      	bne.n	8018936 <sp_init+0x2a>
        a->used = 0;
 801892a:	687b      	ldr	r3, [r7, #4]
 801892c:	2200      	movs	r2, #0
 801892e:	601a      	str	r2, [r3, #0]
        a->size = SP_INT_DIGITS;
 8018930:	687b      	ldr	r3, [r7, #4]
 8018932:	22c1      	movs	r2, #193	; 0xc1
 8018934:	605a      	str	r2, [r3, #4]
    #ifdef HAVE_WOLF_BIGINT
        wc_bigint_init(&a->raw);
    #endif
    }

    return err;
 8018936:	68fb      	ldr	r3, [r7, #12]
}
 8018938:	4618      	mov	r0, r3
 801893a:	3714      	adds	r7, #20
 801893c:	46bd      	mov	sp, r7
 801893e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018942:	4770      	bx	lr

08018944 <sp_init_multi>:
 *
 * @return  MP_OKAY on success.
 */
int sp_init_multi(sp_int* n1, sp_int* n2, sp_int* n3, sp_int* n4, sp_int* n5,
                  sp_int* n6)
{
 8018944:	b480      	push	{r7}
 8018946:	b085      	sub	sp, #20
 8018948:	af00      	add	r7, sp, #0
 801894a:	60f8      	str	r0, [r7, #12]
 801894c:	60b9      	str	r1, [r7, #8]
 801894e:	607a      	str	r2, [r7, #4]
 8018950:	603b      	str	r3, [r7, #0]
    if (n1 != NULL) {
 8018952:	68fb      	ldr	r3, [r7, #12]
 8018954:	2b00      	cmp	r3, #0
 8018956:	d005      	beq.n	8018964 <sp_init_multi+0x20>
        n1->used = 0;
 8018958:	68fb      	ldr	r3, [r7, #12]
 801895a:	2200      	movs	r2, #0
 801895c:	601a      	str	r2, [r3, #0]
        n1->size = SP_INT_DIGITS;
 801895e:	68fb      	ldr	r3, [r7, #12]
 8018960:	22c1      	movs	r2, #193	; 0xc1
 8018962:	605a      	str	r2, [r3, #4]
#ifdef WOLFSSL_SP_INT_NEGATIVE
        n1->sign = MP_ZPOS;
#endif
    }
    if (n2 != NULL) {
 8018964:	68bb      	ldr	r3, [r7, #8]
 8018966:	2b00      	cmp	r3, #0
 8018968:	d005      	beq.n	8018976 <sp_init_multi+0x32>
        n2->used = 0;
 801896a:	68bb      	ldr	r3, [r7, #8]
 801896c:	2200      	movs	r2, #0
 801896e:	601a      	str	r2, [r3, #0]
        n2->size = SP_INT_DIGITS;
 8018970:	68bb      	ldr	r3, [r7, #8]
 8018972:	22c1      	movs	r2, #193	; 0xc1
 8018974:	605a      	str	r2, [r3, #4]
#ifdef WOLFSSL_SP_INT_NEGATIVE
        n2->sign = MP_ZPOS;
#endif
    }
    if (n3 != NULL) {
 8018976:	687b      	ldr	r3, [r7, #4]
 8018978:	2b00      	cmp	r3, #0
 801897a:	d005      	beq.n	8018988 <sp_init_multi+0x44>
        n3->used = 0;
 801897c:	687b      	ldr	r3, [r7, #4]
 801897e:	2200      	movs	r2, #0
 8018980:	601a      	str	r2, [r3, #0]
        n3->size = SP_INT_DIGITS;
 8018982:	687b      	ldr	r3, [r7, #4]
 8018984:	22c1      	movs	r2, #193	; 0xc1
 8018986:	605a      	str	r2, [r3, #4]
#ifdef WOLFSSL_SP_INT_NEGATIVE
        n3->sign = MP_ZPOS;
#endif
    }
    if (n4 != NULL) {
 8018988:	683b      	ldr	r3, [r7, #0]
 801898a:	2b00      	cmp	r3, #0
 801898c:	d005      	beq.n	801899a <sp_init_multi+0x56>
        n4->used = 0;
 801898e:	683b      	ldr	r3, [r7, #0]
 8018990:	2200      	movs	r2, #0
 8018992:	601a      	str	r2, [r3, #0]
        n4->size = SP_INT_DIGITS;
 8018994:	683b      	ldr	r3, [r7, #0]
 8018996:	22c1      	movs	r2, #193	; 0xc1
 8018998:	605a      	str	r2, [r3, #4]
#ifdef WOLFSSL_SP_INT_NEGATIVE
        n4->sign = MP_ZPOS;
#endif
    }
    if (n5 != NULL) {
 801899a:	69bb      	ldr	r3, [r7, #24]
 801899c:	2b00      	cmp	r3, #0
 801899e:	d005      	beq.n	80189ac <sp_init_multi+0x68>
        n5->used = 0;
 80189a0:	69bb      	ldr	r3, [r7, #24]
 80189a2:	2200      	movs	r2, #0
 80189a4:	601a      	str	r2, [r3, #0]
        n5->size = SP_INT_DIGITS;
 80189a6:	69bb      	ldr	r3, [r7, #24]
 80189a8:	22c1      	movs	r2, #193	; 0xc1
 80189aa:	605a      	str	r2, [r3, #4]
#ifdef WOLFSSL_SP_INT_NEGATIVE
        n5->sign = MP_ZPOS;
#endif
    }
    if (n6 != NULL) {
 80189ac:	69fb      	ldr	r3, [r7, #28]
 80189ae:	2b00      	cmp	r3, #0
 80189b0:	d005      	beq.n	80189be <sp_init_multi+0x7a>
        n6->used = 0;
 80189b2:	69fb      	ldr	r3, [r7, #28]
 80189b4:	2200      	movs	r2, #0
 80189b6:	601a      	str	r2, [r3, #0]
        n6->size = SP_INT_DIGITS;
 80189b8:	69fb      	ldr	r3, [r7, #28]
 80189ba:	22c1      	movs	r2, #193	; 0xc1
 80189bc:	605a      	str	r2, [r3, #4]
#ifdef WOLFSSL_SP_INT_NEGATIVE
        n6->sign = MP_ZPOS;
#endif
    }

    return MP_OKAY;
 80189be:	2300      	movs	r3, #0
}
 80189c0:	4618      	mov	r0, r3
 80189c2:	3714      	adds	r7, #20
 80189c4:	46bd      	mov	sp, r7
 80189c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80189ca:	4770      	bx	lr

080189cc <sp_grow>:
 *
 * @return  MP_OKAY on success
 * @return  MP_MEM if the number of digits requested is more than available.
 */
int sp_grow(sp_int* a, int l)
{
 80189cc:	b480      	push	{r7}
 80189ce:	b085      	sub	sp, #20
 80189d0:	af00      	add	r7, sp, #0
 80189d2:	6078      	str	r0, [r7, #4]
 80189d4:	6039      	str	r1, [r7, #0]
    int err = MP_OKAY;
 80189d6:	2300      	movs	r3, #0
 80189d8:	60fb      	str	r3, [r7, #12]

    if (a == NULL) {
 80189da:	687b      	ldr	r3, [r7, #4]
 80189dc:	2b00      	cmp	r3, #0
 80189de:	d102      	bne.n	80189e6 <sp_grow+0x1a>
        err = MP_VAL;
 80189e0:	f06f 0302 	mvn.w	r3, #2
 80189e4:	60fb      	str	r3, [r7, #12]
    }
    if ((err == MP_OKAY) && (l > a->size)) {
 80189e6:	68fb      	ldr	r3, [r7, #12]
 80189e8:	2b00      	cmp	r3, #0
 80189ea:	d107      	bne.n	80189fc <sp_grow+0x30>
 80189ec:	687b      	ldr	r3, [r7, #4]
 80189ee:	685b      	ldr	r3, [r3, #4]
 80189f0:	683a      	ldr	r2, [r7, #0]
 80189f2:	429a      	cmp	r2, r3
 80189f4:	dd02      	ble.n	80189fc <sp_grow+0x30>
        err = MP_MEM;
 80189f6:	f06f 0301 	mvn.w	r3, #1
 80189fa:	60fb      	str	r3, [r7, #12]
    }
    if (err == MP_OKAY) {
 80189fc:	68fb      	ldr	r3, [r7, #12]
 80189fe:	2b00      	cmp	r3, #0
 8018a00:	d110      	bne.n	8018a24 <sp_grow+0x58>
        int i;

        for (i = a->used; i < l; i++) {
 8018a02:	687b      	ldr	r3, [r7, #4]
 8018a04:	681b      	ldr	r3, [r3, #0]
 8018a06:	60bb      	str	r3, [r7, #8]
 8018a08:	e008      	b.n	8018a1c <sp_grow+0x50>
            a->dp[i] = 0;
 8018a0a:	687b      	ldr	r3, [r7, #4]
 8018a0c:	68ba      	ldr	r2, [r7, #8]
 8018a0e:	3202      	adds	r2, #2
 8018a10:	2100      	movs	r1, #0
 8018a12:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i = a->used; i < l; i++) {
 8018a16:	68bb      	ldr	r3, [r7, #8]
 8018a18:	3301      	adds	r3, #1
 8018a1a:	60bb      	str	r3, [r7, #8]
 8018a1c:	68ba      	ldr	r2, [r7, #8]
 8018a1e:	683b      	ldr	r3, [r7, #0]
 8018a20:	429a      	cmp	r2, r3
 8018a22:	dbf2      	blt.n	8018a0a <sp_grow+0x3e>
        }
    }

    return err;
 8018a24:	68fb      	ldr	r3, [r7, #12]
}
 8018a26:	4618      	mov	r0, r3
 8018a28:	3714      	adds	r7, #20
 8018a2a:	46bd      	mov	sp, r7
 8018a2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018a30:	4770      	bx	lr

08018a32 <_sp_zero>:
 * Assumes a is not NULL.
 *
 * @param  [out]  a  SP integer to set to zero.
 */
static void _sp_zero(sp_int* a)
{
 8018a32:	b480      	push	{r7}
 8018a34:	b083      	sub	sp, #12
 8018a36:	af00      	add	r7, sp, #0
 8018a38:	6078      	str	r0, [r7, #4]
    a->dp[0] = 0;
 8018a3a:	687b      	ldr	r3, [r7, #4]
 8018a3c:	2200      	movs	r2, #0
 8018a3e:	609a      	str	r2, [r3, #8]
    a->used = 0;
 8018a40:	687b      	ldr	r3, [r7, #4]
 8018a42:	2200      	movs	r2, #0
 8018a44:	601a      	str	r2, [r3, #0]
#ifdef WOLFSSL_SP_INT_NEGATIVE
    a->sign = MP_ZPOS;
#endif
}
 8018a46:	bf00      	nop
 8018a48:	370c      	adds	r7, #12
 8018a4a:	46bd      	mov	sp, r7
 8018a4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018a50:	4770      	bx	lr

08018a52 <sp_zero>:
/* Set the multi-precision number to zero.
 *
 * @param  [out]  a  SP integer to set to zero.
 */
void sp_zero(sp_int* a)
{
 8018a52:	b580      	push	{r7, lr}
 8018a54:	b082      	sub	sp, #8
 8018a56:	af00      	add	r7, sp, #0
 8018a58:	6078      	str	r0, [r7, #4]
    if (a != NULL) {
 8018a5a:	687b      	ldr	r3, [r7, #4]
 8018a5c:	2b00      	cmp	r3, #0
 8018a5e:	d002      	beq.n	8018a66 <sp_zero+0x14>
        _sp_zero(a);
 8018a60:	6878      	ldr	r0, [r7, #4]
 8018a62:	f7ff ffe6 	bl	8018a32 <_sp_zero>
    }
}
 8018a66:	bf00      	nop
 8018a68:	3708      	adds	r7, #8
 8018a6a:	46bd      	mov	sp, r7
 8018a6c:	bd80      	pop	{r7, pc}

08018a6e <sp_clear>:
/* Clear the data from the multi-precision number and set to zero.
 *
 * @param  [out]  a  SP integer.
 */
void sp_clear(sp_int* a)
{
 8018a6e:	b480      	push	{r7}
 8018a70:	b085      	sub	sp, #20
 8018a72:	af00      	add	r7, sp, #0
 8018a74:	6078      	str	r0, [r7, #4]
    if (a != NULL) {
 8018a76:	687b      	ldr	r3, [r7, #4]
 8018a78:	2b00      	cmp	r3, #0
 8018a7a:	d013      	beq.n	8018aa4 <sp_clear+0x36>
        int i;

        for (i = 0; i < a->used; i++) {
 8018a7c:	2300      	movs	r3, #0
 8018a7e:	60fb      	str	r3, [r7, #12]
 8018a80:	e008      	b.n	8018a94 <sp_clear+0x26>
            a->dp[i] = 0;
 8018a82:	687b      	ldr	r3, [r7, #4]
 8018a84:	68fa      	ldr	r2, [r7, #12]
 8018a86:	3202      	adds	r2, #2
 8018a88:	2100      	movs	r1, #0
 8018a8a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i = 0; i < a->used; i++) {
 8018a8e:	68fb      	ldr	r3, [r7, #12]
 8018a90:	3301      	adds	r3, #1
 8018a92:	60fb      	str	r3, [r7, #12]
 8018a94:	687b      	ldr	r3, [r7, #4]
 8018a96:	681b      	ldr	r3, [r3, #0]
 8018a98:	68fa      	ldr	r2, [r7, #12]
 8018a9a:	429a      	cmp	r2, r3
 8018a9c:	dbf1      	blt.n	8018a82 <sp_clear+0x14>
        }
        a->used = 0;
 8018a9e:	687b      	ldr	r3, [r7, #4]
 8018aa0:	2200      	movs	r2, #0
 8018aa2:	601a      	str	r2, [r3, #0]
    #ifdef WOLFSSL_SP_INT_NEGATIVE
        a->sign = MP_ZPOS;
    #endif
    }
}
 8018aa4:	bf00      	nop
 8018aa6:	3714      	adds	r7, #20
 8018aa8:	46bd      	mov	sp, r7
 8018aaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018aae:	4770      	bx	lr

08018ab0 <sp_forcezero>:
 * Use when security sensitive data needs to be wiped.
 *
 * @param  [in]  a  SP integer.
 */
void sp_forcezero(sp_int* a)
{
 8018ab0:	b580      	push	{r7, lr}
 8018ab2:	b082      	sub	sp, #8
 8018ab4:	af00      	add	r7, sp, #0
 8018ab6:	6078      	str	r0, [r7, #4]
    ForceZero(a->dp, a->used * sizeof(sp_int_digit));
 8018ab8:	687b      	ldr	r3, [r7, #4]
 8018aba:	f103 0208 	add.w	r2, r3, #8
 8018abe:	687b      	ldr	r3, [r7, #4]
 8018ac0:	681b      	ldr	r3, [r3, #0]
 8018ac2:	009b      	lsls	r3, r3, #2
 8018ac4:	4619      	mov	r1, r3
 8018ac6:	4610      	mov	r0, r2
 8018ac8:	f7ff ff08 	bl	80188dc <ForceZero>
    a->used = 0;
 8018acc:	687b      	ldr	r3, [r7, #4]
 8018ace:	2200      	movs	r2, #0
 8018ad0:	601a      	str	r2, [r3, #0]
    a->sign = MP_ZPOS;
#endif
#ifdef HAVE_WOLF_BIGINT
    wc_bigint_zero(&a->raw);
#endif
}
 8018ad2:	bf00      	nop
 8018ad4:	3708      	adds	r7, #8
 8018ad6:	46bd      	mov	sp, r7
 8018ad8:	bd80      	pop	{r7, pc}

08018ada <_sp_cmp_abs>:
 * @return  MP_GT when a is greater than b.
 * @return  MP_LT when a is less than b.
 * @return  MP_EQ when a is equals b.
 */
static int _sp_cmp_abs(sp_int* a, sp_int* b)
{
 8018ada:	b480      	push	{r7}
 8018adc:	b085      	sub	sp, #20
 8018ade:	af00      	add	r7, sp, #0
 8018ae0:	6078      	str	r0, [r7, #4]
 8018ae2:	6039      	str	r1, [r7, #0]
    int ret = MP_EQ;
 8018ae4:	2300      	movs	r3, #0
 8018ae6:	60fb      	str	r3, [r7, #12]

    if (a->used > b->used) {
 8018ae8:	687b      	ldr	r3, [r7, #4]
 8018aea:	681a      	ldr	r2, [r3, #0]
 8018aec:	683b      	ldr	r3, [r7, #0]
 8018aee:	681b      	ldr	r3, [r3, #0]
 8018af0:	429a      	cmp	r2, r3
 8018af2:	dd02      	ble.n	8018afa <_sp_cmp_abs+0x20>
        ret = MP_GT;
 8018af4:	2301      	movs	r3, #1
 8018af6:	60fb      	str	r3, [r7, #12]
 8018af8:	e033      	b.n	8018b62 <_sp_cmp_abs+0x88>
    }
    else if (a->used < b->used) {
 8018afa:	687b      	ldr	r3, [r7, #4]
 8018afc:	681a      	ldr	r2, [r3, #0]
 8018afe:	683b      	ldr	r3, [r7, #0]
 8018b00:	681b      	ldr	r3, [r3, #0]
 8018b02:	429a      	cmp	r2, r3
 8018b04:	da03      	bge.n	8018b0e <_sp_cmp_abs+0x34>
        ret = MP_LT;
 8018b06:	f04f 33ff 	mov.w	r3, #4294967295
 8018b0a:	60fb      	str	r3, [r7, #12]
 8018b0c:	e029      	b.n	8018b62 <_sp_cmp_abs+0x88>
    }
    else {
        int i;

        for (i = a->used - 1; i >= 0; i--) {
 8018b0e:	687b      	ldr	r3, [r7, #4]
 8018b10:	681b      	ldr	r3, [r3, #0]
 8018b12:	3b01      	subs	r3, #1
 8018b14:	60bb      	str	r3, [r7, #8]
 8018b16:	e021      	b.n	8018b5c <_sp_cmp_abs+0x82>
            if (a->dp[i] > b->dp[i]) {
 8018b18:	687b      	ldr	r3, [r7, #4]
 8018b1a:	68ba      	ldr	r2, [r7, #8]
 8018b1c:	3202      	adds	r2, #2
 8018b1e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8018b22:	683b      	ldr	r3, [r7, #0]
 8018b24:	68b9      	ldr	r1, [r7, #8]
 8018b26:	3102      	adds	r1, #2
 8018b28:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8018b2c:	429a      	cmp	r2, r3
 8018b2e:	d902      	bls.n	8018b36 <_sp_cmp_abs+0x5c>
                ret = MP_GT;
 8018b30:	2301      	movs	r3, #1
 8018b32:	60fb      	str	r3, [r7, #12]
                break;
 8018b34:	e015      	b.n	8018b62 <_sp_cmp_abs+0x88>
            }
            else if (a->dp[i] < b->dp[i]) {
 8018b36:	687b      	ldr	r3, [r7, #4]
 8018b38:	68ba      	ldr	r2, [r7, #8]
 8018b3a:	3202      	adds	r2, #2
 8018b3c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8018b40:	683b      	ldr	r3, [r7, #0]
 8018b42:	68b9      	ldr	r1, [r7, #8]
 8018b44:	3102      	adds	r1, #2
 8018b46:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8018b4a:	429a      	cmp	r2, r3
 8018b4c:	d203      	bcs.n	8018b56 <_sp_cmp_abs+0x7c>
                ret = MP_LT;
 8018b4e:	f04f 33ff 	mov.w	r3, #4294967295
 8018b52:	60fb      	str	r3, [r7, #12]
                break;
 8018b54:	e005      	b.n	8018b62 <_sp_cmp_abs+0x88>
        for (i = a->used - 1; i >= 0; i--) {
 8018b56:	68bb      	ldr	r3, [r7, #8]
 8018b58:	3b01      	subs	r3, #1
 8018b5a:	60bb      	str	r3, [r7, #8]
 8018b5c:	68bb      	ldr	r3, [r7, #8]
 8018b5e:	2b00      	cmp	r3, #0
 8018b60:	dada      	bge.n	8018b18 <_sp_cmp_abs+0x3e>
            }
        }
    }

    return ret;
 8018b62:	68fb      	ldr	r3, [r7, #12]
}
 8018b64:	4618      	mov	r0, r3
 8018b66:	3714      	adds	r7, #20
 8018b68:	46bd      	mov	sp, r7
 8018b6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018b6e:	4770      	bx	lr

08018b70 <_sp_cmp>:
 * @return  MP_GT when a is greater than b.
 * @return  MP_LT when a is less than b.
 * @return  MP_EQ when a is equals b.
 */
static int _sp_cmp(sp_int* a, sp_int* b)
{
 8018b70:	b580      	push	{r7, lr}
 8018b72:	b084      	sub	sp, #16
 8018b74:	af00      	add	r7, sp, #0
 8018b76:	6078      	str	r0, [r7, #4]
 8018b78:	6039      	str	r1, [r7, #0]
    int ret;

#ifdef WOLFSSL_SP_INT_NEGATIVE
    if (a->sign == b->sign) {
#endif
        ret = _sp_cmp_abs(a, b);
 8018b7a:	6839      	ldr	r1, [r7, #0]
 8018b7c:	6878      	ldr	r0, [r7, #4]
 8018b7e:	f7ff ffac 	bl	8018ada <_sp_cmp_abs>
 8018b82:	60f8      	str	r0, [r7, #12]
    else /* (a->sign < b->sign) */ {
        ret = MP_GT;
    }
#endif

    return ret;
 8018b84:	68fb      	ldr	r3, [r7, #12]
}
 8018b86:	4618      	mov	r0, r3
 8018b88:	3710      	adds	r7, #16
 8018b8a:	46bd      	mov	sp, r7
 8018b8c:	bd80      	pop	{r7, pc}

08018b8e <sp_cmp>:
 * @return  MP_GT when a is greater than b.
 * @return  MP_LT when a is less than b.
 * @return  MP_EQ when a is equals b.
 */
int sp_cmp(sp_int* a, sp_int* b)
{
 8018b8e:	b580      	push	{r7, lr}
 8018b90:	b084      	sub	sp, #16
 8018b92:	af00      	add	r7, sp, #0
 8018b94:	6078      	str	r0, [r7, #4]
 8018b96:	6039      	str	r1, [r7, #0]
    int ret;

    if (a == b) {
 8018b98:	687a      	ldr	r2, [r7, #4]
 8018b9a:	683b      	ldr	r3, [r7, #0]
 8018b9c:	429a      	cmp	r2, r3
 8018b9e:	d102      	bne.n	8018ba6 <sp_cmp+0x18>
        ret = MP_EQ;
 8018ba0:	2300      	movs	r3, #0
 8018ba2:	60fb      	str	r3, [r7, #12]
 8018ba4:	e011      	b.n	8018bca <sp_cmp+0x3c>
    }
    else if (a == NULL) {
 8018ba6:	687b      	ldr	r3, [r7, #4]
 8018ba8:	2b00      	cmp	r3, #0
 8018baa:	d103      	bne.n	8018bb4 <sp_cmp+0x26>
        ret = MP_LT;
 8018bac:	f04f 33ff 	mov.w	r3, #4294967295
 8018bb0:	60fb      	str	r3, [r7, #12]
 8018bb2:	e00a      	b.n	8018bca <sp_cmp+0x3c>
    }
    else if (b == NULL) {
 8018bb4:	683b      	ldr	r3, [r7, #0]
 8018bb6:	2b00      	cmp	r3, #0
 8018bb8:	d102      	bne.n	8018bc0 <sp_cmp+0x32>
        ret = MP_GT;
 8018bba:	2301      	movs	r3, #1
 8018bbc:	60fb      	str	r3, [r7, #12]
 8018bbe:	e004      	b.n	8018bca <sp_cmp+0x3c>
    }
    else
    {
        ret = _sp_cmp(a, b);
 8018bc0:	6839      	ldr	r1, [r7, #0]
 8018bc2:	6878      	ldr	r0, [r7, #4]
 8018bc4:	f7ff ffd4 	bl	8018b70 <_sp_cmp>
 8018bc8:	60f8      	str	r0, [r7, #12]
    }

    return ret;
 8018bca:	68fb      	ldr	r3, [r7, #12]
}
 8018bcc:	4618      	mov	r0, r3
 8018bce:	3710      	adds	r7, #16
 8018bd0:	46bd      	mov	sp, r7
 8018bd2:	bd80      	pop	{r7, pc}

08018bd4 <sp_count_bits>:
 * @param  [in]  a  SP integer.
 *
 * @return  The number of bits in the number.
 */
int sp_count_bits(sp_int* a)
{
 8018bd4:	b480      	push	{r7}
 8018bd6:	b085      	sub	sp, #20
 8018bd8:	af00      	add	r7, sp, #0
 8018bda:	6078      	str	r0, [r7, #4]
    int r = 0;
 8018bdc:	2300      	movs	r3, #0
 8018bde:	60fb      	str	r3, [r7, #12]

    if (a != NULL) {
 8018be0:	687b      	ldr	r3, [r7, #4]
 8018be2:	2b00      	cmp	r3, #0
 8018be4:	d03b      	beq.n	8018c5e <sp_count_bits+0x8a>
        r = a->used - 1;
 8018be6:	687b      	ldr	r3, [r7, #4]
 8018be8:	681b      	ldr	r3, [r3, #0]
 8018bea:	3b01      	subs	r3, #1
 8018bec:	60fb      	str	r3, [r7, #12]
        while ((r >= 0) && (a->dp[r] == 0)) {
 8018bee:	e002      	b.n	8018bf6 <sp_count_bits+0x22>
            r--;
 8018bf0:	68fb      	ldr	r3, [r7, #12]
 8018bf2:	3b01      	subs	r3, #1
 8018bf4:	60fb      	str	r3, [r7, #12]
        while ((r >= 0) && (a->dp[r] == 0)) {
 8018bf6:	68fb      	ldr	r3, [r7, #12]
 8018bf8:	2b00      	cmp	r3, #0
 8018bfa:	db06      	blt.n	8018c0a <sp_count_bits+0x36>
 8018bfc:	687b      	ldr	r3, [r7, #4]
 8018bfe:	68fa      	ldr	r2, [r7, #12]
 8018c00:	3202      	adds	r2, #2
 8018c02:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8018c06:	2b00      	cmp	r3, #0
 8018c08:	d0f2      	beq.n	8018bf0 <sp_count_bits+0x1c>
        }
        if (r < 0) {
 8018c0a:	68fb      	ldr	r3, [r7, #12]
 8018c0c:	2b00      	cmp	r3, #0
 8018c0e:	da02      	bge.n	8018c16 <sp_count_bits+0x42>
            r = 0;
 8018c10:	2300      	movs	r3, #0
 8018c12:	60fb      	str	r3, [r7, #12]
 8018c14:	e023      	b.n	8018c5e <sp_count_bits+0x8a>
        }
        else {
            sp_int_digit d;

            d = a->dp[r];
 8018c16:	687b      	ldr	r3, [r7, #4]
 8018c18:	68fa      	ldr	r2, [r7, #12]
 8018c1a:	3202      	adds	r2, #2
 8018c1c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8018c20:	60bb      	str	r3, [r7, #8]
            r *= SP_WORD_SIZE;
 8018c22:	68fb      	ldr	r3, [r7, #12]
 8018c24:	015b      	lsls	r3, r3, #5
 8018c26:	60fb      	str	r3, [r7, #12]
            if (d > SP_HALF_MAX) {
 8018c28:	68bb      	ldr	r3, [r7, #8]
 8018c2a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8018c2e:	d313      	bcc.n	8018c58 <sp_count_bits+0x84>
                r += SP_WORD_SIZE;
 8018c30:	68fb      	ldr	r3, [r7, #12]
 8018c32:	3320      	adds	r3, #32
 8018c34:	60fb      	str	r3, [r7, #12]
                while ((d & (1UL << (SP_WORD_SIZE - 1))) == 0) {
 8018c36:	e005      	b.n	8018c44 <sp_count_bits+0x70>
                    r--;
 8018c38:	68fb      	ldr	r3, [r7, #12]
 8018c3a:	3b01      	subs	r3, #1
 8018c3c:	60fb      	str	r3, [r7, #12]
                    d <<= 1;
 8018c3e:	68bb      	ldr	r3, [r7, #8]
 8018c40:	005b      	lsls	r3, r3, #1
 8018c42:	60bb      	str	r3, [r7, #8]
                while ((d & (1UL << (SP_WORD_SIZE - 1))) == 0) {
 8018c44:	68bb      	ldr	r3, [r7, #8]
 8018c46:	2b00      	cmp	r3, #0
 8018c48:	daf6      	bge.n	8018c38 <sp_count_bits+0x64>
 8018c4a:	e008      	b.n	8018c5e <sp_count_bits+0x8a>
                }
            }
            else {
                while (d != 0) {
                    r++;
 8018c4c:	68fb      	ldr	r3, [r7, #12]
 8018c4e:	3301      	adds	r3, #1
 8018c50:	60fb      	str	r3, [r7, #12]
                    d >>= 1;
 8018c52:	68bb      	ldr	r3, [r7, #8]
 8018c54:	085b      	lsrs	r3, r3, #1
 8018c56:	60bb      	str	r3, [r7, #8]
                while (d != 0) {
 8018c58:	68bb      	ldr	r3, [r7, #8]
 8018c5a:	2b00      	cmp	r3, #0
 8018c5c:	d1f6      	bne.n	8018c4c <sp_count_bits+0x78>
                }
            }
        }
    }

    return r;
 8018c5e:	68fb      	ldr	r3, [r7, #12]
}
 8018c60:	4618      	mov	r0, r3
 8018c62:	3714      	adds	r7, #20
 8018c64:	46bd      	mov	sp, r7
 8018c66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018c6a:	4770      	bx	lr

08018c6c <sp_set>:
 *
 * @return  MP_OKAY on success.
 * @return  MP_VAL when a is NULL.
 */
int sp_set(sp_int* a, sp_int_digit d)
{
 8018c6c:	b480      	push	{r7}
 8018c6e:	b085      	sub	sp, #20
 8018c70:	af00      	add	r7, sp, #0
 8018c72:	6078      	str	r0, [r7, #4]
 8018c74:	6039      	str	r1, [r7, #0]
    int err = MP_OKAY;
 8018c76:	2300      	movs	r3, #0
 8018c78:	60fb      	str	r3, [r7, #12]

    if (a == NULL) {
 8018c7a:	687b      	ldr	r3, [r7, #4]
 8018c7c:	2b00      	cmp	r3, #0
 8018c7e:	d102      	bne.n	8018c86 <sp_set+0x1a>
        err = MP_VAL;
 8018c80:	f06f 0302 	mvn.w	r3, #2
 8018c84:	60fb      	str	r3, [r7, #12]
    }
    if (err == MP_OKAY) {
 8018c86:	68fb      	ldr	r3, [r7, #12]
 8018c88:	2b00      	cmp	r3, #0
 8018c8a:	d10b      	bne.n	8018ca4 <sp_set+0x38>
        a->dp[0] = d;
 8018c8c:	687b      	ldr	r3, [r7, #4]
 8018c8e:	683a      	ldr	r2, [r7, #0]
 8018c90:	609a      	str	r2, [r3, #8]
        a->used = d > 0;
 8018c92:	683b      	ldr	r3, [r7, #0]
 8018c94:	2b00      	cmp	r3, #0
 8018c96:	bf14      	ite	ne
 8018c98:	2301      	movne	r3, #1
 8018c9a:	2300      	moveq	r3, #0
 8018c9c:	b2db      	uxtb	r3, r3
 8018c9e:	461a      	mov	r2, r3
 8018ca0:	687b      	ldr	r3, [r7, #4]
 8018ca2:	601a      	str	r2, [r3, #0]
    #ifdef WOLFSSL_SP_INT_NEGATIVE
        a->sign = MP_ZPOS;
    #endif
    }

    return err;
 8018ca4:	68fb      	ldr	r3, [r7, #12]
}
 8018ca6:	4618      	mov	r0, r3
 8018ca8:	3714      	adds	r7, #20
 8018caa:	46bd      	mov	sp, r7
 8018cac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018cb0:	4770      	bx	lr

08018cb2 <sp_cmp_d>:
 * @return  MP_GT when a is greater than d.
 * @return  MP_LT when a is less than d.
 * @return  MP_EQ when a is equals d.
 */
int sp_cmp_d(sp_int* a, sp_int_digit d)
{
 8018cb2:	b480      	push	{r7}
 8018cb4:	b085      	sub	sp, #20
 8018cb6:	af00      	add	r7, sp, #0
 8018cb8:	6078      	str	r0, [r7, #4]
 8018cba:	6039      	str	r1, [r7, #0]
    int ret = MP_EQ;
 8018cbc:	2300      	movs	r3, #0
 8018cbe:	60fb      	str	r3, [r7, #12]

    if (a == NULL) {
 8018cc0:	687b      	ldr	r3, [r7, #4]
 8018cc2:	2b00      	cmp	r3, #0
 8018cc4:	d103      	bne.n	8018cce <sp_cmp_d+0x1c>
        ret = MP_LT;
 8018cc6:	f04f 33ff 	mov.w	r3, #4294967295
 8018cca:	60fb      	str	r3, [r7, #12]
 8018ccc:	e024      	b.n	8018d18 <sp_cmp_d+0x66>
    }
    else
#endif
    {
        /* special case for zero*/
        if (a->used == 0) {
 8018cce:	687b      	ldr	r3, [r7, #4]
 8018cd0:	681b      	ldr	r3, [r3, #0]
 8018cd2:	2b00      	cmp	r3, #0
 8018cd4:	d109      	bne.n	8018cea <sp_cmp_d+0x38>
            if (d == 0) {
 8018cd6:	683b      	ldr	r3, [r7, #0]
 8018cd8:	2b00      	cmp	r3, #0
 8018cda:	d102      	bne.n	8018ce2 <sp_cmp_d+0x30>
                ret = MP_EQ;
 8018cdc:	2300      	movs	r3, #0
 8018cde:	60fb      	str	r3, [r7, #12]
 8018ce0:	e01a      	b.n	8018d18 <sp_cmp_d+0x66>
            }
            else {
                ret = MP_LT;
 8018ce2:	f04f 33ff 	mov.w	r3, #4294967295
 8018ce6:	60fb      	str	r3, [r7, #12]
 8018ce8:	e016      	b.n	8018d18 <sp_cmp_d+0x66>
            }
        }
        else if (a->used > 1) {
 8018cea:	687b      	ldr	r3, [r7, #4]
 8018cec:	681b      	ldr	r3, [r3, #0]
 8018cee:	2b01      	cmp	r3, #1
 8018cf0:	dd02      	ble.n	8018cf8 <sp_cmp_d+0x46>
            ret = MP_GT;
 8018cf2:	2301      	movs	r3, #1
 8018cf4:	60fb      	str	r3, [r7, #12]
 8018cf6:	e00f      	b.n	8018d18 <sp_cmp_d+0x66>
        }
        else {
            if (a->dp[0] > d) {
 8018cf8:	687b      	ldr	r3, [r7, #4]
 8018cfa:	689b      	ldr	r3, [r3, #8]
 8018cfc:	683a      	ldr	r2, [r7, #0]
 8018cfe:	429a      	cmp	r2, r3
 8018d00:	d202      	bcs.n	8018d08 <sp_cmp_d+0x56>
                ret = MP_GT;
 8018d02:	2301      	movs	r3, #1
 8018d04:	60fb      	str	r3, [r7, #12]
 8018d06:	e007      	b.n	8018d18 <sp_cmp_d+0x66>
            }
            else if (a->dp[0] < d) {
 8018d08:	687b      	ldr	r3, [r7, #4]
 8018d0a:	689b      	ldr	r3, [r3, #8]
 8018d0c:	683a      	ldr	r2, [r7, #0]
 8018d0e:	429a      	cmp	r2, r3
 8018d10:	d902      	bls.n	8018d18 <sp_cmp_d+0x66>
                ret = MP_LT;
 8018d12:	f04f 33ff 	mov.w	r3, #4294967295
 8018d16:	60fb      	str	r3, [r7, #12]
            }
        }
    }

    return ret;
 8018d18:	68fb      	ldr	r3, [r7, #12]
}
 8018d1a:	4618      	mov	r0, r3
 8018d1c:	3714      	adds	r7, #20
 8018d1e:	46bd      	mov	sp, r7
 8018d20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018d24:	4770      	bx	lr

08018d26 <_sp_add_d>:
 *
 * @returnn  MP_OKAY on success.
 * @returnn  MP_VAL when result is too large for fixed size dp array.
 */
static int _sp_add_d(sp_int* a, sp_int_digit d, sp_int* r)
{
 8018d26:	b480      	push	{r7}
 8018d28:	b089      	sub	sp, #36	; 0x24
 8018d2a:	af00      	add	r7, sp, #0
 8018d2c:	60f8      	str	r0, [r7, #12]
 8018d2e:	60b9      	str	r1, [r7, #8]
 8018d30:	607a      	str	r2, [r7, #4]
    int err = MP_OKAY;
 8018d32:	2300      	movs	r3, #0
 8018d34:	61fb      	str	r3, [r7, #28]
    int i = 0;
 8018d36:	2300      	movs	r3, #0
 8018d38:	61bb      	str	r3, [r7, #24]
    sp_int_digit t;

    r->used = a->used;
 8018d3a:	68fb      	ldr	r3, [r7, #12]
 8018d3c:	681a      	ldr	r2, [r3, #0]
 8018d3e:	687b      	ldr	r3, [r7, #4]
 8018d40:	601a      	str	r2, [r3, #0]
    if (a->used == 0) {
 8018d42:	68fb      	ldr	r3, [r7, #12]
 8018d44:	681b      	ldr	r3, [r3, #0]
 8018d46:	2b00      	cmp	r3, #0
 8018d48:	d108      	bne.n	8018d5c <_sp_add_d+0x36>
        r->used = d > 0;
 8018d4a:	68bb      	ldr	r3, [r7, #8]
 8018d4c:	2b00      	cmp	r3, #0
 8018d4e:	bf14      	ite	ne
 8018d50:	2301      	movne	r3, #1
 8018d52:	2300      	moveq	r3, #0
 8018d54:	b2db      	uxtb	r3, r3
 8018d56:	461a      	mov	r2, r3
 8018d58:	687b      	ldr	r3, [r7, #4]
 8018d5a:	601a      	str	r2, [r3, #0]
    }
    t = a->dp[0] + d;
 8018d5c:	68fb      	ldr	r3, [r7, #12]
 8018d5e:	689b      	ldr	r3, [r3, #8]
 8018d60:	68ba      	ldr	r2, [r7, #8]
 8018d62:	4413      	add	r3, r2
 8018d64:	617b      	str	r3, [r7, #20]
    if (t < a->dp[0]) {
 8018d66:	68fb      	ldr	r3, [r7, #12]
 8018d68:	689b      	ldr	r3, [r3, #8]
 8018d6a:	697a      	ldr	r2, [r7, #20]
 8018d6c:	429a      	cmp	r2, r3
 8018d6e:	d238      	bcs.n	8018de2 <_sp_add_d+0xbc>
        for (++i; i < a->used; i++) {
 8018d70:	69bb      	ldr	r3, [r7, #24]
 8018d72:	3301      	adds	r3, #1
 8018d74:	61bb      	str	r3, [r7, #24]
 8018d76:	e014      	b.n	8018da2 <_sp_add_d+0x7c>
            r->dp[i] = a->dp[i] + 1;
 8018d78:	68fb      	ldr	r3, [r7, #12]
 8018d7a:	69ba      	ldr	r2, [r7, #24]
 8018d7c:	3202      	adds	r2, #2
 8018d7e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8018d82:	1c59      	adds	r1, r3, #1
 8018d84:	687b      	ldr	r3, [r7, #4]
 8018d86:	69ba      	ldr	r2, [r7, #24]
 8018d88:	3202      	adds	r2, #2
 8018d8a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            if (r->dp[i] != 0) {
 8018d8e:	687b      	ldr	r3, [r7, #4]
 8018d90:	69ba      	ldr	r2, [r7, #24]
 8018d92:	3202      	adds	r2, #2
 8018d94:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8018d98:	2b00      	cmp	r3, #0
 8018d9a:	d108      	bne.n	8018dae <_sp_add_d+0x88>
        for (++i; i < a->used; i++) {
 8018d9c:	69bb      	ldr	r3, [r7, #24]
 8018d9e:	3301      	adds	r3, #1
 8018da0:	61bb      	str	r3, [r7, #24]
 8018da2:	68fb      	ldr	r3, [r7, #12]
 8018da4:	681b      	ldr	r3, [r3, #0]
 8018da6:	69ba      	ldr	r2, [r7, #24]
 8018da8:	429a      	cmp	r2, r3
 8018daa:	dbe5      	blt.n	8018d78 <_sp_add_d+0x52>
 8018dac:	e000      	b.n	8018db0 <_sp_add_d+0x8a>
               break;
 8018dae:	bf00      	nop
            }
        }
        if (i == a->used) {
 8018db0:	68fb      	ldr	r3, [r7, #12]
 8018db2:	681b      	ldr	r3, [r3, #0]
 8018db4:	69ba      	ldr	r2, [r7, #24]
 8018db6:	429a      	cmp	r2, r3
 8018db8:	d113      	bne.n	8018de2 <_sp_add_d+0xbc>
            r->used++;
 8018dba:	687b      	ldr	r3, [r7, #4]
 8018dbc:	681b      	ldr	r3, [r3, #0]
 8018dbe:	1c5a      	adds	r2, r3, #1
 8018dc0:	687b      	ldr	r3, [r7, #4]
 8018dc2:	601a      	str	r2, [r3, #0]
            if (i < r->size)
 8018dc4:	687b      	ldr	r3, [r7, #4]
 8018dc6:	685b      	ldr	r3, [r3, #4]
 8018dc8:	69ba      	ldr	r2, [r7, #24]
 8018dca:	429a      	cmp	r2, r3
 8018dcc:	da06      	bge.n	8018ddc <_sp_add_d+0xb6>
                r->dp[i] = 1;
 8018dce:	687b      	ldr	r3, [r7, #4]
 8018dd0:	69ba      	ldr	r2, [r7, #24]
 8018dd2:	3202      	adds	r2, #2
 8018dd4:	2101      	movs	r1, #1
 8018dd6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8018dda:	e002      	b.n	8018de2 <_sp_add_d+0xbc>
            else
                err = MP_VAL;
 8018ddc:	f06f 0302 	mvn.w	r3, #2
 8018de0:	61fb      	str	r3, [r7, #28]
        }
    }
    if (err == MP_OKAY) {
 8018de2:	69fb      	ldr	r3, [r7, #28]
 8018de4:	2b00      	cmp	r3, #0
 8018de6:	d11c      	bne.n	8018e22 <_sp_add_d+0xfc>
        r->dp[0] = t;
 8018de8:	687b      	ldr	r3, [r7, #4]
 8018dea:	697a      	ldr	r2, [r7, #20]
 8018dec:	609a      	str	r2, [r3, #8]
        if (r != a) {
 8018dee:	687a      	ldr	r2, [r7, #4]
 8018df0:	68fb      	ldr	r3, [r7, #12]
 8018df2:	429a      	cmp	r2, r3
 8018df4:	d015      	beq.n	8018e22 <_sp_add_d+0xfc>
            for (++i; i < a->used; i++) {
 8018df6:	69bb      	ldr	r3, [r7, #24]
 8018df8:	3301      	adds	r3, #1
 8018dfa:	61bb      	str	r3, [r7, #24]
 8018dfc:	e00c      	b.n	8018e18 <_sp_add_d+0xf2>
                r->dp[i] = a->dp[i];
 8018dfe:	68fb      	ldr	r3, [r7, #12]
 8018e00:	69ba      	ldr	r2, [r7, #24]
 8018e02:	3202      	adds	r2, #2
 8018e04:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8018e08:	687b      	ldr	r3, [r7, #4]
 8018e0a:	69ba      	ldr	r2, [r7, #24]
 8018e0c:	3202      	adds	r2, #2
 8018e0e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            for (++i; i < a->used; i++) {
 8018e12:	69bb      	ldr	r3, [r7, #24]
 8018e14:	3301      	adds	r3, #1
 8018e16:	61bb      	str	r3, [r7, #24]
 8018e18:	68fb      	ldr	r3, [r7, #12]
 8018e1a:	681b      	ldr	r3, [r3, #0]
 8018e1c:	69ba      	ldr	r2, [r7, #24]
 8018e1e:	429a      	cmp	r2, r3
 8018e20:	dbed      	blt.n	8018dfe <_sp_add_d+0xd8>
            }
        }
    }

    return err;
 8018e22:	69fb      	ldr	r3, [r7, #28]
}
 8018e24:	4618      	mov	r0, r3
 8018e26:	3724      	adds	r7, #36	; 0x24
 8018e28:	46bd      	mov	sp, r7
 8018e2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018e2e:	4770      	bx	lr

08018e30 <sp_add_d>:
 *
 * @returnn  MP_OKAY on success.
 * @returnn  MP_VAL when result is too large for fixed size dp array.
 */
int sp_add_d(sp_int* a, sp_int_digit d, sp_int* r)
{
 8018e30:	b580      	push	{r7, lr}
 8018e32:	b086      	sub	sp, #24
 8018e34:	af00      	add	r7, sp, #0
 8018e36:	60f8      	str	r0, [r7, #12]
 8018e38:	60b9      	str	r1, [r7, #8]
 8018e3a:	607a      	str	r2, [r7, #4]
    int err = MP_OKAY;
 8018e3c:	2300      	movs	r3, #0
 8018e3e:	617b      	str	r3, [r7, #20]

    if ((a == NULL) || (r == NULL)) {
 8018e40:	68fb      	ldr	r3, [r7, #12]
 8018e42:	2b00      	cmp	r3, #0
 8018e44:	d002      	beq.n	8018e4c <sp_add_d+0x1c>
 8018e46:	687b      	ldr	r3, [r7, #4]
 8018e48:	2b00      	cmp	r3, #0
 8018e4a:	d103      	bne.n	8018e54 <sp_add_d+0x24>
        err = MP_VAL;
 8018e4c:	f06f 0302 	mvn.w	r3, #2
 8018e50:	617b      	str	r3, [r7, #20]
 8018e52:	e005      	b.n	8018e60 <sp_add_d+0x30>
    }
    else
    {
    #ifndef WOLFSSL_SP_INT_NEGATIVE
        err = _sp_add_d(a, d, r);
 8018e54:	687a      	ldr	r2, [r7, #4]
 8018e56:	68b9      	ldr	r1, [r7, #8]
 8018e58:	68f8      	ldr	r0, [r7, #12]
 8018e5a:	f7ff ff64 	bl	8018d26 <_sp_add_d>
 8018e5e:	6178      	str	r0, [r7, #20]
            r->dp[0] = d - a->dp[0];
        }
    #endif
    }

    return err;
 8018e60:	697b      	ldr	r3, [r7, #20]
}
 8018e62:	4618      	mov	r0, r3
 8018e64:	3718      	adds	r7, #24
 8018e66:	46bd      	mov	sp, r7
 8018e68:	bd80      	pop	{r7, pc}

08018e6a <sp_unsigned_bin_size>:
 * @param  [in]  a  SP integer.
 *
 * @return  The count of 8-bit values.
 */
int sp_unsigned_bin_size(sp_int* a)
{
 8018e6a:	b580      	push	{r7, lr}
 8018e6c:	b084      	sub	sp, #16
 8018e6e:	af00      	add	r7, sp, #0
 8018e70:	6078      	str	r0, [r7, #4]
    int cnt = 0;
 8018e72:	2300      	movs	r3, #0
 8018e74:	60fb      	str	r3, [r7, #12]

    if (a != NULL) {
 8018e76:	687b      	ldr	r3, [r7, #4]
 8018e78:	2b00      	cmp	r3, #0
 8018e7a:	d009      	beq.n	8018e90 <sp_unsigned_bin_size+0x26>
        cnt = (sp_count_bits(a) + 7) / 8;
 8018e7c:	6878      	ldr	r0, [r7, #4]
 8018e7e:	f7ff fea9 	bl	8018bd4 <sp_count_bits>
 8018e82:	4603      	mov	r3, r0
 8018e84:	3307      	adds	r3, #7
 8018e86:	2b00      	cmp	r3, #0
 8018e88:	da00      	bge.n	8018e8c <sp_unsigned_bin_size+0x22>
 8018e8a:	3307      	adds	r3, #7
 8018e8c:	10db      	asrs	r3, r3, #3
 8018e8e:	60fb      	str	r3, [r7, #12]
    }

    return cnt;
 8018e90:	68fb      	ldr	r3, [r7, #12]
}
 8018e92:	4618      	mov	r0, r3
 8018e94:	3710      	adds	r7, #16
 8018e96:	46bd      	mov	sp, r7
 8018e98:	bd80      	pop	{r7, pc}
	...

08018e9c <sp_read_unsigned_bin>:
 *
 * @return  MP_OKAY on success.
 * @return  MP_VAL when the number is too big to fit in an SP.
 */
int sp_read_unsigned_bin(sp_int* a, const byte* in, word32 inSz)
{
 8018e9c:	b480      	push	{r7}
 8018e9e:	b08b      	sub	sp, #44	; 0x2c
 8018ea0:	af00      	add	r7, sp, #0
 8018ea2:	60f8      	str	r0, [r7, #12]
 8018ea4:	60b9      	str	r1, [r7, #8]
 8018ea6:	607a      	str	r2, [r7, #4]
    int err = MP_OKAY;
 8018ea8:	2300      	movs	r3, #0
 8018eaa:	627b      	str	r3, [r7, #36]	; 0x24

    if ((a == NULL) || ((in == NULL) && (inSz > 0))) {
 8018eac:	68fb      	ldr	r3, [r7, #12]
 8018eae:	2b00      	cmp	r3, #0
 8018eb0:	d005      	beq.n	8018ebe <sp_read_unsigned_bin+0x22>
 8018eb2:	68bb      	ldr	r3, [r7, #8]
 8018eb4:	2b00      	cmp	r3, #0
 8018eb6:	d105      	bne.n	8018ec4 <sp_read_unsigned_bin+0x28>
 8018eb8:	687b      	ldr	r3, [r7, #4]
 8018eba:	2b00      	cmp	r3, #0
 8018ebc:	d002      	beq.n	8018ec4 <sp_read_unsigned_bin+0x28>
        err = MP_VAL;
 8018ebe:	f06f 0302 	mvn.w	r3, #2
 8018ec2:	627b      	str	r3, [r7, #36]	; 0x24
    }

    /* Extra digit added to SP_INT_DIGITS to be used in calculations. */
    if ((err == MP_OKAY) && (inSz > ((word32)a->size - 1) * SP_WORD_SIZEOF)) {
 8018ec4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018ec6:	2b00      	cmp	r3, #0
 8018ec8:	d10b      	bne.n	8018ee2 <sp_read_unsigned_bin+0x46>
 8018eca:	68fb      	ldr	r3, [r7, #12]
 8018ecc:	685b      	ldr	r3, [r3, #4]
 8018ece:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8018ed2:	3b01      	subs	r3, #1
 8018ed4:	009b      	lsls	r3, r3, #2
 8018ed6:	687a      	ldr	r2, [r7, #4]
 8018ed8:	429a      	cmp	r2, r3
 8018eda:	d902      	bls.n	8018ee2 <sp_read_unsigned_bin+0x46>
        err = MP_VAL;
 8018edc:	f06f 0302 	mvn.w	r3, #2
 8018ee0:	627b      	str	r3, [r7, #36]	; 0x24
        }
        a->used = j + 1;
        sp_clamp(a);
    }
#else
    if (err == MP_OKAY) {
 8018ee2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018ee4:	2b00      	cmp	r3, #0
 8018ee6:	f040 80ba 	bne.w	801905e <sp_read_unsigned_bin+0x1c2>
        int i;
        int j;

        a->used = (inSz + SP_WORD_SIZEOF - 1) / SP_WORD_SIZEOF;
 8018eea:	687b      	ldr	r3, [r7, #4]
 8018eec:	3303      	adds	r3, #3
 8018eee:	089b      	lsrs	r3, r3, #2
 8018ef0:	461a      	mov	r2, r3
 8018ef2:	68fb      	ldr	r3, [r7, #12]
 8018ef4:	601a      	str	r2, [r3, #0]

        for (i = inSz-1, j = 0; i >= SP_WORD_SIZEOF - 1; i -= SP_WORD_SIZEOF) {
 8018ef6:	687b      	ldr	r3, [r7, #4]
 8018ef8:	3b01      	subs	r3, #1
 8018efa:	623b      	str	r3, [r7, #32]
 8018efc:	2300      	movs	r3, #0
 8018efe:	61fb      	str	r3, [r7, #28]
 8018f00:	e03a      	b.n	8018f78 <sp_read_unsigned_bin+0xdc>
            a->dp[j]  = ((sp_int_digit)in[i - 0] <<  0);
 8018f02:	6a3b      	ldr	r3, [r7, #32]
 8018f04:	68ba      	ldr	r2, [r7, #8]
 8018f06:	4413      	add	r3, r2
 8018f08:	781b      	ldrb	r3, [r3, #0]
 8018f0a:	4619      	mov	r1, r3
 8018f0c:	68fb      	ldr	r3, [r7, #12]
 8018f0e:	69fa      	ldr	r2, [r7, #28]
 8018f10:	3202      	adds	r2, #2
 8018f12:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        #if SP_WORD_SIZE >= 16
            a->dp[j] |= ((sp_int_digit)in[i - 1] <<  8);
 8018f16:	68fb      	ldr	r3, [r7, #12]
 8018f18:	69fa      	ldr	r2, [r7, #28]
 8018f1a:	3202      	adds	r2, #2
 8018f1c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8018f20:	6a3b      	ldr	r3, [r7, #32]
 8018f22:	3b01      	subs	r3, #1
 8018f24:	68b9      	ldr	r1, [r7, #8]
 8018f26:	440b      	add	r3, r1
 8018f28:	781b      	ldrb	r3, [r3, #0]
 8018f2a:	021b      	lsls	r3, r3, #8
 8018f2c:	ea42 0103 	orr.w	r1, r2, r3
 8018f30:	68fb      	ldr	r3, [r7, #12]
 8018f32:	69fa      	ldr	r2, [r7, #28]
 8018f34:	3202      	adds	r2, #2
 8018f36:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        #endif
        #if SP_WORD_SIZE >= 32
            a->dp[j] |= ((sp_int_digit)in[i - 2] << 16) |
 8018f3a:	68fb      	ldr	r3, [r7, #12]
 8018f3c:	69fa      	ldr	r2, [r7, #28]
 8018f3e:	3202      	adds	r2, #2
 8018f40:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8018f44:	6a3b      	ldr	r3, [r7, #32]
 8018f46:	3b02      	subs	r3, #2
 8018f48:	68b9      	ldr	r1, [r7, #8]
 8018f4a:	440b      	add	r3, r1
 8018f4c:	781b      	ldrb	r3, [r3, #0]
 8018f4e:	0419      	lsls	r1, r3, #16
                        ((sp_int_digit)in[i - 3] << 24);
 8018f50:	6a3b      	ldr	r3, [r7, #32]
 8018f52:	3b03      	subs	r3, #3
 8018f54:	68b8      	ldr	r0, [r7, #8]
 8018f56:	4403      	add	r3, r0
 8018f58:	781b      	ldrb	r3, [r3, #0]
 8018f5a:	061b      	lsls	r3, r3, #24
            a->dp[j] |= ((sp_int_digit)in[i - 2] << 16) |
 8018f5c:	430b      	orrs	r3, r1
 8018f5e:	ea42 0103 	orr.w	r1, r2, r3
 8018f62:	68fb      	ldr	r3, [r7, #12]
 8018f64:	69fa      	ldr	r2, [r7, #28]
 8018f66:	3202      	adds	r2, #2
 8018f68:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            a->dp[j] |= ((sp_int_digit)in[i - 4] << 32) |
                        ((sp_int_digit)in[i - 5] << 40) |
                        ((sp_int_digit)in[i - 6] << 48) |
                        ((sp_int_digit)in[i - 7] << 56);
        #endif
            j++;
 8018f6c:	69fb      	ldr	r3, [r7, #28]
 8018f6e:	3301      	adds	r3, #1
 8018f70:	61fb      	str	r3, [r7, #28]
        for (i = inSz-1, j = 0; i >= SP_WORD_SIZEOF - 1; i -= SP_WORD_SIZEOF) {
 8018f72:	6a3b      	ldr	r3, [r7, #32]
 8018f74:	3b04      	subs	r3, #4
 8018f76:	623b      	str	r3, [r7, #32]
 8018f78:	6a3b      	ldr	r3, [r7, #32]
 8018f7a:	2b02      	cmp	r3, #2
 8018f7c:	dcc1      	bgt.n	8018f02 <sp_read_unsigned_bin+0x66>
        }
        a->dp[j] = 0;
 8018f7e:	68fb      	ldr	r3, [r7, #12]
 8018f80:	69fa      	ldr	r2, [r7, #28]
 8018f82:	3202      	adds	r2, #2
 8018f84:	2100      	movs	r1, #0
 8018f86:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

    #if SP_WORD_SIZE >= 16
        if (i >= 0) {
 8018f8a:	6a3b      	ldr	r3, [r7, #32]
 8018f8c:	2b00      	cmp	r3, #0
 8018f8e:	db50      	blt.n	8019032 <sp_read_unsigned_bin+0x196>
            byte *d = (byte*)a->dp;
 8018f90:	68fb      	ldr	r3, [r7, #12]
 8018f92:	3308      	adds	r3, #8
 8018f94:	617b      	str	r3, [r7, #20]

            a->dp[a->used - 1] = 0;
 8018f96:	68fb      	ldr	r3, [r7, #12]
 8018f98:	681b      	ldr	r3, [r3, #0]
 8018f9a:	1e5a      	subs	r2, r3, #1
 8018f9c:	68fb      	ldr	r3, [r7, #12]
 8018f9e:	3202      	adds	r2, #2
 8018fa0:	2100      	movs	r1, #0
 8018fa2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            switch (i) {
 8018fa6:	6a3b      	ldr	r3, [r7, #32]
 8018fa8:	2b06      	cmp	r3, #6
 8018faa:	d842      	bhi.n	8019032 <sp_read_unsigned_bin+0x196>
 8018fac:	a201      	add	r2, pc, #4	; (adr r2, 8018fb4 <sp_read_unsigned_bin+0x118>)
 8018fae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8018fb2:	bf00      	nop
 8018fb4:	08019025 	.word	0x08019025
 8018fb8:	08019017 	.word	0x08019017
 8018fbc:	08019009 	.word	0x08019009
 8018fc0:	08018ffb 	.word	0x08018ffb
 8018fc4:	08018fed 	.word	0x08018fed
 8018fc8:	08018fdf 	.word	0x08018fdf
 8018fcc:	08018fd1 	.word	0x08018fd1
                case 6: d[inSz - 1 - 6] = in[6]; FALL_THROUGH;
 8018fd0:	687b      	ldr	r3, [r7, #4]
 8018fd2:	3b07      	subs	r3, #7
 8018fd4:	697a      	ldr	r2, [r7, #20]
 8018fd6:	4413      	add	r3, r2
 8018fd8:	68ba      	ldr	r2, [r7, #8]
 8018fda:	7992      	ldrb	r2, [r2, #6]
 8018fdc:	701a      	strb	r2, [r3, #0]
                case 5: d[inSz - 1 - 5] = in[5]; FALL_THROUGH;
 8018fde:	687b      	ldr	r3, [r7, #4]
 8018fe0:	3b06      	subs	r3, #6
 8018fe2:	697a      	ldr	r2, [r7, #20]
 8018fe4:	4413      	add	r3, r2
 8018fe6:	68ba      	ldr	r2, [r7, #8]
 8018fe8:	7952      	ldrb	r2, [r2, #5]
 8018fea:	701a      	strb	r2, [r3, #0]
                case 4: d[inSz - 1 - 4] = in[4]; FALL_THROUGH;
 8018fec:	687b      	ldr	r3, [r7, #4]
 8018fee:	3b05      	subs	r3, #5
 8018ff0:	697a      	ldr	r2, [r7, #20]
 8018ff2:	4413      	add	r3, r2
 8018ff4:	68ba      	ldr	r2, [r7, #8]
 8018ff6:	7912      	ldrb	r2, [r2, #4]
 8018ff8:	701a      	strb	r2, [r3, #0]
                case 3: d[inSz - 1 - 3] = in[3]; FALL_THROUGH;
 8018ffa:	687b      	ldr	r3, [r7, #4]
 8018ffc:	3b04      	subs	r3, #4
 8018ffe:	697a      	ldr	r2, [r7, #20]
 8019000:	4413      	add	r3, r2
 8019002:	68ba      	ldr	r2, [r7, #8]
 8019004:	78d2      	ldrb	r2, [r2, #3]
 8019006:	701a      	strb	r2, [r3, #0]
                case 2: d[inSz - 1 - 2] = in[2]; FALL_THROUGH;
 8019008:	687b      	ldr	r3, [r7, #4]
 801900a:	3b03      	subs	r3, #3
 801900c:	697a      	ldr	r2, [r7, #20]
 801900e:	4413      	add	r3, r2
 8019010:	68ba      	ldr	r2, [r7, #8]
 8019012:	7892      	ldrb	r2, [r2, #2]
 8019014:	701a      	strb	r2, [r3, #0]
                case 1: d[inSz - 1 - 1] = in[1]; FALL_THROUGH;
 8019016:	687b      	ldr	r3, [r7, #4]
 8019018:	3b02      	subs	r3, #2
 801901a:	697a      	ldr	r2, [r7, #20]
 801901c:	4413      	add	r3, r2
 801901e:	68ba      	ldr	r2, [r7, #8]
 8019020:	7852      	ldrb	r2, [r2, #1]
 8019022:	701a      	strb	r2, [r3, #0]
                case 0: d[inSz - 1 - 0] = in[0];
 8019024:	687b      	ldr	r3, [r7, #4]
 8019026:	3b01      	subs	r3, #1
 8019028:	697a      	ldr	r2, [r7, #20]
 801902a:	4413      	add	r3, r2
 801902c:	68ba      	ldr	r2, [r7, #8]
 801902e:	7812      	ldrb	r2, [r2, #0]
 8019030:	701a      	strb	r2, [r3, #0]
            }
        }
    #endif

        sp_clamp(a);
 8019032:	68fb      	ldr	r3, [r7, #12]
 8019034:	681b      	ldr	r3, [r3, #0]
 8019036:	3b01      	subs	r3, #1
 8019038:	61bb      	str	r3, [r7, #24]
 801903a:	e002      	b.n	8019042 <sp_read_unsigned_bin+0x1a6>
 801903c:	69bb      	ldr	r3, [r7, #24]
 801903e:	3b01      	subs	r3, #1
 8019040:	61bb      	str	r3, [r7, #24]
 8019042:	69bb      	ldr	r3, [r7, #24]
 8019044:	2b00      	cmp	r3, #0
 8019046:	db06      	blt.n	8019056 <sp_read_unsigned_bin+0x1ba>
 8019048:	68fb      	ldr	r3, [r7, #12]
 801904a:	69ba      	ldr	r2, [r7, #24]
 801904c:	3202      	adds	r2, #2
 801904e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019052:	2b00      	cmp	r3, #0
 8019054:	d0f2      	beq.n	801903c <sp_read_unsigned_bin+0x1a0>
 8019056:	69bb      	ldr	r3, [r7, #24]
 8019058:	1c5a      	adds	r2, r3, #1
 801905a:	68fb      	ldr	r3, [r7, #12]
 801905c:	601a      	str	r2, [r3, #0]
    }
#endif /* LITTLE_ENDIAN_ORDER */

    return err;
 801905e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8019060:	4618      	mov	r0, r3
 8019062:	372c      	adds	r7, #44	; 0x2c
 8019064:	46bd      	mov	sp, r7
 8019066:	f85d 7b04 	ldr.w	r7, [sp], #4
 801906a:	4770      	bx	lr

0801906c <_sp_read_radix_16>:
 * @return  MP_OKAY on success.
 * @return  MP_VAL when radix not supported, value is negative, or a character
 *          is not valid.
 */
static int _sp_read_radix_16(sp_int* a, const char* in)
{
 801906c:	b580      	push	{r7, lr}
 801906e:	b088      	sub	sp, #32
 8019070:	af00      	add	r7, sp, #0
 8019072:	6078      	str	r0, [r7, #4]
 8019074:	6039      	str	r1, [r7, #0]
    int  err = MP_OKAY;
 8019076:	2300      	movs	r3, #0
 8019078:	61fb      	str	r3, [r7, #28]
    int  i;
    int  s = 0;
 801907a:	2300      	movs	r3, #0
 801907c:	617b      	str	r3, [r7, #20]
    int  j = 0;
 801907e:	2300      	movs	r3, #0
 8019080:	613b      	str	r3, [r7, #16]
        a->sign = MP_NEG;
        in++;
    }
#endif

    while (*in == '0') {
 8019082:	e002      	b.n	801908a <_sp_read_radix_16+0x1e>
        in++;
 8019084:	683b      	ldr	r3, [r7, #0]
 8019086:	3301      	adds	r3, #1
 8019088:	603b      	str	r3, [r7, #0]
    while (*in == '0') {
 801908a:	683b      	ldr	r3, [r7, #0]
 801908c:	781b      	ldrb	r3, [r3, #0]
 801908e:	2b30      	cmp	r3, #48	; 0x30
 8019090:	d0f8      	beq.n	8019084 <_sp_read_radix_16+0x18>
    }

    a->dp[0] = 0;
 8019092:	687b      	ldr	r3, [r7, #4]
 8019094:	2200      	movs	r2, #0
 8019096:	609a      	str	r2, [r3, #8]
    for (i = (int)(XSTRLEN(in) - 1); i >= 0; i--) {
 8019098:	6838      	ldr	r0, [r7, #0]
 801909a:	f7e7 f8b1 	bl	8000200 <strlen>
 801909e:	4603      	mov	r3, r0
 80190a0:	3b01      	subs	r3, #1
 80190a2:	61bb      	str	r3, [r7, #24]
 80190a4:	e053      	b.n	801914e <_sp_read_radix_16+0xe2>
        char ch = in[i];
 80190a6:	69bb      	ldr	r3, [r7, #24]
 80190a8:	683a      	ldr	r2, [r7, #0]
 80190aa:	4413      	add	r3, r2
 80190ac:	781b      	ldrb	r3, [r3, #0]
 80190ae:	73fb      	strb	r3, [r7, #15]
        if ((ch >= '0') && (ch <= '9')) {
 80190b0:	7bfb      	ldrb	r3, [r7, #15]
 80190b2:	2b2f      	cmp	r3, #47	; 0x2f
 80190b4:	d906      	bls.n	80190c4 <_sp_read_radix_16+0x58>
 80190b6:	7bfb      	ldrb	r3, [r7, #15]
 80190b8:	2b39      	cmp	r3, #57	; 0x39
 80190ba:	d803      	bhi.n	80190c4 <_sp_read_radix_16+0x58>
            ch -= '0';
 80190bc:	7bfb      	ldrb	r3, [r7, #15]
 80190be:	3b30      	subs	r3, #48	; 0x30
 80190c0:	73fb      	strb	r3, [r7, #15]
 80190c2:	e017      	b.n	80190f4 <_sp_read_radix_16+0x88>
        }
        else if ((ch >= 'A') && (ch <= 'F')) {
 80190c4:	7bfb      	ldrb	r3, [r7, #15]
 80190c6:	2b40      	cmp	r3, #64	; 0x40
 80190c8:	d906      	bls.n	80190d8 <_sp_read_radix_16+0x6c>
 80190ca:	7bfb      	ldrb	r3, [r7, #15]
 80190cc:	2b46      	cmp	r3, #70	; 0x46
 80190ce:	d803      	bhi.n	80190d8 <_sp_read_radix_16+0x6c>
            ch -= 'A' - 10;
 80190d0:	7bfb      	ldrb	r3, [r7, #15]
 80190d2:	3b37      	subs	r3, #55	; 0x37
 80190d4:	73fb      	strb	r3, [r7, #15]
 80190d6:	e00d      	b.n	80190f4 <_sp_read_radix_16+0x88>
        }
        else if ((ch >= 'a') && (ch <= 'f')) {
 80190d8:	7bfb      	ldrb	r3, [r7, #15]
 80190da:	2b60      	cmp	r3, #96	; 0x60
 80190dc:	d906      	bls.n	80190ec <_sp_read_radix_16+0x80>
 80190de:	7bfb      	ldrb	r3, [r7, #15]
 80190e0:	2b66      	cmp	r3, #102	; 0x66
 80190e2:	d803      	bhi.n	80190ec <_sp_read_radix_16+0x80>
            ch -= 'a' - 10;
 80190e4:	7bfb      	ldrb	r3, [r7, #15]
 80190e6:	3b57      	subs	r3, #87	; 0x57
 80190e8:	73fb      	strb	r3, [r7, #15]
 80190ea:	e003      	b.n	80190f4 <_sp_read_radix_16+0x88>
        }
        else {
            err = MP_VAL;
 80190ec:	f06f 0302 	mvn.w	r3, #2
 80190f0:	61fb      	str	r3, [r7, #28]
            break;
 80190f2:	e02f      	b.n	8019154 <_sp_read_radix_16+0xe8>
        }

        if (s == SP_WORD_SIZE) {
 80190f4:	697b      	ldr	r3, [r7, #20]
 80190f6:	2b20      	cmp	r3, #32
 80190f8:	d113      	bne.n	8019122 <_sp_read_radix_16+0xb6>
            j++;
 80190fa:	693b      	ldr	r3, [r7, #16]
 80190fc:	3301      	adds	r3, #1
 80190fe:	613b      	str	r3, [r7, #16]
            if (j >= a->size) {
 8019100:	687b      	ldr	r3, [r7, #4]
 8019102:	685b      	ldr	r3, [r3, #4]
 8019104:	693a      	ldr	r2, [r7, #16]
 8019106:	429a      	cmp	r2, r3
 8019108:	db03      	blt.n	8019112 <_sp_read_radix_16+0xa6>
                err = MP_VAL;
 801910a:	f06f 0302 	mvn.w	r3, #2
 801910e:	61fb      	str	r3, [r7, #28]
                break;
 8019110:	e020      	b.n	8019154 <_sp_read_radix_16+0xe8>
            }
            s = 0;
 8019112:	2300      	movs	r3, #0
 8019114:	617b      	str	r3, [r7, #20]
            a->dp[j] = 0;
 8019116:	687b      	ldr	r3, [r7, #4]
 8019118:	693a      	ldr	r2, [r7, #16]
 801911a:	3202      	adds	r2, #2
 801911c:	2100      	movs	r1, #0
 801911e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        }

        a->dp[j] |= ((sp_int_digit)ch) << s;
 8019122:	687b      	ldr	r3, [r7, #4]
 8019124:	693a      	ldr	r2, [r7, #16]
 8019126:	3202      	adds	r2, #2
 8019128:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801912c:	7bf9      	ldrb	r1, [r7, #15]
 801912e:	697b      	ldr	r3, [r7, #20]
 8019130:	fa01 f303 	lsl.w	r3, r1, r3
 8019134:	ea42 0103 	orr.w	r1, r2, r3
 8019138:	687b      	ldr	r3, [r7, #4]
 801913a:	693a      	ldr	r2, [r7, #16]
 801913c:	3202      	adds	r2, #2
 801913e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        s += 4;
 8019142:	697b      	ldr	r3, [r7, #20]
 8019144:	3304      	adds	r3, #4
 8019146:	617b      	str	r3, [r7, #20]
    for (i = (int)(XSTRLEN(in) - 1); i >= 0; i--) {
 8019148:	69bb      	ldr	r3, [r7, #24]
 801914a:	3b01      	subs	r3, #1
 801914c:	61bb      	str	r3, [r7, #24]
 801914e:	69bb      	ldr	r3, [r7, #24]
 8019150:	2b00      	cmp	r3, #0
 8019152:	daa8      	bge.n	80190a6 <_sp_read_radix_16+0x3a>
    }

    if (err == MP_OKAY) {
 8019154:	69fb      	ldr	r3, [r7, #28]
 8019156:	2b00      	cmp	r3, #0
 8019158:	d119      	bne.n	801918e <_sp_read_radix_16+0x122>
        a->used = j + 1;
 801915a:	693b      	ldr	r3, [r7, #16]
 801915c:	1c5a      	adds	r2, r3, #1
 801915e:	687b      	ldr	r3, [r7, #4]
 8019160:	601a      	str	r2, [r3, #0]
        sp_clamp(a);
 8019162:	687b      	ldr	r3, [r7, #4]
 8019164:	681b      	ldr	r3, [r3, #0]
 8019166:	3b01      	subs	r3, #1
 8019168:	60bb      	str	r3, [r7, #8]
 801916a:	e002      	b.n	8019172 <_sp_read_radix_16+0x106>
 801916c:	68bb      	ldr	r3, [r7, #8]
 801916e:	3b01      	subs	r3, #1
 8019170:	60bb      	str	r3, [r7, #8]
 8019172:	68bb      	ldr	r3, [r7, #8]
 8019174:	2b00      	cmp	r3, #0
 8019176:	db06      	blt.n	8019186 <_sp_read_radix_16+0x11a>
 8019178:	687b      	ldr	r3, [r7, #4]
 801917a:	68ba      	ldr	r2, [r7, #8]
 801917c:	3202      	adds	r2, #2
 801917e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019182:	2b00      	cmp	r3, #0
 8019184:	d0f2      	beq.n	801916c <_sp_read_radix_16+0x100>
 8019186:	68bb      	ldr	r3, [r7, #8]
 8019188:	1c5a      	adds	r2, r3, #1
 801918a:	687b      	ldr	r3, [r7, #4]
 801918c:	601a      	str	r2, [r3, #0]
    }

    return err;
 801918e:	69fb      	ldr	r3, [r7, #28]
}
 8019190:	4618      	mov	r0, r3
 8019192:	3720      	adds	r7, #32
 8019194:	46bd      	mov	sp, r7
 8019196:	bd80      	pop	{r7, pc}

08019198 <sp_read_radix>:
 * @return  MP_OKAY on success.
 * @return  MP_VAL when a or in is NULL, radix not supported, value is negative,
 *          or a character is not valid.
 */
int sp_read_radix(sp_int* a, const char* in, int radix)
{
 8019198:	b580      	push	{r7, lr}
 801919a:	b086      	sub	sp, #24
 801919c:	af00      	add	r7, sp, #0
 801919e:	60f8      	str	r0, [r7, #12]
 80191a0:	60b9      	str	r1, [r7, #8]
 80191a2:	607a      	str	r2, [r7, #4]
    int err = MP_OKAY;
 80191a4:	2300      	movs	r3, #0
 80191a6:	617b      	str	r3, [r7, #20]

    if ((a == NULL) || (in == NULL)) {
 80191a8:	68fb      	ldr	r3, [r7, #12]
 80191aa:	2b00      	cmp	r3, #0
 80191ac:	d002      	beq.n	80191b4 <sp_read_radix+0x1c>
 80191ae:	68bb      	ldr	r3, [r7, #8]
 80191b0:	2b00      	cmp	r3, #0
 80191b2:	d102      	bne.n	80191ba <sp_read_radix+0x22>
        err = MP_VAL;
 80191b4:	f06f 0302 	mvn.w	r3, #2
 80191b8:	617b      	str	r3, [r7, #20]
    }

    if (err == MP_OKAY) {
 80191ba:	697b      	ldr	r3, [r7, #20]
 80191bc:	2b00      	cmp	r3, #0
 80191be:	d113      	bne.n	80191e8 <sp_read_radix+0x50>
    #ifndef WOLFSSL_SP_INT_NEGATIVE
        if (*in == '-') {
 80191c0:	68bb      	ldr	r3, [r7, #8]
 80191c2:	781b      	ldrb	r3, [r3, #0]
 80191c4:	2b2d      	cmp	r3, #45	; 0x2d
 80191c6:	d103      	bne.n	80191d0 <sp_read_radix+0x38>
            err = MP_VAL;
 80191c8:	f06f 0302 	mvn.w	r3, #2
 80191cc:	617b      	str	r3, [r7, #20]
 80191ce:	e00b      	b.n	80191e8 <sp_read_radix+0x50>
        }
        else
    #endif
        if (radix == 16) {
 80191d0:	687b      	ldr	r3, [r7, #4]
 80191d2:	2b10      	cmp	r3, #16
 80191d4:	d105      	bne.n	80191e2 <sp_read_radix+0x4a>
            err = _sp_read_radix_16(a, in);
 80191d6:	68b9      	ldr	r1, [r7, #8]
 80191d8:	68f8      	ldr	r0, [r7, #12]
 80191da:	f7ff ff47 	bl	801906c <_sp_read_radix_16>
 80191de:	6178      	str	r0, [r7, #20]
 80191e0:	e002      	b.n	80191e8 <sp_read_radix+0x50>
        else if (radix == 10) {
            err = _sp_read_radix_10(a, in);
        }
    #endif
        else {
            err = MP_VAL;
 80191e2:	f06f 0302 	mvn.w	r3, #2
 80191e6:	617b      	str	r3, [r7, #20]
        }
    }

    return err;
 80191e8:	697b      	ldr	r3, [r7, #20]
}
 80191ea:	4618      	mov	r0, r3
 80191ec:	3718      	adds	r7, #24
 80191ee:	46bd      	mov	sp, r7
 80191f0:	bd80      	pop	{r7, pc}
	...

080191f4 <wolfCrypt_Init>:

/* Used to initialize state for wolfcrypt
   return 0 on success
 */
int wolfCrypt_Init(void)
{
 80191f4:	b580      	push	{r7, lr}
 80191f6:	b082      	sub	sp, #8
 80191f8:	af00      	add	r7, sp, #0
    int ret = 0;
 80191fa:	2300      	movs	r3, #0
 80191fc:	607b      	str	r3, [r7, #4]
    if (initRefCount == 0) {
 80191fe:	4b0b      	ldr	r3, [pc, #44]	; (801922c <wolfCrypt_Init+0x38>)
 8019200:	681b      	ldr	r3, [r3, #0]
 8019202:	2b00      	cmp	r3, #0
 8019204:	d107      	bne.n	8019216 <wolfCrypt_Init+0x22>
        }
    #endif

    #if WOLFSSL_CRYPT_HW_MUTEX
        /* If crypto hardware mutex protection is enabled, then initialize it */
        ret = wolfSSL_CryptHwMutexInit();
 8019206:	f000 f813 	bl	8019230 <wolfSSL_CryptHwMutexInit>
 801920a:	6078      	str	r0, [r7, #4]
        if (ret != 0) {
 801920c:	687b      	ldr	r3, [r7, #4]
 801920e:	2b00      	cmp	r3, #0
 8019210:	d001      	beq.n	8019216 <wolfCrypt_Init+0x22>
            WOLFSSL_MSG("Hw crypt mutex init failed");
            return ret;
 8019212:	687b      	ldr	r3, [r7, #4]
 8019214:	e005      	b.n	8019222 <wolfCrypt_Init+0x2e>
            return ret;
        }
        rpcmem_init();
#endif
    }
    initRefCount++;
 8019216:	4b05      	ldr	r3, [pc, #20]	; (801922c <wolfCrypt_Init+0x38>)
 8019218:	681b      	ldr	r3, [r3, #0]
 801921a:	3301      	adds	r3, #1
 801921c:	4a03      	ldr	r2, [pc, #12]	; (801922c <wolfCrypt_Init+0x38>)
 801921e:	6013      	str	r3, [r2, #0]

    return ret;
 8019220:	687b      	ldr	r3, [r7, #4]
}
 8019222:	4618      	mov	r0, r3
 8019224:	3708      	adds	r7, #8
 8019226:	46bd      	mov	sp, r7
 8019228:	bd80      	pop	{r7, pc}
 801922a:	bf00      	nop
 801922c:	20000234 	.word	0x20000234

08019230 <wolfSSL_CryptHwMutexInit>:
/* Mutex for protection of cryptography hardware */
static wolfSSL_Mutex wcCryptHwMutex;
static int wcCryptHwMutexInit = 0;

int wolfSSL_CryptHwMutexInit(void)
{
 8019230:	b580      	push	{r7, lr}
 8019232:	b082      	sub	sp, #8
 8019234:	af00      	add	r7, sp, #0
    int ret = 0;
 8019236:	2300      	movs	r3, #0
 8019238:	607b      	str	r3, [r7, #4]
    if (wcCryptHwMutexInit == 0) {
 801923a:	4b09      	ldr	r3, [pc, #36]	; (8019260 <wolfSSL_CryptHwMutexInit+0x30>)
 801923c:	681b      	ldr	r3, [r3, #0]
 801923e:	2b00      	cmp	r3, #0
 8019240:	d109      	bne.n	8019256 <wolfSSL_CryptHwMutexInit+0x26>
        ret = wc_InitMutex(&wcCryptHwMutex);
 8019242:	4808      	ldr	r0, [pc, #32]	; (8019264 <wolfSSL_CryptHwMutexInit+0x34>)
 8019244:	f000 f810 	bl	8019268 <wc_InitMutex>
 8019248:	6078      	str	r0, [r7, #4]
        if (ret == 0) {
 801924a:	687b      	ldr	r3, [r7, #4]
 801924c:	2b00      	cmp	r3, #0
 801924e:	d102      	bne.n	8019256 <wolfSSL_CryptHwMutexInit+0x26>
            wcCryptHwMutexInit = 1;
 8019250:	4b03      	ldr	r3, [pc, #12]	; (8019260 <wolfSSL_CryptHwMutexInit+0x30>)
 8019252:	2201      	movs	r2, #1
 8019254:	601a      	str	r2, [r3, #0]
        }
    }
    return ret;
 8019256:	687b      	ldr	r3, [r7, #4]
}
 8019258:	4618      	mov	r0, r3
 801925a:	3708      	adds	r7, #8
 801925c:	46bd      	mov	sp, r7
 801925e:	bd80      	pop	{r7, pc}
 8019260:	2000023c 	.word	0x2000023c
 8019264:	20000238 	.word	0x20000238

08019268 <wc_InitMutex>:
    }
#endif /* defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) */
#ifdef SINGLE_THREADED

    int wc_InitMutex(wolfSSL_Mutex* m)
    {
 8019268:	b480      	push	{r7}
 801926a:	b083      	sub	sp, #12
 801926c:	af00      	add	r7, sp, #0
 801926e:	6078      	str	r0, [r7, #4]
        (void)m;
        return 0;
 8019270:	2300      	movs	r3, #0
    }
 8019272:	4618      	mov	r0, r3
 8019274:	370c      	adds	r7, #12
 8019276:	46bd      	mov	sp, r7
 8019278:	f85d 7b04 	ldr.w	r7, [sp], #4
 801927c:	4770      	bx	lr

0801927e <wc_FreeMutex>:

    int wc_FreeMutex(wolfSSL_Mutex *m)
    {
 801927e:	b480      	push	{r7}
 8019280:	b083      	sub	sp, #12
 8019282:	af00      	add	r7, sp, #0
 8019284:	6078      	str	r0, [r7, #4]
        (void)m;
        return 0;
 8019286:	2300      	movs	r3, #0
    }
 8019288:	4618      	mov	r0, r3
 801928a:	370c      	adds	r7, #12
 801928c:	46bd      	mov	sp, r7
 801928e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019292:	4770      	bx	lr

08019294 <wc_LockMutex>:


    int wc_LockMutex(wolfSSL_Mutex *m)
    {
 8019294:	b480      	push	{r7}
 8019296:	b083      	sub	sp, #12
 8019298:	af00      	add	r7, sp, #0
 801929a:	6078      	str	r0, [r7, #4]
        (void)m;
        return 0;
 801929c:	2300      	movs	r3, #0
    }
 801929e:	4618      	mov	r0, r3
 80192a0:	370c      	adds	r7, #12
 80192a2:	46bd      	mov	sp, r7
 80192a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80192a8:	4770      	bx	lr

080192aa <wc_UnLockMutex>:


    int wc_UnLockMutex(wolfSSL_Mutex *m)
    {
 80192aa:	b480      	push	{r7}
 80192ac:	b083      	sub	sp, #12
 80192ae:	af00      	add	r7, sp, #0
 80192b0:	6078      	str	r0, [r7, #4]
        (void)m;
        return 0;
 80192b2:	2300      	movs	r3, #0
    }
 80192b4:	4618      	mov	r0, r3
 80192b6:	370c      	adds	r7, #12
 80192b8:	46bd      	mov	sp, r7
 80192ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80192be:	4770      	bx	lr

080192c0 <mystrnstr>:

#endif /* !NO_ASN_TIME */

#ifndef WOLFSSL_LEANPSK
char* mystrnstr(const char* s1, const char* s2, unsigned int n)
{
 80192c0:	b580      	push	{r7, lr}
 80192c2:	b086      	sub	sp, #24
 80192c4:	af00      	add	r7, sp, #0
 80192c6:	60f8      	str	r0, [r7, #12]
 80192c8:	60b9      	str	r1, [r7, #8]
 80192ca:	607a      	str	r2, [r7, #4]
    unsigned int s2_len = (unsigned int)XSTRLEN(s2);
 80192cc:	68b8      	ldr	r0, [r7, #8]
 80192ce:	f7e6 ff97 	bl	8000200 <strlen>
 80192d2:	6178      	str	r0, [r7, #20]

    if (s2_len == 0)
 80192d4:	697b      	ldr	r3, [r7, #20]
 80192d6:	2b00      	cmp	r3, #0
 80192d8:	d117      	bne.n	801930a <mystrnstr+0x4a>
        return (char*)s1;
 80192da:	68fb      	ldr	r3, [r7, #12]
 80192dc:	e01e      	b.n	801931c <mystrnstr+0x5c>

    while (n >= s2_len && s1[0]) {
        if (s1[0] == s2[0])
 80192de:	68fb      	ldr	r3, [r7, #12]
 80192e0:	781a      	ldrb	r2, [r3, #0]
 80192e2:	68bb      	ldr	r3, [r7, #8]
 80192e4:	781b      	ldrb	r3, [r3, #0]
 80192e6:	429a      	cmp	r2, r3
 80192e8:	d109      	bne.n	80192fe <mystrnstr+0x3e>
            if (XMEMCMP(s1, s2, s2_len) == 0)
 80192ea:	697a      	ldr	r2, [r7, #20]
 80192ec:	68b9      	ldr	r1, [r7, #8]
 80192ee:	68f8      	ldr	r0, [r7, #12]
 80192f0:	f000 f872 	bl	80193d8 <memcmp>
 80192f4:	4603      	mov	r3, r0
 80192f6:	2b00      	cmp	r3, #0
 80192f8:	d101      	bne.n	80192fe <mystrnstr+0x3e>
                return (char*)s1;
 80192fa:	68fb      	ldr	r3, [r7, #12]
 80192fc:	e00e      	b.n	801931c <mystrnstr+0x5c>
        s1++;
 80192fe:	68fb      	ldr	r3, [r7, #12]
 8019300:	3301      	adds	r3, #1
 8019302:	60fb      	str	r3, [r7, #12]
        n--;
 8019304:	687b      	ldr	r3, [r7, #4]
 8019306:	3b01      	subs	r3, #1
 8019308:	607b      	str	r3, [r7, #4]
    while (n >= s2_len && s1[0]) {
 801930a:	687a      	ldr	r2, [r7, #4]
 801930c:	697b      	ldr	r3, [r7, #20]
 801930e:	429a      	cmp	r2, r3
 8019310:	d303      	bcc.n	801931a <mystrnstr+0x5a>
 8019312:	68fb      	ldr	r3, [r7, #12]
 8019314:	781b      	ldrb	r3, [r3, #0]
 8019316:	2b00      	cmp	r3, #0
 8019318:	d1e1      	bne.n	80192de <mystrnstr+0x1e>
    }

    return NULL;
 801931a:	2300      	movs	r3, #0
}
 801931c:	4618      	mov	r0, r3
 801931e:	3718      	adds	r7, #24
 8019320:	46bd      	mov	sp, r7
 8019322:	bd80      	pop	{r7, pc}

08019324 <__errno>:
 8019324:	4b01      	ldr	r3, [pc, #4]	; (801932c <__errno+0x8>)
 8019326:	6818      	ldr	r0, [r3, #0]
 8019328:	4770      	bx	lr
 801932a:	bf00      	nop
 801932c:	2000000c 	.word	0x2000000c

08019330 <__libc_init_array>:
 8019330:	b570      	push	{r4, r5, r6, lr}
 8019332:	4e0d      	ldr	r6, [pc, #52]	; (8019368 <__libc_init_array+0x38>)
 8019334:	4c0d      	ldr	r4, [pc, #52]	; (801936c <__libc_init_array+0x3c>)
 8019336:	1ba4      	subs	r4, r4, r6
 8019338:	10a4      	asrs	r4, r4, #2
 801933a:	2500      	movs	r5, #0
 801933c:	42a5      	cmp	r5, r4
 801933e:	d109      	bne.n	8019354 <__libc_init_array+0x24>
 8019340:	4e0b      	ldr	r6, [pc, #44]	; (8019370 <__libc_init_array+0x40>)
 8019342:	4c0c      	ldr	r4, [pc, #48]	; (8019374 <__libc_init_array+0x44>)
 8019344:	f001 f824 	bl	801a390 <_init>
 8019348:	1ba4      	subs	r4, r4, r6
 801934a:	10a4      	asrs	r4, r4, #2
 801934c:	2500      	movs	r5, #0
 801934e:	42a5      	cmp	r5, r4
 8019350:	d105      	bne.n	801935e <__libc_init_array+0x2e>
 8019352:	bd70      	pop	{r4, r5, r6, pc}
 8019354:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8019358:	4798      	blx	r3
 801935a:	3501      	adds	r5, #1
 801935c:	e7ee      	b.n	801933c <__libc_init_array+0xc>
 801935e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8019362:	4798      	blx	r3
 8019364:	3501      	adds	r5, #1
 8019366:	e7f2      	b.n	801934e <__libc_init_array+0x1e>
 8019368:	0801b624 	.word	0x0801b624
 801936c:	0801b624 	.word	0x0801b624
 8019370:	0801b624 	.word	0x0801b624
 8019374:	0801b628 	.word	0x0801b628

08019378 <__locale_ctype_ptr>:
 8019378:	4b04      	ldr	r3, [pc, #16]	; (801938c <__locale_ctype_ptr+0x14>)
 801937a:	4a05      	ldr	r2, [pc, #20]	; (8019390 <__locale_ctype_ptr+0x18>)
 801937c:	681b      	ldr	r3, [r3, #0]
 801937e:	6a1b      	ldr	r3, [r3, #32]
 8019380:	2b00      	cmp	r3, #0
 8019382:	bf08      	it	eq
 8019384:	4613      	moveq	r3, r2
 8019386:	f8d3 00ec 	ldr.w	r0, [r3, #236]	; 0xec
 801938a:	4770      	bx	lr
 801938c:	2000000c 	.word	0x2000000c
 8019390:	20000070 	.word	0x20000070

08019394 <malloc>:
 8019394:	4b02      	ldr	r3, [pc, #8]	; (80193a0 <malloc+0xc>)
 8019396:	4601      	mov	r1, r0
 8019398:	6818      	ldr	r0, [r3, #0]
 801939a:	f000 b8a7 	b.w	80194ec <_malloc_r>
 801939e:	bf00      	nop
 80193a0:	2000000c 	.word	0x2000000c

080193a4 <free>:
 80193a4:	4b02      	ldr	r3, [pc, #8]	; (80193b0 <free+0xc>)
 80193a6:	4601      	mov	r1, r0
 80193a8:	6818      	ldr	r0, [r3, #0]
 80193aa:	f000 b851 	b.w	8019450 <_free_r>
 80193ae:	bf00      	nop
 80193b0:	2000000c 	.word	0x2000000c

080193b4 <__ascii_mbtowc>:
 80193b4:	b082      	sub	sp, #8
 80193b6:	b901      	cbnz	r1, 80193ba <__ascii_mbtowc+0x6>
 80193b8:	a901      	add	r1, sp, #4
 80193ba:	b142      	cbz	r2, 80193ce <__ascii_mbtowc+0x1a>
 80193bc:	b14b      	cbz	r3, 80193d2 <__ascii_mbtowc+0x1e>
 80193be:	7813      	ldrb	r3, [r2, #0]
 80193c0:	600b      	str	r3, [r1, #0]
 80193c2:	7812      	ldrb	r2, [r2, #0]
 80193c4:	1c10      	adds	r0, r2, #0
 80193c6:	bf18      	it	ne
 80193c8:	2001      	movne	r0, #1
 80193ca:	b002      	add	sp, #8
 80193cc:	4770      	bx	lr
 80193ce:	4610      	mov	r0, r2
 80193d0:	e7fb      	b.n	80193ca <__ascii_mbtowc+0x16>
 80193d2:	f06f 0001 	mvn.w	r0, #1
 80193d6:	e7f8      	b.n	80193ca <__ascii_mbtowc+0x16>

080193d8 <memcmp>:
 80193d8:	b530      	push	{r4, r5, lr}
 80193da:	2400      	movs	r4, #0
 80193dc:	42a2      	cmp	r2, r4
 80193de:	d101      	bne.n	80193e4 <memcmp+0xc>
 80193e0:	2000      	movs	r0, #0
 80193e2:	e007      	b.n	80193f4 <memcmp+0x1c>
 80193e4:	5d03      	ldrb	r3, [r0, r4]
 80193e6:	3401      	adds	r4, #1
 80193e8:	190d      	adds	r5, r1, r4
 80193ea:	f815 5c01 	ldrb.w	r5, [r5, #-1]
 80193ee:	42ab      	cmp	r3, r5
 80193f0:	d0f4      	beq.n	80193dc <memcmp+0x4>
 80193f2:	1b58      	subs	r0, r3, r5
 80193f4:	bd30      	pop	{r4, r5, pc}

080193f6 <memcpy>:
 80193f6:	b510      	push	{r4, lr}
 80193f8:	1e43      	subs	r3, r0, #1
 80193fa:	440a      	add	r2, r1
 80193fc:	4291      	cmp	r1, r2
 80193fe:	d100      	bne.n	8019402 <memcpy+0xc>
 8019400:	bd10      	pop	{r4, pc}
 8019402:	f811 4b01 	ldrb.w	r4, [r1], #1
 8019406:	f803 4f01 	strb.w	r4, [r3, #1]!
 801940a:	e7f7      	b.n	80193fc <memcpy+0x6>

0801940c <memmove>:
 801940c:	4288      	cmp	r0, r1
 801940e:	b510      	push	{r4, lr}
 8019410:	eb01 0302 	add.w	r3, r1, r2
 8019414:	d807      	bhi.n	8019426 <memmove+0x1a>
 8019416:	1e42      	subs	r2, r0, #1
 8019418:	4299      	cmp	r1, r3
 801941a:	d00a      	beq.n	8019432 <memmove+0x26>
 801941c:	f811 4b01 	ldrb.w	r4, [r1], #1
 8019420:	f802 4f01 	strb.w	r4, [r2, #1]!
 8019424:	e7f8      	b.n	8019418 <memmove+0xc>
 8019426:	4283      	cmp	r3, r0
 8019428:	d9f5      	bls.n	8019416 <memmove+0xa>
 801942a:	1881      	adds	r1, r0, r2
 801942c:	1ad2      	subs	r2, r2, r3
 801942e:	42d3      	cmn	r3, r2
 8019430:	d100      	bne.n	8019434 <memmove+0x28>
 8019432:	bd10      	pop	{r4, pc}
 8019434:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8019438:	f801 4d01 	strb.w	r4, [r1, #-1]!
 801943c:	e7f7      	b.n	801942e <memmove+0x22>

0801943e <memset>:
 801943e:	4402      	add	r2, r0
 8019440:	4603      	mov	r3, r0
 8019442:	4293      	cmp	r3, r2
 8019444:	d100      	bne.n	8019448 <memset+0xa>
 8019446:	4770      	bx	lr
 8019448:	f803 1b01 	strb.w	r1, [r3], #1
 801944c:	e7f9      	b.n	8019442 <memset+0x4>
	...

08019450 <_free_r>:
 8019450:	b538      	push	{r3, r4, r5, lr}
 8019452:	4605      	mov	r5, r0
 8019454:	2900      	cmp	r1, #0
 8019456:	d045      	beq.n	80194e4 <_free_r+0x94>
 8019458:	f851 3c04 	ldr.w	r3, [r1, #-4]
 801945c:	1f0c      	subs	r4, r1, #4
 801945e:	2b00      	cmp	r3, #0
 8019460:	bfb8      	it	lt
 8019462:	18e4      	addlt	r4, r4, r3
 8019464:	f000 fc1e 	bl	8019ca4 <__malloc_lock>
 8019468:	4a1f      	ldr	r2, [pc, #124]	; (80194e8 <_free_r+0x98>)
 801946a:	6813      	ldr	r3, [r2, #0]
 801946c:	4610      	mov	r0, r2
 801946e:	b933      	cbnz	r3, 801947e <_free_r+0x2e>
 8019470:	6063      	str	r3, [r4, #4]
 8019472:	6014      	str	r4, [r2, #0]
 8019474:	4628      	mov	r0, r5
 8019476:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 801947a:	f000 bc14 	b.w	8019ca6 <__malloc_unlock>
 801947e:	42a3      	cmp	r3, r4
 8019480:	d90c      	bls.n	801949c <_free_r+0x4c>
 8019482:	6821      	ldr	r1, [r4, #0]
 8019484:	1862      	adds	r2, r4, r1
 8019486:	4293      	cmp	r3, r2
 8019488:	bf04      	itt	eq
 801948a:	681a      	ldreq	r2, [r3, #0]
 801948c:	685b      	ldreq	r3, [r3, #4]
 801948e:	6063      	str	r3, [r4, #4]
 8019490:	bf04      	itt	eq
 8019492:	1852      	addeq	r2, r2, r1
 8019494:	6022      	streq	r2, [r4, #0]
 8019496:	6004      	str	r4, [r0, #0]
 8019498:	e7ec      	b.n	8019474 <_free_r+0x24>
 801949a:	4613      	mov	r3, r2
 801949c:	685a      	ldr	r2, [r3, #4]
 801949e:	b10a      	cbz	r2, 80194a4 <_free_r+0x54>
 80194a0:	42a2      	cmp	r2, r4
 80194a2:	d9fa      	bls.n	801949a <_free_r+0x4a>
 80194a4:	6819      	ldr	r1, [r3, #0]
 80194a6:	1858      	adds	r0, r3, r1
 80194a8:	42a0      	cmp	r0, r4
 80194aa:	d10b      	bne.n	80194c4 <_free_r+0x74>
 80194ac:	6820      	ldr	r0, [r4, #0]
 80194ae:	4401      	add	r1, r0
 80194b0:	1858      	adds	r0, r3, r1
 80194b2:	4282      	cmp	r2, r0
 80194b4:	6019      	str	r1, [r3, #0]
 80194b6:	d1dd      	bne.n	8019474 <_free_r+0x24>
 80194b8:	6810      	ldr	r0, [r2, #0]
 80194ba:	6852      	ldr	r2, [r2, #4]
 80194bc:	605a      	str	r2, [r3, #4]
 80194be:	4401      	add	r1, r0
 80194c0:	6019      	str	r1, [r3, #0]
 80194c2:	e7d7      	b.n	8019474 <_free_r+0x24>
 80194c4:	d902      	bls.n	80194cc <_free_r+0x7c>
 80194c6:	230c      	movs	r3, #12
 80194c8:	602b      	str	r3, [r5, #0]
 80194ca:	e7d3      	b.n	8019474 <_free_r+0x24>
 80194cc:	6820      	ldr	r0, [r4, #0]
 80194ce:	1821      	adds	r1, r4, r0
 80194d0:	428a      	cmp	r2, r1
 80194d2:	bf04      	itt	eq
 80194d4:	6811      	ldreq	r1, [r2, #0]
 80194d6:	6852      	ldreq	r2, [r2, #4]
 80194d8:	6062      	str	r2, [r4, #4]
 80194da:	bf04      	itt	eq
 80194dc:	1809      	addeq	r1, r1, r0
 80194de:	6021      	streq	r1, [r4, #0]
 80194e0:	605c      	str	r4, [r3, #4]
 80194e2:	e7c7      	b.n	8019474 <_free_r+0x24>
 80194e4:	bd38      	pop	{r3, r4, r5, pc}
 80194e6:	bf00      	nop
 80194e8:	20000240 	.word	0x20000240

080194ec <_malloc_r>:
 80194ec:	b570      	push	{r4, r5, r6, lr}
 80194ee:	1ccd      	adds	r5, r1, #3
 80194f0:	f025 0503 	bic.w	r5, r5, #3
 80194f4:	3508      	adds	r5, #8
 80194f6:	2d0c      	cmp	r5, #12
 80194f8:	bf38      	it	cc
 80194fa:	250c      	movcc	r5, #12
 80194fc:	2d00      	cmp	r5, #0
 80194fe:	4606      	mov	r6, r0
 8019500:	db01      	blt.n	8019506 <_malloc_r+0x1a>
 8019502:	42a9      	cmp	r1, r5
 8019504:	d903      	bls.n	801950e <_malloc_r+0x22>
 8019506:	230c      	movs	r3, #12
 8019508:	6033      	str	r3, [r6, #0]
 801950a:	2000      	movs	r0, #0
 801950c:	bd70      	pop	{r4, r5, r6, pc}
 801950e:	f000 fbc9 	bl	8019ca4 <__malloc_lock>
 8019512:	4a21      	ldr	r2, [pc, #132]	; (8019598 <_malloc_r+0xac>)
 8019514:	6814      	ldr	r4, [r2, #0]
 8019516:	4621      	mov	r1, r4
 8019518:	b991      	cbnz	r1, 8019540 <_malloc_r+0x54>
 801951a:	4c20      	ldr	r4, [pc, #128]	; (801959c <_malloc_r+0xb0>)
 801951c:	6823      	ldr	r3, [r4, #0]
 801951e:	b91b      	cbnz	r3, 8019528 <_malloc_r+0x3c>
 8019520:	4630      	mov	r0, r6
 8019522:	f000 f855 	bl	80195d0 <_sbrk_r>
 8019526:	6020      	str	r0, [r4, #0]
 8019528:	4629      	mov	r1, r5
 801952a:	4630      	mov	r0, r6
 801952c:	f000 f850 	bl	80195d0 <_sbrk_r>
 8019530:	1c43      	adds	r3, r0, #1
 8019532:	d124      	bne.n	801957e <_malloc_r+0x92>
 8019534:	230c      	movs	r3, #12
 8019536:	6033      	str	r3, [r6, #0]
 8019538:	4630      	mov	r0, r6
 801953a:	f000 fbb4 	bl	8019ca6 <__malloc_unlock>
 801953e:	e7e4      	b.n	801950a <_malloc_r+0x1e>
 8019540:	680b      	ldr	r3, [r1, #0]
 8019542:	1b5b      	subs	r3, r3, r5
 8019544:	d418      	bmi.n	8019578 <_malloc_r+0x8c>
 8019546:	2b0b      	cmp	r3, #11
 8019548:	d90f      	bls.n	801956a <_malloc_r+0x7e>
 801954a:	600b      	str	r3, [r1, #0]
 801954c:	50cd      	str	r5, [r1, r3]
 801954e:	18cc      	adds	r4, r1, r3
 8019550:	4630      	mov	r0, r6
 8019552:	f000 fba8 	bl	8019ca6 <__malloc_unlock>
 8019556:	f104 000b 	add.w	r0, r4, #11
 801955a:	1d23      	adds	r3, r4, #4
 801955c:	f020 0007 	bic.w	r0, r0, #7
 8019560:	1ac3      	subs	r3, r0, r3
 8019562:	d0d3      	beq.n	801950c <_malloc_r+0x20>
 8019564:	425a      	negs	r2, r3
 8019566:	50e2      	str	r2, [r4, r3]
 8019568:	e7d0      	b.n	801950c <_malloc_r+0x20>
 801956a:	428c      	cmp	r4, r1
 801956c:	684b      	ldr	r3, [r1, #4]
 801956e:	bf16      	itet	ne
 8019570:	6063      	strne	r3, [r4, #4]
 8019572:	6013      	streq	r3, [r2, #0]
 8019574:	460c      	movne	r4, r1
 8019576:	e7eb      	b.n	8019550 <_malloc_r+0x64>
 8019578:	460c      	mov	r4, r1
 801957a:	6849      	ldr	r1, [r1, #4]
 801957c:	e7cc      	b.n	8019518 <_malloc_r+0x2c>
 801957e:	1cc4      	adds	r4, r0, #3
 8019580:	f024 0403 	bic.w	r4, r4, #3
 8019584:	42a0      	cmp	r0, r4
 8019586:	d005      	beq.n	8019594 <_malloc_r+0xa8>
 8019588:	1a21      	subs	r1, r4, r0
 801958a:	4630      	mov	r0, r6
 801958c:	f000 f820 	bl	80195d0 <_sbrk_r>
 8019590:	3001      	adds	r0, #1
 8019592:	d0cf      	beq.n	8019534 <_malloc_r+0x48>
 8019594:	6025      	str	r5, [r4, #0]
 8019596:	e7db      	b.n	8019550 <_malloc_r+0x64>
 8019598:	20000240 	.word	0x20000240
 801959c:	20000244 	.word	0x20000244

080195a0 <iprintf>:
 80195a0:	b40f      	push	{r0, r1, r2, r3}
 80195a2:	4b0a      	ldr	r3, [pc, #40]	; (80195cc <iprintf+0x2c>)
 80195a4:	b513      	push	{r0, r1, r4, lr}
 80195a6:	681c      	ldr	r4, [r3, #0]
 80195a8:	b124      	cbz	r4, 80195b4 <iprintf+0x14>
 80195aa:	69a3      	ldr	r3, [r4, #24]
 80195ac:	b913      	cbnz	r3, 80195b4 <iprintf+0x14>
 80195ae:	4620      	mov	r0, r4
 80195b0:	f000 fa8a 	bl	8019ac8 <__sinit>
 80195b4:	ab05      	add	r3, sp, #20
 80195b6:	9a04      	ldr	r2, [sp, #16]
 80195b8:	68a1      	ldr	r1, [r4, #8]
 80195ba:	9301      	str	r3, [sp, #4]
 80195bc:	4620      	mov	r0, r4
 80195be:	f000 fb9d 	bl	8019cfc <_vfiprintf_r>
 80195c2:	b002      	add	sp, #8
 80195c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80195c8:	b004      	add	sp, #16
 80195ca:	4770      	bx	lr
 80195cc:	2000000c 	.word	0x2000000c

080195d0 <_sbrk_r>:
 80195d0:	b538      	push	{r3, r4, r5, lr}
 80195d2:	4c06      	ldr	r4, [pc, #24]	; (80195ec <_sbrk_r+0x1c>)
 80195d4:	2300      	movs	r3, #0
 80195d6:	4605      	mov	r5, r0
 80195d8:	4608      	mov	r0, r1
 80195da:	6023      	str	r3, [r4, #0]
 80195dc:	f7e8 f906 	bl	80017ec <_sbrk>
 80195e0:	1c43      	adds	r3, r0, #1
 80195e2:	d102      	bne.n	80195ea <_sbrk_r+0x1a>
 80195e4:	6823      	ldr	r3, [r4, #0]
 80195e6:	b103      	cbz	r3, 80195ea <_sbrk_r+0x1a>
 80195e8:	602b      	str	r3, [r5, #0]
 80195ea:	bd38      	pop	{r3, r4, r5, pc}
 80195ec:	200006cc 	.word	0x200006cc

080195f0 <setvbuf>:
 80195f0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 80195f4:	461d      	mov	r5, r3
 80195f6:	4b51      	ldr	r3, [pc, #324]	; (801973c <setvbuf+0x14c>)
 80195f8:	681e      	ldr	r6, [r3, #0]
 80195fa:	4604      	mov	r4, r0
 80195fc:	460f      	mov	r7, r1
 80195fe:	4690      	mov	r8, r2
 8019600:	b126      	cbz	r6, 801960c <setvbuf+0x1c>
 8019602:	69b3      	ldr	r3, [r6, #24]
 8019604:	b913      	cbnz	r3, 801960c <setvbuf+0x1c>
 8019606:	4630      	mov	r0, r6
 8019608:	f000 fa5e 	bl	8019ac8 <__sinit>
 801960c:	4b4c      	ldr	r3, [pc, #304]	; (8019740 <setvbuf+0x150>)
 801960e:	429c      	cmp	r4, r3
 8019610:	d152      	bne.n	80196b8 <setvbuf+0xc8>
 8019612:	6874      	ldr	r4, [r6, #4]
 8019614:	f1b8 0f02 	cmp.w	r8, #2
 8019618:	d006      	beq.n	8019628 <setvbuf+0x38>
 801961a:	f1b8 0f01 	cmp.w	r8, #1
 801961e:	f200 8089 	bhi.w	8019734 <setvbuf+0x144>
 8019622:	2d00      	cmp	r5, #0
 8019624:	f2c0 8086 	blt.w	8019734 <setvbuf+0x144>
 8019628:	4621      	mov	r1, r4
 801962a:	4630      	mov	r0, r6
 801962c:	f000 f9e2 	bl	80199f4 <_fflush_r>
 8019630:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8019632:	b141      	cbz	r1, 8019646 <setvbuf+0x56>
 8019634:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8019638:	4299      	cmp	r1, r3
 801963a:	d002      	beq.n	8019642 <setvbuf+0x52>
 801963c:	4630      	mov	r0, r6
 801963e:	f7ff ff07 	bl	8019450 <_free_r>
 8019642:	2300      	movs	r3, #0
 8019644:	6363      	str	r3, [r4, #52]	; 0x34
 8019646:	2300      	movs	r3, #0
 8019648:	61a3      	str	r3, [r4, #24]
 801964a:	6063      	str	r3, [r4, #4]
 801964c:	89a3      	ldrh	r3, [r4, #12]
 801964e:	061b      	lsls	r3, r3, #24
 8019650:	d503      	bpl.n	801965a <setvbuf+0x6a>
 8019652:	6921      	ldr	r1, [r4, #16]
 8019654:	4630      	mov	r0, r6
 8019656:	f7ff fefb 	bl	8019450 <_free_r>
 801965a:	89a3      	ldrh	r3, [r4, #12]
 801965c:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
 8019660:	f023 0303 	bic.w	r3, r3, #3
 8019664:	f1b8 0f02 	cmp.w	r8, #2
 8019668:	81a3      	strh	r3, [r4, #12]
 801966a:	d05d      	beq.n	8019728 <setvbuf+0x138>
 801966c:	ab01      	add	r3, sp, #4
 801966e:	466a      	mov	r2, sp
 8019670:	4621      	mov	r1, r4
 8019672:	4630      	mov	r0, r6
 8019674:	f000 fab2 	bl	8019bdc <__swhatbuf_r>
 8019678:	89a3      	ldrh	r3, [r4, #12]
 801967a:	4318      	orrs	r0, r3
 801967c:	81a0      	strh	r0, [r4, #12]
 801967e:	bb2d      	cbnz	r5, 80196cc <setvbuf+0xdc>
 8019680:	9d00      	ldr	r5, [sp, #0]
 8019682:	4628      	mov	r0, r5
 8019684:	f7ff fe86 	bl	8019394 <malloc>
 8019688:	4607      	mov	r7, r0
 801968a:	2800      	cmp	r0, #0
 801968c:	d14e      	bne.n	801972c <setvbuf+0x13c>
 801968e:	f8dd 9000 	ldr.w	r9, [sp]
 8019692:	45a9      	cmp	r9, r5
 8019694:	d13c      	bne.n	8019710 <setvbuf+0x120>
 8019696:	f04f 30ff 	mov.w	r0, #4294967295
 801969a:	89a3      	ldrh	r3, [r4, #12]
 801969c:	f043 0302 	orr.w	r3, r3, #2
 80196a0:	81a3      	strh	r3, [r4, #12]
 80196a2:	2300      	movs	r3, #0
 80196a4:	60a3      	str	r3, [r4, #8]
 80196a6:	f104 0347 	add.w	r3, r4, #71	; 0x47
 80196aa:	6023      	str	r3, [r4, #0]
 80196ac:	6123      	str	r3, [r4, #16]
 80196ae:	2301      	movs	r3, #1
 80196b0:	6163      	str	r3, [r4, #20]
 80196b2:	b003      	add	sp, #12
 80196b4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80196b8:	4b22      	ldr	r3, [pc, #136]	; (8019744 <setvbuf+0x154>)
 80196ba:	429c      	cmp	r4, r3
 80196bc:	d101      	bne.n	80196c2 <setvbuf+0xd2>
 80196be:	68b4      	ldr	r4, [r6, #8]
 80196c0:	e7a8      	b.n	8019614 <setvbuf+0x24>
 80196c2:	4b21      	ldr	r3, [pc, #132]	; (8019748 <setvbuf+0x158>)
 80196c4:	429c      	cmp	r4, r3
 80196c6:	bf08      	it	eq
 80196c8:	68f4      	ldreq	r4, [r6, #12]
 80196ca:	e7a3      	b.n	8019614 <setvbuf+0x24>
 80196cc:	2f00      	cmp	r7, #0
 80196ce:	d0d8      	beq.n	8019682 <setvbuf+0x92>
 80196d0:	69b3      	ldr	r3, [r6, #24]
 80196d2:	b913      	cbnz	r3, 80196da <setvbuf+0xea>
 80196d4:	4630      	mov	r0, r6
 80196d6:	f000 f9f7 	bl	8019ac8 <__sinit>
 80196da:	f1b8 0f01 	cmp.w	r8, #1
 80196de:	bf08      	it	eq
 80196e0:	89a3      	ldrheq	r3, [r4, #12]
 80196e2:	6027      	str	r7, [r4, #0]
 80196e4:	bf04      	itt	eq
 80196e6:	f043 0301 	orreq.w	r3, r3, #1
 80196ea:	81a3      	strheq	r3, [r4, #12]
 80196ec:	89a3      	ldrh	r3, [r4, #12]
 80196ee:	f013 0008 	ands.w	r0, r3, #8
 80196f2:	e9c4 7504 	strd	r7, r5, [r4, #16]
 80196f6:	d01b      	beq.n	8019730 <setvbuf+0x140>
 80196f8:	f013 0001 	ands.w	r0, r3, #1
 80196fc:	bf18      	it	ne
 80196fe:	426d      	negne	r5, r5
 8019700:	f04f 0300 	mov.w	r3, #0
 8019704:	bf1d      	ittte	ne
 8019706:	60a3      	strne	r3, [r4, #8]
 8019708:	61a5      	strne	r5, [r4, #24]
 801970a:	4618      	movne	r0, r3
 801970c:	60a5      	streq	r5, [r4, #8]
 801970e:	e7d0      	b.n	80196b2 <setvbuf+0xc2>
 8019710:	4648      	mov	r0, r9
 8019712:	f7ff fe3f 	bl	8019394 <malloc>
 8019716:	4607      	mov	r7, r0
 8019718:	2800      	cmp	r0, #0
 801971a:	d0bc      	beq.n	8019696 <setvbuf+0xa6>
 801971c:	89a3      	ldrh	r3, [r4, #12]
 801971e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8019722:	81a3      	strh	r3, [r4, #12]
 8019724:	464d      	mov	r5, r9
 8019726:	e7d3      	b.n	80196d0 <setvbuf+0xe0>
 8019728:	2000      	movs	r0, #0
 801972a:	e7b6      	b.n	801969a <setvbuf+0xaa>
 801972c:	46a9      	mov	r9, r5
 801972e:	e7f5      	b.n	801971c <setvbuf+0x12c>
 8019730:	60a0      	str	r0, [r4, #8]
 8019732:	e7be      	b.n	80196b2 <setvbuf+0xc2>
 8019734:	f04f 30ff 	mov.w	r0, #4294967295
 8019738:	e7bb      	b.n	80196b2 <setvbuf+0xc2>
 801973a:	bf00      	nop
 801973c:	2000000c 	.word	0x2000000c
 8019740:	0801b5a8 	.word	0x0801b5a8
 8019744:	0801b5c8 	.word	0x0801b5c8
 8019748:	0801b588 	.word	0x0801b588

0801974c <__swbuf_r>:
 801974c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801974e:	460e      	mov	r6, r1
 8019750:	4614      	mov	r4, r2
 8019752:	4605      	mov	r5, r0
 8019754:	b118      	cbz	r0, 801975e <__swbuf_r+0x12>
 8019756:	6983      	ldr	r3, [r0, #24]
 8019758:	b90b      	cbnz	r3, 801975e <__swbuf_r+0x12>
 801975a:	f000 f9b5 	bl	8019ac8 <__sinit>
 801975e:	4b21      	ldr	r3, [pc, #132]	; (80197e4 <__swbuf_r+0x98>)
 8019760:	429c      	cmp	r4, r3
 8019762:	d12a      	bne.n	80197ba <__swbuf_r+0x6e>
 8019764:	686c      	ldr	r4, [r5, #4]
 8019766:	69a3      	ldr	r3, [r4, #24]
 8019768:	60a3      	str	r3, [r4, #8]
 801976a:	89a3      	ldrh	r3, [r4, #12]
 801976c:	071a      	lsls	r2, r3, #28
 801976e:	d52e      	bpl.n	80197ce <__swbuf_r+0x82>
 8019770:	6923      	ldr	r3, [r4, #16]
 8019772:	b363      	cbz	r3, 80197ce <__swbuf_r+0x82>
 8019774:	6923      	ldr	r3, [r4, #16]
 8019776:	6820      	ldr	r0, [r4, #0]
 8019778:	1ac0      	subs	r0, r0, r3
 801977a:	6963      	ldr	r3, [r4, #20]
 801977c:	b2f6      	uxtb	r6, r6
 801977e:	4283      	cmp	r3, r0
 8019780:	4637      	mov	r7, r6
 8019782:	dc04      	bgt.n	801978e <__swbuf_r+0x42>
 8019784:	4621      	mov	r1, r4
 8019786:	4628      	mov	r0, r5
 8019788:	f000 f934 	bl	80199f4 <_fflush_r>
 801978c:	bb28      	cbnz	r0, 80197da <__swbuf_r+0x8e>
 801978e:	68a3      	ldr	r3, [r4, #8]
 8019790:	3b01      	subs	r3, #1
 8019792:	60a3      	str	r3, [r4, #8]
 8019794:	6823      	ldr	r3, [r4, #0]
 8019796:	1c5a      	adds	r2, r3, #1
 8019798:	6022      	str	r2, [r4, #0]
 801979a:	701e      	strb	r6, [r3, #0]
 801979c:	6963      	ldr	r3, [r4, #20]
 801979e:	3001      	adds	r0, #1
 80197a0:	4283      	cmp	r3, r0
 80197a2:	d004      	beq.n	80197ae <__swbuf_r+0x62>
 80197a4:	89a3      	ldrh	r3, [r4, #12]
 80197a6:	07db      	lsls	r3, r3, #31
 80197a8:	d519      	bpl.n	80197de <__swbuf_r+0x92>
 80197aa:	2e0a      	cmp	r6, #10
 80197ac:	d117      	bne.n	80197de <__swbuf_r+0x92>
 80197ae:	4621      	mov	r1, r4
 80197b0:	4628      	mov	r0, r5
 80197b2:	f000 f91f 	bl	80199f4 <_fflush_r>
 80197b6:	b190      	cbz	r0, 80197de <__swbuf_r+0x92>
 80197b8:	e00f      	b.n	80197da <__swbuf_r+0x8e>
 80197ba:	4b0b      	ldr	r3, [pc, #44]	; (80197e8 <__swbuf_r+0x9c>)
 80197bc:	429c      	cmp	r4, r3
 80197be:	d101      	bne.n	80197c4 <__swbuf_r+0x78>
 80197c0:	68ac      	ldr	r4, [r5, #8]
 80197c2:	e7d0      	b.n	8019766 <__swbuf_r+0x1a>
 80197c4:	4b09      	ldr	r3, [pc, #36]	; (80197ec <__swbuf_r+0xa0>)
 80197c6:	429c      	cmp	r4, r3
 80197c8:	bf08      	it	eq
 80197ca:	68ec      	ldreq	r4, [r5, #12]
 80197cc:	e7cb      	b.n	8019766 <__swbuf_r+0x1a>
 80197ce:	4621      	mov	r1, r4
 80197d0:	4628      	mov	r0, r5
 80197d2:	f000 f81b 	bl	801980c <__swsetup_r>
 80197d6:	2800      	cmp	r0, #0
 80197d8:	d0cc      	beq.n	8019774 <__swbuf_r+0x28>
 80197da:	f04f 37ff 	mov.w	r7, #4294967295
 80197de:	4638      	mov	r0, r7
 80197e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80197e2:	bf00      	nop
 80197e4:	0801b5a8 	.word	0x0801b5a8
 80197e8:	0801b5c8 	.word	0x0801b5c8
 80197ec:	0801b588 	.word	0x0801b588

080197f0 <__ascii_wctomb>:
 80197f0:	b149      	cbz	r1, 8019806 <__ascii_wctomb+0x16>
 80197f2:	2aff      	cmp	r2, #255	; 0xff
 80197f4:	bf85      	ittet	hi
 80197f6:	238a      	movhi	r3, #138	; 0x8a
 80197f8:	6003      	strhi	r3, [r0, #0]
 80197fa:	700a      	strbls	r2, [r1, #0]
 80197fc:	f04f 30ff 	movhi.w	r0, #4294967295
 8019800:	bf98      	it	ls
 8019802:	2001      	movls	r0, #1
 8019804:	4770      	bx	lr
 8019806:	4608      	mov	r0, r1
 8019808:	4770      	bx	lr
	...

0801980c <__swsetup_r>:
 801980c:	4b32      	ldr	r3, [pc, #200]	; (80198d8 <__swsetup_r+0xcc>)
 801980e:	b570      	push	{r4, r5, r6, lr}
 8019810:	681d      	ldr	r5, [r3, #0]
 8019812:	4606      	mov	r6, r0
 8019814:	460c      	mov	r4, r1
 8019816:	b125      	cbz	r5, 8019822 <__swsetup_r+0x16>
 8019818:	69ab      	ldr	r3, [r5, #24]
 801981a:	b913      	cbnz	r3, 8019822 <__swsetup_r+0x16>
 801981c:	4628      	mov	r0, r5
 801981e:	f000 f953 	bl	8019ac8 <__sinit>
 8019822:	4b2e      	ldr	r3, [pc, #184]	; (80198dc <__swsetup_r+0xd0>)
 8019824:	429c      	cmp	r4, r3
 8019826:	d10f      	bne.n	8019848 <__swsetup_r+0x3c>
 8019828:	686c      	ldr	r4, [r5, #4]
 801982a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801982e:	b29a      	uxth	r2, r3
 8019830:	0715      	lsls	r5, r2, #28
 8019832:	d42c      	bmi.n	801988e <__swsetup_r+0x82>
 8019834:	06d0      	lsls	r0, r2, #27
 8019836:	d411      	bmi.n	801985c <__swsetup_r+0x50>
 8019838:	2209      	movs	r2, #9
 801983a:	6032      	str	r2, [r6, #0]
 801983c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8019840:	81a3      	strh	r3, [r4, #12]
 8019842:	f04f 30ff 	mov.w	r0, #4294967295
 8019846:	e03e      	b.n	80198c6 <__swsetup_r+0xba>
 8019848:	4b25      	ldr	r3, [pc, #148]	; (80198e0 <__swsetup_r+0xd4>)
 801984a:	429c      	cmp	r4, r3
 801984c:	d101      	bne.n	8019852 <__swsetup_r+0x46>
 801984e:	68ac      	ldr	r4, [r5, #8]
 8019850:	e7eb      	b.n	801982a <__swsetup_r+0x1e>
 8019852:	4b24      	ldr	r3, [pc, #144]	; (80198e4 <__swsetup_r+0xd8>)
 8019854:	429c      	cmp	r4, r3
 8019856:	bf08      	it	eq
 8019858:	68ec      	ldreq	r4, [r5, #12]
 801985a:	e7e6      	b.n	801982a <__swsetup_r+0x1e>
 801985c:	0751      	lsls	r1, r2, #29
 801985e:	d512      	bpl.n	8019886 <__swsetup_r+0x7a>
 8019860:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8019862:	b141      	cbz	r1, 8019876 <__swsetup_r+0x6a>
 8019864:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8019868:	4299      	cmp	r1, r3
 801986a:	d002      	beq.n	8019872 <__swsetup_r+0x66>
 801986c:	4630      	mov	r0, r6
 801986e:	f7ff fdef 	bl	8019450 <_free_r>
 8019872:	2300      	movs	r3, #0
 8019874:	6363      	str	r3, [r4, #52]	; 0x34
 8019876:	89a3      	ldrh	r3, [r4, #12]
 8019878:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 801987c:	81a3      	strh	r3, [r4, #12]
 801987e:	2300      	movs	r3, #0
 8019880:	6063      	str	r3, [r4, #4]
 8019882:	6923      	ldr	r3, [r4, #16]
 8019884:	6023      	str	r3, [r4, #0]
 8019886:	89a3      	ldrh	r3, [r4, #12]
 8019888:	f043 0308 	orr.w	r3, r3, #8
 801988c:	81a3      	strh	r3, [r4, #12]
 801988e:	6923      	ldr	r3, [r4, #16]
 8019890:	b94b      	cbnz	r3, 80198a6 <__swsetup_r+0x9a>
 8019892:	89a3      	ldrh	r3, [r4, #12]
 8019894:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8019898:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801989c:	d003      	beq.n	80198a6 <__swsetup_r+0x9a>
 801989e:	4621      	mov	r1, r4
 80198a0:	4630      	mov	r0, r6
 80198a2:	f000 f9bf 	bl	8019c24 <__smakebuf_r>
 80198a6:	89a2      	ldrh	r2, [r4, #12]
 80198a8:	f012 0301 	ands.w	r3, r2, #1
 80198ac:	d00c      	beq.n	80198c8 <__swsetup_r+0xbc>
 80198ae:	2300      	movs	r3, #0
 80198b0:	60a3      	str	r3, [r4, #8]
 80198b2:	6963      	ldr	r3, [r4, #20]
 80198b4:	425b      	negs	r3, r3
 80198b6:	61a3      	str	r3, [r4, #24]
 80198b8:	6923      	ldr	r3, [r4, #16]
 80198ba:	b953      	cbnz	r3, 80198d2 <__swsetup_r+0xc6>
 80198bc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80198c0:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 80198c4:	d1ba      	bne.n	801983c <__swsetup_r+0x30>
 80198c6:	bd70      	pop	{r4, r5, r6, pc}
 80198c8:	0792      	lsls	r2, r2, #30
 80198ca:	bf58      	it	pl
 80198cc:	6963      	ldrpl	r3, [r4, #20]
 80198ce:	60a3      	str	r3, [r4, #8]
 80198d0:	e7f2      	b.n	80198b8 <__swsetup_r+0xac>
 80198d2:	2000      	movs	r0, #0
 80198d4:	e7f7      	b.n	80198c6 <__swsetup_r+0xba>
 80198d6:	bf00      	nop
 80198d8:	2000000c 	.word	0x2000000c
 80198dc:	0801b5a8 	.word	0x0801b5a8
 80198e0:	0801b5c8 	.word	0x0801b5c8
 80198e4:	0801b588 	.word	0x0801b588

080198e8 <__sflush_r>:
 80198e8:	898a      	ldrh	r2, [r1, #12]
 80198ea:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80198ee:	4605      	mov	r5, r0
 80198f0:	0710      	lsls	r0, r2, #28
 80198f2:	460c      	mov	r4, r1
 80198f4:	d458      	bmi.n	80199a8 <__sflush_r+0xc0>
 80198f6:	684b      	ldr	r3, [r1, #4]
 80198f8:	2b00      	cmp	r3, #0
 80198fa:	dc05      	bgt.n	8019908 <__sflush_r+0x20>
 80198fc:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 80198fe:	2b00      	cmp	r3, #0
 8019900:	dc02      	bgt.n	8019908 <__sflush_r+0x20>
 8019902:	2000      	movs	r0, #0
 8019904:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8019908:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 801990a:	2e00      	cmp	r6, #0
 801990c:	d0f9      	beq.n	8019902 <__sflush_r+0x1a>
 801990e:	2300      	movs	r3, #0
 8019910:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8019914:	682f      	ldr	r7, [r5, #0]
 8019916:	6a21      	ldr	r1, [r4, #32]
 8019918:	602b      	str	r3, [r5, #0]
 801991a:	d032      	beq.n	8019982 <__sflush_r+0x9a>
 801991c:	6d60      	ldr	r0, [r4, #84]	; 0x54
 801991e:	89a3      	ldrh	r3, [r4, #12]
 8019920:	075a      	lsls	r2, r3, #29
 8019922:	d505      	bpl.n	8019930 <__sflush_r+0x48>
 8019924:	6863      	ldr	r3, [r4, #4]
 8019926:	1ac0      	subs	r0, r0, r3
 8019928:	6b63      	ldr	r3, [r4, #52]	; 0x34
 801992a:	b10b      	cbz	r3, 8019930 <__sflush_r+0x48>
 801992c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 801992e:	1ac0      	subs	r0, r0, r3
 8019930:	2300      	movs	r3, #0
 8019932:	4602      	mov	r2, r0
 8019934:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8019936:	6a21      	ldr	r1, [r4, #32]
 8019938:	4628      	mov	r0, r5
 801993a:	47b0      	blx	r6
 801993c:	1c43      	adds	r3, r0, #1
 801993e:	89a3      	ldrh	r3, [r4, #12]
 8019940:	d106      	bne.n	8019950 <__sflush_r+0x68>
 8019942:	6829      	ldr	r1, [r5, #0]
 8019944:	291d      	cmp	r1, #29
 8019946:	d848      	bhi.n	80199da <__sflush_r+0xf2>
 8019948:	4a29      	ldr	r2, [pc, #164]	; (80199f0 <__sflush_r+0x108>)
 801994a:	40ca      	lsrs	r2, r1
 801994c:	07d6      	lsls	r6, r2, #31
 801994e:	d544      	bpl.n	80199da <__sflush_r+0xf2>
 8019950:	2200      	movs	r2, #0
 8019952:	6062      	str	r2, [r4, #4]
 8019954:	04d9      	lsls	r1, r3, #19
 8019956:	6922      	ldr	r2, [r4, #16]
 8019958:	6022      	str	r2, [r4, #0]
 801995a:	d504      	bpl.n	8019966 <__sflush_r+0x7e>
 801995c:	1c42      	adds	r2, r0, #1
 801995e:	d101      	bne.n	8019964 <__sflush_r+0x7c>
 8019960:	682b      	ldr	r3, [r5, #0]
 8019962:	b903      	cbnz	r3, 8019966 <__sflush_r+0x7e>
 8019964:	6560      	str	r0, [r4, #84]	; 0x54
 8019966:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8019968:	602f      	str	r7, [r5, #0]
 801996a:	2900      	cmp	r1, #0
 801996c:	d0c9      	beq.n	8019902 <__sflush_r+0x1a>
 801996e:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8019972:	4299      	cmp	r1, r3
 8019974:	d002      	beq.n	801997c <__sflush_r+0x94>
 8019976:	4628      	mov	r0, r5
 8019978:	f7ff fd6a 	bl	8019450 <_free_r>
 801997c:	2000      	movs	r0, #0
 801997e:	6360      	str	r0, [r4, #52]	; 0x34
 8019980:	e7c0      	b.n	8019904 <__sflush_r+0x1c>
 8019982:	2301      	movs	r3, #1
 8019984:	4628      	mov	r0, r5
 8019986:	47b0      	blx	r6
 8019988:	1c41      	adds	r1, r0, #1
 801998a:	d1c8      	bne.n	801991e <__sflush_r+0x36>
 801998c:	682b      	ldr	r3, [r5, #0]
 801998e:	2b00      	cmp	r3, #0
 8019990:	d0c5      	beq.n	801991e <__sflush_r+0x36>
 8019992:	2b1d      	cmp	r3, #29
 8019994:	d001      	beq.n	801999a <__sflush_r+0xb2>
 8019996:	2b16      	cmp	r3, #22
 8019998:	d101      	bne.n	801999e <__sflush_r+0xb6>
 801999a:	602f      	str	r7, [r5, #0]
 801999c:	e7b1      	b.n	8019902 <__sflush_r+0x1a>
 801999e:	89a3      	ldrh	r3, [r4, #12]
 80199a0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80199a4:	81a3      	strh	r3, [r4, #12]
 80199a6:	e7ad      	b.n	8019904 <__sflush_r+0x1c>
 80199a8:	690f      	ldr	r7, [r1, #16]
 80199aa:	2f00      	cmp	r7, #0
 80199ac:	d0a9      	beq.n	8019902 <__sflush_r+0x1a>
 80199ae:	0793      	lsls	r3, r2, #30
 80199b0:	680e      	ldr	r6, [r1, #0]
 80199b2:	bf08      	it	eq
 80199b4:	694b      	ldreq	r3, [r1, #20]
 80199b6:	600f      	str	r7, [r1, #0]
 80199b8:	bf18      	it	ne
 80199ba:	2300      	movne	r3, #0
 80199bc:	eba6 0807 	sub.w	r8, r6, r7
 80199c0:	608b      	str	r3, [r1, #8]
 80199c2:	f1b8 0f00 	cmp.w	r8, #0
 80199c6:	dd9c      	ble.n	8019902 <__sflush_r+0x1a>
 80199c8:	4643      	mov	r3, r8
 80199ca:	463a      	mov	r2, r7
 80199cc:	6a21      	ldr	r1, [r4, #32]
 80199ce:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 80199d0:	4628      	mov	r0, r5
 80199d2:	47b0      	blx	r6
 80199d4:	2800      	cmp	r0, #0
 80199d6:	dc06      	bgt.n	80199e6 <__sflush_r+0xfe>
 80199d8:	89a3      	ldrh	r3, [r4, #12]
 80199da:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80199de:	81a3      	strh	r3, [r4, #12]
 80199e0:	f04f 30ff 	mov.w	r0, #4294967295
 80199e4:	e78e      	b.n	8019904 <__sflush_r+0x1c>
 80199e6:	4407      	add	r7, r0
 80199e8:	eba8 0800 	sub.w	r8, r8, r0
 80199ec:	e7e9      	b.n	80199c2 <__sflush_r+0xda>
 80199ee:	bf00      	nop
 80199f0:	20400001 	.word	0x20400001

080199f4 <_fflush_r>:
 80199f4:	b538      	push	{r3, r4, r5, lr}
 80199f6:	690b      	ldr	r3, [r1, #16]
 80199f8:	4605      	mov	r5, r0
 80199fa:	460c      	mov	r4, r1
 80199fc:	b1db      	cbz	r3, 8019a36 <_fflush_r+0x42>
 80199fe:	b118      	cbz	r0, 8019a08 <_fflush_r+0x14>
 8019a00:	6983      	ldr	r3, [r0, #24]
 8019a02:	b90b      	cbnz	r3, 8019a08 <_fflush_r+0x14>
 8019a04:	f000 f860 	bl	8019ac8 <__sinit>
 8019a08:	4b0c      	ldr	r3, [pc, #48]	; (8019a3c <_fflush_r+0x48>)
 8019a0a:	429c      	cmp	r4, r3
 8019a0c:	d109      	bne.n	8019a22 <_fflush_r+0x2e>
 8019a0e:	686c      	ldr	r4, [r5, #4]
 8019a10:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8019a14:	b17b      	cbz	r3, 8019a36 <_fflush_r+0x42>
 8019a16:	4621      	mov	r1, r4
 8019a18:	4628      	mov	r0, r5
 8019a1a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8019a1e:	f7ff bf63 	b.w	80198e8 <__sflush_r>
 8019a22:	4b07      	ldr	r3, [pc, #28]	; (8019a40 <_fflush_r+0x4c>)
 8019a24:	429c      	cmp	r4, r3
 8019a26:	d101      	bne.n	8019a2c <_fflush_r+0x38>
 8019a28:	68ac      	ldr	r4, [r5, #8]
 8019a2a:	e7f1      	b.n	8019a10 <_fflush_r+0x1c>
 8019a2c:	4b05      	ldr	r3, [pc, #20]	; (8019a44 <_fflush_r+0x50>)
 8019a2e:	429c      	cmp	r4, r3
 8019a30:	bf08      	it	eq
 8019a32:	68ec      	ldreq	r4, [r5, #12]
 8019a34:	e7ec      	b.n	8019a10 <_fflush_r+0x1c>
 8019a36:	2000      	movs	r0, #0
 8019a38:	bd38      	pop	{r3, r4, r5, pc}
 8019a3a:	bf00      	nop
 8019a3c:	0801b5a8 	.word	0x0801b5a8
 8019a40:	0801b5c8 	.word	0x0801b5c8
 8019a44:	0801b588 	.word	0x0801b588

08019a48 <std>:
 8019a48:	2300      	movs	r3, #0
 8019a4a:	b510      	push	{r4, lr}
 8019a4c:	4604      	mov	r4, r0
 8019a4e:	e9c0 3300 	strd	r3, r3, [r0]
 8019a52:	6083      	str	r3, [r0, #8]
 8019a54:	8181      	strh	r1, [r0, #12]
 8019a56:	6643      	str	r3, [r0, #100]	; 0x64
 8019a58:	81c2      	strh	r2, [r0, #14]
 8019a5a:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8019a5e:	6183      	str	r3, [r0, #24]
 8019a60:	4619      	mov	r1, r3
 8019a62:	2208      	movs	r2, #8
 8019a64:	305c      	adds	r0, #92	; 0x5c
 8019a66:	f7ff fcea 	bl	801943e <memset>
 8019a6a:	4b05      	ldr	r3, [pc, #20]	; (8019a80 <std+0x38>)
 8019a6c:	6263      	str	r3, [r4, #36]	; 0x24
 8019a6e:	4b05      	ldr	r3, [pc, #20]	; (8019a84 <std+0x3c>)
 8019a70:	62a3      	str	r3, [r4, #40]	; 0x28
 8019a72:	4b05      	ldr	r3, [pc, #20]	; (8019a88 <std+0x40>)
 8019a74:	62e3      	str	r3, [r4, #44]	; 0x2c
 8019a76:	4b05      	ldr	r3, [pc, #20]	; (8019a8c <std+0x44>)
 8019a78:	6224      	str	r4, [r4, #32]
 8019a7a:	6323      	str	r3, [r4, #48]	; 0x30
 8019a7c:	bd10      	pop	{r4, pc}
 8019a7e:	bf00      	nop
 8019a80:	0801a239 	.word	0x0801a239
 8019a84:	0801a25b 	.word	0x0801a25b
 8019a88:	0801a293 	.word	0x0801a293
 8019a8c:	0801a2b7 	.word	0x0801a2b7

08019a90 <_cleanup_r>:
 8019a90:	4901      	ldr	r1, [pc, #4]	; (8019a98 <_cleanup_r+0x8>)
 8019a92:	f000 b885 	b.w	8019ba0 <_fwalk_reent>
 8019a96:	bf00      	nop
 8019a98:	080199f5 	.word	0x080199f5

08019a9c <__sfmoreglue>:
 8019a9c:	b570      	push	{r4, r5, r6, lr}
 8019a9e:	1e4a      	subs	r2, r1, #1
 8019aa0:	2568      	movs	r5, #104	; 0x68
 8019aa2:	4355      	muls	r5, r2
 8019aa4:	460e      	mov	r6, r1
 8019aa6:	f105 0174 	add.w	r1, r5, #116	; 0x74
 8019aaa:	f7ff fd1f 	bl	80194ec <_malloc_r>
 8019aae:	4604      	mov	r4, r0
 8019ab0:	b140      	cbz	r0, 8019ac4 <__sfmoreglue+0x28>
 8019ab2:	2100      	movs	r1, #0
 8019ab4:	e9c0 1600 	strd	r1, r6, [r0]
 8019ab8:	300c      	adds	r0, #12
 8019aba:	60a0      	str	r0, [r4, #8]
 8019abc:	f105 0268 	add.w	r2, r5, #104	; 0x68
 8019ac0:	f7ff fcbd 	bl	801943e <memset>
 8019ac4:	4620      	mov	r0, r4
 8019ac6:	bd70      	pop	{r4, r5, r6, pc}

08019ac8 <__sinit>:
 8019ac8:	6983      	ldr	r3, [r0, #24]
 8019aca:	b510      	push	{r4, lr}
 8019acc:	4604      	mov	r4, r0
 8019ace:	bb33      	cbnz	r3, 8019b1e <__sinit+0x56>
 8019ad0:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
 8019ad4:	6503      	str	r3, [r0, #80]	; 0x50
 8019ad6:	4b12      	ldr	r3, [pc, #72]	; (8019b20 <__sinit+0x58>)
 8019ad8:	4a12      	ldr	r2, [pc, #72]	; (8019b24 <__sinit+0x5c>)
 8019ada:	681b      	ldr	r3, [r3, #0]
 8019adc:	6282      	str	r2, [r0, #40]	; 0x28
 8019ade:	4298      	cmp	r0, r3
 8019ae0:	bf04      	itt	eq
 8019ae2:	2301      	moveq	r3, #1
 8019ae4:	6183      	streq	r3, [r0, #24]
 8019ae6:	f000 f81f 	bl	8019b28 <__sfp>
 8019aea:	6060      	str	r0, [r4, #4]
 8019aec:	4620      	mov	r0, r4
 8019aee:	f000 f81b 	bl	8019b28 <__sfp>
 8019af2:	60a0      	str	r0, [r4, #8]
 8019af4:	4620      	mov	r0, r4
 8019af6:	f000 f817 	bl	8019b28 <__sfp>
 8019afa:	2200      	movs	r2, #0
 8019afc:	60e0      	str	r0, [r4, #12]
 8019afe:	2104      	movs	r1, #4
 8019b00:	6860      	ldr	r0, [r4, #4]
 8019b02:	f7ff ffa1 	bl	8019a48 <std>
 8019b06:	2201      	movs	r2, #1
 8019b08:	2109      	movs	r1, #9
 8019b0a:	68a0      	ldr	r0, [r4, #8]
 8019b0c:	f7ff ff9c 	bl	8019a48 <std>
 8019b10:	2202      	movs	r2, #2
 8019b12:	2112      	movs	r1, #18
 8019b14:	68e0      	ldr	r0, [r4, #12]
 8019b16:	f7ff ff97 	bl	8019a48 <std>
 8019b1a:	2301      	movs	r3, #1
 8019b1c:	61a3      	str	r3, [r4, #24]
 8019b1e:	bd10      	pop	{r4, pc}
 8019b20:	0801b478 	.word	0x0801b478
 8019b24:	08019a91 	.word	0x08019a91

08019b28 <__sfp>:
 8019b28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8019b2a:	4b1b      	ldr	r3, [pc, #108]	; (8019b98 <__sfp+0x70>)
 8019b2c:	681e      	ldr	r6, [r3, #0]
 8019b2e:	69b3      	ldr	r3, [r6, #24]
 8019b30:	4607      	mov	r7, r0
 8019b32:	b913      	cbnz	r3, 8019b3a <__sfp+0x12>
 8019b34:	4630      	mov	r0, r6
 8019b36:	f7ff ffc7 	bl	8019ac8 <__sinit>
 8019b3a:	3648      	adds	r6, #72	; 0x48
 8019b3c:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 8019b40:	3b01      	subs	r3, #1
 8019b42:	d503      	bpl.n	8019b4c <__sfp+0x24>
 8019b44:	6833      	ldr	r3, [r6, #0]
 8019b46:	b133      	cbz	r3, 8019b56 <__sfp+0x2e>
 8019b48:	6836      	ldr	r6, [r6, #0]
 8019b4a:	e7f7      	b.n	8019b3c <__sfp+0x14>
 8019b4c:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 8019b50:	b16d      	cbz	r5, 8019b6e <__sfp+0x46>
 8019b52:	3468      	adds	r4, #104	; 0x68
 8019b54:	e7f4      	b.n	8019b40 <__sfp+0x18>
 8019b56:	2104      	movs	r1, #4
 8019b58:	4638      	mov	r0, r7
 8019b5a:	f7ff ff9f 	bl	8019a9c <__sfmoreglue>
 8019b5e:	6030      	str	r0, [r6, #0]
 8019b60:	2800      	cmp	r0, #0
 8019b62:	d1f1      	bne.n	8019b48 <__sfp+0x20>
 8019b64:	230c      	movs	r3, #12
 8019b66:	603b      	str	r3, [r7, #0]
 8019b68:	4604      	mov	r4, r0
 8019b6a:	4620      	mov	r0, r4
 8019b6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8019b6e:	4b0b      	ldr	r3, [pc, #44]	; (8019b9c <__sfp+0x74>)
 8019b70:	6665      	str	r5, [r4, #100]	; 0x64
 8019b72:	e9c4 5500 	strd	r5, r5, [r4]
 8019b76:	60a5      	str	r5, [r4, #8]
 8019b78:	e9c4 3503 	strd	r3, r5, [r4, #12]
 8019b7c:	e9c4 5505 	strd	r5, r5, [r4, #20]
 8019b80:	2208      	movs	r2, #8
 8019b82:	4629      	mov	r1, r5
 8019b84:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8019b88:	f7ff fc59 	bl	801943e <memset>
 8019b8c:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 8019b90:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 8019b94:	e7e9      	b.n	8019b6a <__sfp+0x42>
 8019b96:	bf00      	nop
 8019b98:	0801b478 	.word	0x0801b478
 8019b9c:	ffff0001 	.word	0xffff0001

08019ba0 <_fwalk_reent>:
 8019ba0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8019ba4:	4680      	mov	r8, r0
 8019ba6:	4689      	mov	r9, r1
 8019ba8:	f100 0448 	add.w	r4, r0, #72	; 0x48
 8019bac:	2600      	movs	r6, #0
 8019bae:	b914      	cbnz	r4, 8019bb6 <_fwalk_reent+0x16>
 8019bb0:	4630      	mov	r0, r6
 8019bb2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8019bb6:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
 8019bba:	3f01      	subs	r7, #1
 8019bbc:	d501      	bpl.n	8019bc2 <_fwalk_reent+0x22>
 8019bbe:	6824      	ldr	r4, [r4, #0]
 8019bc0:	e7f5      	b.n	8019bae <_fwalk_reent+0xe>
 8019bc2:	89ab      	ldrh	r3, [r5, #12]
 8019bc4:	2b01      	cmp	r3, #1
 8019bc6:	d907      	bls.n	8019bd8 <_fwalk_reent+0x38>
 8019bc8:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8019bcc:	3301      	adds	r3, #1
 8019bce:	d003      	beq.n	8019bd8 <_fwalk_reent+0x38>
 8019bd0:	4629      	mov	r1, r5
 8019bd2:	4640      	mov	r0, r8
 8019bd4:	47c8      	blx	r9
 8019bd6:	4306      	orrs	r6, r0
 8019bd8:	3568      	adds	r5, #104	; 0x68
 8019bda:	e7ee      	b.n	8019bba <_fwalk_reent+0x1a>

08019bdc <__swhatbuf_r>:
 8019bdc:	b570      	push	{r4, r5, r6, lr}
 8019bde:	460e      	mov	r6, r1
 8019be0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8019be4:	2900      	cmp	r1, #0
 8019be6:	b096      	sub	sp, #88	; 0x58
 8019be8:	4614      	mov	r4, r2
 8019bea:	461d      	mov	r5, r3
 8019bec:	da07      	bge.n	8019bfe <__swhatbuf_r+0x22>
 8019bee:	2300      	movs	r3, #0
 8019bf0:	602b      	str	r3, [r5, #0]
 8019bf2:	89b3      	ldrh	r3, [r6, #12]
 8019bf4:	061a      	lsls	r2, r3, #24
 8019bf6:	d410      	bmi.n	8019c1a <__swhatbuf_r+0x3e>
 8019bf8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8019bfc:	e00e      	b.n	8019c1c <__swhatbuf_r+0x40>
 8019bfe:	466a      	mov	r2, sp
 8019c00:	f000 fb80 	bl	801a304 <_fstat_r>
 8019c04:	2800      	cmp	r0, #0
 8019c06:	dbf2      	blt.n	8019bee <__swhatbuf_r+0x12>
 8019c08:	9a01      	ldr	r2, [sp, #4]
 8019c0a:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 8019c0e:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 8019c12:	425a      	negs	r2, r3
 8019c14:	415a      	adcs	r2, r3
 8019c16:	602a      	str	r2, [r5, #0]
 8019c18:	e7ee      	b.n	8019bf8 <__swhatbuf_r+0x1c>
 8019c1a:	2340      	movs	r3, #64	; 0x40
 8019c1c:	2000      	movs	r0, #0
 8019c1e:	6023      	str	r3, [r4, #0]
 8019c20:	b016      	add	sp, #88	; 0x58
 8019c22:	bd70      	pop	{r4, r5, r6, pc}

08019c24 <__smakebuf_r>:
 8019c24:	898b      	ldrh	r3, [r1, #12]
 8019c26:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8019c28:	079d      	lsls	r5, r3, #30
 8019c2a:	4606      	mov	r6, r0
 8019c2c:	460c      	mov	r4, r1
 8019c2e:	d507      	bpl.n	8019c40 <__smakebuf_r+0x1c>
 8019c30:	f104 0347 	add.w	r3, r4, #71	; 0x47
 8019c34:	6023      	str	r3, [r4, #0]
 8019c36:	6123      	str	r3, [r4, #16]
 8019c38:	2301      	movs	r3, #1
 8019c3a:	6163      	str	r3, [r4, #20]
 8019c3c:	b002      	add	sp, #8
 8019c3e:	bd70      	pop	{r4, r5, r6, pc}
 8019c40:	ab01      	add	r3, sp, #4
 8019c42:	466a      	mov	r2, sp
 8019c44:	f7ff ffca 	bl	8019bdc <__swhatbuf_r>
 8019c48:	9900      	ldr	r1, [sp, #0]
 8019c4a:	4605      	mov	r5, r0
 8019c4c:	4630      	mov	r0, r6
 8019c4e:	f7ff fc4d 	bl	80194ec <_malloc_r>
 8019c52:	b948      	cbnz	r0, 8019c68 <__smakebuf_r+0x44>
 8019c54:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8019c58:	059a      	lsls	r2, r3, #22
 8019c5a:	d4ef      	bmi.n	8019c3c <__smakebuf_r+0x18>
 8019c5c:	f023 0303 	bic.w	r3, r3, #3
 8019c60:	f043 0302 	orr.w	r3, r3, #2
 8019c64:	81a3      	strh	r3, [r4, #12]
 8019c66:	e7e3      	b.n	8019c30 <__smakebuf_r+0xc>
 8019c68:	4b0d      	ldr	r3, [pc, #52]	; (8019ca0 <__smakebuf_r+0x7c>)
 8019c6a:	62b3      	str	r3, [r6, #40]	; 0x28
 8019c6c:	89a3      	ldrh	r3, [r4, #12]
 8019c6e:	6020      	str	r0, [r4, #0]
 8019c70:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8019c74:	81a3      	strh	r3, [r4, #12]
 8019c76:	9b00      	ldr	r3, [sp, #0]
 8019c78:	6163      	str	r3, [r4, #20]
 8019c7a:	9b01      	ldr	r3, [sp, #4]
 8019c7c:	6120      	str	r0, [r4, #16]
 8019c7e:	b15b      	cbz	r3, 8019c98 <__smakebuf_r+0x74>
 8019c80:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8019c84:	4630      	mov	r0, r6
 8019c86:	f000 fb4f 	bl	801a328 <_isatty_r>
 8019c8a:	b128      	cbz	r0, 8019c98 <__smakebuf_r+0x74>
 8019c8c:	89a3      	ldrh	r3, [r4, #12]
 8019c8e:	f023 0303 	bic.w	r3, r3, #3
 8019c92:	f043 0301 	orr.w	r3, r3, #1
 8019c96:	81a3      	strh	r3, [r4, #12]
 8019c98:	89a3      	ldrh	r3, [r4, #12]
 8019c9a:	431d      	orrs	r5, r3
 8019c9c:	81a5      	strh	r5, [r4, #12]
 8019c9e:	e7cd      	b.n	8019c3c <__smakebuf_r+0x18>
 8019ca0:	08019a91 	.word	0x08019a91

08019ca4 <__malloc_lock>:
 8019ca4:	4770      	bx	lr

08019ca6 <__malloc_unlock>:
 8019ca6:	4770      	bx	lr

08019ca8 <__sfputc_r>:
 8019ca8:	6893      	ldr	r3, [r2, #8]
 8019caa:	3b01      	subs	r3, #1
 8019cac:	2b00      	cmp	r3, #0
 8019cae:	b410      	push	{r4}
 8019cb0:	6093      	str	r3, [r2, #8]
 8019cb2:	da08      	bge.n	8019cc6 <__sfputc_r+0x1e>
 8019cb4:	6994      	ldr	r4, [r2, #24]
 8019cb6:	42a3      	cmp	r3, r4
 8019cb8:	db01      	blt.n	8019cbe <__sfputc_r+0x16>
 8019cba:	290a      	cmp	r1, #10
 8019cbc:	d103      	bne.n	8019cc6 <__sfputc_r+0x1e>
 8019cbe:	f85d 4b04 	ldr.w	r4, [sp], #4
 8019cc2:	f7ff bd43 	b.w	801974c <__swbuf_r>
 8019cc6:	6813      	ldr	r3, [r2, #0]
 8019cc8:	1c58      	adds	r0, r3, #1
 8019cca:	6010      	str	r0, [r2, #0]
 8019ccc:	7019      	strb	r1, [r3, #0]
 8019cce:	4608      	mov	r0, r1
 8019cd0:	f85d 4b04 	ldr.w	r4, [sp], #4
 8019cd4:	4770      	bx	lr

08019cd6 <__sfputs_r>:
 8019cd6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8019cd8:	4606      	mov	r6, r0
 8019cda:	460f      	mov	r7, r1
 8019cdc:	4614      	mov	r4, r2
 8019cde:	18d5      	adds	r5, r2, r3
 8019ce0:	42ac      	cmp	r4, r5
 8019ce2:	d101      	bne.n	8019ce8 <__sfputs_r+0x12>
 8019ce4:	2000      	movs	r0, #0
 8019ce6:	e007      	b.n	8019cf8 <__sfputs_r+0x22>
 8019ce8:	463a      	mov	r2, r7
 8019cea:	f814 1b01 	ldrb.w	r1, [r4], #1
 8019cee:	4630      	mov	r0, r6
 8019cf0:	f7ff ffda 	bl	8019ca8 <__sfputc_r>
 8019cf4:	1c43      	adds	r3, r0, #1
 8019cf6:	d1f3      	bne.n	8019ce0 <__sfputs_r+0xa>
 8019cf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08019cfc <_vfiprintf_r>:
 8019cfc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8019d00:	460c      	mov	r4, r1
 8019d02:	b09d      	sub	sp, #116	; 0x74
 8019d04:	4617      	mov	r7, r2
 8019d06:	461d      	mov	r5, r3
 8019d08:	4606      	mov	r6, r0
 8019d0a:	b118      	cbz	r0, 8019d14 <_vfiprintf_r+0x18>
 8019d0c:	6983      	ldr	r3, [r0, #24]
 8019d0e:	b90b      	cbnz	r3, 8019d14 <_vfiprintf_r+0x18>
 8019d10:	f7ff feda 	bl	8019ac8 <__sinit>
 8019d14:	4b7c      	ldr	r3, [pc, #496]	; (8019f08 <_vfiprintf_r+0x20c>)
 8019d16:	429c      	cmp	r4, r3
 8019d18:	d158      	bne.n	8019dcc <_vfiprintf_r+0xd0>
 8019d1a:	6874      	ldr	r4, [r6, #4]
 8019d1c:	89a3      	ldrh	r3, [r4, #12]
 8019d1e:	0718      	lsls	r0, r3, #28
 8019d20:	d55e      	bpl.n	8019de0 <_vfiprintf_r+0xe4>
 8019d22:	6923      	ldr	r3, [r4, #16]
 8019d24:	2b00      	cmp	r3, #0
 8019d26:	d05b      	beq.n	8019de0 <_vfiprintf_r+0xe4>
 8019d28:	2300      	movs	r3, #0
 8019d2a:	9309      	str	r3, [sp, #36]	; 0x24
 8019d2c:	2320      	movs	r3, #32
 8019d2e:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8019d32:	2330      	movs	r3, #48	; 0x30
 8019d34:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8019d38:	9503      	str	r5, [sp, #12]
 8019d3a:	f04f 0b01 	mov.w	fp, #1
 8019d3e:	46b8      	mov	r8, r7
 8019d40:	4645      	mov	r5, r8
 8019d42:	f815 3b01 	ldrb.w	r3, [r5], #1
 8019d46:	b10b      	cbz	r3, 8019d4c <_vfiprintf_r+0x50>
 8019d48:	2b25      	cmp	r3, #37	; 0x25
 8019d4a:	d154      	bne.n	8019df6 <_vfiprintf_r+0xfa>
 8019d4c:	ebb8 0a07 	subs.w	sl, r8, r7
 8019d50:	d00b      	beq.n	8019d6a <_vfiprintf_r+0x6e>
 8019d52:	4653      	mov	r3, sl
 8019d54:	463a      	mov	r2, r7
 8019d56:	4621      	mov	r1, r4
 8019d58:	4630      	mov	r0, r6
 8019d5a:	f7ff ffbc 	bl	8019cd6 <__sfputs_r>
 8019d5e:	3001      	adds	r0, #1
 8019d60:	f000 80c2 	beq.w	8019ee8 <_vfiprintf_r+0x1ec>
 8019d64:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8019d66:	4453      	add	r3, sl
 8019d68:	9309      	str	r3, [sp, #36]	; 0x24
 8019d6a:	f898 3000 	ldrb.w	r3, [r8]
 8019d6e:	2b00      	cmp	r3, #0
 8019d70:	f000 80ba 	beq.w	8019ee8 <_vfiprintf_r+0x1ec>
 8019d74:	2300      	movs	r3, #0
 8019d76:	f04f 32ff 	mov.w	r2, #4294967295
 8019d7a:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8019d7e:	9304      	str	r3, [sp, #16]
 8019d80:	9307      	str	r3, [sp, #28]
 8019d82:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8019d86:	931a      	str	r3, [sp, #104]	; 0x68
 8019d88:	46a8      	mov	r8, r5
 8019d8a:	2205      	movs	r2, #5
 8019d8c:	f818 1b01 	ldrb.w	r1, [r8], #1
 8019d90:	485e      	ldr	r0, [pc, #376]	; (8019f0c <_vfiprintf_r+0x210>)
 8019d92:	f7e6 fa3d 	bl	8000210 <memchr>
 8019d96:	9b04      	ldr	r3, [sp, #16]
 8019d98:	bb78      	cbnz	r0, 8019dfa <_vfiprintf_r+0xfe>
 8019d9a:	06d9      	lsls	r1, r3, #27
 8019d9c:	bf44      	itt	mi
 8019d9e:	2220      	movmi	r2, #32
 8019da0:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8019da4:	071a      	lsls	r2, r3, #28
 8019da6:	bf44      	itt	mi
 8019da8:	222b      	movmi	r2, #43	; 0x2b
 8019daa:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8019dae:	782a      	ldrb	r2, [r5, #0]
 8019db0:	2a2a      	cmp	r2, #42	; 0x2a
 8019db2:	d02a      	beq.n	8019e0a <_vfiprintf_r+0x10e>
 8019db4:	9a07      	ldr	r2, [sp, #28]
 8019db6:	46a8      	mov	r8, r5
 8019db8:	2000      	movs	r0, #0
 8019dba:	250a      	movs	r5, #10
 8019dbc:	4641      	mov	r1, r8
 8019dbe:	f811 3b01 	ldrb.w	r3, [r1], #1
 8019dc2:	3b30      	subs	r3, #48	; 0x30
 8019dc4:	2b09      	cmp	r3, #9
 8019dc6:	d969      	bls.n	8019e9c <_vfiprintf_r+0x1a0>
 8019dc8:	b360      	cbz	r0, 8019e24 <_vfiprintf_r+0x128>
 8019dca:	e024      	b.n	8019e16 <_vfiprintf_r+0x11a>
 8019dcc:	4b50      	ldr	r3, [pc, #320]	; (8019f10 <_vfiprintf_r+0x214>)
 8019dce:	429c      	cmp	r4, r3
 8019dd0:	d101      	bne.n	8019dd6 <_vfiprintf_r+0xda>
 8019dd2:	68b4      	ldr	r4, [r6, #8]
 8019dd4:	e7a2      	b.n	8019d1c <_vfiprintf_r+0x20>
 8019dd6:	4b4f      	ldr	r3, [pc, #316]	; (8019f14 <_vfiprintf_r+0x218>)
 8019dd8:	429c      	cmp	r4, r3
 8019dda:	bf08      	it	eq
 8019ddc:	68f4      	ldreq	r4, [r6, #12]
 8019dde:	e79d      	b.n	8019d1c <_vfiprintf_r+0x20>
 8019de0:	4621      	mov	r1, r4
 8019de2:	4630      	mov	r0, r6
 8019de4:	f7ff fd12 	bl	801980c <__swsetup_r>
 8019de8:	2800      	cmp	r0, #0
 8019dea:	d09d      	beq.n	8019d28 <_vfiprintf_r+0x2c>
 8019dec:	f04f 30ff 	mov.w	r0, #4294967295
 8019df0:	b01d      	add	sp, #116	; 0x74
 8019df2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8019df6:	46a8      	mov	r8, r5
 8019df8:	e7a2      	b.n	8019d40 <_vfiprintf_r+0x44>
 8019dfa:	4a44      	ldr	r2, [pc, #272]	; (8019f0c <_vfiprintf_r+0x210>)
 8019dfc:	1a80      	subs	r0, r0, r2
 8019dfe:	fa0b f000 	lsl.w	r0, fp, r0
 8019e02:	4318      	orrs	r0, r3
 8019e04:	9004      	str	r0, [sp, #16]
 8019e06:	4645      	mov	r5, r8
 8019e08:	e7be      	b.n	8019d88 <_vfiprintf_r+0x8c>
 8019e0a:	9a03      	ldr	r2, [sp, #12]
 8019e0c:	1d11      	adds	r1, r2, #4
 8019e0e:	6812      	ldr	r2, [r2, #0]
 8019e10:	9103      	str	r1, [sp, #12]
 8019e12:	2a00      	cmp	r2, #0
 8019e14:	db01      	blt.n	8019e1a <_vfiprintf_r+0x11e>
 8019e16:	9207      	str	r2, [sp, #28]
 8019e18:	e004      	b.n	8019e24 <_vfiprintf_r+0x128>
 8019e1a:	4252      	negs	r2, r2
 8019e1c:	f043 0302 	orr.w	r3, r3, #2
 8019e20:	9207      	str	r2, [sp, #28]
 8019e22:	9304      	str	r3, [sp, #16]
 8019e24:	f898 3000 	ldrb.w	r3, [r8]
 8019e28:	2b2e      	cmp	r3, #46	; 0x2e
 8019e2a:	d10e      	bne.n	8019e4a <_vfiprintf_r+0x14e>
 8019e2c:	f898 3001 	ldrb.w	r3, [r8, #1]
 8019e30:	2b2a      	cmp	r3, #42	; 0x2a
 8019e32:	d138      	bne.n	8019ea6 <_vfiprintf_r+0x1aa>
 8019e34:	9b03      	ldr	r3, [sp, #12]
 8019e36:	1d1a      	adds	r2, r3, #4
 8019e38:	681b      	ldr	r3, [r3, #0]
 8019e3a:	9203      	str	r2, [sp, #12]
 8019e3c:	2b00      	cmp	r3, #0
 8019e3e:	bfb8      	it	lt
 8019e40:	f04f 33ff 	movlt.w	r3, #4294967295
 8019e44:	f108 0802 	add.w	r8, r8, #2
 8019e48:	9305      	str	r3, [sp, #20]
 8019e4a:	4d33      	ldr	r5, [pc, #204]	; (8019f18 <_vfiprintf_r+0x21c>)
 8019e4c:	f898 1000 	ldrb.w	r1, [r8]
 8019e50:	2203      	movs	r2, #3
 8019e52:	4628      	mov	r0, r5
 8019e54:	f7e6 f9dc 	bl	8000210 <memchr>
 8019e58:	b140      	cbz	r0, 8019e6c <_vfiprintf_r+0x170>
 8019e5a:	2340      	movs	r3, #64	; 0x40
 8019e5c:	1b40      	subs	r0, r0, r5
 8019e5e:	fa03 f000 	lsl.w	r0, r3, r0
 8019e62:	9b04      	ldr	r3, [sp, #16]
 8019e64:	4303      	orrs	r3, r0
 8019e66:	f108 0801 	add.w	r8, r8, #1
 8019e6a:	9304      	str	r3, [sp, #16]
 8019e6c:	f898 1000 	ldrb.w	r1, [r8]
 8019e70:	482a      	ldr	r0, [pc, #168]	; (8019f1c <_vfiprintf_r+0x220>)
 8019e72:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8019e76:	2206      	movs	r2, #6
 8019e78:	f108 0701 	add.w	r7, r8, #1
 8019e7c:	f7e6 f9c8 	bl	8000210 <memchr>
 8019e80:	2800      	cmp	r0, #0
 8019e82:	d037      	beq.n	8019ef4 <_vfiprintf_r+0x1f8>
 8019e84:	4b26      	ldr	r3, [pc, #152]	; (8019f20 <_vfiprintf_r+0x224>)
 8019e86:	bb1b      	cbnz	r3, 8019ed0 <_vfiprintf_r+0x1d4>
 8019e88:	9b03      	ldr	r3, [sp, #12]
 8019e8a:	3307      	adds	r3, #7
 8019e8c:	f023 0307 	bic.w	r3, r3, #7
 8019e90:	3308      	adds	r3, #8
 8019e92:	9303      	str	r3, [sp, #12]
 8019e94:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8019e96:	444b      	add	r3, r9
 8019e98:	9309      	str	r3, [sp, #36]	; 0x24
 8019e9a:	e750      	b.n	8019d3e <_vfiprintf_r+0x42>
 8019e9c:	fb05 3202 	mla	r2, r5, r2, r3
 8019ea0:	2001      	movs	r0, #1
 8019ea2:	4688      	mov	r8, r1
 8019ea4:	e78a      	b.n	8019dbc <_vfiprintf_r+0xc0>
 8019ea6:	2300      	movs	r3, #0
 8019ea8:	f108 0801 	add.w	r8, r8, #1
 8019eac:	9305      	str	r3, [sp, #20]
 8019eae:	4619      	mov	r1, r3
 8019eb0:	250a      	movs	r5, #10
 8019eb2:	4640      	mov	r0, r8
 8019eb4:	f810 2b01 	ldrb.w	r2, [r0], #1
 8019eb8:	3a30      	subs	r2, #48	; 0x30
 8019eba:	2a09      	cmp	r2, #9
 8019ebc:	d903      	bls.n	8019ec6 <_vfiprintf_r+0x1ca>
 8019ebe:	2b00      	cmp	r3, #0
 8019ec0:	d0c3      	beq.n	8019e4a <_vfiprintf_r+0x14e>
 8019ec2:	9105      	str	r1, [sp, #20]
 8019ec4:	e7c1      	b.n	8019e4a <_vfiprintf_r+0x14e>
 8019ec6:	fb05 2101 	mla	r1, r5, r1, r2
 8019eca:	2301      	movs	r3, #1
 8019ecc:	4680      	mov	r8, r0
 8019ece:	e7f0      	b.n	8019eb2 <_vfiprintf_r+0x1b6>
 8019ed0:	ab03      	add	r3, sp, #12
 8019ed2:	9300      	str	r3, [sp, #0]
 8019ed4:	4622      	mov	r2, r4
 8019ed6:	4b13      	ldr	r3, [pc, #76]	; (8019f24 <_vfiprintf_r+0x228>)
 8019ed8:	a904      	add	r1, sp, #16
 8019eda:	4630      	mov	r0, r6
 8019edc:	f3af 8000 	nop.w
 8019ee0:	f1b0 3fff 	cmp.w	r0, #4294967295
 8019ee4:	4681      	mov	r9, r0
 8019ee6:	d1d5      	bne.n	8019e94 <_vfiprintf_r+0x198>
 8019ee8:	89a3      	ldrh	r3, [r4, #12]
 8019eea:	065b      	lsls	r3, r3, #25
 8019eec:	f53f af7e 	bmi.w	8019dec <_vfiprintf_r+0xf0>
 8019ef0:	9809      	ldr	r0, [sp, #36]	; 0x24
 8019ef2:	e77d      	b.n	8019df0 <_vfiprintf_r+0xf4>
 8019ef4:	ab03      	add	r3, sp, #12
 8019ef6:	9300      	str	r3, [sp, #0]
 8019ef8:	4622      	mov	r2, r4
 8019efa:	4b0a      	ldr	r3, [pc, #40]	; (8019f24 <_vfiprintf_r+0x228>)
 8019efc:	a904      	add	r1, sp, #16
 8019efe:	4630      	mov	r0, r6
 8019f00:	f000 f888 	bl	801a014 <_printf_i>
 8019f04:	e7ec      	b.n	8019ee0 <_vfiprintf_r+0x1e4>
 8019f06:	bf00      	nop
 8019f08:	0801b5a8 	.word	0x0801b5a8
 8019f0c:	0801b5e8 	.word	0x0801b5e8
 8019f10:	0801b5c8 	.word	0x0801b5c8
 8019f14:	0801b588 	.word	0x0801b588
 8019f18:	0801b5ee 	.word	0x0801b5ee
 8019f1c:	0801b5f2 	.word	0x0801b5f2
 8019f20:	00000000 	.word	0x00000000
 8019f24:	08019cd7 	.word	0x08019cd7

08019f28 <_printf_common>:
 8019f28:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8019f2c:	4691      	mov	r9, r2
 8019f2e:	461f      	mov	r7, r3
 8019f30:	688a      	ldr	r2, [r1, #8]
 8019f32:	690b      	ldr	r3, [r1, #16]
 8019f34:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8019f38:	4293      	cmp	r3, r2
 8019f3a:	bfb8      	it	lt
 8019f3c:	4613      	movlt	r3, r2
 8019f3e:	f8c9 3000 	str.w	r3, [r9]
 8019f42:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8019f46:	4606      	mov	r6, r0
 8019f48:	460c      	mov	r4, r1
 8019f4a:	b112      	cbz	r2, 8019f52 <_printf_common+0x2a>
 8019f4c:	3301      	adds	r3, #1
 8019f4e:	f8c9 3000 	str.w	r3, [r9]
 8019f52:	6823      	ldr	r3, [r4, #0]
 8019f54:	0699      	lsls	r1, r3, #26
 8019f56:	bf42      	ittt	mi
 8019f58:	f8d9 3000 	ldrmi.w	r3, [r9]
 8019f5c:	3302      	addmi	r3, #2
 8019f5e:	f8c9 3000 	strmi.w	r3, [r9]
 8019f62:	6825      	ldr	r5, [r4, #0]
 8019f64:	f015 0506 	ands.w	r5, r5, #6
 8019f68:	d107      	bne.n	8019f7a <_printf_common+0x52>
 8019f6a:	f104 0a19 	add.w	sl, r4, #25
 8019f6e:	68e3      	ldr	r3, [r4, #12]
 8019f70:	f8d9 2000 	ldr.w	r2, [r9]
 8019f74:	1a9b      	subs	r3, r3, r2
 8019f76:	42ab      	cmp	r3, r5
 8019f78:	dc28      	bgt.n	8019fcc <_printf_common+0xa4>
 8019f7a:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 8019f7e:	6822      	ldr	r2, [r4, #0]
 8019f80:	3300      	adds	r3, #0
 8019f82:	bf18      	it	ne
 8019f84:	2301      	movne	r3, #1
 8019f86:	0692      	lsls	r2, r2, #26
 8019f88:	d42d      	bmi.n	8019fe6 <_printf_common+0xbe>
 8019f8a:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8019f8e:	4639      	mov	r1, r7
 8019f90:	4630      	mov	r0, r6
 8019f92:	47c0      	blx	r8
 8019f94:	3001      	adds	r0, #1
 8019f96:	d020      	beq.n	8019fda <_printf_common+0xb2>
 8019f98:	6823      	ldr	r3, [r4, #0]
 8019f9a:	68e5      	ldr	r5, [r4, #12]
 8019f9c:	f8d9 2000 	ldr.w	r2, [r9]
 8019fa0:	f003 0306 	and.w	r3, r3, #6
 8019fa4:	2b04      	cmp	r3, #4
 8019fa6:	bf08      	it	eq
 8019fa8:	1aad      	subeq	r5, r5, r2
 8019faa:	68a3      	ldr	r3, [r4, #8]
 8019fac:	6922      	ldr	r2, [r4, #16]
 8019fae:	bf0c      	ite	eq
 8019fb0:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8019fb4:	2500      	movne	r5, #0
 8019fb6:	4293      	cmp	r3, r2
 8019fb8:	bfc4      	itt	gt
 8019fba:	1a9b      	subgt	r3, r3, r2
 8019fbc:	18ed      	addgt	r5, r5, r3
 8019fbe:	f04f 0900 	mov.w	r9, #0
 8019fc2:	341a      	adds	r4, #26
 8019fc4:	454d      	cmp	r5, r9
 8019fc6:	d11a      	bne.n	8019ffe <_printf_common+0xd6>
 8019fc8:	2000      	movs	r0, #0
 8019fca:	e008      	b.n	8019fde <_printf_common+0xb6>
 8019fcc:	2301      	movs	r3, #1
 8019fce:	4652      	mov	r2, sl
 8019fd0:	4639      	mov	r1, r7
 8019fd2:	4630      	mov	r0, r6
 8019fd4:	47c0      	blx	r8
 8019fd6:	3001      	adds	r0, #1
 8019fd8:	d103      	bne.n	8019fe2 <_printf_common+0xba>
 8019fda:	f04f 30ff 	mov.w	r0, #4294967295
 8019fde:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8019fe2:	3501      	adds	r5, #1
 8019fe4:	e7c3      	b.n	8019f6e <_printf_common+0x46>
 8019fe6:	18e1      	adds	r1, r4, r3
 8019fe8:	1c5a      	adds	r2, r3, #1
 8019fea:	2030      	movs	r0, #48	; 0x30
 8019fec:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8019ff0:	4422      	add	r2, r4
 8019ff2:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8019ff6:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8019ffa:	3302      	adds	r3, #2
 8019ffc:	e7c5      	b.n	8019f8a <_printf_common+0x62>
 8019ffe:	2301      	movs	r3, #1
 801a000:	4622      	mov	r2, r4
 801a002:	4639      	mov	r1, r7
 801a004:	4630      	mov	r0, r6
 801a006:	47c0      	blx	r8
 801a008:	3001      	adds	r0, #1
 801a00a:	d0e6      	beq.n	8019fda <_printf_common+0xb2>
 801a00c:	f109 0901 	add.w	r9, r9, #1
 801a010:	e7d8      	b.n	8019fc4 <_printf_common+0x9c>
	...

0801a014 <_printf_i>:
 801a014:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801a018:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 801a01c:	460c      	mov	r4, r1
 801a01e:	7e09      	ldrb	r1, [r1, #24]
 801a020:	b085      	sub	sp, #20
 801a022:	296e      	cmp	r1, #110	; 0x6e
 801a024:	4617      	mov	r7, r2
 801a026:	4606      	mov	r6, r0
 801a028:	4698      	mov	r8, r3
 801a02a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801a02c:	f000 80b3 	beq.w	801a196 <_printf_i+0x182>
 801a030:	d822      	bhi.n	801a078 <_printf_i+0x64>
 801a032:	2963      	cmp	r1, #99	; 0x63
 801a034:	d036      	beq.n	801a0a4 <_printf_i+0x90>
 801a036:	d80a      	bhi.n	801a04e <_printf_i+0x3a>
 801a038:	2900      	cmp	r1, #0
 801a03a:	f000 80b9 	beq.w	801a1b0 <_printf_i+0x19c>
 801a03e:	2958      	cmp	r1, #88	; 0x58
 801a040:	f000 8083 	beq.w	801a14a <_printf_i+0x136>
 801a044:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801a048:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 801a04c:	e032      	b.n	801a0b4 <_printf_i+0xa0>
 801a04e:	2964      	cmp	r1, #100	; 0x64
 801a050:	d001      	beq.n	801a056 <_printf_i+0x42>
 801a052:	2969      	cmp	r1, #105	; 0x69
 801a054:	d1f6      	bne.n	801a044 <_printf_i+0x30>
 801a056:	6820      	ldr	r0, [r4, #0]
 801a058:	6813      	ldr	r3, [r2, #0]
 801a05a:	0605      	lsls	r5, r0, #24
 801a05c:	f103 0104 	add.w	r1, r3, #4
 801a060:	d52a      	bpl.n	801a0b8 <_printf_i+0xa4>
 801a062:	681b      	ldr	r3, [r3, #0]
 801a064:	6011      	str	r1, [r2, #0]
 801a066:	2b00      	cmp	r3, #0
 801a068:	da03      	bge.n	801a072 <_printf_i+0x5e>
 801a06a:	222d      	movs	r2, #45	; 0x2d
 801a06c:	425b      	negs	r3, r3
 801a06e:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 801a072:	486f      	ldr	r0, [pc, #444]	; (801a230 <_printf_i+0x21c>)
 801a074:	220a      	movs	r2, #10
 801a076:	e039      	b.n	801a0ec <_printf_i+0xd8>
 801a078:	2973      	cmp	r1, #115	; 0x73
 801a07a:	f000 809d 	beq.w	801a1b8 <_printf_i+0x1a4>
 801a07e:	d808      	bhi.n	801a092 <_printf_i+0x7e>
 801a080:	296f      	cmp	r1, #111	; 0x6f
 801a082:	d020      	beq.n	801a0c6 <_printf_i+0xb2>
 801a084:	2970      	cmp	r1, #112	; 0x70
 801a086:	d1dd      	bne.n	801a044 <_printf_i+0x30>
 801a088:	6823      	ldr	r3, [r4, #0]
 801a08a:	f043 0320 	orr.w	r3, r3, #32
 801a08e:	6023      	str	r3, [r4, #0]
 801a090:	e003      	b.n	801a09a <_printf_i+0x86>
 801a092:	2975      	cmp	r1, #117	; 0x75
 801a094:	d017      	beq.n	801a0c6 <_printf_i+0xb2>
 801a096:	2978      	cmp	r1, #120	; 0x78
 801a098:	d1d4      	bne.n	801a044 <_printf_i+0x30>
 801a09a:	2378      	movs	r3, #120	; 0x78
 801a09c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 801a0a0:	4864      	ldr	r0, [pc, #400]	; (801a234 <_printf_i+0x220>)
 801a0a2:	e055      	b.n	801a150 <_printf_i+0x13c>
 801a0a4:	6813      	ldr	r3, [r2, #0]
 801a0a6:	1d19      	adds	r1, r3, #4
 801a0a8:	681b      	ldr	r3, [r3, #0]
 801a0aa:	6011      	str	r1, [r2, #0]
 801a0ac:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801a0b0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 801a0b4:	2301      	movs	r3, #1
 801a0b6:	e08c      	b.n	801a1d2 <_printf_i+0x1be>
 801a0b8:	681b      	ldr	r3, [r3, #0]
 801a0ba:	6011      	str	r1, [r2, #0]
 801a0bc:	f010 0f40 	tst.w	r0, #64	; 0x40
 801a0c0:	bf18      	it	ne
 801a0c2:	b21b      	sxthne	r3, r3
 801a0c4:	e7cf      	b.n	801a066 <_printf_i+0x52>
 801a0c6:	6813      	ldr	r3, [r2, #0]
 801a0c8:	6825      	ldr	r5, [r4, #0]
 801a0ca:	1d18      	adds	r0, r3, #4
 801a0cc:	6010      	str	r0, [r2, #0]
 801a0ce:	0628      	lsls	r0, r5, #24
 801a0d0:	d501      	bpl.n	801a0d6 <_printf_i+0xc2>
 801a0d2:	681b      	ldr	r3, [r3, #0]
 801a0d4:	e002      	b.n	801a0dc <_printf_i+0xc8>
 801a0d6:	0668      	lsls	r0, r5, #25
 801a0d8:	d5fb      	bpl.n	801a0d2 <_printf_i+0xbe>
 801a0da:	881b      	ldrh	r3, [r3, #0]
 801a0dc:	4854      	ldr	r0, [pc, #336]	; (801a230 <_printf_i+0x21c>)
 801a0de:	296f      	cmp	r1, #111	; 0x6f
 801a0e0:	bf14      	ite	ne
 801a0e2:	220a      	movne	r2, #10
 801a0e4:	2208      	moveq	r2, #8
 801a0e6:	2100      	movs	r1, #0
 801a0e8:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 801a0ec:	6865      	ldr	r5, [r4, #4]
 801a0ee:	60a5      	str	r5, [r4, #8]
 801a0f0:	2d00      	cmp	r5, #0
 801a0f2:	f2c0 8095 	blt.w	801a220 <_printf_i+0x20c>
 801a0f6:	6821      	ldr	r1, [r4, #0]
 801a0f8:	f021 0104 	bic.w	r1, r1, #4
 801a0fc:	6021      	str	r1, [r4, #0]
 801a0fe:	2b00      	cmp	r3, #0
 801a100:	d13d      	bne.n	801a17e <_printf_i+0x16a>
 801a102:	2d00      	cmp	r5, #0
 801a104:	f040 808e 	bne.w	801a224 <_printf_i+0x210>
 801a108:	4665      	mov	r5, ip
 801a10a:	2a08      	cmp	r2, #8
 801a10c:	d10b      	bne.n	801a126 <_printf_i+0x112>
 801a10e:	6823      	ldr	r3, [r4, #0]
 801a110:	07db      	lsls	r3, r3, #31
 801a112:	d508      	bpl.n	801a126 <_printf_i+0x112>
 801a114:	6923      	ldr	r3, [r4, #16]
 801a116:	6862      	ldr	r2, [r4, #4]
 801a118:	429a      	cmp	r2, r3
 801a11a:	bfde      	ittt	le
 801a11c:	2330      	movle	r3, #48	; 0x30
 801a11e:	f805 3c01 	strble.w	r3, [r5, #-1]
 801a122:	f105 35ff 	addle.w	r5, r5, #4294967295
 801a126:	ebac 0305 	sub.w	r3, ip, r5
 801a12a:	6123      	str	r3, [r4, #16]
 801a12c:	f8cd 8000 	str.w	r8, [sp]
 801a130:	463b      	mov	r3, r7
 801a132:	aa03      	add	r2, sp, #12
 801a134:	4621      	mov	r1, r4
 801a136:	4630      	mov	r0, r6
 801a138:	f7ff fef6 	bl	8019f28 <_printf_common>
 801a13c:	3001      	adds	r0, #1
 801a13e:	d14d      	bne.n	801a1dc <_printf_i+0x1c8>
 801a140:	f04f 30ff 	mov.w	r0, #4294967295
 801a144:	b005      	add	sp, #20
 801a146:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801a14a:	4839      	ldr	r0, [pc, #228]	; (801a230 <_printf_i+0x21c>)
 801a14c:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 801a150:	6813      	ldr	r3, [r2, #0]
 801a152:	6821      	ldr	r1, [r4, #0]
 801a154:	1d1d      	adds	r5, r3, #4
 801a156:	681b      	ldr	r3, [r3, #0]
 801a158:	6015      	str	r5, [r2, #0]
 801a15a:	060a      	lsls	r2, r1, #24
 801a15c:	d50b      	bpl.n	801a176 <_printf_i+0x162>
 801a15e:	07ca      	lsls	r2, r1, #31
 801a160:	bf44      	itt	mi
 801a162:	f041 0120 	orrmi.w	r1, r1, #32
 801a166:	6021      	strmi	r1, [r4, #0]
 801a168:	b91b      	cbnz	r3, 801a172 <_printf_i+0x15e>
 801a16a:	6822      	ldr	r2, [r4, #0]
 801a16c:	f022 0220 	bic.w	r2, r2, #32
 801a170:	6022      	str	r2, [r4, #0]
 801a172:	2210      	movs	r2, #16
 801a174:	e7b7      	b.n	801a0e6 <_printf_i+0xd2>
 801a176:	064d      	lsls	r5, r1, #25
 801a178:	bf48      	it	mi
 801a17a:	b29b      	uxthmi	r3, r3
 801a17c:	e7ef      	b.n	801a15e <_printf_i+0x14a>
 801a17e:	4665      	mov	r5, ip
 801a180:	fbb3 f1f2 	udiv	r1, r3, r2
 801a184:	fb02 3311 	mls	r3, r2, r1, r3
 801a188:	5cc3      	ldrb	r3, [r0, r3]
 801a18a:	f805 3d01 	strb.w	r3, [r5, #-1]!
 801a18e:	460b      	mov	r3, r1
 801a190:	2900      	cmp	r1, #0
 801a192:	d1f5      	bne.n	801a180 <_printf_i+0x16c>
 801a194:	e7b9      	b.n	801a10a <_printf_i+0xf6>
 801a196:	6813      	ldr	r3, [r2, #0]
 801a198:	6825      	ldr	r5, [r4, #0]
 801a19a:	6961      	ldr	r1, [r4, #20]
 801a19c:	1d18      	adds	r0, r3, #4
 801a19e:	6010      	str	r0, [r2, #0]
 801a1a0:	0628      	lsls	r0, r5, #24
 801a1a2:	681b      	ldr	r3, [r3, #0]
 801a1a4:	d501      	bpl.n	801a1aa <_printf_i+0x196>
 801a1a6:	6019      	str	r1, [r3, #0]
 801a1a8:	e002      	b.n	801a1b0 <_printf_i+0x19c>
 801a1aa:	066a      	lsls	r2, r5, #25
 801a1ac:	d5fb      	bpl.n	801a1a6 <_printf_i+0x192>
 801a1ae:	8019      	strh	r1, [r3, #0]
 801a1b0:	2300      	movs	r3, #0
 801a1b2:	6123      	str	r3, [r4, #16]
 801a1b4:	4665      	mov	r5, ip
 801a1b6:	e7b9      	b.n	801a12c <_printf_i+0x118>
 801a1b8:	6813      	ldr	r3, [r2, #0]
 801a1ba:	1d19      	adds	r1, r3, #4
 801a1bc:	6011      	str	r1, [r2, #0]
 801a1be:	681d      	ldr	r5, [r3, #0]
 801a1c0:	6862      	ldr	r2, [r4, #4]
 801a1c2:	2100      	movs	r1, #0
 801a1c4:	4628      	mov	r0, r5
 801a1c6:	f7e6 f823 	bl	8000210 <memchr>
 801a1ca:	b108      	cbz	r0, 801a1d0 <_printf_i+0x1bc>
 801a1cc:	1b40      	subs	r0, r0, r5
 801a1ce:	6060      	str	r0, [r4, #4]
 801a1d0:	6863      	ldr	r3, [r4, #4]
 801a1d2:	6123      	str	r3, [r4, #16]
 801a1d4:	2300      	movs	r3, #0
 801a1d6:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 801a1da:	e7a7      	b.n	801a12c <_printf_i+0x118>
 801a1dc:	6923      	ldr	r3, [r4, #16]
 801a1de:	462a      	mov	r2, r5
 801a1e0:	4639      	mov	r1, r7
 801a1e2:	4630      	mov	r0, r6
 801a1e4:	47c0      	blx	r8
 801a1e6:	3001      	adds	r0, #1
 801a1e8:	d0aa      	beq.n	801a140 <_printf_i+0x12c>
 801a1ea:	6823      	ldr	r3, [r4, #0]
 801a1ec:	079b      	lsls	r3, r3, #30
 801a1ee:	d413      	bmi.n	801a218 <_printf_i+0x204>
 801a1f0:	68e0      	ldr	r0, [r4, #12]
 801a1f2:	9b03      	ldr	r3, [sp, #12]
 801a1f4:	4298      	cmp	r0, r3
 801a1f6:	bfb8      	it	lt
 801a1f8:	4618      	movlt	r0, r3
 801a1fa:	e7a3      	b.n	801a144 <_printf_i+0x130>
 801a1fc:	2301      	movs	r3, #1
 801a1fe:	464a      	mov	r2, r9
 801a200:	4639      	mov	r1, r7
 801a202:	4630      	mov	r0, r6
 801a204:	47c0      	blx	r8
 801a206:	3001      	adds	r0, #1
 801a208:	d09a      	beq.n	801a140 <_printf_i+0x12c>
 801a20a:	3501      	adds	r5, #1
 801a20c:	68e3      	ldr	r3, [r4, #12]
 801a20e:	9a03      	ldr	r2, [sp, #12]
 801a210:	1a9b      	subs	r3, r3, r2
 801a212:	42ab      	cmp	r3, r5
 801a214:	dcf2      	bgt.n	801a1fc <_printf_i+0x1e8>
 801a216:	e7eb      	b.n	801a1f0 <_printf_i+0x1dc>
 801a218:	2500      	movs	r5, #0
 801a21a:	f104 0919 	add.w	r9, r4, #25
 801a21e:	e7f5      	b.n	801a20c <_printf_i+0x1f8>
 801a220:	2b00      	cmp	r3, #0
 801a222:	d1ac      	bne.n	801a17e <_printf_i+0x16a>
 801a224:	7803      	ldrb	r3, [r0, #0]
 801a226:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 801a22a:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801a22e:	e76c      	b.n	801a10a <_printf_i+0xf6>
 801a230:	0801b5f9 	.word	0x0801b5f9
 801a234:	0801b60a 	.word	0x0801b60a

0801a238 <__sread>:
 801a238:	b510      	push	{r4, lr}
 801a23a:	460c      	mov	r4, r1
 801a23c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801a240:	f000 f894 	bl	801a36c <_read_r>
 801a244:	2800      	cmp	r0, #0
 801a246:	bfab      	itete	ge
 801a248:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 801a24a:	89a3      	ldrhlt	r3, [r4, #12]
 801a24c:	181b      	addge	r3, r3, r0
 801a24e:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 801a252:	bfac      	ite	ge
 801a254:	6563      	strge	r3, [r4, #84]	; 0x54
 801a256:	81a3      	strhlt	r3, [r4, #12]
 801a258:	bd10      	pop	{r4, pc}

0801a25a <__swrite>:
 801a25a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801a25e:	461f      	mov	r7, r3
 801a260:	898b      	ldrh	r3, [r1, #12]
 801a262:	05db      	lsls	r3, r3, #23
 801a264:	4605      	mov	r5, r0
 801a266:	460c      	mov	r4, r1
 801a268:	4616      	mov	r6, r2
 801a26a:	d505      	bpl.n	801a278 <__swrite+0x1e>
 801a26c:	2302      	movs	r3, #2
 801a26e:	2200      	movs	r2, #0
 801a270:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801a274:	f000 f868 	bl	801a348 <_lseek_r>
 801a278:	89a3      	ldrh	r3, [r4, #12]
 801a27a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 801a27e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 801a282:	81a3      	strh	r3, [r4, #12]
 801a284:	4632      	mov	r2, r6
 801a286:	463b      	mov	r3, r7
 801a288:	4628      	mov	r0, r5
 801a28a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 801a28e:	f000 b817 	b.w	801a2c0 <_write_r>

0801a292 <__sseek>:
 801a292:	b510      	push	{r4, lr}
 801a294:	460c      	mov	r4, r1
 801a296:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801a29a:	f000 f855 	bl	801a348 <_lseek_r>
 801a29e:	1c43      	adds	r3, r0, #1
 801a2a0:	89a3      	ldrh	r3, [r4, #12]
 801a2a2:	bf15      	itete	ne
 801a2a4:	6560      	strne	r0, [r4, #84]	; 0x54
 801a2a6:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 801a2aa:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 801a2ae:	81a3      	strheq	r3, [r4, #12]
 801a2b0:	bf18      	it	ne
 801a2b2:	81a3      	strhne	r3, [r4, #12]
 801a2b4:	bd10      	pop	{r4, pc}

0801a2b6 <__sclose>:
 801a2b6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801a2ba:	f000 b813 	b.w	801a2e4 <_close_r>
	...

0801a2c0 <_write_r>:
 801a2c0:	b538      	push	{r3, r4, r5, lr}
 801a2c2:	4c07      	ldr	r4, [pc, #28]	; (801a2e0 <_write_r+0x20>)
 801a2c4:	4605      	mov	r5, r0
 801a2c6:	4608      	mov	r0, r1
 801a2c8:	4611      	mov	r1, r2
 801a2ca:	2200      	movs	r2, #0
 801a2cc:	6022      	str	r2, [r4, #0]
 801a2ce:	461a      	mov	r2, r3
 801a2d0:	f7e6 f980 	bl	80005d4 <_write>
 801a2d4:	1c43      	adds	r3, r0, #1
 801a2d6:	d102      	bne.n	801a2de <_write_r+0x1e>
 801a2d8:	6823      	ldr	r3, [r4, #0]
 801a2da:	b103      	cbz	r3, 801a2de <_write_r+0x1e>
 801a2dc:	602b      	str	r3, [r5, #0]
 801a2de:	bd38      	pop	{r3, r4, r5, pc}
 801a2e0:	200006cc 	.word	0x200006cc

0801a2e4 <_close_r>:
 801a2e4:	b538      	push	{r3, r4, r5, lr}
 801a2e6:	4c06      	ldr	r4, [pc, #24]	; (801a300 <_close_r+0x1c>)
 801a2e8:	2300      	movs	r3, #0
 801a2ea:	4605      	mov	r5, r0
 801a2ec:	4608      	mov	r0, r1
 801a2ee:	6023      	str	r3, [r4, #0]
 801a2f0:	f7e7 fa48 	bl	8001784 <_close>
 801a2f4:	1c43      	adds	r3, r0, #1
 801a2f6:	d102      	bne.n	801a2fe <_close_r+0x1a>
 801a2f8:	6823      	ldr	r3, [r4, #0]
 801a2fa:	b103      	cbz	r3, 801a2fe <_close_r+0x1a>
 801a2fc:	602b      	str	r3, [r5, #0]
 801a2fe:	bd38      	pop	{r3, r4, r5, pc}
 801a300:	200006cc 	.word	0x200006cc

0801a304 <_fstat_r>:
 801a304:	b538      	push	{r3, r4, r5, lr}
 801a306:	4c07      	ldr	r4, [pc, #28]	; (801a324 <_fstat_r+0x20>)
 801a308:	2300      	movs	r3, #0
 801a30a:	4605      	mov	r5, r0
 801a30c:	4608      	mov	r0, r1
 801a30e:	4611      	mov	r1, r2
 801a310:	6023      	str	r3, [r4, #0]
 801a312:	f7e7 fa43 	bl	800179c <_fstat>
 801a316:	1c43      	adds	r3, r0, #1
 801a318:	d102      	bne.n	801a320 <_fstat_r+0x1c>
 801a31a:	6823      	ldr	r3, [r4, #0]
 801a31c:	b103      	cbz	r3, 801a320 <_fstat_r+0x1c>
 801a31e:	602b      	str	r3, [r5, #0]
 801a320:	bd38      	pop	{r3, r4, r5, pc}
 801a322:	bf00      	nop
 801a324:	200006cc 	.word	0x200006cc

0801a328 <_isatty_r>:
 801a328:	b538      	push	{r3, r4, r5, lr}
 801a32a:	4c06      	ldr	r4, [pc, #24]	; (801a344 <_isatty_r+0x1c>)
 801a32c:	2300      	movs	r3, #0
 801a32e:	4605      	mov	r5, r0
 801a330:	4608      	mov	r0, r1
 801a332:	6023      	str	r3, [r4, #0]
 801a334:	f7e7 fa42 	bl	80017bc <_isatty>
 801a338:	1c43      	adds	r3, r0, #1
 801a33a:	d102      	bne.n	801a342 <_isatty_r+0x1a>
 801a33c:	6823      	ldr	r3, [r4, #0]
 801a33e:	b103      	cbz	r3, 801a342 <_isatty_r+0x1a>
 801a340:	602b      	str	r3, [r5, #0]
 801a342:	bd38      	pop	{r3, r4, r5, pc}
 801a344:	200006cc 	.word	0x200006cc

0801a348 <_lseek_r>:
 801a348:	b538      	push	{r3, r4, r5, lr}
 801a34a:	4c07      	ldr	r4, [pc, #28]	; (801a368 <_lseek_r+0x20>)
 801a34c:	4605      	mov	r5, r0
 801a34e:	4608      	mov	r0, r1
 801a350:	4611      	mov	r1, r2
 801a352:	2200      	movs	r2, #0
 801a354:	6022      	str	r2, [r4, #0]
 801a356:	461a      	mov	r2, r3
 801a358:	f7e7 fa3b 	bl	80017d2 <_lseek>
 801a35c:	1c43      	adds	r3, r0, #1
 801a35e:	d102      	bne.n	801a366 <_lseek_r+0x1e>
 801a360:	6823      	ldr	r3, [r4, #0]
 801a362:	b103      	cbz	r3, 801a366 <_lseek_r+0x1e>
 801a364:	602b      	str	r3, [r5, #0]
 801a366:	bd38      	pop	{r3, r4, r5, pc}
 801a368:	200006cc 	.word	0x200006cc

0801a36c <_read_r>:
 801a36c:	b538      	push	{r3, r4, r5, lr}
 801a36e:	4c07      	ldr	r4, [pc, #28]	; (801a38c <_read_r+0x20>)
 801a370:	4605      	mov	r5, r0
 801a372:	4608      	mov	r0, r1
 801a374:	4611      	mov	r1, r2
 801a376:	2200      	movs	r2, #0
 801a378:	6022      	str	r2, [r4, #0]
 801a37a:	461a      	mov	r2, r3
 801a37c:	f7e7 f9e5 	bl	800174a <_read>
 801a380:	1c43      	adds	r3, r0, #1
 801a382:	d102      	bne.n	801a38a <_read_r+0x1e>
 801a384:	6823      	ldr	r3, [r4, #0]
 801a386:	b103      	cbz	r3, 801a38a <_read_r+0x1e>
 801a388:	602b      	str	r3, [r5, #0]
 801a38a:	bd38      	pop	{r3, r4, r5, pc}
 801a38c:	200006cc 	.word	0x200006cc

0801a390 <_init>:
 801a390:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801a392:	bf00      	nop
 801a394:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801a396:	bc08      	pop	{r3}
 801a398:	469e      	mov	lr, r3
 801a39a:	4770      	bx	lr

0801a39c <_fini>:
 801a39c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801a39e:	bf00      	nop
 801a3a0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801a3a2:	bc08      	pop	{r3}
 801a3a4:	469e      	mov	lr, r3
 801a3a6:	4770      	bx	lr
